<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020年8月31日-58同城2021校园招聘后台开发笔试</title>
    <url>/2020/08/31/58%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<p>选择题22题，一道多选题，3道把编程题，时间挺紧张的。。。</p>
<h1 id="编程题1：找出共有字符串"><a href="#编程题1：找出共有字符串" class="headerlink" title="编程题1：找出共有字符串"></a>编程题1：找出共有字符串</h1><p>就是给几个存放字符串的列表，找出他们的公共的字符串。也就是都出现过的，这题a了80 %</p>
<p>没有去重复…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wubatongcheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hongliang.singleton.Father;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.regexp.internal.RE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-08-31 20:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindCommonString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  ArrayList&lt;String&gt; <span class="title">findCommonString</span> <span class="params">(List&lt;List&lt;String&gt;&gt; values)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; values.get(<span class="number">0</span>).size(); j++) &#123;</span><br><span class="line">            String s = values.get(<span class="number">0</span>).get(j);</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">                flag |= values.get(i).contains(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!res.contains(s)) &#123; <span class="comment">// 去重</span></span><br><span class="line">                    res.add(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;hnf&quot;</span>, <span class="string">&quot;uhg&quot;</span>, <span class="string">&quot;hnf&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;ass&quot;</span>, <span class="string">&quot;ggg&quot;</span>, <span class="string">&quot;hnf&quot;</span>);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; values = Arrays.asList(list, list2);</span><br><span class="line">        ArrayList&lt;String&gt; commonString = findCommonString(values);</span><br><span class="line">        System.out.println(commonString);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h1 id="编程题2：500以内的整数k"><a href="#编程题2：500以内的整数k" class="headerlink" title="编程题2：500以内的整数k"></a>编程题2：500以内的整数k</h1><p>一个500以内的整数k， 加上a之后变成一个完全平方数，再加上b后也变成一个完全平方数，求这个k。</p>
<p>暴力枚举即可，找到k+a 和 k+a+b他们是否能完全开平方。但是我只过了20% 。。。为啥</p>
<p>原来来理解错了题意… </p>
<p>应该比较 a+k 和 k+b….</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b int整型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">question</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">500</span>; k++)&#123;</span><br><span class="line"><span class="comment">//            double sqrt = Math.sqrt(k + a);</span></span><br><span class="line"><span class="comment">//            double sqrt1 = Math.sqrt(k + a + b);</span></span><br><span class="line">            <span class="keyword">boolean</span> f = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k+a; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i * i == k+a)&#123;</span><br><span class="line">                    f = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> g = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k+a+b; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i * i == k+b)&#123;</span><br><span class="line">                    g = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( f &amp;&amp; g)&#123;</span><br><span class="line">                <span class="keyword">return</span> k;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            int aa = (int)sqrt;</span></span><br><span class="line"><span class="comment">//            int bb = (int)sqrt1;</span></span><br><span class="line"><span class="comment">//            if((aa-sqrt) == 0 &amp;&amp; (bb-sqrt1) == 0)&#123;</span></span><br><span class="line"><span class="comment">//                return k;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="编程题3：-敌军破译密码"><a href="#编程题3：-敌军破译密码" class="headerlink" title="编程题3： 敌军破译密码"></a>编程题3： 敌军破译密码</h1><p>leetcode: <a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/</a> </p>
<p> dp[i] 表示以字符i结尾的字符串的翻译种数。</p>
<p>如果第i位和第i-1位数字可以翻译，则dp[i] = dp[i-1]+dp[i-2];</p>
<p>否则dp[i] = dp[i-1];</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Integer.valueOf(s.substring(i-<span class="number">2</span>,i)) &gt;= <span class="number">10</span> &amp;&amp; Integer.valueOf(s.substring(i-<span class="number">2</span>,i)) &lt;= <span class="number">25</span>  )&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]+ dp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>笔试</tag>
        <tag>校招</tag>
      </tags>
  </entry>
  <entry>
    <title>Anchor Diffusion for Unsupervised Video Object Segmentation</title>
    <url>/2020/02/21/AnchorDiffusion/</url>
    <content><![CDATA[<h1 id="Anchor-Diffusion-for-Unsupervised-Video-Object-Segmentation"><a href="#Anchor-Diffusion-for-Unsupervised-Video-Object-Segmentation" class="headerlink" title="Anchor Diffusion for Unsupervised Video Object Segmentation"></a>Anchor Diffusion for Unsupervised Video Object Segmentation</h1><h1 id="基于“锚扩散”的无监督视频目标分割"><a href="#基于“锚扩散”的无监督视频目标分割" class="headerlink" title="基于“锚扩散”的无监督视频目标分割"></a>基于“锚扩散”的无监督视频目标分割</h1><h3 id="github：-https-github-com-yz93-anchor-diff-VOS"><a href="#github：-https-github-com-yz93-anchor-diff-VOS" class="headerlink" title="github：  https://github.com/yz93/anchor-diff-VOS"></a>github：  <a href="https://github.com/yz93/anchor-diff-VOS">https://github.com/yz93/anchor-diff-VOS</a></h3><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​        论文指出了目前的视频目标分割方法存在的缺点。提出更简单的方法，基它基于学习属于帧的像素之间的相似性，这些帧在时间上可以任意地相隔很远。这种方法能够处理long-term的依赖关系。</p>
<p>​        这篇论文受<strong>Non-local operators</strong>的启发提出了一个简单而有效的模型无监督视频目标分割模型，可以捕获<strong>长期依赖</strong>。通过将“锚帧”的嵌入像素与当前的帧建立联系，可以学习到任意长距离的成对依赖关系。在Davis2016数据集上取得了第一名的成绩。</p>
<p>​        追踪基于时间变化的的目标，现在流行的方法是通过在视频序列中的<strong>光流</strong>或者使用RNN对运动信息进行建模。这些方法持续将前面的特征传到当前帧，让当前帧的预测依赖于整个历史的帧。但是RNNs常常依赖于训练技术，如通过时间的截断反向传播来降低参数更新的成本，这限制了它们的长期建模能力。虽然LSTM的门控机制缓解了梯度消失的问题。但在训练中，梯度爆炸的现象往往需要对梯度的范数进行裁剪或重新调整。</p>
<p>​        光流向量只能预测视频中每一帧的<strong>单步运动</strong>线索，这样会累积误差。而且计算成本很高。使用这些方法会产生不准确的结果，<strong>特别是当前景物体几乎是静态的时候</strong>。</p>
<p>​        基于双流的模型有三个缺点：</p>
<p>​        第一：流估计网络通常是在合成数据集上训练的，因此在现实世界中部署时可能会导致较差的性能。<br>​        第二：虽然建模长期的时间依赖关系对于适应重大的在线变化是至关重要的，但是向量场只能建模短期的一                    步依赖关系。<br>​        第三： 当前景和背景以同步方式移动时，向量场无法区分它们，即前景与背景相同的运动。</p>
<hr>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><img src="/2020/02/21/AnchorDiffusion/1582273121006.png" alt="1582273121006" style="zoom:100%;">



<p>我们的方法从属于锚帧的单个像素嵌入到当前帧(左侧)的所有像素嵌入之间学习<strong>一对多相似性</strong>的例子(右侧)。稠密相似点的轮廓与锚框中相应像素嵌入的颜色相匹配。注意的相似之处与前景的像素嵌入汽车(红色)产生一个整洁的热图,识别对象,而两组相似的像素嵌入“错误选择”车(绿色)和道路(紫色)更高的通信背景。这些学习到的相似性是一种简单而有效的分割前景对象的方法。彩色效果最佳。</p>
<img src="/2020/02/21/AnchorDiffusion/1582295328791.png" alt="1582295328791" style="zoom:100%;">

<p>最终的热图是所有输出热图的平均值。0.5的阈值产生最终的二进制标签。</p>
<hr>
<h1 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h1><img src="/2020/02/21/AnchorDiffusion/1582295374722.png" alt="1582295374722" style="zoom:100%;">

<p><strong>输入：</strong> 图片对，锚帧和目标帧 $I_t$，锚帧 $ I_0 $  是视频序列的第一个帧，随机采样视频中的一帧作为第二张图片</p>
<p><strong>特征编码：</strong>DeepLabv3将锚帧和当前要分割的帧编码成相关的嵌入向量<br>$$<br>X_0 ∈ R^{hw × c}<br>$$</p>
<p>$$<br>X_t ∈ R^{hw ×c }<br>$$</p>
<p>​        将每个位置的c维特征向量称为像素嵌入。</p>
<p>三个分支：锚扩散分支、帧内分支、跳层连接分支</p>
<blockquote>
<p>a skip connection with an identity mapping</p>
<p>the intraframe branch</p>
<p>the anchor-diffusion branch</p>
<p>在帧内分支的情况下，每个输出像素嵌入可以被认为是所有输入像素嵌入的全局集合，通过两两外观相似度加权。已有研究表明，这种<strong>非局部操作可以利用长程空间信息，有利于语义分割</strong></p>
</blockquote>
<p>第一阶段的输出会喂入三个平行的分支 ， $X_t$ 会送到所有的分支中， $X_0$ 只会送入到Anchor-Diffusion中。</p>
<p>最后三个分支的特征沿着通道维度Concatenate  。</p>
<h2 id="Anchor-diffusion"><a href="#Anchor-diffusion" class="headerlink" title="Anchor diffusion"></a><strong>Anchor diffusion</strong></h2><p>为了增强前景信号，了解目标帧中的哪个像素嵌入对应于整个视频中引入的背景是很重要的。</p>
<img src="/2020/02/21/AnchorDiffusion/1582295535830.png" alt="1582295535830" style="zoom:80%;">

<img src="/2020/02/21/AnchorDiffusion/1582295572127.png" alt="1582295572127" style="zoom:80%;">
$$
Z = \sqrt{c}
$$
​        过渡矩阵 P 建立了 $X_0 $ 和 $X_t$ 像 素对之间的密集对应关系。转换矩阵P学习了一个相似度度量，可以很好地识别两帧内的共同object，因此，在式中，P可以增强锚帧中具有较强对应关系的像素点的信号，减弱不具有较强对应关系的像素点的信号。由于前景目标对象几乎总是出现在两帧中，而背景变化相对较快，我们的扩散过程通常是增强前景，压制背景。

<p>​        <code>Softmax</code>函数将里面的式子的每一行进行归一化，可以保持像素嵌入的尺度不变性。如果不进行归一化，上式子可能会完全改变像素嵌入的比例。</p>
<p>​     像素嵌入随时间的时间一致性，测量为锚帧中的前景像素嵌入与逐渐变远的帧中的前景像素嵌入之间的余弦距离，得到以下结果：</p>
<img src="/2020/02/21/AnchorDiffusion/1582295606508.png" alt="1582295606508" style="zoom:80%;">

<p>这表明，AD-Net能够在较长时间内保存视频中第一帧的前景信息。</p>
<h1 id="后处理Instance-Pruning"><a href="#后处理Instance-Pruning" class="headerlink" title="后处理Instance Pruning"></a><strong>后处理Instance Pruning</strong></h1><p>​        因为AD-net主要区分前景和背景，将前景分割，但是对于有一些视频序列有很多类似前景的像素，使用<strong>Instance Pruning</strong> <strong>可以细化分割效果。</strong></p>
<p>​        首先，（这个实例裁剪算法）SmallStatic返回一组包围框和对应的实例掩码，它们表示小的和几乎静态的实例。输入，并为每一帧生成一个修剪掩码，该掩码合并所有比当前帧中的最大实例小得多的小型和静态实例。最后，每个输入掩码与相应的修剪掩码相乘然后，将这些实例和原始掩码作为 输出最终的预测。</p>
<img src="/2020/02/21/AnchorDiffusion/1582295731939.png" alt="1582295731939" style="zoom:80%;">

<img src="/2020/02/21/AnchorDiffusion/1582295754571.png" alt="1582295754571" style="zoom:150%;">

<hr>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><img src="/2020/02/21/AnchorDiffusion/1582295802040.png" alt="1582295802040" style="zoom:150%;">



]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>papers</tag>
        <tag>UVOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CosNet:基于协同注意孪生网络的无监督视频目标分割</title>
    <url>/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h1 id="【CVPR2019】CosNet：See-More-Know-More-Unsupervised-Video-Object-Segmentation-with-Co-Attention-Siamese-Networks"><a href="#【CVPR2019】CosNet：See-More-Know-More-Unsupervised-Video-Object-Segmentation-with-Co-Attention-Siamese-Networks" class="headerlink" title="【CVPR2019】CosNet：See More, Know More: Unsupervised Video Object Segmentation with Co-Attention Siamese Networks"></a>【CVPR2019】CosNet：See More, Know More: Unsupervised Video Object Segmentation with Co-Attention Siamese Networks</h1><h2 id="基于协同注意孪生网络的无监督视频目标分割"><a href="#基于协同注意孪生网络的无监督视频目标分割" class="headerlink" title="基于协同注意孪生网络的无监督视频目标分割"></a>基于协同注意孪生网络的无监督视频目标分割</h2><p><strong>代码： <a href="https://github.com/Castile/COSNet">https://github.com/Castile/COSNet</a></strong> </p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​         以往的无监督视频目标分割基于深度学习的方法仅仅考虑短期时域信息，没有考虑整个视频的全局信息，而且并没有有效利用视频内容的内在相关信息 ，**Co-attention Siamese Network(CosNet)**提出了一个统一的端到端的无监督视频目标分割网络。  </p>
<p>​        CosNet将UVOS作为co-attention的过程。一个co-attention模块学习去显示编码帧与帧之间的关系，使CosNet可以获取频繁相关的区域，进而可以帮助发现前景目标来进行分割。具体的，在训练阶段，co-attention过程能够分解为同一视频中任意帧对之间的相关性学习，在测试的时候，CosNet使用全局视角推断前景目标，也就是说利用测试帧与多个相关的帧的co-attention信息来判断主要的前景目标。CosNet的网络结构如下图所示。这是无监督视频目标分割最好的模型，在Davis2016数据集上的J-means达到了80.5的分数。</p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580910682924.png" alt="1580910682924" style="zoom:80%;">

<p>​        CosNet认为无监督视频目标分割下的主要目标拥有以下特点：</p>
<blockquote>
<p>1)单帧可区分(本地显著性)；</p>
<p>2)在整个视频序列中频繁出现的目标(全局一致性)。</p>
</blockquote>
<p>​        这两个特点对于区分视频序列中的主要目标的非常重要的。通过考虑视频的全局信息，可以锁定主要目标，进而进行分割。</p>
<h1 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h1><img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580910735819.png" class>



<p>​        输入是图片对，图片对可以从视频中随机取得。两帧图片经过基网络（DeeplabV3），也称编码网络（Encoder）， 将两帧编码成嵌入特征，然后协同注意力模块会计算两帧的相似性，即两帧之间的相关注意力特征。最后输入到分割模块得到最后的分割结果。</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="Co-attention-Mechanisms-in-COSNet"><a href="#Co-attention-Mechanisms-in-COSNet" class="headerlink" title="Co-attention Mechanisms in COSNet"></a>Co-attention Mechanisms in COSNet</h2><p>作者提出了三种协同注意力机制，分别为Vanilla co-attention， Symmetric co-attention，Channel-wise co-attention。一个注意力模块这显式地编码两帧之间的相关性，这样可以使得COsNet学习到频繁相关的区域。</p>
<h3 id="Vanilla-co-attention"><a href="#Vanilla-co-attention" class="headerlink" title="Vanilla co-attention"></a>Vanilla co-attention</h3><img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580911492126.png" class width="1580911492126">

<p>S 是两帧之间的afﬁnity matrix（相似矩阵），Va和Vb的shape是<br>$$<br>W * H  * C<br>$$<br>Va的每一列表示特征向量，W是一个方阵</p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580911687054.png" class width="1580911687054">

<p>所以S又可以写成：</p>
<div align="center"> 

<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580911733141.png" class width="1580911733141">

</div>

<p>通过上面公式，首先对每一帧的特征表示进行线性变换，然后计算它们之间的距离 。</p>
<h3 id="Symmetric-co-attention"><a href="#Symmetric-co-attention" class="headerlink" title="Symmetric co-attention"></a>Symmetric co-attention</h3><p>如果对权重矩阵进行约束，令权重矩阵为一个对称矩阵。则投影矩阵P就变成一个正交矩阵<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912078801.png" alt="1580912078801" style="zoom: 80%;"></p>
<p>I是一个C * C的单位阵。则Symmetric co-attention的计算公式为：</p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912157546.png" alt="1580912157546" style="zoom:80%;" align="center">

<p> 上述公式表明将嵌入向量Va和Vb的特征投影到正交公共空间中，并保持它们的范数。这一特性可以消除不同通道之间的相关性和提高网络的泛化能力。</p>
<h2 id="Channel-wise-co-attention"><a href="#Channel-wise-co-attention" class="headerlink" title="Channel-wise co-attention"></a>Channel-wise co-attention</h2><p>将投影矩阵P简单地表示成单位矩阵 I （也就是没有进行空间的转换），然后权重矩阵W变成对角矩阵，在这种情况下，W（也就是D）可以分为两个对角矩阵Da和Db， 因此，公式3可以重新写成一下形式，也就是Channel-wise co-attention：</p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912721357.png" alt="1580912721357" style="zoom:80%;" align="center">

<p> 这个操作相当于在计算相似度之前对Va和Vb应用一个信道权值, 这有助于缓解通道冗余 .</p>
<h1 id="协同注意力操作"><a href="#协同注意力操作" class="headerlink" title="协同注意力操作"></a>协同注意力操作</h1><img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912845406.png" alt="1580912845406" style="zoom:80%;" align="center">

<p>协同注意力操作如上图所示，在获取了相似度矩阵S之后，对S的行向量和列向量进行SoftMax操作：</p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580912943618.png" alt="1580912943618" style="zoom:80%;" align="center">

<p>结合上图：</p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913044245.png" alt="1580913044245" style="zoom:80%;" align="center">

<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580910735819.png" alt="1580910735819" style="zoom:80%;">



<p>在网络中的协同注意力模块还有一个Gated co-attention操作， 考虑到输入对、遮挡和背景噪声之间潜在的外观变化，最好对来自不同输入帧的信息进行加权，而不是平均处理所有的共同注意信息。</p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913182677.png" alt="1580913182677" style="zoom:150%;" align="center"> 
$$
\sigma是一个sigmoid激活函数，
w_f和b_f表示卷积核和偏置参数。
$$


<p>计算完gate的置信度之后，注意力Z表示为：<br><img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913526624.png" alt="1580913526624" align="center"></p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913588288.png" alt="1580913588288" style="zoom:80%;">

<hr>
<h1 id="CosNet-整体架构"><a href="#CosNet-整体架构" class="headerlink" title="CosNet 整体架构"></a>CosNet 整体架构</h1><img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580913733433.png" alt="1580913733433" align="center">

<p>CosNet是一个孪生网络，由三个级联的部分，一个基于DeepLabV3的特征嵌入模块，一个协同注意力模块以及分割模块。</p>
<h2 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h2><p>​        上文说到，视频中的主要对象（即要分割的对象）有两个基本属性:(i)帧内可分辨性，(ii)帧间一致性。为了区分前景目标和背景(属性(i))，我们利用现有的显著性目标分割数据集DUTS和MSRA 10K来训练我们的backbone特征嵌入模块。同时，为了确保COSNet能够捕获主要视频对象的全局帧间相干性(property (ii))，我们使用视频分割数据训练整个COSNet，其中co-attention模块在捕获视频帧之间的相关性方面起着关键作用。具体来说，我们在一个视频序列中随机选取两帧来建立训练对。值得一提的是，与以往的基于循环神经网络的UVOS模型只需要连续帧相比，这种操作自然有效地扩充了训练数据, 即数据增强。</p>
<p>​        通过这种方式，COSNet可以交替使用静态图像数据和动态视频数据进行训练。在使用图像数据时，我们只训练了特征嵌入模块，其中增加了1×1的sigmoid激活卷积层，生成中间分割的sideoutput。视频数据用于训练整个COSNet，包括特征嵌入模块、协同注意模块和分割模块。利用加权二叉熵损失训练网络: </p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914232679.png" alt="1580914232679" style="zoom:80%;" align="center">

<p> 其实训练阶段是<strong>完全监督</strong>的，因为使用到了groundtruth。</p>
<h2 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h2><p>​        训练完成之后，使用模型在其他没有见过的视频序列中进行测试。给定一个测试视频序列，我们可以将每个要分割的帧，以及从同一视频中采样的一个参考帧，依次输入到COSNet中，通过逐帧的操作，我们可以得到所有的分割结果。</p>
<p>​        然而，在这样一个简单的策略下，分割结果仍然含有相当大的噪声，因为视频中丰富的全局相关信息并没有得到充分的挖掘。因此，在测试阶段包含更多的是推导帧常重要的：</p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914483240.png" alt="1580914483240" style="zoom:80%;" align="center">

<p> 将一组N个不同的参考帧(从同一视频中均匀采样)输入推理分支，并对所有预测进行平均。 </p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914542254.png" alt="1580914542254" style="zoom:80%;" align="center">

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>DAVIS-2016数据集：</p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914796880.png" alt="1580914796880" style="zoom:80%;" align="center">

<p>FBMS数据集：<br><img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914854214.png" alt="1580914854214" style="zoom:80%;" align="center"></p>
<p>  YoutubeObjects  数据集：</p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580914901876.png" alt="1580914901876" style="zoom:80%;" align="center">

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ol>
<li><p>协同注意力机制基于全局的视角进行推断前景和背景的分割，效果显著。</p>
</li>
<li><p>在测试时，平均多个帧的的注意力更有效</p>
</li>
<li><p> 为了研究最终预测在测试阶段的帧选择策略，我们进一步使用不同的采样方法进行了一系列的实验。具体采用全局随机抽样、全局均匀抽样和局部连续抽样。从表1中可以看出，两种全局水平的采样策略都能获得近似的性能，但都优于局部采样方法。同时，基于局部采样的结果仍然优于从骨干网获得的结果。整体比较进一步证明了合并的重要性 。</p>
</li>
<li><p>关于参考帧数的选择，如表：</p>
<img src="/2020/02/05/CosNet-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E5%90%8C%E6%B3%A8%E6%84%8F%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E8%A7%86%E9%A2%91%E7%9B%AE%E6%A0%87%E5%88%86%E5%89%B2/1580915369748.png" alt="1580915369748" style="zoom:80%;" align="center">

<p> 当N = 0时，这意味着没有共同注意分割。当N从0变为1时，可以看到一个很大的性能改进 。N从2变化到5，定量结果显示性能有所提高。当我们进一步增加N时，最终的性能没有明显的变化。实验中使用的N=5。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>papers</tag>
        <tag>UVOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Davis数据集评估工具使用-MATLAB</title>
    <url>/2020/03/14/Davis%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%84%E4%BC%B0%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-MATLAB/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>因为很久不做实验很容易忘记怎么使用，所以还是做个记录吧。</p>
<p>在Davis官网上下载matlab版本的代码: <a href="https://github.com/davisvideochallenge/davis-matlab/tree/davis-2016">https://github.com/davisvideochallenge/davis-matlab/tree/davis-2016</a> </p>
<img src="/2020/03/14/Davis%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%84%E4%BC%B0%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-MATLAB/1584191875571.png" alt="1584191875571" style="zoom:100%;">

<p>在window操作系统下会有点问题，解压时会遇到aux文件夹内容解压失败，这是因为aux是windows保留的名称，因此不能创建名称为aux的文件夹或文件。 所以解决方法是 </p>
<p>创建文件夹aux_ :  ..\DAVIS2016\davis-matlab-davis-2016\measures\aux_  </p>
<p> 然后把aux中对应内容解压到aux_中。还要修改的相应的文件：</p>
<p> 修改 ..\DAVIS2016\davis-matlab-davis-2016\startup.m ：</p>
<img src="/2020/03/14/Davis%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%84%E4%BC%B0%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-MATLAB/1584192104385.png" alt="1584192104385" style="zoom:100%;">



<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>修改<code>db_root_dir.m</code>，使得地址指向<code>DAVIS</code>数据库在你系统中解压的位置（包含文件夹Annotations和JPEGImages）。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">root_dir</span> = <span class="title">db_root_dir</span><span class="params">()</span></span></span><br><span class="line">    root_dir = <span class="string">&#x27;F:\data\DAVIS-data\DAVIS&#x27;</span>;  <span class="comment">%% 设置数据集的路径</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>运行<code>startup.m</code>，添加必要的路径和执行一些检查操作。</p>
</li>
<li><p>如果上一步出问题了，就执行build.m，进行重编译。</p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>创建main.m文件，调用评估代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% main.m</span></span><br><span class="line">addpath(fullfile(db_matlab_root_dir,<span class="string">&#x27;db_util&#x27;</span>));</span><br><span class="line">addpath(fullfile(db_matlab_root_dir,<span class="string">&#x27;measures&#x27;</span>));</span><br><span class="line"> </span><br><span class="line">[eval, raw_eval] = eval_result(<span class="string">&#x27;mvos_test_3_final&#x27;</span>, &#123;<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;T&#x27;</span>&#125;,<span class="string">&#x27;val&#x27;</span>);</span><br><span class="line"><span class="comment">%function [eval, raw_eval] = eval_result(result_id, measures, gt_set)</span></span><br></pre></td></tr></table></figure>

<p>上面eval_result(‘mvos_test_3_final’, {‘J’,’F’,’T’},’val’); 中填入你要评估的方法名称，这个是你的Reslut结果文件夹的名称，也就是分割的结果。</p>
<p>measures/<code>eval_result.m</code>并非demo，而是一个<code>function</code>，需要自己写个<code>demo</code>调用它，也就是创建的main.m</p>
<p>看看这个<code>eval_result.m</code>文件：</p>
<blockquote>
<p>function [eval, raw_eval] = eval_result(result_id, measures, gt_set)</p>
</blockquote>
<p>输入：</p>
<ol>
<li><code>result_id</code>：要评估的方法的ID，比如’COSNET’、’ARP’、’AGNN’等等</li>
<li><code>measures</code>：要评估的指标，三种{ $J 、F、T$} 。</li>
<li><code>gt_set</code>：用哪个集合作为gt集合，有三种：<code>&#39;all&#39;、&#39;train&#39;、&#39;val&#39;</code></li>
</ol>
<p>运行main.m就可以生成三个评价指标的mat</p>
</li>
<li><p>使用experiments\experiments_params.m可以将表格画出来。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% List of techniques compared</span></span><br><span class="line"><span class="comment">% techniques = &#123;&#x27;mcg&#x27;,&#x27;sf-lab&#x27;,&#x27;sf-mot&#x27;,...</span></span><br><span class="line"><span class="comment">%               &#x27;nlc&#x27;,&#x27;cvos&#x27;,&#x27;trc&#x27;,&#x27;msg&#x27;,...</span></span><br><span class="line"><span class="comment">%               &#x27;key&#x27;,&#x27;sal&#x27;,&#x27;fst&#x27;,...</span></span><br><span class="line"><span class="comment">%               &#x27;tsp&#x27;,&#x27;sea&#x27;,&#x27;hvs&#x27;,&#x27;jmp&#x27;,&#x27;fcp&#x27;,&#x27;bvs&#x27;,&#x27;ofl&#x27;,&#x27;msk&#x27;,&#x27;osvos&#x27;,&#x27;epo+&#x27;,  &#x27;AGNN&#x27;&#125;;</span></span><br><span class="line"><span class="comment">%           </span></span><br><span class="line">techniques = &#123;<span class="string">&#x27;AGNN&#x27;</span>,  <span class="string">&#x27;AGNN_CRF&#x27;</span>, <span class="string">&#x27;agnn_10&#x27;</span>, <span class="string">&#x27;COSNET&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">% Names to be shown on the tables</span></span><br><span class="line"><span class="comment">% techniques_paper = &#123;&#x27;MCG&#x27;,&#x27;SF-LAB&#x27;,&#x27;SF-MOT&#x27;,...</span></span><br><span class="line"><span class="comment">%                     &#x27;NLC&#x27;,&#x27;CVOS&#x27;,&#x27;TRC&#x27;,&#x27;MSG&#x27;,...</span></span><br><span class="line"><span class="comment">%                     &#x27;KEY&#x27;,&#x27;SAL&#x27;,&#x27;FST&#x27;,...</span></span><br><span class="line"><span class="comment">%                     &#x27;TSP&#x27;,&#x27;SEA&#x27;,&#x27;HVS&#x27;,&#x27;JMP&#x27;,&#x27;FCP&#x27;,&#x27;BVS&#x27;,&#x27;OFL&#x27;,&#x27;MSK&#x27;,&#x27;OSVOS&#x27;,&#x27;epo+&#x27;, &#x27;AGNN&#x27;&#125;;</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line">techniques_paper = &#123;<span class="string">&#x27;AGNN&#x27;</span>,  <span class="string">&#x27;AGNN_CRF&#x27;</span>, <span class="string">&#x27;agnn_10&#x27;</span>, <span class="string">&#x27;COSNET&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">% Output folder to save files</span></span><br><span class="line">paper_data = <span class="string">&#x27;~/tmp&#x27;</span>;       </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面填你要比较的方法名称。</p>
</li>
<li><p>experiments\global_table.m 生成结果</p>
<p> 直接运行即可得到下面表格的数据。各个方法的评价指标值，比较表格。 </p>
<img src="/2020/03/14/Davis%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%84%E4%BC%B0%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-MATLAB/1584192901696.png" alt="1584192901696" style="zoom:100%;"></li>
<li><p>experiments\attribute_table.m</p>
<p> 直接运行即可得到下面的表格数据。在不同的挑战下各算法性能比较。 </p>
<img src="/2020/03/14/Davis%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%84%E4%BC%B0%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-MATLAB/1584192927384.png" alt="1584192927384" style="zoom:100%;"></li>
</ol>
<hr>
<h1 id="结果文件夹的位置"><a href="#结果文件夹的位置" class="headerlink" title="结果文件夹的位置"></a>结果文件夹的位置</h1><p>一般你要有如下的文件层级：……/DAVIS-data/DAVIS/Results/Segmentations/480p/</p>
<p>480p文件夹放入你分割的结果：</p>
<img src="/2020/03/14/Davis%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AF%84%E4%BC%B0%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-MATLAB/1584193115830.png" alt="1584193115830" style="zoom:100%;">

<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/qq_25379821/article/details/83035945">https://blog.csdn.net/qq_25379821/article/details/83035945</a> </li>
</ol>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>davis</tag>
        <tag>matlab</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>GCNet： 当NLNet遇到SENet</title>
    <url>/2020/03/23/GCNet/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="GCNet-Non-local-Networks-Meet-Squeeze-Excitation-Networks-and-Beyond【CVPR2019】"><a href="#GCNet-Non-local-Networks-Meet-Squeeze-Excitation-Networks-and-Beyond【CVPR2019】" class="headerlink" title="GCNet: Non-local Networks Meet Squeeze-Excitation Networks and Beyond【CVPR2019】"></a>GCNet: Non-local Networks Meet Squeeze-Excitation Networks and Beyond【CVPR2019】</h2><p>传送地址：<a href="https://arxiv.org/pdf/1904.11492.pdf">https://arxiv.org/pdf/1904.11492.pdf</a> </p>
<p>GitHub：<a href="https://github.com/xvjiarui/GCNet">https://github.com/xvjiarui/GCNet</a>.</p>
<p><code>Non-Local Network (NLNet)</code>  在捕获长距离依赖关系（ <code>long-range dependency</code> ）方面是一项开创性的工作，它通过在一个位置的计算响应是输入特性图中所有位置的特征的加权总和来获得全局上下文的信息。但是作者发现，对于一副图片，不同的<code>query positions</code> 通过 <code>non-local</code>结构获得的全局上下文信息几乎一样，这让作者对<code>Non-local</code>产生了质疑，<code>Non-Local</code>的参数量和计算量相对来说都比较大，这么费力气去计算响应图，发现每个位置的<code>attention</code>都几乎一致。所以作者提出了一种简化的网络，在准确率差不多的情况下，计算量却降低了，然后作者发现经过他改造后的网络结构和  <code>Squeeze-Excitation Network (SENet)</code> 的结构很相似。把它称作为<code>GCNet(global conntext block)</code>。<code>SENet</code> 的 <code>three steps</code>：1、全局上下文建模；2、<code>channel-wise</code> 依赖关系转换；3、特征融合。 这种<code>GC block</code>是轻量级的，这就可以被运用到<code>backbone</code>网络中，并且可以多层，从而构成一个 <code>GCNet</code>，它通常在各种识别任务的主要基准上都优于简化的<code>NLNet</code>和<code>SENet</code> 。</p>
<p><code>SENet</code>、<code>Non-local</code>以及本文的<code>GCNet</code>都是想办法获取视频或者<code>image</code>中的<code>long-range dependency</code> ，它们的目的都是尽可能从<strong>全局的角度</strong>（<code>global context</code>）来理解视频和图像。在卷积神经网络中，单靠传统的卷积层是无法自己做到这一点的（或者说做的不够好），卷积层是在<strong>局部邻域</strong>（  <code>local neighborhood</code>  ）内建立<strong>像素关系</strong>，其长期依赖关系主要通过深度叠加卷积层来建模 。虽然可以通过不断的加深网络，来达到网络后半部分的神经元的感受野变大，这样计算量大，优化也很困难，达到一种不那么“local”的效果。但这种粗暴的加深网络的做，有如下三个缺点：</p>
<ol>
<li>不够精巧，参数量、计算量粗暴拼凑出来的。</li>
<li>网络越深，优化难度越大。</li>
<li>不那么”local”并不代表全局，有最大距离的限制。 比如在网络的后半部分，<code>feature map</code>右下角的cell，感受野可能扩大了，但可能还是始终无法获得原图片上左上角的信息(因为卷积操作最大距离的限制)。 </li>
</ol>
<h1 id="non-local-和-SENet"><a href="#non-local-和-SENet" class="headerlink" title="non-local 和 SENet"></a>non-local 和 SENet</h1><p> 不同查询位置的注意力图几乎是相同的   but surprisingly observe that the attention maps for different query positions are almost the same, indicating only query-independent dependency is learnt. 如下图所示。</p>
<img src="/2020/03/23/GCNet/1584974323783.png" class width="1584974323783">

<p>二者都是通过从各个位置聚集的相同特征来强化原有特征，但在聚集策略、转换和强化功能上的选择又相互区别。</p>
<p> 通过对这些函数的抽象，得到了一个统一简化的<code>NL</code>块和<code>SE</code>块的三步通用框架:</p>
<ul>
<li>(a)<strong>上下文建模模块</strong>，它将所有位置的特征集合在一起，形成全局上下文特征;</li>
<li>(b)<strong>特征转换模块</strong>，以捕捉<strong>各通道</strong>之间的相互依存关系;</li>
<li>(c)<strong>融合模块</strong>，将<em>全局上下文</em>特征合并到<em>所有位置的特征</em>中 </li>
</ul>
<h1 id="Long-range-dependency-modeling"><a href="#Long-range-dependency-modeling" class="headerlink" title="Long-range dependency modeling"></a>Long-range dependency modeling</h1><p> 最近的<strong>远程依赖关系</strong>（<code>Long-range dependency</code>）建模方法可以分为两类。第一种是采用自我注意机制（<code>self-attention</code>）来建立两两关系的模型。第二种方法是对查询无关（  <code>query-independent</code> ）的全局上下文建模 。</p>
<hr>
<h1 id="Analysis-on-Non-local-Networks"><a href="#Analysis-on-Non-local-Networks" class="headerlink" title="Analysis on Non-local Networks"></a>Analysis on Non-local Networks</h1><p>既然attention map与具体点的位置无关，一个最直观的反应是，那就不要每一个点单独算一个attention map了。用另外一种同样能够获得全局信息，但一个feature map上的点共用的特征吧。基于此，本文作者提出了简化版的NL(snl)。从网络结构上可以看是如图2的变化：</p>
<img src="/2020/03/23/GCNet/1584976283304.png" class width="1584976283304">





<p> 两个标准任务的两个距离测量结果如表1所示。首先，“<code>input</code>”列中的余弦距离值较大，表明<code>Non-local block</code>的输入特征可以在不同位置上进行识别。但是“<code>output</code>”中的余弦距离值非常小，这表明由<code>Non-local block</code>建模的<strong>全局上下文特征</strong>对于不同的查询位置几乎是相同的。对于所有实例化，“<code>att</code>”上的两个距离度量值都非常小，这再次验证了来自可视化的观察结果。换句话说，虽然一个<code>Non-local block</code>打算计算特定于每个查询位置的全局上下文，但是训练后的全局上下文实际上是独立于查询位置的。因此，不需要为每个查询位置计算查询特定的全局上下文，从而允许我们简化非本地块 。</p>
<img src="/2020/03/23/GCNet/1584978438008.png" class width="1584978438008">



<h1 id="GCNet"><a href="#GCNet" class="headerlink" title="GCNet"></a>GCNet</h1><img src="/2020/03/23/GCNet/1584978612596.png" class width="1584978612596">

<p> 通过计算一个<strong>全局</strong>(  <code>query-independent</code> )的<code>attention map</code>并<strong>共享</strong>所有查询位置的global attention map来简化Non-local.</p>
<p>如下图(b),这是简化后的<code>Non-local</code>，一个直观的感觉是block结构确实简化了。</p>
<img src="/2020/03/23/GCNet/1584979117291.png" class width="1584979117291">

<p>简化后的Non-local公式：</p>
<img src="/2020/03/23/GCNet/1584979015664.png" class width="1584979015664">

<p> 为了进一步降低这个简化块的计算成本，我们应用分配律将$W_v$移出  <code>attention pooling</code> ，即 </p>
<img src="/2020/03/23/GCNet/1584979280086.png" class width="1584979280086">

<p>关键部分在于**+**号后面的变化。<code>Non-local</code> **+<strong>号后面的内容与$x_i$有关，因此每一个点 i，需要计算一次。而<code>SNL</code>的表达公式</strong>+**号后面的内容已与$x_i$无关，也即计算一次，然后所有位置上共享，也映证了上文所讲的<code>query-independent</code>。</p>
<p>看上图（b），简化后的NL block可以抽象成三个过程：</p>
<ol>
<li>首先采用1x1的卷积，$W_k$为权值矩阵以及一个<code>softmax</code>函数去获得<code>attention weight</code>，然后将注意力权重汇集到原始图中以获得全局上下文特征。</li>
<li>通过1x1卷积，$W_v$为权重，进行特征转换。</li>
<li>特征融合。 它使用加法将全局上下文特性聚合到每个位置的特征上。 </li>
</ol>
<p>到目前为止，该网络结构还只能称之为<code>SNL</code>。作者对<code>SNL</code>做了一些结构的优化，就变成了最终的<code>GC block</code>。主要有两点：</p>
<ol>
<li>对于<code>SNL</code>模块中右下角的1x1卷积，它的参数量是CxC 。例如，输入通道是2048，输出通道是2048。则参数量就是4000000。这样会导致该模块不够轻量级，无法插入网络的任意位置。作者是通过一个<code>bottleneck</code>结构来替换。这样参数量可以从CxC 到 2xCxC/r（r通常设置为16）。 参数数量可以减少到原来的<code>SNL</code>块的1/8。 </li>
<li><code>two-level bottleneck</code> 的引入增加了网络优化的难度，因此作者引入了<code>layer norm</code>（作者论文中实验讲，这一加入还是蛮有效的，0.x个点吧）。</li>
</ol>
<p>GC 公式：</p>
<img src="/2020/03/23/GCNet/1584981063477.png" class width="1584981063477">

<p>具体地：</p>
<img src="/2020/03/23/GCNet/1584981563661.png" class width="1584981563661">

<p>这个结构和SENet的结构很像：</p>
<img src="/2020/03/23/GCNet/1584981633319.png" class width="1584981633319">

<p>  这时，作者提出了一个“<code>Global context modeling framework</code>”来抽象这一类结构:就是上面说的三个过程:Context modeling、Transform、Fusion</p>
<blockquote>
<p>Specifically, our GC block consists of: </p>
<p>(a) global attention pooling for context modeling;</p>
<p> (b)bottleneck transform to capture channel-wise dependencies; </p>
<p>and (c) broadcast element-wise addition for feature fusion.  </p>
</blockquote>
<img src="/2020/03/23/GCNet/1584981728931.png" class width="1584981728931">

<p>作者在论文中总结了自己提出的<code>GCNet</code>与<code>SENet</code>网络之间的差异：</p>
<p>1、<code>SENet</code>在融合的时候使用的是<code>rescale</code>，而<code>GCNet</code>使用的是<code>sum</code>。因此<code>&quot;SE recalibrate the importance of channels but inadequately models long-range dependency&quot;</code>。</p>
<p>2、<code>Layer-norm</code>的使用。</p>
<p>3、<code>SE</code>中用于提取全局信息的<code>global pooling</code> 是<code>GCNet</code> <code>global attention pooling</code>的一种特例</p>
<p>4、性能上，优于<code>SENet</code>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li> <a href="https://blog.csdn.net/u011345885/article/details/96566339">https://blog.csdn.net/u011345885/article/details/96566339</a> </li>
<li><a href="https://arxiv.org/abs/1711.07971">non-local论文地址</a><br><a href="https://github.com/facebookresearch/video-nonlocal-net">non-local代码地址</a><br><a href="https://arxiv.org/abs/1904.11492?context=cs.LG">gcnet论文地址</a><br><a href="https://github.com/xvjiarui/GCNet">gcnet代码地址</a><br><a href="https://arxiv.org/abs/1709.01507">senet论文地址</a><br><a href="https://github.com/hujie-frank/SENet">senet代码地址</a> </li>
</ol>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>papers</tag>
        <tag>Attention</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK8中日期的API的使用</title>
    <url>/2020/02/27/JDK8%E4%B8%AD%E6%97%A5%E6%9C%9F%E7%9A%84API%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="jdk8之前"><a href="#jdk8之前" class="headerlink" title="jdk8之前"></a>jdk8之前</h1><h2 id="java-util-Date-日期类"><a href="#java-util-Date-日期类" class="headerlink" title="java.util.Date 日期类"></a>java.util.Date 日期类</h2><p>​            —- java.sql.Date  数据库里面使用的数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Date</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>System类提供的<code>public static long currentTimeMillis()</code>用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。      <strong>此方法适于计算时间差</strong>  </p>
<blockquote>
<p>getTime() :返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</p>
<p>toString() :把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。</p>
</blockquote>
<h2 id="java-text-SimpleDateFormat类"><a href="#java-text-SimpleDateFormat类" class="headerlink" title="java.text.SimpleDateFormat类"></a>java.text.SimpleDateFormat类</h2><p>Date类的API不易于国际化，大部分被废弃了，<code>java.text.SimpleDateFormat</code>类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</p>
<p><strong>它允许进行格式化（日期—&gt;文本）、解析（文本—-&gt;日期）</strong></p>
<p>格式化：</p>
<blockquote>
<p><code>SimpleDateFormat()</code> ：默认的模式和语言环境创建对象</p>
<p><code>public SimpleDateFormat</code>(String pattern)：该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用：</p>
<p><code>public String format</code>(Date date)：方法格式化时间对象date</p>
</blockquote>
<p>解析：</p>
<blockquote>
<p><code>public Date parse(String source)</code>：从给定字符串的开始解析文本，以生成一个日期。</p>
</blockquote>
<h2 id="三天打渔两天晒网"><a href="#三天打渔两天晒网" class="headerlink" title="三天打渔两天晒网"></a>三天打渔两天晒网</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">       <span class="comment">// 三天打渔两天晒网： 问 在xxxx-xx-xx这一天是打渔还是在晒网。</span></span><br><span class="line">       <span class="comment">// 从1996-10-02开始三天打渔两天晒网</span></span><br><span class="line">       SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">       String begin = <span class="string">&quot;1996-10-02&quot;</span>;</span><br><span class="line">       String now = <span class="string">&quot;2020-02-28&quot;</span>;</span><br><span class="line">       Date start = sdf.parse(begin);</span><br><span class="line">      <span class="keyword">long</span> totalMills = sdf.parse(now).getTime() -  start.getTime();</span><br><span class="line">      <span class="keyword">long</span> totalDays = totalMills / (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>) + <span class="number">1</span>; <span class="comment">//防止小数点</span></span><br><span class="line">       System.out.println(<span class="string">&quot;总天数：&quot;</span> + totalDays);</span><br><span class="line">	<span class="comment">//  System.out.println(totalDays / 366.0);</span></span><br><span class="line">      <span class="keyword">int</span> res = (<span class="keyword">int</span>)totalDays % <span class="number">5</span>;</span><br><span class="line">       System.out.println(<span class="string">&quot;结果: &quot;</span>+ res);</span><br><span class="line">      <span class="keyword">if</span>(res &gt;= <span class="number">1</span> &amp;&amp; res &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;在打渔。。。。。。。。。&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;在晒网....................&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="java-util-Calendar-日历-类"><a href="#java-util-Calendar-日历-类" class="headerlink" title="java.util.Calendar(日历)类"></a>java.util.Calendar(日历)类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Calendar calendar = Calendar.getInstance();</span><br><span class="line">      <span class="keyword">int</span> days =  calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">      System.out.println(days);  <span class="comment">// 27</span></span><br><span class="line">      days = calendar.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">      System.out.println(days); <span class="comment">// 58</span></span><br><span class="line"></span><br><span class="line">      calendar.add(Calendar.DAY_OF_MONTH , -<span class="number">3</span>);</span><br><span class="line">      days = calendar.get(Calendar.DAY_OF_MONTH);  <span class="comment">// 24</span></span><br><span class="line">      System.out.println(days);</span><br><span class="line"></span><br><span class="line">      Date date = calendar.getTime();</span><br><span class="line">      System.out.println(date); <span class="comment">// Mon Feb 24 16:29:10 CST 2020</span></span><br><span class="line"></span><br><span class="line">      Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">      calendar.setTime(date1);</span><br><span class="line">      days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">      System.out.println(days); <span class="comment">// 27</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="JDK8中的日期API"><a href="#JDK8中的日期API" class="headerlink" title="JDK8中的日期API"></a>JDK8中的日期API</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JDK1.0中包含了一个java.util.Date类， 但是它的大多数方法已经在JDK1.1中引入Calendar类之后被弃用了。然而Calendar类也并不比Date好多少。它们面临的问题是：</p>
<blockquote>
<p>可变性： 像日期和时间这样的类应该是不可变的，但是Calendar类有set方法可以改变原来的时间。</p>
<p>偏移性： Date的年份是从1900年开始的，而月份都是从0开始的。</p>
<p>格式化： 格式化只对Date有用， Calendar则不行。</p>
<p>此外， 它们也不是线程安全的，； 不能处理闰秒等。</p>
</blockquote>
<blockquote>
<p>闰秒：也称作“跳秒”，  是指为保持<a href="https://baike.baidu.com/item/%E5%8D%8F%E8%B0%83/787659">协调</a><a href="https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E6%97%B6/692237">世界时</a>接近于<a href="https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E6%97%B6">世界时</a>时刻，由<a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E8%AE%A1%E9%87%8F%E5%B1%80/2545290">国际计量局</a>统一规定在年底或<a href="https://baike.baidu.com/item/%E5%B9%B4%E4%B8%AD">年中</a>（也可能在<a href="https://baike.baidu.com/item/%E5%AD%A3%E6%9C%AB/9671176">季末</a>）对协调世界时增加或减少1<a href="https://baike.baidu.com/item/%E7%A7%92/2924586">秒</a>的调整。由于地球<a href="https://baike.baidu.com/item/%E8%87%AA%E8%BD%AC/1011647">自转</a>的不均匀性和长期变慢性（主要由<a href="https://baike.baidu.com/item/%E6%BD%AE%E6%B1%90%E6%91%A9%E6%93%A6/4765297">潮汐摩擦</a>引起的），会使世界时（<a href="https://baike.baidu.com/item/%E6%B0%91%E7%94%A8%E6%97%B6">民用时</a>）和<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%AD%90%E6%97%B6">原子时</a>之间相差超过到±0.9秒时，就把协调世界时向前拨1秒（负闰秒，最后一分钟为59秒）或向后拨1秒（正闰秒，最后一分钟为61秒）； 闰秒一般加在<a href="https://baike.baidu.com/item/%E5%85%AC%E5%8E%86/449762">公历</a>年末或公历六月末。</p>
<p>目前，全球已经进行了27次闰秒，均为正闰秒。</p>
<p>最近一次闰秒在<a href="https://baike.baidu.com/item/%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B4/410384">北京时间</a>2017年1月1日7时59分59秒（<strong>时钟显示07:59:60</strong>）出现。这也是本世纪的第五次闰秒。</p>
</blockquote>
<p>总结： 对日期和时间操作一直是Java程序员最痛苦的地方之一。</p>
<p>Java 8 吸收了 <code>Joda-Time</code> 的精华，以一个新的开始为 Java 创建优秀的 API。新的 <code>java.time</code> 中包含了所有关于时钟（<code>Clock</code>），本地日期（<code>LocalDate</code>）、本地时间（<code>LocalTime</code>）、本地日期时间（<code>LocalDateTime</code>）、时区（ZonedDateTime）和持续时间（<code>Duration</code>）的类。历史悠久的 <code>Date</code> 类新增了 <code>toInstant()</code> 方法，用于把 <code>Date</code> 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了了日期时间和本地化的管理。  </p>
<h2 id="使用-LocalDate、LocalTime、LocalDateTime"><a href="#使用-LocalDate、LocalTime、LocalDateTime" class="headerlink" title="使用 LocalDate、LocalTime、LocalDateTime"></a><strong>使用</strong> LocalDate、LocalTime、LocalDateTime</h2><p><code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code> 类的实例是不可变的对象，分别表示使用 <code>ISO-8601</code>日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</p>
<blockquote>
<p>​     ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法  </p>
</blockquote>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table>
<thead>
<tr>
<th align="center"><strong>方法</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>now()</strong></td>
<td align="center">静态方法，根据当前时间创建对象</td>
</tr>
<tr>
<td align="center"><strong>of()</strong></td>
<td align="center">静态方法，根据指定日期/时间创建对象</td>
</tr>
<tr>
<td align="center"><strong>plusDays, plusWeeks, plusMonths,  plusYears</strong></td>
<td align="center">向当前 LocalDate 对象添加几天、几周、几个月、几年</td>
</tr>
<tr>
<td align="center"><strong>minusDays,  minusWeeks,</strong>  <strong>minusMonths,  minusYears</strong></td>
<td align="center">从当前 LocalDate 对象减去几天、几周、几个月、几年</td>
</tr>
<tr>
<td align="center"><strong>plus,  minus</strong></td>
<td align="center">添加或减少一个 Duration 或 Period</td>
</tr>
<tr>
<td align="center"><strong>withDayOfMonth,</strong>  <strong>withDayOfYear,</strong>  <strong>withMonth,</strong>  <strong>withYear</strong></td>
<td align="center">将月份天数、年份天数、月份、年份修改为指定的值并返回新的 LocalDate 对象</td>
</tr>
<tr>
<td align="center"><strong>getDayOfMonth</strong></td>
<td align="center">获得月份天数(1-31)</td>
</tr>
<tr>
<td align="center"><strong>getDayOfYear</strong></td>
<td align="center">获得年份天数(1-366)</td>
</tr>
<tr>
<td align="center"><strong>getDayOfWeek</strong></td>
<td align="center">获得星期几(返回一个 DayOfWeek 枚举值)</td>
</tr>
<tr>
<td align="center"><strong>getMonth</strong></td>
<td align="center">获得月份, 返回一个 Month 枚举值</td>
</tr>
<tr>
<td align="center"><strong>getMonthValue</strong></td>
<td align="center">获得月份(1-12)</td>
</tr>
<tr>
<td align="center"><strong>getYear</strong></td>
<td align="center">获得年份</td>
</tr>
<tr>
<td align="center"><strong>until</strong></td>
<td align="center">获得两个日期之间的 Period 对象，或者指定 ChronoUnits 的数字</td>
</tr>
<tr>
<td align="center"><strong>isBefore,  isAfter</strong></td>
<td align="center">比较两个 LocalDate</td>
</tr>
<tr>
<td align="center"><strong>isLeapYear</strong></td>
<td align="center">判断是否是闰年</td>
</tr>
</tbody></table>
<h3 id="获取当前时间的日期、时间、-日期-时间"><a href="#获取当前时间的日期、时间、-日期-时间" class="headerlink" title="获取当前时间的日期、时间、 日期+时间"></a>获取当前时间的日期、时间、 日期+时间</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  now（）： 获取当前时间的日期、时间、 日期+时间</span></span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(localDate);  <span class="comment">// 2020-02-28</span></span><br><span class="line">System.out.println(localTime); <span class="comment">// 11:16:05.208365800</span></span><br><span class="line">System.out.println(localDateTime); <span class="comment">// 2020-02-28T11:16:05.208365800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// of(): 设置指定的年、月、日、时分秒</span></span><br><span class="line">LocalDateTime time1 = LocalDateTime.of(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">9</span>);</span><br><span class="line">System.out.println(time1);  <span class="comment">//  2020-10-06T15:23:09</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取具体的属性值"><a href="#获取具体的属性值" class="headerlink" title="获取具体的属性值"></a>获取具体的属性值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//getXXX(): 获取具体的属性值</span></span><br><span class="line">System.out.println(localDateTime.getDayOfWeek()); <span class="comment">//  FRIDAY</span></span><br><span class="line">System.out.println(localDateTime.getDayOfMonth());  <span class="comment">//  28</span></span><br><span class="line">System.out.println(localDateTime.getDayOfYear()); <span class="comment">// 59</span></span><br><span class="line">System.out.println(localDateTime.getMonth()); <span class="comment">// FEBRUARY</span></span><br><span class="line">System.out.println(localDateTime.getMonthValue()); <span class="comment">// 2</span></span><br><span class="line">System.out.println(localDateTime.getHour()); <span class="comment">//11</span></span><br><span class="line">System.out.println(localDateTime.getMinute()); <span class="comment">// 23</span></span><br><span class="line">System.out.println(localDateTime.getSecond()); <span class="comment">// 26</span></span><br></pre></td></tr></table></figure>

<h3 id="修改-不可变"><a href="#修改-不可变" class="headerlink" title="修改-不可变"></a>修改-不可变</h3><p>体现了不可变性， 会返回新的LocalDate对象，不会修改原来的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//修改 体现了不可变性， 会返回新的LocalDate对象，不会修改原来的值</span></span><br><span class="line">LocalDate localDate1 = localDate.withDayOfMonth(<span class="number">22</span>);</span><br><span class="line">System.out.println(localDate1); <span class="comment">//  2020-02-22</span></span><br><span class="line">System.out.println(localDate); <span class="comment">// 2020-02-28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加操作，同样是不可改变的，返回一个新的对象  不可变性</span></span><br><span class="line">LocalDateTime localDateTime1 = localDateTime.plusMonths(<span class="number">3</span>);<span class="comment">// 现有的基础上三个月</span></span><br><span class="line">System.out.println(localDateTime1); <span class="comment">// 2020-05-28T12:50:47.920841500</span></span><br><span class="line">System.out.println(localDateTime);  <span class="comment">// 2020-02-28T12:50:47.920841500</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Instant时间戳"><a href="#Instant时间戳" class="headerlink" title="Instant时间戳"></a>Instant时间戳</h1><p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算。 类似于java.util.Date类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Instant now = Instant.now();</span><br><span class="line">    System.out.println(now);  <span class="comment">// 2020-02-28T04:56:34.925610700Z 这个是本初子午线的时间，不											是东八区的时间</span></span><br><span class="line">    <span class="comment">//处理时区问题  添加时间偏移量</span></span><br><span class="line">    OffsetDateTime offsetDateTime = now.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    System.out.println(offsetDateTime); <span class="comment">// 2020-02-28T13:01:14.149267200+08:00</span></span><br><span class="line">    <span class="comment">// 获取对应时间点的毫秒数          类似于--- &gt; Date.getTime()</span></span><br><span class="line">    <span class="keyword">long</span> mills = now.toEpochMilli();</span><br><span class="line">    System.out.println(mills);  <span class="comment">// 1582866180907</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ofEpochMilli  通过给定的毫秒数，获取Instant实例  类似于--- &gt; Date(long mills)</span></span><br><span class="line">    Instant instant = Instant.ofEpochMilli(<span class="number">156698646645646140L</span>);</span><br><span class="line">    System.out.println(instant); <span class="comment">// 1582866180907</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="解析与格式化"><a href="#解析与格式化" class="headerlink" title="解析与格式化"></a>解析与格式化</h1><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p>
<ul>
<li><p>预定义的标准格式</p>
</li>
<li><p>语言环境相关的格式</p>
</li>
<li><p>自定义的格式</p>
</li>
</ul>
<p>类似于SimpleDateFormat。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 预定义的模式</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    DateTimeFormatter format = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">    String str1 = format.format(localDateTime);</span><br><span class="line">    System.out.println(str1);  <span class="comment">// 2020-02-28T13:12:45.4405114</span></span><br><span class="line">    System.out.println(localDateTime); <span class="comment">//2020-02-28T13:12:45.440511400</span></span><br><span class="line">    <span class="comment">//解析：字符串--&gt; 日期</span></span><br><span class="line">    TemporalAccessor parse = format.parse(str1);</span><br><span class="line">    System.out.println(parse);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 本地化相关格式  ofLocalDateTime()</span></span><br><span class="line"><span class="comment">        * fFormatStyle.LONG / MEDIUM / SHORT  : 适用于LocalDateTime</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);</span><br><span class="line">    LocalDateTime localDateTime1 = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    String format1 = formatter.format(localDateTime1);</span><br><span class="line">    System.out.println(format1);  <span class="comment">// 2020/2/28 下午1:22</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面两种方式用得不多，在开发中通常使用的是自定义模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">* 重点： 自定义模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String str4 = formatter1.format(LocalDateTime.now());</span><br><span class="line">System.out.println(str4); <span class="comment">// 2020-02-28 01:30:33</span></span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line">TemporalAccessor parse1 = formatter1.parse(<span class="string">&quot;2020-02-28 01:30:33&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;NanoOfSecond=0, MilliOfSecond=0, MinuteOfHour=30, SecondOfMinute=33, HourOfAmPm=1, MicroOfSecond=0&#125;,ISO resolved to 2020-02-28</span></span><br><span class="line">System.out.println(parse1);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="与传统日期处理的转换"><a href="#与传统日期处理的转换" class="headerlink" title="与传统日期处理的转换"></a><strong>与传统日期处理的转换</strong></h1><table>
<thead>
<tr>
<th align="center"><strong>类</strong></th>
<th align="center"><strong>To</strong> <strong>遗留类</strong></th>
<th align="center"><strong>From</strong> <strong>遗留类</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>java.time.Instant     java.util.Date</strong></td>
<td align="center">Date.from(instant)</td>
<td align="center">date.toInstant()</td>
</tr>
<tr>
<td align="center"><strong>java.time.Instant     java.sql.Timestamp</strong></td>
<td align="center">Timestamp.from(instant)</td>
<td align="center">timestamp.toInstant()</td>
</tr>
<tr>
<td align="center"><strong>java.time.ZonedDateTime</strong>** **    <strong>java.util.GregorianCalendar</strong></td>
<td align="center">GregorianCalendar.from(zonedDateTime)</td>
<td align="center">cal.toZonedDateTime()</td>
</tr>
<tr>
<td align="center"><strong>java.time.LocalDate</strong>** **    <strong>java.sql.Time</strong></td>
<td align="center">Date.valueOf(localDate)</td>
<td align="center">date.toLocalDate()</td>
</tr>
<tr>
<td align="center"><strong>java.time.LocalTime     java.sql.Time</strong></td>
<td align="center">Date.valueOf(localDate)</td>
<td align="center">date.toLocalTime()</td>
</tr>
<tr>
<td align="center"><strong>java.time.LocalDateTime     java.sql.Timestamp</strong></td>
<td align="center">Timestamp.valueOf(localDateTime)</td>
<td align="center">timestamp.toLocalDateTime()</td>
</tr>
<tr>
<td align="center">**java.time.ZoneId **    <strong>java.util.TimeZone</strong></td>
<td align="center">Timezone.getTimeZone(id)</td>
<td align="center">timeZone.toZoneId()</td>
</tr>
<tr>
<td align="center">**java.time.format.DateTimeFormatter **    <strong>java.text.DateFormat</strong></td>
<td align="center">formatter.toFormat()</td>
<td align="center">无</td>
</tr>
</tbody></table>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>参考API</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC错误解决</title>
    <url>/2020/03/15/JDBC%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="JDBC连接问题"><a href="#JDBC连接问题" class="headerlink" title="JDBC连接问题"></a>JDBC连接问题</h1><p>环境：win10、mysql-8.17、jdbc8.17</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="string">&quot;jdbc:mysql://localhost:3306/books&quot;</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">           Connection connection = DriverManager.getConnection(url,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">           System.out.println(connection);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>报出一下警告错误：</p>
<p>==<em><u>Loading class <code>com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class is </code>com.mysql.cj.jdbc.Driver’. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.</u></em>==</p>
<p>这是因为我的mysql版本为8以上，连接方式有点变化，5.0以上是<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code>， 而现在不推荐这样了，应该改为<code>com.mysql.cj.jdbc.Driver</code></p>
<p>然后继续运行：又来一堆错误。。。。。。。。。。。。。。。</p>
<img src="/2020/03/15/JDBC%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/1584239105053.png" alt="1584239105053" style="zoom:100%;">

<p>还是因为的的mysql版本过高。。。时区有问题。改成下面方式即可解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String url = &quot;jdbc:mysql://localhost:3306/books?serverTimezone=UTC&quot;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>errors</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8中的Lambda表达式</title>
    <url>/2020/03/05/Java8%E4%B8%AD%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><p>Java 8 于2014年3月14号发布，可以看成是自Java 5 以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。</p>
<blockquote>
<p>速度更快</p>
<p>代码更少(增加了新的语法：<strong>Lambda</strong> <strong>表达式</strong></p>
<p>强大的 <strong>Stream API</strong></p>
<p>便于并行</p>
<p>最大化减少空指针异常：<code>Optional</code>  </p>
</blockquote>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p><code>Lambda</code> 是一个<strong>匿名函数</strong>，我们可以把 <code>Lambda</code> 表达式理解为是<strong>一段可以传递的代码</strong>（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<p><code>Lambda</code> 表达式在Java 8 语言中引入了一个新的语法元素和操作符。这个操作符为 <code>-&gt;</code> ， 该操作符被称为 <code>Lambda</code> 操作符或<strong>箭头操作符</strong>。它将 Lambda 分为两个部分：</p>
<blockquote>
<p><strong>左侧：</strong>指定了 <code>Lambda</code> 表达式需要的参数列表。</p>
<p><strong>右侧：</strong>指定了 <code>Lambda</code> 体，即 <code>Lambda</code> 表达式要执行的功能。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Comparator&lt;Integer&gt; con = (o1, o2)-&gt; o1.compareTo(o2);</span><br><span class="line">      System.out.println(con.compare(<span class="number">11</span>, <span class="number">56</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happy</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; con)</span></span>&#123;</span><br><span class="line">        con.accept(money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 原始写法</span></span><br><span class="line">        happy(<span class="number">19000</span>, <span class="keyword">new</span> Consumer&lt;Double&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Double money)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;花了&quot;</span>+ money);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lambda表达式</span></span><br><span class="line">    happy(<span class="number">9000</span>, money-&gt;System.out.println(<span class="string">&quot;花了&quot;</span>+money));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lambda表达式语法格式"><a href="#Lambda表达式语法格式" class="headerlink" title="Lambda表达式语法格式"></a>Lambda表达式语法格式</h1><p>语法格式一： 无参数， 无返回值</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r  = ()-&gt; System.out.println(<span class="string">&quot;helllo&quot;</span>); </span><br></pre></td></tr></table></figure>
</blockquote>
<p>语法格式二： 需要一个参数，但是没有返回值。如果只有一个参数，<strong>参数的小括号可以省略。</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = str -&gt; System.out.println(str);con.accept(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>语法格式三： Lambda 需要两个或以上的参数，多条执行语句，并且有返回值 。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com = (x, y)-&gt;&#123;    </span><br><span class="line">	System.out.println(<span class="string">&quot;实现函数式接口方法...&quot;</span>);    </span><br><span class="line">	<span class="keyword">return</span> Integer.compare(x, y);</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>


</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的Pair</title>
    <url>/2020/02/12/Java%E4%B8%AD%E7%9A%84Pair/</url>
    <content><![CDATA[<h1 id="Java-中的Pair"><a href="#Java-中的Pair" class="headerlink" title="Java 中的Pair"></a>Java 中的Pair</h1><p>​        Pair（配对）：  当一个函数返回两个值并且两个值都有重要意义时我们一般会用Map的key和value来表达，但是这样的话就需要两个键值对，用Map映射去做处理时，此时的key相当于value的一个描述或者引用，而具体的信息都保存在value中，我们可以通过key去获取对应的value。<strong>但是当key和value都保存具体信息时，我们就需要用到Pair对了。Pair对也是键值对的形式。</strong> </p>
<p>​        实际上Pair保存的应该说是一个信息对，两个信息都是我们需要的，没有key和value之分。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>​        在<code>javax.util</code>包下，有一个简单<code>Pair</code>类可以直接调用，用法是直接通过构造函数将所吸引类型的Key和value存入，这个key和value没有任何的对应关系类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.util.Pair;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-12 13:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pair</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer, String&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="string">&quot;zhuhongliang&quot;</span>);  <span class="comment">// 要传入对应的值</span></span><br><span class="line">        System.out.println(p.getKey());</span><br><span class="line">        System.out.println(p.getValue());</span><br><span class="line"></span><br><span class="line">        Pair&lt;String, String&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;Tony&quot;</span>, <span class="string">&quot;Jane&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(p2.getKey());</span><br><span class="line">        System.out.println(p2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1<br>zhuhongliang<br>Tony<br>Jane</p>
</blockquote>
<pre><code>     这种Pair的返回对一个函数返回两个都有意义的值有特别用处。 
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的枚举类</title>
    <url>/2020/02/29/Java%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JDK1.5之前需要自定义枚举类</p>
<p>JDK 1.5 新增的 <code>enum</code> 关键字用于定义枚举类</p>
<p>当需要定义一组常量时，强烈建议使用枚举类。故里面的属性应该为<code>final</code>修饰。</p>
<blockquote>
<p>理解：类的对象只有有限个，确定的。称之为枚举类。</p>
</blockquote>
<p>若枚举只有一个成员, 则可以作为一种单例模式的实现方式。</p>
<hr>
<h1 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h1><ul>
<li>枚举类对象的属性不应允许被改动，所以应该使用 <code>private final</code> 修饰。</li>
<li>枚举类的使用 <code>private final</code> 修饰的属性应该在构造器中为其赋值。</li>
<li>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数。</li>
<li>只能获取对象的属性，不能修改，即只能提供<code>get</code>方法，不能提供<code>set</code>方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义枚举类对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Seasons</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String  seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SeasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Seasons</span><span class="params">(String seasonName, String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.SeasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提供当前枚举类的多个对象  public static final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Seasons SPRING = <span class="keyword">new</span> Seasons(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春风又绿江南岸&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Seasons SUMMER = <span class="keyword">new</span> Seasons(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;映日荷花别样红&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Seasons AUTUMN = <span class="keyword">new</span> Seasons(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋水共长天一色&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Seasons WINTER = <span class="keyword">new</span> Seasons(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取枚举类的对象的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SeasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Seasons&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, SeasonDesc=&#x27;&quot;</span> + SeasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/29/Java%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB/1582942677494.png" alt="1582942677494" style="zoom:100%;">

<hr>
<h1 id="使用enum定义枚举类"><a href="#使用enum定义枚举类" class="headerlink" title="使用enum定义枚举类"></a>使用enum定义枚举类</h1><p>必须在枚举类的第一行声明枚举类对象。多个对象之间用逗号隔开，最后一个对象用；结束。</p>
<p>枚举类和普通类的区别：</p>
<blockquote>
<p>使用 <code>enum</code> 定义的枚举类默认继承了 <code>java.lang.Enum</code> 类。</p>
<p>枚举类的构造器只能使用 <code>private</code> 访问控制符。</p>
<p>枚举类的所有实例必须在枚举类中显式列出 (,分隔  <strong>;</strong> 结尾). 列出的实例系统会自动添加 <code>public static final</code>修饰。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum  Season &#123;</span><br><span class="line"></span><br><span class="line">    // 必须在枚举类的第一行声明枚举类对象。</span><br><span class="line">    SPRING(&quot;春天&quot;, &quot;春风又绿江南岸&quot;),</span><br><span class="line">    SUMMER(&quot;夏天&quot;, &quot;映日荷花别样红&quot;),</span><br><span class="line">    AUTUMN(&quot;秋天&quot;, &quot;秋水共长天一色&quot;),</span><br><span class="line">    WINTER(&quot;冬天&quot;, &quot;窗含西岭千秋雪&quot;);</span><br><span class="line"></span><br><span class="line">    private final String seasonName;</span><br><span class="line">    private final String SeasonDesc;</span><br><span class="line"></span><br><span class="line">    // 私有化构造函数</span><br><span class="line">    private Season(String seasonName, String seasonDesc) &#123;</span><br><span class="line">        this.seasonName = seasonName;</span><br><span class="line">        this.SeasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 获取枚举类的对象的属性</span><br><span class="line"></span><br><span class="line">    public String getSeasonName() &#123;</span><br><span class="line">        return seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSeasonDesc() &#123;</span><br><span class="line">        return SeasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="枚举类的常用方法"><a href="#枚举类的常用方法" class="headerlink" title="枚举类的常用方法"></a>枚举类的常用方法</h1><p>枚举类的主要方法：</p>
<blockquote>
<p>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</p>
<p>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常。</p>
</blockquote>
<p>线程的状态就是一个枚举类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.State[] values = Thread.State.values();</span><br><span class="line"><span class="keyword">for</span> (Thread.State v: values)&#123;</span><br><span class="line">System.out.println(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>NEW<br>RUNNABLE<br>BLOCKED<br>WAITING<br>TIMED_WAITING<br>TERMINATED</p>
</blockquote>
<img src="/2020/02/29/Java%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB/1582944911052.png" alt="1582944911052" style="zoom:80%;">



<hr>
<h1 id="实现接口的枚举类"><a href="#实现接口的枚举类" class="headerlink" title="实现接口的枚举类"></a>实现接口的枚举类</h1><p>和普通 Java 类一样，枚举类可以实现一个或多个接口</p>
<p>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span>  <span class="title">Season</span> <span class="keyword">implements</span> <span class="title">info</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须在枚举类的第一行声明枚举类对象。</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春风又绿江南岸&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是春天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;映日荷花别样红&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是夏天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋水共长天一色&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是秋天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;窗含西岭千秋雪&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是冬天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SeasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.SeasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取枚举类的对象的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SeasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season[] s = Season.values();</span><br><span class="line">        <span class="keyword">for</span> (Season a: s)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a.show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SPRING<br>我是春天<br>SUMMER<br>我是夏天<br>AUTUMN<br>我是秋天<br>WINTER<br>我是冬天</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java关键字</title>
    <url>/2020/01/29/Java%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="1-数据"><a href="#1-数据" class="headerlink" title="1. 数据"></a><strong>1. 数据</strong></h2><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable &#x27;x&#x27;</span></span><br><span class="line"><span class="keyword">final</span> A y = <span class="keyword">new</span> A();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a><strong>2. 方法</strong></h2><p>声明方法不能被子类重写。</p>
<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，<strong>而是在子类中定义了一个新的方法。</strong></p>
<h2 id="3-类"><a href="#3-类" class="headerlink" title="3. 类"></a><strong>3. 类</strong></h2><p>声明类不允许被继承。</p>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="1-静态变量"><a href="#1-静态变量" class="headerlink" title="1. 静态变量"></a><strong>1. 静态变量</strong></h2><ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">int</span> x = a.x;</span><br><span class="line">        <span class="keyword">int</span> y = A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a><strong>2. 静态方法</strong></h2><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。 即静态域中不能访问非静态的，因为静态的变量是先于对象（或者非静态）出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = x;</span><br><span class="line">        <span class="comment">// int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="comment">// int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-静态语句块"><a href="#3-静态语句块" class="headerlink" title="3. 静态语句块"></a><strong>3. 静态语句块</strong></h2><p>静态语句块在类初始化时运行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果只输出一次“123”</span></span><br></pre></td></tr></table></figure>

<h2 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4. 静态内部类"></a><strong>4. 静态内部类</strong></h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><blockquote>
<p> 大部分时候，类被定义成一个独立的程序单元。在某些情况下，也会把一个类放在另一个类的内部定义，这个定义在其他类内部的类就被称为内部类（有些地方也叫做嵌套类），包含内部类的类也被称为外部类（有些地方也叫做宿主类） </p>
</blockquote>
<h3 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h3><blockquote>
<ul>
<li>更好的封装性</li>
<li>内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员，但外部类不能访问内部类的实现细节，例如内部类的成员变量</li>
<li>匿名内部类适合用于创建那些仅需要一次使用的类</li>
</ul>
</blockquote>
<p> 使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。称为静态内部类（也可称为类内部类），这样的内部类是类级别的，<strong>static关键字的作用是把类的成员变成类相关，而不是实例相关 。</strong></p>
<p> 注意：</p>
<ol>
<li>非静态内部类中不允许定义静态成员<ol start="2">
<li>外部类的静态成员不可以直接使用非静态内部类<ol start="3">
<li>静态内部类，不能访问外部类的实例成员，只能访问外部类的类成员 </li>
</ol>
</li>
</ol>
</li>
</ol>
<ul>
<li>在建造者模式中有使用，具体可以参考<a href="https://blog.csdn.net/cd18333612683/article/details/79129503">链接</a></li>
</ul>
<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        InnerClass innerClass = outerClass.<span class="function">new <span class="title">InnerClass</span><span class="params">()</span></span>;</span><br><span class="line">        StaticInnerClass staticInnerClass = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<h2 id="5-静态导包"><a href="#5-静态导包" class="headerlink" title="5. 静态导包"></a><strong>5. 静态导包</strong></h2><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<p>一般我们导入一个类都用 <code>import com…..ClassName;</code></p>
<p>而静态导入是这样：<code>import static com…..ClassName.*;</code>  这里的多了个static，还有就是类名ClassName后面多了个.* ，意思是导入这个类里的静态方法。当然，也可以只导入某个静态方法，只要把 .* 换成静态方法名就行了。然后在这个类中，就可以直接用方法名调用静态方法，而不必用ClassName.方法名 的方式来调用。</p>
<p><strong><code>好处：</code></strong></p>
<p>这种方法的好处就是可以简化一些操作，例如打印操作System.out.println(…); 就可以将其写入一个静态方</p>
<p>法print(…)，在使用时直接print(…)就可以了。但是这种方法建议在有很多重复调用的时候使用，如果仅有一到两次调用，不如直接写来的方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-29 10:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">keywords</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-初始化顺序"><a href="#6-初始化顺序" class="headerlink" title="6. 初始化顺序"></a><strong>6. 初始化顺序</strong></h2><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">&quot;静态变量&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String field = <span class="string">&quot;实例变量&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后才是构造函数的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p> <a href="https://cyc2018.github.io/CS-Notes">https://cyc2018.github.io/CS-Notes</a> </p>
</li>
<li><p> <a href="https://blog.csdn.net/cd18333612683/article/details/79129503">https://blog.csdn.net/cd18333612683/article/details/79129503</a> </p>
</li>
<li><p><a href="https://blog.csdn.net/u012338954/article/details/51010337">https://blog.csdn.net/u012338954/article/details/51010337</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>Java动态编译与脚本引擎</title>
    <url>/2020/03/03/Java%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h1><p>JAVA 6.0引入了动态编译机制。</p>
<h2 id="动态编译的应用场景"><a href="#动态编译的应用场景" class="headerlink" title="动态编译的应用场景"></a>动态编译的应用场景</h2><p>可以做一个浏览器端编写java代码，上传服务器编译和运行的在线评测 系统。</p>
<p>服务器动态加载某些类文件进行编译。</p>
<h2 id="动态编译的两种做法"><a href="#动态编译的两种做法" class="headerlink" title="动态编译的两种做法"></a>动态编译的两种做法</h2><ol>
<li><p>通过<code>Runtime</code>调用<code>javac</code>，启动新的进程去操作。</p>
</li>
<li><p>通过<code>JavaCompiler</code>动态编译。</p>
<p>JavaCompiler：</p>
<blockquote>
<p>JavaCompiler.run(…):</p>
<p>int run(InputStream in, OutputStream out, OutputStream err, String… arguments);</p>
<p> 第一个参数：为java编译器提供参数 输入： null 表示<code>System.in</code></p>
<p> 第二个参数：得到 Java 编译器的输出信息 :  null 表示<code>System.out</code></p>
<p>第三个参数：接收编译器的 错误信息:  null 表示<code>System.err</code></p>
<p>第四个参数：可变参数（是一个String数组）能传入一个或多个 Java 源文件 </p>
<p>返回值：0表示编译成功，非0表示编译失败</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.tools.JavaCompiler;</span><br><span class="line"><span class="keyword">import</span> javax.tools.ToolProvider;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态编译</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-03 14:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDynamic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 编译</span></span><br><span class="line">        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        <span class="keyword">int</span> run = compiler.run(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&quot;F:\\java\\base\\DynamicCompille\\src\\hello.java&quot;</span>);</span><br><span class="line">        System.out.println(run == <span class="number">0</span>?<span class="string">&quot;编译成功&quot;</span>:<span class="string">&quot;编译失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行class 运行程序</span></span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">        Process process = runtime.exec(<span class="string">&quot;java -cp F:\\java\\base\\DynamicCompille\\src hello&quot;</span>);</span><br><span class="line">        InputStream inputStream = process.getInputStream();</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">        String info = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((info = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(info);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译成功<br>        hello!!!</p>
</blockquote>
<h2 id="通过反射运行编译好的类"><a href="#通过反射运行编译好的类" class="headerlink" title="通过反射运行编译好的类"></a>通过反射运行编译好的类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestReflect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL[] uRls = <span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> URL(<span class="string">&quot;file:/&quot;</span>+<span class="string">&quot;F:/java/base/DynamicCompille/src/&quot;</span>)&#125;;</span><br><span class="line">            URLClassLoader loader = <span class="keyword">new</span> URLClassLoader(uRls);</span><br><span class="line">            Class clazz = loader.loadClass(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="comment">// 调用加载类的main方法</span></span><br><span class="line">            Method m = clazz.getMethod(<span class="string">&quot;main&quot;</span>, String[].class);</span><br><span class="line">            m.invoke(<span class="keyword">null</span>, (Object)<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">            <span class="comment">// 由于可变参数是JDK5.0之后才有的，上面代码会编译成： m.invoke(null, &quot;aa0, &quot;bb&quot;);, 我们知道</span></span><br><span class="line">            <span class="comment">// main方法中的参数是一个String[],这样就会发生参数个数不匹配的问题，所以要加上Object强制装换。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hello!!!</p>
</blockquote>
<p>同样可以执行。</p>
<hr>
<h1 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h1><p>JAVA脚本引擎是从JDK6.0之后添加的新功能。</p>
<p>脚本引擎介绍：使得 Java 应用程序可以通过一套固定的接口与各种脚本引擎交互，从而达到在 Java 平台上调用各种脚本语言的目的。</p>
<p>Java 脚本 API 是连通 Java 平台和脚本语言的桥梁。可以把一些复杂异变的业务逻辑交给脚本语言处理，这又大大提高了 开发效率。</p>
<h2 id="脚本引擎执行JavaScript代码"><a href="#脚本引擎执行JavaScript代码" class="headerlink" title="脚本引擎执行JavaScript代码"></a>脚本引擎执行JavaScript代码</h2><p>获取脚本程序输入，通过脚本引擎运行脚本并返回运行结果，这是最核心的接口。 </p>
<p><code>Rhino</code> 是一种使用 Java 语言编写的 <code>JavaScript</code> 的开源实现，原先由<code>Mozilla</code>开发 ，现在被集成进入<code>JDK 6.0</code>。</p>
<p>通过脚本引擎的运行上下文在脚本和 Java 平台间交换数据，通过 Java 应用程序调用脚本函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得脚本引擎对象</span></span><br><span class="line">ScriptEngineManager scriptEngineManager = <span class="keyword">new</span> ScriptEngineManager();</span><br><span class="line">ScriptEngine engine = scriptEngineManager.getEngineByName(<span class="string">&quot;javascript&quot;</span>);</span><br><span class="line"><span class="comment">//定义变量，存储到引擎上下文中</span></span><br><span class="line">engine.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;you see you , one day day de&quot;</span>);</span><br><span class="line"><span class="comment">// 下面是JavaScript脚本</span></span><br><span class="line">String str = <span class="string">&quot;var user = &#123; name: &#x27;jack&#x27;, age:18, schools:[&#x27;北京交通大学&#x27;,&#x27;计算机与信息技术学院&#x27;]&#125;;&quot;</span>;</span><br><span class="line">str+=<span class="string">&quot;print(user.name);&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行脚本</span></span><br><span class="line">engine.eval(str);</span><br><span class="line">System.out.println(engine.get(<span class="string">&quot;msg&quot;</span>));</span><br><span class="line">engine.eval(<span class="string">&quot;msg = &#x27;day by day&#x27;;&quot;</span>); <span class="comment">//更改</span></span><br><span class="line">System.out.println(engine.get(<span class="string">&quot;msg&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>jack<br>        you see you , one day day de<br>        day by day</p>
</blockquote>
<h2 id="脚本引擎执行JavaScript函数"><a href="#脚本引擎执行JavaScript函数" class="headerlink" title="脚本引擎执行JavaScript函数"></a>脚本引擎执行JavaScript函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line">engine.eval(</span><br><span class="line">    <span class="string">&quot;function add(a, b)&#123; var sum = a+b; return sum;&#125;&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//执行js函数</span></span><br><span class="line"><span class="comment">// 取得调用接口</span></span><br><span class="line">Invocable jsInvoke = (Invocable)engine;</span><br><span class="line">Object add = jsInvoke.invokeFunction(<span class="string">&quot;add&quot;</span>, <span class="keyword">new</span> Object[]&#123;<span class="number">13</span>, <span class="number">44</span>&#125;);</span><br><span class="line">System.out.println(add); <span class="comment">// 打印返回结果  57.0</span></span><br></pre></td></tr></table></figure>

<h2 id="交换数据"><a href="#交换数据" class="headerlink" title="交换数据"></a>交换数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入其他java包，使用其他包中的Java类</span></span><br><span class="line">String jsCode = <span class="string">&quot; var list = java.util.Arrays.asList([\&quot;北京交通大学\&quot;,\&quot;计算机与信息技术学院\&quot;]);&quot;</span>;</span><br><span class="line">engine.eval(jsCode);</span><br><span class="line">List&lt;String&gt; list = (List) engine.get(<span class="string">&quot;list&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String t: list)&#123;</span><br><span class="line">	System.out.println(t);  <span class="comment">// 北京交通大学  计算机与信息技术学院</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="脚本引擎执行js文件"><a href="#脚本引擎执行js文件" class="headerlink" title="脚本引擎执行js文件"></a>脚本引擎执行js文件</h2><p>a.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义test方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> b =<span class="number">4</span>;</span><br><span class="line">    print(<span class="string">&quot;invoke js file:&quot;</span> + (a+b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行test</span></span><br><span class="line">test()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行一个js文件</span></span><br><span class="line">InputStream resource = testengine.class.getClassLoader().getResourceAsStream(<span class="string">&quot;a.js&quot;</span>);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(resource));</span><br><span class="line">engine.eval(br);  <span class="comment">// invoke js file:7</span></span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>invoke js file: 7</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的自动装箱和拆箱</title>
    <url>/2020/01/28/Java%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/</url>
    <content><![CDATA[<h1 id="自动装箱-拆箱"><a href="#自动装箱-拆箱" class="headerlink" title="自动装箱/拆箱"></a>自动装箱/拆箱</h1><hr>
<blockquote>
<p>自动装箱：指开发人员可以把一个基本数据类型直接赋给对应的包装类。</p>
<p>自动拆箱：指开发人员可以把一个包装类对象直接赋给对应的基本数据类型。</p>
</blockquote>
<h2 id="基本数据类型包装类"><a href="#基本数据类型包装类" class="headerlink" title="基本数据类型包装类"></a>基本数据类型包装类</h2><table>
<thead>
<tr>
<th>包装类</th>
<th>基本数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>byte</td>
</tr>
<tr>
<td>Integer</td>
<td>int</td>
</tr>
<tr>
<td>Long</td>
<td>long</td>
</tr>
<tr>
<td>Boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>Float</td>
<td>float</td>
</tr>
<tr>
<td>Double</td>
<td>double</td>
</tr>
<tr>
<td>Character</td>
<td>char</td>
</tr>
<tr>
<td>对象变基本数据类型:拆箱</td>
<td>基本数据类型包装为对象:装箱</td>
</tr>
</tbody></table>
<hr>
<p> 在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。 </p>
<p>Example：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">&quot;12&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//字符串转换成int类型数据。 可以把字符串转换成对应的数字</span></span><br><span class="line">		<span class="keyword">int</span> i = Integer.parseInt(str);</span><br><span class="line">		System.out.println(i+<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//把数字转换成字符串</span></span><br><span class="line">		System.out.println(<span class="string">&quot;把整数转换成对应 的字符串：&quot;</span>+Integer.toString(i));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//把整数转换成对应的进制形式</span></span><br><span class="line">		System.out.println(<span class="string">&quot;10的二进制：&quot;</span>+ Integer.toBinaryString(<span class="number">10</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;10的二进制：&quot;</span>+ Integer.toBinaryString(<span class="number">10</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;10的十六进制：&quot;</span>+ Integer.toHexString(<span class="number">10</span>));</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//可以把字符串当成对应的进行数据帮你转换</span></span><br><span class="line">		String data = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> a = Integer.parseInt(data, <span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;a=&quot;</span>+a);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//集合： 集合是可以存储任意对象类型数据的容器。</span></span><br><span class="line">		ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		list.add(<span class="number">1</span>);</span><br><span class="line">		list.add(<span class="number">2</span>);</span><br><span class="line">		list.add(<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//自动装箱： 自动把java的基本数据类型数据转换成对象类型数据。</span></span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">10</span>;  <span class="comment">//基本数据类型</span></span><br><span class="line">		Integer b =temp; <span class="comment">//把a存储的值赋予给b变量。</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//自动拆箱： 把引用类型的数据转换成基本类型的数据</span></span><br><span class="line">		Integer c = <span class="keyword">new</span> Integer(<span class="number">13</span>);</span><br><span class="line">		<span class="keyword">int</span> d = c; <span class="comment">//</span></span><br><span class="line">		System.out.println(d);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//引用的数据类型</span></span><br><span class="line">		Integer e = <span class="number">127</span>;</span><br><span class="line">		Integer f = <span class="number">127</span>; </span><br><span class="line">		System.out.println(<span class="string">&quot;同一个对象吗？&quot;</span>+(e==f)); <span class="comment">// ture</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<blockquote>
<p>Integer类内部维护 了缓冲数组，该缓冲数组存储的-128~127<br>这些数据在一个数组中。如果你获取的数据是落入到这个范围之内的，那么就直接从该缓冲区中获取对应的数据。【Java8】</p>
</blockquote>
<p> 编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">integer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">111</span>);</span><br><span class="line">        Integer b = <span class="keyword">new</span> Integer(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">        Integer c = Integer.valueOf(<span class="number">111</span>);</span><br><span class="line">        Integer d = Integer.valueOf(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果： false   true</p>
<blockquote>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
</blockquote>
<p>看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-28 11:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">integer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">160</span>);</span><br><span class="line">        Integer b = <span class="keyword">new</span> Integer(<span class="number">160</span>);</span><br><span class="line"></span><br><span class="line">        Integer c = Integer.valueOf(<span class="number">160</span>);</span><br><span class="line">        Integer d = Integer.valueOf(<span class="number">160</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果为： false  false</p>
<p>因为160超过了缓存的范围（-128-127），所以都是不同的对象， valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 如果不在缓存池中，则会new一个Integer对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<p><strong>看源码：</strong></p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​     在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=<size> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。 </size></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li> [<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%9F%BA%E7%A1%80]">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%9F%BA%E7%A1%80]</a>(<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 基础) </li>
<li> <a href="https://blog.csdn.net/Castile_zhu/article/details/78822267">https://blog.csdn.net/Castile_zhu/article/details/78822267</a> </li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>搞定Latex</title>
    <url>/2020/04/28/Latex/</url>
    <content><![CDATA[<h1 id="安装Latex"><a href="#安装Latex" class="headerlink" title="安装Latex"></a>安装Latex</h1><p>参照网上博客安装即可。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ol>
<li><p>使用记事本写下如下代码：<code>test.tex</code></p>
<img src="/2020/04/28/Latex/1588053375288.png" class width="1588053375288"></li>
<li><p>保存，cmd运行命令：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">latex test.tex</span><br></pre></td></tr></table></figure>

<img src="/2020/04/28/Latex/1588053490406.png" class width="1588053490406">

<ol start="3">
<li><p>编译成pdf文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dvipdfmx test.dvi</span><br></pre></td></tr></table></figure>

<img src="/2020/04/28/Latex/1588053639810.png" class width="1588053639810">

<img src="/2020/04/28/Latex/1588053670417.png" class width="1588053670417">



<p>也可以直接使用<code>xelatex</code>命令直接生成<code>pdf</code>文件，免去了使用中间命令。</p>
<p>上述的操作比较复杂，流程繁琐，可以直接写一个bat批处理文件：</p>
<img src="/2020/04/28/Latex/1588054048548.png" class width="1588054048548">

<p>效果是一样的。</p>
<h1 id="TexStudio"><a href="#TexStudio" class="headerlink" title="TexStudio"></a>TexStudio</h1><p>软件设置以支持中文：</p>
<img src="/2020/04/28/Latex/1588054860512.png" class width="1588054860512">

<p>新建一个文档：F5构建并查看</p>
<img src="/2020/04/28/Latex/1588054886413.png" class width="1588054886413">

<hr>
</li>
</ol>
<p>一个latex文档包括导言区和正文区：在导言区进行一些全局的设置</p>
<img src="/2020/04/28/Latex/1588055978134.png" class width="1588055978134">

<p>并且只能有一个正文区，通过命名来设置一些显示效果，$$符号是在行内嵌入公式，双$符号是另起一行嵌入公式。文档中如果要换行，则在之间插入一个空行即可，或者 \ \  .</p>
<h2 id="中文设置"><a href="#中文设置" class="headerlink" title="中文设置"></a>中文设置</h2><p>查看是否是<code>xelatex</code>编译器, 编码为UTF-8。然后导入<code>\usepackage&#123;ctex&#125;</code>。</p>
<img src="/2020/04/28/Latex/1588056463182.png" class width="1588056463182">

<p>LATEX 源代码中，空格键和  Tab 键输入的空白字符视为“空格”。连续的若干个空白字符视为一个空格。一行开头的空格忽略不计。</p>
<p>分段的方法有两种：</p>
<p>（1）行末的回车视为一个空格，但连续两个回车，也就是空行，会将文字分段。多个空行被视为一个空行。</p>
<p>（2）也可以在行末使用 \par 命令分段。</p>
<img src="/2020/04/28/Latex/1588056892446.png" class width="1588056892446">

<hr>
<h2 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h2><p>字体族设置：罗马字体，无衬线字体，打字机字体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% 字体族设置（罗马字体，无衬线字体，打字机字体）</span><br><span class="line">\textrm&#123;Roman Family&#125; % 罗马字体</span><br><span class="line">\textsf&#123;Sans Serif Family&#125; % 无衬线字体</span><br><span class="line">\texttt&#123;Typewriter Family&#125; % 打字机字体</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\rmfamily Roman Family % 字体声明： 声明后面字体为罗马字体</span><br><span class="line">&#123;\sffamily Sans Serif Family&#125; &#123;\ttfamily Typewriter Family&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/28/Latex/1588057785244.png" class width="1588057785244">

<p>大括号对声明分组，指定作用的范围。</p>
<img src="/2020/04/28/Latex/1588058093339.png" class width="1588058093339">

<p>完整源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%导言区</span><br><span class="line">\documentclass[12px]&#123;article&#125; %book, report , lettle</span><br><span class="line"></span><br><span class="line">\title&#123;\heiti  视频目标分割算法综述&#125;</span><br><span class="line">%\author&#123;\kaishu 卡西迪奥&#125;</span><br><span class="line">\author&#123;小明\thanks&#123;第一作者&#125; </span><br><span class="line">	\and 小红\thanks&#123;第二作者&#125; </span><br><span class="line">	\and 隔壁老王\thanks&#123;通讯作者&#125;&#125; </span><br><span class="line">\usepackage&#123;ctex&#125;</span><br><span class="line"></span><br><span class="line">% 自定义命令</span><br><span class="line">\newcommand&#123;\myfont&#125;&#123;\textbf&#123;\textsf&#123;Fancy Text&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">% 正文区</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">	\maketitle</span><br><span class="line"></span><br><span class="line">	% 字体族设置（罗马字体，无衬线字体，打字机字体）</span><br><span class="line">	\textrm&#123;Roman Family&#125; % 罗马字体</span><br><span class="line">	\textsf&#123;Sans Serif Family&#125; % 无衬线字体</span><br><span class="line">	\texttt&#123;Typewriter Family&#125; % 打字机字体</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	\rmfamily Roman Family % 字体声明： 声明后面字体为罗马字体</span><br><span class="line">	&#123;\sffamily Sans Serif Family&#125; &#123;\ttfamily Typewriter Family&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;\sffamily Video object segmentation (VOS) is a fundamental task in computer vision, with important applications including video editing, robotics, and selfdriving cars. According to whether the ground-truth mask of the target objects is given for the first frame, VOS task can be seen as semi-supervised VOS and unsupervised VOS. &#125;</span><br><span class="line">	</span><br><span class="line">	&#123;\rmfamily Given the mask of the target objects for the first frame, algorithm for semi-supervised VOS focuses on using it to model the appearance of the objects of interest, such as fine-tuning the model using the first frame or matching the pixel or superpixel of following frames with the first frame. Motion cue or temporal information is considered to be complementary information to enhance performance. While the information for the object of interest is unknown, the method of unsupervised VOS leverages the motion cue and the general appearance model to get dominant feature and segment the salient object .&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	% 字体形状设置（直立，斜体，伪斜体，小型大写）</span><br><span class="line">	\textup&#123;Upright Shape&#125; \textit&#123;Italic Shape&#125;  \textsl&#123;Slanted Shape&#125; \textsc&#123; Small Caps Shape&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#123;\upshape Upright Shape &#125; &#123;\itshape Italic Shape &#125;  &#123;\slshape Slanted Shape&#125; &#123;\scshape Small Caps Shape&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	% 中文字体设置</span><br><span class="line">	\noindent 我是全局字体，我使用的是宋体\\</span><br><span class="line">	&#123;\kaishu 我是ctex已定义好的字体，我使用的楷体&#125;\\</span><br><span class="line">	&#123;\heiti 我是ctex已定义好的字体，我使用的黑体&#125;\\</span><br><span class="line">	&#123;\fangsong 我是ctex已定义好的字体，我使用的仿宋&#125;\\</span><br><span class="line">	</span><br><span class="line">	% 设置字体大小</span><br><span class="line">	&#123;\tiny Hello&#125; \\</span><br><span class="line">	&#123;\scriptsize Hello&#125; \\</span><br><span class="line">	&#123;\footnotesize Hello&#125; \\</span><br><span class="line">	&#123;\small Hello&#125; \\</span><br><span class="line">	&#123;\normalsize Hello&#125; \\</span><br><span class="line">	&#123;\large Hello&#125; \\</span><br><span class="line">	&#123;\Large Hello&#125; \\</span><br><span class="line">	&#123;\LARGE Hello&#125; \\</span><br><span class="line">	&#123;\huge Hello&#125; \\</span><br><span class="line">	&#123;\Huge Hello&#125; \\</span><br><span class="line">	</span><br><span class="line">	% 中文字体字号</span><br><span class="line">	\zihao&#123;4&#125; 你好</span><br><span class="line">	</span><br><span class="line">	\myfont</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Latex的篇章结构"><a href="#Latex的篇章结构" class="headerlink" title="Latex的篇章结构"></a>Latex的篇章结构</h1><img src="/2020/04/28/Latex/1588059495664.png" class width="1588059495664">

<hr>
<h1 id="Latex-插图"><a href="#Latex-插图" class="headerlink" title="Latex 插图"></a>Latex 插图</h1><p>通过<code>\usepackage&#123;graphicx&#125;</code>来引入。支持EPS，PDF，PNG，JPEG，BMP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%导言区</span><br><span class="line">\documentclass&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line">% 导言区：\usepackage&#123;graphicx&#125;</span><br><span class="line">% 语法：\includegraphics[keyvals]&#123;imagefile&#125;</span><br><span class="line">\usepackage&#123;graphicx&#125;</span><br><span class="line">\graphicspath&#123;&#123;figures/&#125;,&#123;pic/&#125;&#125; % 图片在当前目录下的figures目录</span><br><span class="line"></span><br><span class="line">% 正文区</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">	\zihao&#123;4&#125;\LaTeX&#123;&#125;中的插图：</span><br><span class="line">	</span><br><span class="line">	\includegraphics[scale=0.5]&#123;camel&#125;</span><br><span class="line">	</span><br><span class="line">	\includegraphics[scale=0.3,height=10cm]&#123;head&#125;</span><br><span class="line">	</span><br><span class="line">	\includegraphics[scale=0.4]&#123;cosnet&#125;</span><br><span class="line">	</span><br><span class="line">	\includegraphics[scale=0.5, angle=45]&#123;camel&#125;</span><br><span class="line">	</span><br><span class="line">	\includegraphics[scale=0.3,height=10cm,,angle=90]&#123;head&#125;</span><br><span class="line">	</span><br><span class="line">	\includegraphics[scale=0.4,clip]&#123;cosnet&#125;</span><br><span class="line">\end&#123;document&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2020/04/28/Latex/1588067478564.png" class width="1588067478564">

<hr>
<h1 id="Latex中的表格"><a href="#Latex中的表格" class="headerlink" title="Latex中的表格"></a>Latex中的表格</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;ctexart&#125; % ctexbook, ctexrep</span><br><span class="line"></span><br><span class="line">% \usepackage&#123;ctex&#125;</span><br><span class="line"></span><br><span class="line">%正文区</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">	</span><br><span class="line">	\begin&#123;table*&#125;</span><br><span class="line">		\centering</span><br><span class="line">		\caption&#123;成绩表&#125; </span><br><span class="line">		</span><br><span class="line">		\begin&#123;tabular&#125;&#123;|l||c|c||c|p&#123;3cm&#125;|&#125; % l 表示左对齐， r表示右对齐， c居中</span><br><span class="line">			\hline</span><br><span class="line">			姓名 &amp; 语文 &amp; 数学 &amp; 英语 &amp; 备注 \\</span><br><span class="line">			\hline \hline</span><br><span class="line">			张三 &amp; 98 &amp; 100 &amp; 99 &amp; 优秀 \\</span><br><span class="line">			\hline</span><br><span class="line">			李四 &amp; 94 &amp; 88 &amp; 56 &amp; 补考另行通知 \\</span><br><span class="line">			\hline</span><br><span class="line">			梨花 &amp; 88 &amp; 99 &amp; 100 &amp; 优秀 \\</span><br><span class="line">			\hline</span><br><span class="line">		</span><br><span class="line">		\end&#123;tabular&#125;</span><br><span class="line">\end&#123;table*&#125;</span><br><span class="line">\end&#123;document&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2020/04/28/Latex/1588067986637.png" class width="1588067986637">



<hr>
<h1 id="Latex中的浮动体"><a href="#Latex中的浮动体" class="headerlink" title="Latex中的浮动体"></a>Latex中的浮动体</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line">\usepackage&#123;graphicx&#125;</span><br><span class="line">\graphicspath&#123;&#123;figures/&#125;&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">	\LaTeX&#123;&#125;中的插图：</span><br><span class="line">	</span><br><span class="line">	这个是一只骆驼，骆驼见图\ref&#123;fig-camel&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	\begin&#123;figure&#125;[htbp]</span><br><span class="line">		\centering</span><br><span class="line">		\includegraphics[scale=0.3]&#123;camel&#125;</span><br><span class="line">		\caption&#123;\ 这是一只骆驼&#125;\label&#123;fig-camel&#125;</span><br><span class="line">	\end&#123;figure&#125;</span><br><span class="line"></span><br><span class="line">	\LaTeX&#123;&#125;中的表格：</span><br><span class="line">	</span><br><span class="line">	\begin&#123;table&#125;[h]</span><br><span class="line">		\centering</span><br><span class="line">		\caption&#123;考试成绩单&#125;</span><br><span class="line">		\begin&#123;tabular&#125;&#123;|l||c|c||c|p&#123;3cm&#125;|&#125;</span><br><span class="line">			\hline</span><br><span class="line">			姓名 &amp; 语文 &amp; 数学 &amp; 英语 &amp; 备注 \\</span><br><span class="line">			\hline \hline</span><br><span class="line">			张三 &amp; 98 &amp; 100 &amp; 99 &amp; 优秀 \\</span><br><span class="line">			\hline</span><br><span class="line">			李四 &amp; 94 &amp; 88 &amp; 56 &amp; 补考另行通知 \\</span><br><span class="line">			\hline</span><br><span class="line">			梨花 &amp; 88 &amp; 99 &amp; 100 &amp; 优秀 \\</span><br><span class="line">			\hline</span><br><span class="line">			</span><br><span class="line">		\end&#123;tabular&#125;</span><br><span class="line">	\end&#123;table&#125;</span><br><span class="line">	</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>浮动体可以实现灵活分页和排版。，避免无法分割的内容产生的页面空白。还可以使用caption给图表添加标题，以及使用label和ref实现对图表的交叉引用。</p>
<p>可以设置图表的允许位置，默认是tbp：</p>
<blockquote>
<p>h: 此处here  – 代码所在的上下文位置</p>
<p>t: 页顶top – 代码所在页面或者之后页面的顶部</p>
<p>b: 页底bottom – 代码所在页面或者之后页面的底部</p>
<p>p: 独立一页page – 浮动页面</p>
</blockquote>
<hr>
<h1 id="Latex中的数学公式"><a href="#Latex中的数学公式" class="headerlink" title="Latex中的数学公式"></a>Latex中的数学公式</h1><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>懒得写了。。。可以去各大博客看看。</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">	\[</span><br><span class="line">	\begin&#123;matrix&#125;</span><br><span class="line">		0 &amp; 1 \\</span><br><span class="line">		1 &amp; 0</span><br><span class="line">	\end&#123;matrix&#125; \qquad	</span><br><span class="line">	% pmatrix环境</span><br><span class="line">	\begin&#123;pmatrix&#125;</span><br><span class="line">	0 &amp; -i \\</span><br><span class="line">	i &amp; 0</span><br><span class="line">	\end&#123;pmatrix&#125; \qquad</span><br><span class="line">		% bmatrix环境</span><br><span class="line">	\begin&#123;bmatrix&#125;</span><br><span class="line">	0 &amp; -1 \\</span><br><span class="line">	1 &amp; 0</span><br><span class="line">	\end&#123;bmatrix&#125; \qquad</span><br><span class="line">		% Bmatrix环境</span><br><span class="line">	\begin&#123;Bmatrix&#125;</span><br><span class="line">	0 &amp; -i \\</span><br><span class="line">	i &amp; 0</span><br><span class="line">	\end&#123;Bmatrix&#125; \qquad</span><br><span class="line">		% vmatrix环境</span><br><span class="line">	\begin&#123;vmatrix&#125;</span><br><span class="line">	a &amp; b \\</span><br><span class="line">	c &amp; d</span><br><span class="line">	\end&#123;vmatrix&#125; \qquad</span><br><span class="line">		% Vmatrix环境</span><br><span class="line">	\begin&#123;Vmatrix&#125;</span><br><span class="line">	0 &amp; -i \\</span><br><span class="line">	i &amp; 0</span><br><span class="line">	\end&#123;Vmatrix&#125; \qquad</span><br><span class="line">	\]</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/28/Latex/1588070516631.png" class width="1588070516631">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\[</span><br><span class="line">A = \begin&#123;bmatrix&#125;</span><br><span class="line">a_&#123;11&#125; &amp; \dots &amp; a_&#123;1n&#125; \\</span><br><span class="line">&amp; \ddots &amp; \vdots \\</span><br><span class="line">0 &amp; &amp; a_&#123;nn&#125;</span><br><span class="line">\end&#123;bmatrix&#125;_&#123;n \times n&#125;</span><br><span class="line">\]</span><br><span class="line"></span><br><span class="line">\[</span><br><span class="line">A = \begin&#123;pmatrix&#125;</span><br><span class="line">a_&#123;11&#125;^2 &amp; a_&#123;12&#125;^2 &amp; a_&#123;13&#125;^2 \\</span><br><span class="line">0 &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; \\</span><br><span class="line">0 &amp; 0 &amp; a_&#123;33&#125;</span><br><span class="line">\end&#123;pmatrix&#125;</span><br><span class="line">\]</span><br></pre></td></tr></table></figure>

<img src="/2020/04/28/Latex/1588070863077.png" class width="1588070863077">

<h2 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line">\usepackage&#123;amsmath&#125;</span><br><span class="line">\usepackage&#123;amssymb&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">% 多行公式  带编号</span><br><span class="line">	\begin&#123;gather&#125;</span><br><span class="line">	a + b = b + a \\</span><br><span class="line">	ab ba</span><br><span class="line">	\end&#123;gather&#125;</span><br><span class="line">	</span><br><span class="line">		% 多行公式 	%不带编号</span><br><span class="line">	\begin&#123;gather*&#125;</span><br><span class="line">	a + b = b + a \\</span><br><span class="line">	ab ba</span><br><span class="line">	\end&#123;gather*&#125;</span><br><span class="line">	</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/28/Latex/1588071422128.png" class width="1588071422128">

<hr>
<h1 id="Latex参考文献BibTex"><a href="#Latex参考文献BibTex" class="headerlink" title="Latex参考文献BibTex"></a>Latex参考文献BibTex</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;ctexart&#125;</span><br><span class="line"></span><br><span class="line">\bibliographystyle&#123;plain&#125; % plain alpha abbrv</span><br><span class="line"></span><br><span class="line">% 正文区</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">	我引用了一篇文章\cite&#123;20174704440428&#125;\\</span><br><span class="line">	我引用了一篇文章\cite&#123;20181605023233&#125;\\</span><br><span class="line">	我引用了一篇文章\cite&#123;20183905849930&#125;\\</span><br><span class="line">	我引用了一篇文章\cite&#123;20193207282709&#125;\\</span><br><span class="line">	我引用了一篇文章\cite&#123;20194407608844&#125;</span><br><span class="line">	</span><br><span class="line">	在谷歌学术上引用\cite&#123;logothetis1996visual&#125;</span><br><span class="line">	</span><br><span class="line">	\bibliography&#123;test&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/04/28/Latex/1588072822567.png" class width="1588072822567">

<p>可以使用zotero火狐插件导出bibTex， 知网也行。</p>
<p>好了，就这样。Latex学习曲线听陡峭的。。。命令很多，不用就会忘记，所以以后还是多用用的，工具还是挺强大的！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Motion-Attentive Transition for Zero-Shot Video Object Segmentation</title>
    <url>/2020/04/16/MAT-Net/</url>
    <content><![CDATA[<h1 id="Motion-Attentive-Transition-for-Zero-Shot-Video-Object-Segmentation-2020"><a href="#Motion-Attentive-Transition-for-Zero-Shot-Video-Object-Segmentation-2020" class="headerlink" title="Motion-Attentive Transition for Zero-Shot Video Object Segmentation  [2020]"></a>Motion-Attentive Transition for Zero-Shot Video Object Segmentation  [2020]</h1><p>论文地址：<a href="https://arxiv.org/abs/2003.04253">https://arxiv.org/abs/2003.04253</a></p>
<p>github:  <a href="https://github.com/tfzhou/MATNet">https://github.com/tfzhou/MATNet</a> </p>
<p>这篇文章的结果在Davis2016数据集上达到了82.5，截止到2020年4月16日11:03取得了第一名的成绩:100:</p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>论文提出了一种基于双流编码的用于Zero-Shot视频目标分割任务，称为  <code>Motion-Attentive Transition Network (MATNet)</code>   。它和以往的双流网络有区别，以往的双流网络将运动信息和外观信息独立的处理，视为同等重要， 学习直接将光流映射到相应的分割掩码中，并且会导致外观网络的过度拟合。而MAT-Net不但继承了传统双流网络的特性（对多模态的学习），而且还能逐步转移中间的运动注意特征，以促进外观学习。</p>
<h1 id="NetWork"><a href="#NetWork" class="headerlink" title="NetWork"></a>NetWork</h1><p>MAT-Net的网络结构如下图所示：</p>
<img src="/2020/04/16/MAT-Net/1587196989190.png" class width="1587196989190">

<p> 网络由三部分组成： 交叉编码网络（<code>Interleaved encoder</code>）, 桥接网络（<code>a bridge network</code> ），解码网络（<code>decoder</code>）。</p>
<h2 id="Interleaved-encoder"><a href="#Interleaved-encoder" class="headerlink" title="Interleaved encoder"></a>Interleaved encoder</h2><p> 编码器依赖于一个双流结构来合编码对象的外观和运动信息，不像以前的工作一样对待两个流，编码器在每个网络中间层包含一个<code>MAT block</code>，它为信息传播提供了一个运动到外观的路径。 </p>
<p>以ResNet-101作为backbone，则编码器的流程为：首先输入image $I_a$ 和它对应的光流图 $I_m$ ，encoder分别提取中间特征$ V_{a,i} \in R^{W * H * C} $  和  $ V_{m,i} \in R^{W * H * C} $,  $ i \in {2,3,4,5} $, 表示<code>residual stage</code>。MAT-Block会增强这些特征：<br>$$<br>U_{a,i}， U_{m,i} =F{<em>{MAT}(V</em>{a,i}, V_{m,i})}<br>$$<br>$U$ 表示增强之后的特征。</p>
<h2 id="Bridge-Network"><a href="#Bridge-Network" class="headerlink" title="Bridge Network"></a>Bridge Network</h2><p>桥接网络由SSA模块构成。使用尺度敏感注意(SSA)来自适应地选择和转换编码器的特性，而不是直接通过跳过连接来连接编码器和解码器。具体来说，SSA被添加到每一对编码器和解码器层中，它包含一个两级注意方案， 其中，局部注意采用信道和空间两种注意机制，将输入特征集中在正确的目标区域，同时抑制冗余特征中可能存在的噪声，而全局注意则针对多尺度目标对特征进行重新校准。 </p>
<h2 id="Decoder-Network"><a href="#Decoder-Network" class="headerlink" title="Decoder Network"></a>Decoder Network</h2><p> 解码器网络采用粗到精的方案进行分割，它由四个<code>BAR</code>（  <code>Boundary-Aware Refinement</code> ）模块组成。</p>
<h1 id="Motion-Attentive-Transition-Module"><a href="#Motion-Attentive-Transition-Module" class="headerlink" title="Motion-Attentive Transition Module"></a>Motion-Attentive Transition Module</h1><p>MAT-module 由一个soft attention和一个attention transition单元组成。SA 集中注意到输入图像的重要区域，AT则将注意的运动特征转移到外观流中，以促进外观学习 。</p>
<img src="/2020/04/16/MAT-Net/1587198540152.png" alt="1587198540152" style="zoom:80%;">

<h2 id="Soft-Attention"><a href="#Soft-Attention" class="headerlink" title="Soft Attention"></a>Soft Attention</h2><p> 这个单元在每个空间位置上对输入的特征图$V_m$(或$V_a$)进行加权 。</p>
<img src="/2020/04/16/MAT-Net/1587198845982.png" class width="1587198845982">

<h2 id="Attention-Transition"><a href="#Attention-Transition" class="headerlink" title="Attention Transition"></a>Attention Transition</h2><img src="/2020/04/16/MAT-Net/1587199092530.png" class width="1587199092530">

<p> 矩阵S可以有效地捕获两个特征空间之间的两两关系。 </p>
<p>然后对S的每一行进行归一化，得到一个基于运动特征的注意图 $S^r$ 并实现增强的外观特征$U_a$ </p>
<img src="/2020/04/16/MAT-Net/1587199227817.png" class width="1587199227817">

<p>下面是MAT-block的计算图：</p>
<img src="/2020/04/16/MAT-Net/1587198503730.png" class width="1587198503730">



<h1 id="Scale-Sensitive-Attention-Module"><a href="#Scale-Sensitive-Attention-Module" class="headerlink" title="Scale-Sensitive Attention Module"></a>Scale-Sensitive Attention Module</h1><p>基于 <a href="https://arxiv.org/abs/1807.06521">CBAM: Convolutional Block Attention Module</a>  。 Convolutional Block Attention Module (CBAM) 表示卷积模块的注意力机制模块。是一种结合了空间（spatial）和通道（channel）的注意力机制模块。相比于senet只关注通道（channel）的注意力机制可以取得更好的效果。 </p>
<img src="/2020/04/16/MAT-Net/1587199880143.png" class width="1587200172360">

<p>SSA 基于CBAM，加上了全局的注意$F_g$， 给定一个特征图作为输入$U \in R^{W<em>H</em>2C}$,  SSA refine it:</p>
<p><img src="/2020/04/16/MAT-Net/MAT-Net%5C1587200047886.png" alt="1587200047886"></p>
<h2 id="CBAM"><a href="#CBAM" class="headerlink" title="CBAM"></a>CBAM</h2><img src="/2020/04/16/MAT-Net/1587200211851.png" class width="1587200211851">

<hr>
<h1 id="Boundary-Aware-Refinement-Module"><a href="#Boundary-Aware-Refinement-Module" class="headerlink" title="Boundary-Aware Refinement Module"></a>Boundary-Aware Refinement Module</h1><img src="/2020/04/16/MAT-Net/1587200394476.png" class width="1587200394476">

<p>对于BAR来说，有两个因素是非常关键的：</p>
<ol>
<li><p>ASPP模块，可以增大感受野的同时，获得更大的特征图。</p>
</li>
<li><p> 引入了一种启发式的方法来自动挖掘  <code>hard negative pixels</code>   来支持$F_{bdry}$的训练 :</p>
</li>
</ol>
<p>   使用HED-model来预测边界特征图$E\in[0,1]^{W*H}$,   $E_k$ 表示第k个像素是边界的概率。 那么，如果像素k具有较高的边缘概率（eg ： &gt;0.2）并且落在扩展的ground-truth区域之外 ，则将其视为<code>hard negative pixels</code>。 如果像素k是硬像素，则其权值$w_k = 1+ E_k$; 否则$w_k =1$。 然后，使用$w_k$对下面的边界损失进行加权，以便在硬像素分类错误时对其进行重罚 </p>
   <img src="/2020/04/16/MAT-Net/1587201115614.png" class width="1587201115614">

<p>   $M^b$ 和 $G^b$ 分别是边缘预测和<code>ground-truth</code></p>
<p>   <img src="/2020/04/16/MAT-Net/MAT-Net%5C1587201214550.png" alt="1587201214550"></p>
<hr>
<h1 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h1><h2 id="Ablation-study"><a href="#Ablation-study" class="headerlink" title="Ablation study"></a>Ablation study</h2><img src="/2020/04/16/MAT-Net/1587201713466.png" class width="1587201713466">



<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><h3 id="Davis16"><a href="#Davis16" class="headerlink" title="Davis16"></a>Davis16</h3><img src="/2020/04/16/MAT-Net/1587201799182.png" class width="1587201799182">

<h3 id="Youtube-Object"><a href="#Youtube-Object" class="headerlink" title="Youtube-Object"></a>Youtube-Object</h3><img src="/2020/04/16/MAT-Net/1587201822784.png" class width="1587201822784">

<p>CosNet :   70.5</p>
<img src="/2020/04/16/MAT-Net/1587202164962.png" class width="1587202164962">

<p>AGNN： 81.1 75.9 70.7 78.1 67.9 69.7 77.4 67.3 68.3 47.8 70.8 </p>
<h3 id="FBMS"><a href="#FBMS" class="headerlink" title="FBMS"></a>FBMS</h3><img src="/2020/04/16/MAT-Net/1587201862722.png" class width="1587201862722">

<p>CosNet：75.6</p>
<img src="/2020/04/16/MAT-Net/1587202225022.png" class width="1587202225022">







]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>papers</tag>
        <tag>UVOS</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis配置sqlMapConfig.xml中settings标签错误</title>
    <url>/2020/03/31/MyBatis%E9%85%8D%E7%BD%AEsqlMapConfig-xml%E4%B8%ADsettings%E6%A0%87%E7%AD%BE%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="错误："><a href="#错误：" class="headerlink" title="错误："></a>错误：</h1><p>在 Mybatis 的配置文件 SqlMapConfig.xml 文件中添加延迟加载的配置。 配置<settings>标签的时候运行程序出现以下错误：</settings></p>
<p><strong>org.apache.ibatis.exceptions.PersistenceException:</strong> </p>
<p><strong>Error building SqlSession.</strong></p>
<p><strong>Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance.  Cause: org.xml.sax.SAXParseException; lineNumber: 54; columnNumber: 17; 元素类型为 “configuration” 的内容必须匹配 “(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”。</strong></p>
<img src="/2020/03/31/MyBatis%E9%85%8D%E7%BD%AEsqlMapConfig-xml%E4%B8%ADsettings%E6%A0%87%E7%AD%BE%E9%94%99%E8%AF%AF/1585665614645.png" class width="1585665614645">

<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>天杀的MyBatis。。。我服了， 原来Mybatis的配置节点必须按顺序来，顺序错了就会报以上的错误。 </p>
<blockquote>
<p>元素类型为 “configuration” 的内容必须匹配 “  <code>(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)&quot;</code>。 应该按照以上顺序来配置configuration里面的设置。</p>
</blockquote>
<p>坑。。。</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>errors</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Non-local Neural Networks</title>
    <url>/2020/03/01/Non-local/</url>
    <content><![CDATA[<p>论文：   <a href="https://arxiv.org/abs/1711.07971v3">https://arxiv.org/abs/1711.07971v3</a> </p>
<p>作者：  <a href="https://arxiv.org/search/cs?searchtype=author&query=Wang,+X">Xiaolong Wang</a>, <a href="https://arxiv.org/search/cs?searchtype=author&query=Girshick,+R">Ross Girshick</a>, <a href="https://arxiv.org/search/cs?searchtype=author&query=Gupta,+A">Abhinav Gupta</a>, <a href="https://arxiv.org/search/cs?searchtype=author&query=He,+K">Kaiming He</a> </p>
<h1 id="Non-local-Neural-Networks"><a href="#Non-local-Neural-Networks" class="headerlink" title="Non-local Neural Networks"></a>Non-local Neural Networks</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>文章从BM3D去噪算法中的<code>non-local means</code> 和<code>self-attention</code>出发，在<code>neural network</code>中考虑不同空间和时间位置上的特征之间的关系。<code>non-local</code>在一个位置的计算响应是输入特性图中所有位置的特征的加权总和。一组位置可以在空间、时间或时空上，适用于图像、序列和视频问题。</p>
<img src="/2020/03/01/Non-local/1583049317879.png" alt="1583049317879" style="zoom: 100%;">

<p>在深度神经网络中捕获<code>long-range dependencies</code>是非常重要的。对于序列数据，比如音频，语言文本，通常是使用循环网络来对<code>long-range dependencies</code>建模。对于图像数据，是通过不断堆叠卷积层以获得大的感受野来对<code>long-range dependencies</code>进行建模。</p>
<p>卷积运算和循环网络运算论是在空间上还是在时间上都是只处理一个局部邻域，因此，<code>long-range dependencies</code>只能在重复应用这些操作时捕获，这些操作通过数据逐步传播信号。但是这种重复操作有很多缺点或者限制。</p>
<p>首先，计算效率很低，第二，很依赖于训练技巧，很难优化，随着网络的深读增加，很导致梯度消失和梯度爆炸等问题。 最后，这些挑战使得多跳依赖关系建模（<code>multihop dependency modeling</code>）变得困难，例如，当需要在遥远的位置之间来回传递消息时。</p>
<p>使用Non-local有很多优势：</p>
<blockquote>
<ol>
<li>与卷积操作和RNN相比， Non-local操作通过计算<strong>任意</strong>两个位置之间的交互来直接捕获<code>long-range dependencies</code>，而不管它们的位置距离的有多远。</li>
<li>Non-local很有效，即使只有很少的层（比如5层）也能取得最佳效果在一些实验中。</li>
<li> Non-local操作的输入大小可变，并且可以轻松地与其他操作(例如，卷积)相结合。 </li>
</ol>
</blockquote>
<hr>
<h1 id="Non-local-Mean"><a href="#Non-local-Mean" class="headerlink" title="Non-local Mean"></a>Non-local Mean</h1><p>NL-means去噪与常用的双线性滤波、中值滤波等利用图像局部信息来滤波不同的是，它利用了整幅图像来进行去噪，以图像块为单位在图像中寻找相似区域，再对这些区域求平均，能够比较好地去掉图像中存在的高斯噪声。  </p>
<img src="/2020/03/01/Non-local/1583050609985.png" alt="1583050609985" style="zoom:100%;">

<hr>
<h1 id="Graphical-models"><a href="#Graphical-models" class="headerlink" title="Graphical models"></a>Graphical models</h1><p>  <code>Long-range dependencies</code>  可以通过图模型来进行建模，比如CRF。在深度神经网络的环境下，CRF可以被用来对语义分割预测结果的后处理操作。 CRF的迭代平均场推理可以转化为递归网络并进行训练 。</p>
<h1 id="Self-attention"><a href="#Self-attention" class="headerlink" title="Self-attention"></a>Self-attention</h1><p>论文的工作和机器翻译中的自注意力机制有关。自注意模块在一个 <code>embedding space</code>通过关注所有位置并取它们的加权平均值来计算序列(例如，一个句子)中某个位置的响应。 </p>
<h1 id="Non-local-Neural-Networks-1"><a href="#Non-local-Neural-Networks-1" class="headerlink" title="Non-local Neural Networks"></a>Non-local Neural Networks</h1><img src="/2020/03/01/Non-local/1583057207023.png" alt="1583057207023" style="zoom:80%;">

<img src="/2020/03/01/Non-local/1583057243176.png" alt="1583057243176" style="zoom:80%;">

<p>上面的公式中，输入是x，输出是y，i 和 j 分别代表输入的某个空间位置， $x_i$ 是一个向量，维数跟x的<code>channel</code>数一样，$f$  是一个计算任意两点<strong>相似关系</strong>的函数，$g $ 是一个映射函数，将一个点映射成一个向量，可以看成是计算一个点的特征。$C(x)$  是一个<code>normalize</code>系数。也就是说，为了计算输出层的一个点，需要将输入的每个点都考虑一遍，而且考虑的方式很像<code>attention</code>：输出的某个点在原图上的<code>attention</code>，而<code>mask</code>则是由相似性给出。看下图： Non-local操作可以看成<code>attention</code> </p>
 <img src="/2020/03/01/Non-local/v2-f4dc875bcf7948df67847ac9b7d1ba21_r.jpg" alt="preview" style="zoom:80%;"> 

<p>与卷积操作比较，卷积运算将一个局部邻域的加权输入相加，比如在一维卷积中，kernel size为3 的卷积核： $i -1 \le j \le i + 1$。 与循环网络比较，一个在时间 $i $ 递归操作的局部一般是基于当前状态和上一次的时间的状态。</p>
<p>Non-local与全连接网络也不一样， 在上述公式是根据不同位置之间的关系计算响应， 而fc是使用学习到的权重来计算的。换句话说， $x_i$ 和 $x_j$  之间的关系也不是在fc中输入数据的函数。而且， Non-local支持可变尺寸，并且输出的尺寸和输入的一样。</p>
<p>以图像为例，为了简化问题，作者简单地设置$g$函数为一个<code>1*1</code>的卷积： $g(x_j) = W_gx_j$ 。 相似性度量函数 $f$ 的选择有多种:</p>
<h2 id="Gaussian"><a href="#Gaussian" class="headerlink" title="Gaussian"></a>Gaussian</h2><p>$$<br>f(x_i,  x_j) = e^{\mathbf{x_i}^\mathsf{T} \mathbf{x_j}}<br>$$</p>
<p>$$<br>C(\mathbf{x}) = \sum_{\forall j} f(\mathbf{x_i, \mathbf{x_j}})<br>$$</p>
<p>$\mathbf{x_i}^\mathsf{T} \mathbf{x_j}$  是点积相似性，也可以用欧氏距离。但是点积在依稀额深度学习框架中实现起来更方便一些。</p>
<h2 id="Embedded-Gaussian"><a href="#Embedded-Gaussian" class="headerlink" title="Embedded Gaussian"></a>Embedded Gaussian</h2><p>是上一中的一个扩展，通过在一个嵌入空间中计算<br>$$<br>f(x_i,  x_j) = e^{\theta(\mathbf{x_i})\top \phi(\mathbf{x_j})}<br>$$</p>
<p>$$<br>\theta(\mathbf{x_i}) =  W_{\theta}\mathbf{x_i} \space\space, \space \phi(\mathbf{x_j}) = W_{\phi}{\mathbf{x_j}}<br>$$</p>
<p>$$<br>设： C(\mathbf{x}) = \sum_{\forall j} f(\mathbf{x_i, \mathbf{x_j}})<br>$$</p>
<p> 最近提出的用于机器翻译的自我注意模块《Attention is all you need》是Embedded Gaussian 版本中Non-local操作的一个特例。从中可以看出，对于  $i$ ,   $\frac{1}{ C(\mathbf{x})}f(\mathbf{x_i, \mathbf{x_j}})$  相当于对 $j$ 维进行<code>softmax</code>操作。所以：<br>$$<br>\mathbf{y} = softmax(\mathbf{x^{\top}}W_{\theta}^\top W_{\phi}\mathbf{x})g(\mathbf{x})<br>$$<br>这就是<code>self-attentiond</code> 的形式。</p>
<h2 id="Dot-product"><a href="#Dot-product" class="headerlink" title="Dot product"></a>Dot product</h2><p>$$<br>f(x_i,  x_j) =\theta(\mathbf{x_i})\top \phi(\mathbf{x_j})<br>$$</p>
<p>$$<br>normalization factor： C\mathbf(x) =  N<br>$$</p>
<h2 id="Concatenation"><a href="#Concatenation" class="headerlink" title="Concatenation"></a>Concatenation</h2><p>  Relation Networks中的成对函数将连接用于视觉推理:<br>$$<br>f(\mathbf{x_i}, \mathbf{x_j}) = ReLu(\mathbf{w_f^T[\theta(x_i),  \phi(x_j)]}).<br>$$<br> 这相当于<code>embedded</code>的两个点拼接作为带ReLU激活函数全连接层的输入。它在<code>visual reasoning</code>中用的比较多。 </p>
<p> 后两种选择的归一化系数 $C(x)$选择为$\mathbf{x}$的点数，只是为了简化计算，同时，还能保证对任意尺寸的输入，不会产生数值上的尺度伸缩。 </p>
<p> Embedding的实现方式，以图像为例，在文章中都采用1*1的卷积，也就是$\theta $和$\phi$都是卷积操作。 </p>
<h2 id="Non-local-Block"><a href="#Non-local-Block" class="headerlink" title="Non-local Block"></a>Non-local Block</h2><p> 为了能让<code>non-local</code>操作作为一个组件，可以直接插入任意的神经网络中，作者把<code>non-local</code>设计成<code>residual block</code>的形式，让<code>non-local</code>操作去学习 x的<code>residual</code> 。<br>$$<br>\mathbf{z_i} = W_z\mathbf{y_i + x_i}<br>$$<br>$+\mathbf{x_i}$  表示残差连接。 $W_z$  实际上是一个卷积操作，它的输出<code>channel</code>数跟x一致。这样以来，non-local操作就可以作为一个组件，组装到任意卷积神经网络中。</p>
<img src="/2020/03/01/Non-local/1583061046477.png" alt="1583061046477" style="zoom:100%;">



<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><img src="/2020/03/01/Non-local/1583061290054.png" alt="1583061290054" style="zoom:100%;">

<p>看下图：计算相似性</p>
<img src="/2020/03/01/Non-local/1583061090577.png" alt="1583061090577" style="zoom:100%;">

<img src="/2020/03/01/Non-local/1583061147252.png" alt="1583061147252" style="zoom:100%;">

<img src="/2020/03/01/Non-local/1583061190381.png" alt="1583061190381" style="zoom:100%;">



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、单一的<code>non-local block</code>加在较浅层次效果显著。高层次丢失的信息太多了，找不到细小的远距离的联系，太模糊了。</p>
<p>2、多个<code>non-local block</code>加入，也就是加深<code>non-local</code>特性，有一定效果提升但不会很明显。</p>
<p>既然容易起作用的是在低层加，那么使劲加深意义不大，加多了这种东西就要考虑梯度消失和引入噪声。毕竟你把背景全都扔进来算。</p>
<p>3、时空同时<code>non-local</code>比单一时间维度或单一空间维度效果都要好。</p>
<p>4、<code>non-local</code>比<code>3D-CNN</code>要好。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p> <a href="https://zhuanlan.zhihu.com/p/33345791">https://zhuanlan.zhihu.com/p/33345791</a> </p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>papers</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch错误解决</title>
    <url>/2020/03/19/Pytorch%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="1-writer-add-graph-model-model-input"><a href="#1-writer-add-graph-model-model-input" class="headerlink" title="1.writer.add_graph(model, model_input)"></a>1.writer.add_graph(model, model_input)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;./run/exp&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用TensorBoard对训练可视化，在增加模型的计算图的时候，报了以下错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer.add_graph(model, [dummy_input, dummy_input,dummy_input], verbose=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<p><strong>RuntimeError: Input type (torch.cuda.FloatTensor) and weight type (torch.FloatTensor) should be the same</strong></p>
<p> <strong>输入的数据类型与网络参数的类型不符</strong>。 </p>
<p>查询网上都说：</p>
<img src="/2020/03/19/Pytorch%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/1584607598513.png" class width="1584607598513">

<p>但是全都是bullshit！！！！！</p>
<p>正确解决方案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dummy_input = torch.rand(<span class="number">2</span>, <span class="number">3</span>, <span class="number">378</span>,<span class="number">378</span>)</span><br><span class="line">writer.add_graph(model, [dummy_input.cuda(), dummy_input.cuda(), dummy_input.cuda()], verbose=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>注意：<code>pytorch</code>模型不会记录其输入输出的大小，更不会记录每层输出的尺寸。</p>
<p>所以，<code>tensorbaord</code>需要一个假的数据 <code>data</code> （<code>dummy_input</code>）来探测网络各层输出大小，并指示输入尺寸。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的持久化</title>
    <url>/2020/09/14/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Redis-的持久化"><a href="#Redis-的持久化" class="headerlink" title="Redis 的持久化"></a>Redis 的持久化</h1><p>Redis是一个基于内存的数据库，这就体现了其易失性。内存中的数据当机器断电的时候就会消失，所以，持久化机制对于数据的完整性使至关重要的。</p>
<p>Redis提供了两种持久化机制，分别是分别是<code>RDB(Redis DataBase)</code>和<code>AOF(Append Only File)</code>。</p>
<p>Redis在以前的版本中是单线程的，而在6.0后对Redis的io模型做了优化，<code>io Thread</code>为多线程的，但是<code>worker Thread</code>仍然是单线程。</p>
<p>在Redis启动的时候就会去加载持久化的文件，如果没有就直接启动，在启动后的某一时刻继续持久化内存中产生的数据。</p>
<h1 id="RDB持久化机制"><a href="#RDB持久化机制" class="headerlink" title="RDB持久化机制"></a>RDB持久化机制</h1><p>RDB持久化就是将当前进程的数据以生成快照的形式持久化到磁盘中。 它恢复时是将快照文件直接读到内存里。</p>
<p>RDB持久化的时候会单独fork一个与当前进程一摸一样的子进程来进行持久化，因此RDB持久化有如下特点：</p>
<ol>
<li>开机恢复数据快。</li>
<li>写入持久化文件快。</li>
</ol>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失</p>
<p>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p>
<p>RDB的持久化也是Redis默认的持久化机制，它会把内存中的数据以快照的形式写入默认文件名为<code>dump.rdb</code>中保存。 文件名可以咋Redis的配置文件redis.conf中进行配置。dafilename就是配置rdb的持久化文件名。</p>
<h2 id="RDB-的触发"><a href="#RDB-的触发" class="headerlink" title="RDB 的触发"></a>RDB 的触发</h2><ol>
<li><p>save命令</p>
<p>save命令不会fork子进程，通过阻塞当前Redis服务器，直到RDB完成为止，所以该命令在生产中一般不会使用。</p>
<p>可以配置redis.conf文件中的dir，表示rdb持久化后生成的rdb二进制文件所在的位置。</p>
</li>
<li><p> bgsave命令</p>
</li>
</ol>
<p>   Redis会在后台<strong>异步</strong>进行快照操作， 命令会在后台fork一个与Redis主线程一摸一样的子线程，由子线程负责内存中的数据持久化。 快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间。</p>
<ol start="3">
<li><p>自动化</p>
<p>除了上面在命令行使用save和bgsave命令触发持久化，也可以在<code>redis.conf</code>配置文件中，完成配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 100000</span><br></pre></td></tr></table></figure>

<p>在新安装的redis中由默认的以上三个save配置，<code>save 900 1</code>表示900秒内如果至少有1个key值变化，则进行持久化保存数据；  <code>save 300 10</code>则表示300秒内如果至少有10个key值发生变化，则进行持久化，<code>save 60 10000</code>以此类推。 </p>
</li>
</ol>
<h2 id="save和bgsave的对比"><a href="#save和bgsave的对比" class="headerlink" title="save和bgsave的对比"></a>save和bgsave的对比</h2><ol>
<li>save是<strong>同步</strong>持久化数据，而bgsave是<strong>异步</strong>持久化数据。</li>
<li><code>save</code>不会fork子进程，通过<strong>主进程</strong>持久化数据，会<strong>阻塞</strong>处理客户端的请求，而<code>bgsave</code>会<code>fork</code>子进程持久化数据，同时还可以处理客户端请求，高效。</li>
<li>save<strong>不会消耗内存</strong>，而bgsave<strong>会消耗内存</strong>。因为会fork新进程。</li>
</ol>
<h2 id="RDB优势和劣势"><a href="#RDB优势和劣势" class="headerlink" title="RDB优势和劣势"></a>RDB优势和劣势</h2><p> <strong>缺点：</strong> RDB持久化后的文件是紧凑的二进制文件，适合于备份、<strong>全量复制</strong>、大规模数据恢复的场景，对数据完整性和一致性要求不高，RDB会丢失最后一次快照的数据。也即在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。而且如果使用的bgsave的话，Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。</p>
<p> <strong>优点：</strong> 开机的恢复数据快，写入持久化文件快。 </p>
<img src="/2020/09/14/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/1600060815531.png" class width="1600060815531">

<hr>
<h1 id="AOF持久化机制"><a href="#AOF持久化机制" class="headerlink" title="AOF持久化机制"></a>AOF持久化机制</h1><p>AOF持久化机制是以日志的形式记录Redis中的每一次的<strong>增删改</strong>操作，<strong>不会记录查询操作</strong>，以文本的形式记录，打开记录的日志文件就可以查看操作记录。只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p>AOF默认不开启，开启需要配置redis.conf中的 appendonly no 修改为 appendonly yes， 也可以配置文件名，通过appendonly.aof， 当然，也可以配置dir。</p>
<h2 id="AOF触发机制"><a href="#AOF触发机制" class="headerlink" title="AOF触发机制"></a>AOF触发机制</h2><p>AOF带来的持久化更加安全可靠，默认提供<strong>三种</strong>触发机制，如下所示：</p>
<ol>
<li><code>no</code>：表示等操作系统等数据缓存同步到磁盘中（快、持久化没保证）。</li>
<li><code>always</code>：同步持久化，每次发生数据变更时，就会立即记录到磁盘中（慢，安全）。</li>
<li><code>everysec</code>：表示每秒同步一次（默认值，很快，但是会丢失一秒内的数据）。</li>
</ol>
<p>AOF中每秒同步也是异步完成的，<strong>效率是非常高</strong>的，由于该机制对日志文件的写入操作是采用<code>append</code>的形式。</p>
<p>在redis中配置 appendfsync always。在写入的过程即使宕机，也不会丢失已经存入日志文件的数据，数据的完整性是非常高的。</p>
<h2 id="AOF的重写机制"><a href="#AOF的重写机制" class="headerlink" title="AOF的重写机制"></a>AOF的重写机制</h2><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。</p>
<p>导致aof文件增大的无效的操作有很多， 举个例子，比如某一时刻对一个k++，然后后面的某一时刻k–，这样k的值是保持不变的，那么这两次的操作就是无效的。  如果像这样的无效操作很多，记录的文件臃肿，就浪费了资源空间，所以在Redis中出现了<code>rewrite</code>机制。 </p>
<p>redis提供了<code>bgrewriteaof</code>命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。  重写AOF的日志文件不是读取旧的日志文件瘦身，而是将内存中的数据用<strong>命令的方式重写</strong>一个AOF文件，重新保存替换原来旧的日志文件，因此内存中的数据才是最新的。 </p>
<p>重写操作也会<code>fork</code>一个子进程来处理重写操作，重写以内存中的数据作为重写的源，避免了操作的冗余性，保证了数据的最新。</p>
<p>执行<code>set k1 1</code>的命令，此命令映射到文件中的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*3 //表示该命令有三组 <span class="built_in">set</span>为一组 k1为一组 1为一组</span><br><span class="line"><span class="variable">$3</span> // 表示 <span class="built_in">set</span> 有三个字符</span><br><span class="line"><span class="built_in">set</span> // 表示执行了<span class="built_in">set</span>命令</span><br><span class="line"><span class="variable">$2</span> // 表示k1有两个字符</span><br><span class="line">k1 // key值</span><br><span class="line"><span class="variable">$1</span> // 便是value值的字符长度为1</span><br><span class="line">1  // value值</span><br></pre></td></tr></table></figure>

<p>当AOF的日志文件增长到一定大小的时候Redis就能够<code>bgrewriteaof</code>对日志文件进行重写瘦身。当AOF配置文件大于改配置项时自动开启重写（这里指超过原大小的100%）。 </p>
<p>该配置可以通过如下的配置项进行配置： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64m</span><br></pre></td></tr></table></figure>

<p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。</p>
<h2 id="AOF的优缺点"><a href="#AOF的优缺点" class="headerlink" title="AOF的优缺点"></a>AOF的优缺点</h2><p>每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好</p>
<p>每秒同步：appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失</p>
<p>不同步：appendfsync no   从不同步</p>
<p><strong>优点</strong>：  AOF更好保证数据不会被丢失，<strong>最多只丢失一秒内的数据</strong>，通过fork一个子进程处理持久化操作，保证了主进程不会进程<strong>io</strong>操作，能高效的处理客户端的请求。</p>
<p>另外重写操作保证了数据的有效性，即使日志文件过大也会进行重写。</p>
<p><strong>AOF的日志文件的记录可读性非常的高，即使某一时刻有人执行<code>flushall</code>清空了所有数据，只需要拿到<code>aof</code>的日志文件，然后把最后一条的<code>flushall</code>给删除掉，就可以恢复数据。</strong></p>
<p> <strong>缺点：</strong> 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。AOF在运行效率上往往会慢于RDB。 </p>
<img src="/2020/09/14/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/1600059664550.png" class width="1600059664550">



<h1 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h1><p>在redis4.0后混合持久化（<code>RDB+AOF</code>）对重写的优化，4.0版本的混合持久化默认是关闭的，可以通过以下的配置开启混合持久化： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aof-use-rdb-preamble no</span><br></pre></td></tr></table></figure>

<p>混合持久化也是通过<code>bgrewriteaof</code>来完成的，不同的是当开启混合持久化时，<code>fork</code>出的子进程先将共享内存的数据以<code>RDB</code>方式写入<code>aof</code>文件中，然后再将重写缓冲区的增量命令以<code>AOF</code>方式写入文件中。  写入完成后通知主进程统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的AOF文件。简单的说：新的AOF文件前半段是以RDB格式的全量数据后半段是AOF格式的增量数据。</p>
<p><strong>优点：</strong> 混合持久化结合<strong>RDB持久化</strong>和<strong>AOF持久化</strong>的优点，由于绝大部分的格式是RDB格式，加载速度快，增量数据以AOF方式保存，数据更少的丢失。 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据。AOF命令以Redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。</li>
<li>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</li>
<li>如果同时开启两种持久化方式，在这种情况下，当redis重启的时候会<strong>优先载入AOF文件</strong>来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
</ol>
<h1 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h1><p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</p>
<p>如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</p>
<p>如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。</p>
<h1 id="Redis是怎么持久化的？服务主从数据怎么交互的？"><a href="#Redis是怎么持久化的？服务主从数据怎么交互的？" class="headerlink" title="Redis是怎么持久化的？服务主从数据怎么交互的？"></a>Redis是怎么持久化的？服务主从数据怎么交互的？</h1><p>RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。 </p>
<p><strong>不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件完成后，Redis启动成功；AOF/RDB文件存在错误时，Redis启动失败并打印错误信息</strong> </p>
<h2 id="如果突然机器掉电会怎样？"><a href="#如果突然机器掉电会怎样？" class="headerlink" title="如果突然机器掉电会怎样？"></a>如果突然机器掉电会怎样？</h2><p>取决于AOF日志<code>sync</code>属性的配置，如果不要求性能，在每条写指令时都<code>sync</code>一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247492908&idx=2&sn=c267f0a64a0351c04ec90aee67adea53&chksm=9bf75599ac80dc8f4dd0c0c7e26d02687d9b2d09c65e31cbbe93e7538141a31717ddb092d3d0&mpshare=1&scene=24&srcid=0910zUE11c03LEUNb2MMQlcQ&sharer_sharetime=1599710287928&sharer_shareid=aeb401628295afea2c86016b3d2e688a&key=c3402f98b9ff36461430d990546f29bfee944ed635248dc88054dbf8009b06d8618ec57a50704ad9bb8a909c006789d1e5b3746ef9e424bc694da2f72645940c7643236ec0f2c6161f1529cd0b7766464850db79ab9570fb2ad0b0a7f3e3dcb4648db6b2d653b7497ff50dc767275e4a8c36f99b2e92233b4fca409ac156c633&ascene=14&uin=MjY3ODQ2NDEwMA==&devicetype=Windows+10+x64&version=62090538&lang=zh_CN&exportkey=AdPC4RHJGpcux7aZXd97k0Y=&pass_ticket=i7dXOrdw4RePybTZOo6ZJhWekdu7HluH0I8XZTjYjDnJGqh1XgpinBI8xO777jWR&wx_header=0">一不小心肝出了4W字的Redis面试教程</a></li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的事务控制</title>
    <url>/2020/04/28/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>JavaEE</code> 体系进行分层开发，事务处理位于业务层，<code>Spring</code> 提供了分层设计业务层的事务处理解决方案。<code>spring</code> 框架为我们提供了一组事务控制的接口。这组接口是在 <code>spring-tx-5.0.2.RELEASE.jar</code> 中。<code>spring</code> 的事务控制都是基于 <code>AOP</code> 的，它既可以使用编程的方式实现，也可以使用配置的方式实现。重点掌握配置实现。</p>
<h1 id="Spring中事务控制的-API介绍"><a href="#Spring中事务控制的-API介绍" class="headerlink" title="Spring中事务控制的 API介绍"></a>Spring中事务控制的 API介绍</h1><h2 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h2><p>此接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*  获取事务的状态信息 */</span></span><br><span class="line">	<span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">	<span class="comment">/*提交事务*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">	<span class="comment">/*回滚事务*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在开发中都是使用它的实现类:</p>
<img src="/2020/04/28/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/1588079199528.png" class width="1588079199528">

<img src="/2020/04/28/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/1588079513927.png" class width="1588079513927">

<blockquote>
<p>真正管理事务的对象 ：<code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code> ：使用 Spring JDBC 或 iBatis 进行持久化数据时使用 。<code>org.springframework.orm.hibernate5.HibernateTransactionManager</code>  使用 Hibernate 版本进行持久化数据时使用。</p>
</blockquote>
<h2 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h2><p>它是事务的定义信息对象，里面有如下方法： </p>
<img src="/2020/04/28/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/1588079910190.png" class width="1588079910190">

<blockquote>
<p>读写型事务：增删改 开启事务</p>
<p>只读型事务：执行查询时，也会开启事务</p>
</blockquote>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><img src="/2020/04/28/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/1588080014533.png" class width="1588080014533">

<h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><p>A 方法和B方法都有事务，当A调用B时，会将A中的事务传播给B方法，B方法对于实物的处理方式就是事务的传播行为。</p>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p><code>REQUIRED</code>:<strong>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</strong></p>
<p><code>SUPPORTS</code>:<strong>支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</strong></p>
<p><code>MANDATORY</code>：使用当前的事务，如果当前没有事务，就抛出异常</p>
<p><code>REQUERS_NEW</code>: 新建事务，如果当前在事务中，把当前事务挂起。 </p>
<p><code>NOT_SUPPORTED</code>:  以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 </p>
<p><code>NEVER</code>: 以非事务方式运行，如果当前存在事务，抛出异常 </p>
<p><code>NESTED</code>: 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 <code>REQUIRED</code> 类似的操作。 </p>
<p>是不是有点晕。。。我也是。</p>
<h3 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h3><p>默认值是-1，没有超时限制。如果有，以秒为单位进行设置。 </p>
<h3 id="是否是只读事务"><a href="#是否是只读事务" class="headerlink" title="是否是只读事务"></a>是否是只读事务</h3><p>建议查询时设置为只读。 </p>
<h2 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h2><p>此接口提供的是事务具体的运行状态，描述了某个时间点上事务对象的状态信息，包含6个具体的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  判断事务是否为新的事务 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/* 获取事务是否存在存储点 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/* 设置事务回滚 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/* 判断事务是否回滚 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  刷新事务 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/* 判断事务是否完成 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="基于-XML-的声明式事务控制"><a href="#基于-XML-的声明式事务控制" class="headerlink" title="基于 XML 的声明式事务控制"></a>基于 XML 的声明式事务控制</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><img src="/2020/04/28/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/1588080967285.png" class width="1588080967285">

<h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hongliang.domain.Account;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id查询账户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名称查询账户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新账户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hongliang.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.hongliang.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.hongliang.service.IAccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 事务控制应该都是在业务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transfer....&quot;</span>);</span><br><span class="line">            <span class="comment">//2.1根据名称查询转出账户</span></span><br><span class="line">            Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">            <span class="comment">//2.2根据名称查询转入账户</span></span><br><span class="line">            Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">            <span class="comment">//2.3转出账户减钱</span></span><br><span class="line">            source.setMoney(source.getMoney()-money);</span><br><span class="line">            <span class="comment">//2.4转入账户加钱</span></span><br><span class="line">            target.setMoney(target.getMoney()+money);</span><br><span class="line">            <span class="comment">//2.5更新转出账户</span></span><br><span class="line">            accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            int i=1/0;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.6更新转入账户</span></span><br><span class="line">            accountDao.updateAccount(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="pom文件依赖"><a href="#pom文件依赖" class="headerlink" title="pom文件依赖"></a>pom文件依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置bean-xml"><a href="#配置bean-xml" class="headerlink" title="配置bean.xml"></a>配置bean.xml</h2><h3 id="配置事务管理器"><a href="#配置事务管理器" class="headerlink" title="配置事务管理器"></a>配置事务管理器</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ds&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置事务的通知引用事务管理器"><a href="#配置事务的通知引用事务管理器" class="headerlink" title="配置事务的通知引用事务管理器"></a>配置事务的通知引用事务管理器</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">!--    配置事务的通知--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置事务的属性"><a href="#配置事务的属性" class="headerlink" title="配置事务的属性"></a>配置事务的属性</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在 tx:advice 标签内部 配置事务的属性 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 指定方法名称：是业务核心方法   </span></span><br><span class="line"><span class="comment">			read-only：是否是只读事务。默认 false，不只读。  </span></span><br><span class="line"><span class="comment">			isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。   				propagation：指定事务的传播行为。  </span></span><br><span class="line"><span class="comment">			timeout：指定超时时间。默认值为：-1。永不超时。  </span></span><br><span class="line"><span class="comment">			rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。 没有默认值，任何异常都回滚。  </span></span><br><span class="line"><span class="comment">			no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。  --&gt;</span>  </span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-AOP-切入点表达式"><a href="#配置-AOP-切入点表达式" class="headerlink" title="配置 AOP 切入点表达式"></a>配置 AOP 切入点表达式</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置AOP--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--       配置切入点表达式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.hongliang.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="配置切入点表达式和事务通知的对应关系"><a href="#配置切入点表达式和事务通知的对应关系" class="headerlink" title="配置切入点表达式和事务通知的对应关系"></a>配置切入点表达式和事务通知的对应关系</h3><p>在 <code>aop:config</code>标签内部:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--     建立切入点表达式和事务通知的对应关系  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置完成后的<code>bean.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hongliang.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ds&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置业务层--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hongliang.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ds&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置事务的通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            配置切入点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.hongliang.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            建立切入点表达式和事务通知的对应关系  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Junit单元测试：测试我们的配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;classpath:bean.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService as;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testTransfer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        as.transfer(<span class="string">&quot;马化腾&quot;</span>,<span class="string">&quot;王思聪&quot;</span>,<span class="number">1000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试，事务可以成功控制。</p>
<hr>
<h1 id="基于注解的配置方式"><a href="#基于注解的配置方式" class="headerlink" title="基于注解的配置方式"></a>基于注解的配置方式</h1><p>环境搭建同上</p>
<h2 id="创建业务层接口和实现类并使用注解让-spring-管理"><a href="#创建业务层接口和实现类并使用注解让-spring-管理" class="headerlink" title="创建业务层接口和实现类并使用注解让 spring 管理"></a>创建业务层接口和实现类并使用注解让 spring 管理</h2><img src="/2020/04/28/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/1588083544008.png" class width="1588083544008">

<h2 id="创建-Dao-接口和实现类并使用注解让-spring-管理"><a href="#创建-Dao-接口和实现类并使用注解让-spring-管理" class="headerlink" title="创建 Dao 接口和实现类并使用注解让 spring 管理"></a>创建 Dao 接口和实现类并使用注解让 spring 管理</h2><img src="/2020/04/28/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/1588083593706.png" class width="1588083593706">

<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="配置spring容器要扫描的包"><a href="#配置spring容器要扫描的包" class="headerlink" title="配置spring容器要扫描的包"></a>配置spring容器要扫描的包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置spring容器要扫描的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hongliang&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="配置事务管理器并注入数据源"><a href="#配置事务管理器并注入数据源" class="headerlink" title="配置事务管理器并注入数据源"></a>配置事务管理器并注入数据源</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ds&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="开启spring对注解事务的支持"><a href="#开启spring对注解事务的支持" class="headerlink" title="开启spring对注解事务的支持"></a>开启spring对注解事务的支持</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    开启spring对注解事务的支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="在业务层使用-Transactional-注解"><a href="#在业务层使用-Transactional-注解" class="headerlink" title="在业务层使用@Transactional 注解"></a>在业务层使用@Transactional 注解</h3><img src="/2020/04/28/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/1588083824521.png" class width="1588083824521">

<p>该注解的属性和 xml 中的属性含义一致。该注解可以出现在接口上，类上和方法上。 出现接口上，表示该接口的所有实现类都有事务支持。 出现在类上，表示类中所有方法有事务支持 出现在方法上，表示方法有事务支持。 以上三个位置的优先级：方法&gt;类&gt;接口。</p>
<hr>
<h1 id="不使用-xml的配置方式-（纯注解-）"><a href="#不使用-xml的配置方式-（纯注解-）" class="headerlink" title="不使用 xml的配置方式 （纯注解 ）"></a>不使用 xml的配置方式 （纯注解 ）</h1><h2 id="配置类取代bean-xml"><a href="#配置类取代bean-xml" class="headerlink" title="配置类取代bean.xml"></a>配置类取代bean.xml</h2><h3 id="Springconfiguration-java"><a href="#Springconfiguration-java" class="headerlink" title="Springconfiguration.java"></a>Springconfiguration.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring的配置类： 相当于bean.xml</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-04-28 22:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.hongliang&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;jdbcConfig.class, TransactionConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">//开启spring对注解事务的支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springconfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="jdbcConfig-java"><a href="#jdbcConfig-java" class="headerlink" title="jdbcConfig.java"></a>jdbcConfig.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库相关的配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-04-28 22:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driverClass&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driverClass;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建JdbcTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;jdbctemplate&quot;)</span>  <span class="comment">// 放入spring容器中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">createJdbcTemplate</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建数据源对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DriverManagerDataSource ds = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        ds.setPassword(driverClass);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(username);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="TransactionConfig-java"><a href="#TransactionConfig-java" class="headerlink" title="TransactionConfig.java"></a>TransactionConfig.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和事务相关的配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-04-28 22:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建事务管理器对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;transactionManager&quot;)</span>  <span class="comment">// 放入spring容器中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">createTransactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-04-28 23:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = Springconfiguration.class)</span> <span class="comment">// 引入配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">serviceText</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService service;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        service.transfer(<span class="string">&quot;马化腾&quot;</span>, <span class="string">&quot;王思聪&quot;</span>, <span class="number">2000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax发送异步请求</title>
    <url>/2020/05/09/ajax%E5%8F%91%E9%80%81%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>概念：<code>ASynchronous JavaScript And XML</code>    ：异步的<code>JavaScript</code> 和 <code>XML</code>。</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>异步和同步：客户端和服务器端相互通信的基础上。</p>
<img src="/2020/05/09/ajax%E5%8F%91%E9%80%81%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/1588998589929.png" class width="1588998589929">

<blockquote>
<p>同步请求：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。<br>        异步请求：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。</p>
</blockquote>
<p><code>Ajax</code> 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br>        传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。优点就是可以提升用户的体验。</p>
<h1 id="Ajax的实现方式"><a href="#Ajax的实现方式" class="headerlink" title="Ajax的实现方式"></a>Ajax的实现方式</h1><h2 id="原生的JS实现方式"><a href="#原生的JS实现方式" class="headerlink" title="原生的JS实现方式"></a>原生的JS实现方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//1.创建核心对象</span></span><br><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">&#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// code for IE6, IE5</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 建立连接</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	                参数：</span></span><br><span class="line"><span class="comment">	                    1. 请求方式：GET、POST</span></span><br><span class="line"><span class="comment">	                        * get方式，请求参数在URL后边拼接。send方法为空参</span></span><br><span class="line"><span class="comment">	                        * post方式，请求参数在send方法中定义</span></span><br><span class="line"><span class="comment">	                    2. 请求的URL：</span></span><br><span class="line"><span class="comment">	                    3. 同步或异步请求：true（异步）或 false（同步）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	             */</span></span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;ajaxServlet?username=tom&quot;</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.发送请求</span></span><br><span class="line">xmlhttp.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.接受并处理来自服务器的响应结果</span></span><br><span class="line"><span class="comment">//获取方式 ：xmlhttp.responseText</span></span><br><span class="line"><span class="comment">//什么时候获取？当服务器响应成功后再获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。</span></span><br><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断readyState就绪状态是否为4，判断status响应状态码是否为200</span></span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取服务器的响应结果</span></span><br><span class="line">        <span class="keyword">var</span> responseText = xmlhttp.responseText;</span><br><span class="line">        alert(responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="JQeury实现方式"><a href="#JQeury实现方式" class="headerlink" title="JQeury实现方式"></a>JQeury实现方式</h2><h3 id="ajax-："><a href="#ajax-：" class="headerlink" title="$.ajax()："></a>$.ajax()：</h3><p>语法：<code>$.ajax(&#123;键值对&#125;);</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用$.ajax()发送异步请求</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;ajaxServlet1111&quot;</span> , <span class="comment">// 请求路径</span></span><br><span class="line">    <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span> , <span class="comment">//请求方式</span></span><br><span class="line">    <span class="comment">//data: &quot;username=jack&amp;age=23&quot;,//请求参数</span></span><br><span class="line">    <span class="attr">data</span>:&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>&#125;,</span><br><span class="line">    <span class="attr">success</span>:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        alert(data);</span><br><span class="line">    &#125;,<span class="comment">//响应成功后的回调函数</span></span><br><span class="line">    <span class="attr">error</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;出错啦...&quot;</span>)</span><br><span class="line">    &#125;,<span class="comment">//表示如果请求响应出现错误，会执行的回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">dataType</span>:<span class="string">&quot;text&quot;</span><span class="comment">//设置接受到的响应数据的格式</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="get-：发送get请求"><a href="#get-：发送get请求" class="headerlink" title="$.get()：发送get请求"></a>$.get()：发送get请求</h3><p>语法：<code>$.get(url, [data], [callback], [type])：</code></p>
<ul>
<li>参数：<pre><code>              `url`：请求路径
              `data`：请求参数
              `callback`：回调函数
               `type`：响应结果的类型
</code></pre>
</li>
</ul>
<h3 id="post-：发送post请求"><a href="#post-：发送post请求" class="headerlink" title="$.post()：发送post请求"></a>$.post()：发送post请求</h3><p>语法：<code>$.post(url, [data], [callback], [type])</code>， 参数同<code>get</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义方法</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">//    使用ajax发送异步请求</span></span><br><span class="line">          $.get(<span class="string">&quot;ajaxServlet&quot;</span>, &#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;zhuhongliang&quot;</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">              alert(data);</span><br><span class="line">          &#125;, <span class="string">&quot;text&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="检查用户名是否存在"><a href="#检查用户名是否存在" class="headerlink" title="检查用户名是否存在"></a>检查用户名是否存在</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>注册页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">&quot;#username&quot;</span>).blur(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 获取文本输入框的值</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> username = $(<span class="built_in">this</span>).val();</span></span><br><span class="line"><span class="javascript">                <span class="comment">//发送ajax请求</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> span = $(<span class="string">&quot;#s_username&quot;</span>);</span></span><br><span class="line"><span class="javascript">                $.get(<span class="string">&quot;findUserServlet&quot;</span>, &#123;<span class="string">&#x27;username&#x27;</span>:username&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// alert(data);</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 期望返回的数据格式</span></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 判断userExist键是否为true</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>(data.userExist)&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// 用户名存在</span></span></span><br><span class="line"><span class="javascript">                        span.css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span></span><br><span class="line"><span class="javascript">                        span.html(data.msg);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// 用户名不存在</span></span></span><br><span class="line"><span class="javascript">                        span.html(data.msg);</span></span><br><span class="line"><span class="javascript">                        span.css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;green&quot;</span>);</span></span><br><span class="line"><span class="javascript">                    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                &#125;, <span class="string">&quot;json&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;s_username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2020/05/09/ajax%E5%8F%91%E9%80%81%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/1589019658006.png" class width="1589019658006">

<img src="/2020/05/09/ajax%E5%8F%91%E9%80%81%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/1589019686872.png" class width="1589019686872">]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOs7安装MySQL5踩坑记录</title>
    <url>/2020/06/17/centosmysql/</url>
    <content><![CDATA[<h1 id="安装CentOs7"><a href="#安装CentOs7" class="headerlink" title="安装CentOs7"></a>安装CentOs7</h1><img src="/2020/06/17/centosmysql/1592388617697.png" class width="1592388617697">

<p>主要就是配置分区 /boot:200m 、 /:10240m(10G) 、 /swap:2048m</p>
<p>然后配置网络  ifconfig –&gt; ssh远程连接。</p>
<h1 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h1><p>在/opt目录下：</p>
<ol>
<li><p>检查是否安装过：  rpm -qa|grep -i mysql </p>
<p>yum -y remove maria*  删除 mariadb </p>
</li>
<li><p>下载服务器包：wget <a href="https://dev.mysql.com/get/Downloads/MySQL-5.5/MySQL-server-5.5.59-1.el7.x86_64.rpm">https://dev.mysql.com/get/Downloads/MySQL-5.5/MySQL-server-5.5.59-1.el7.x86_64.rpm</a></p>
</li>
<li><p>下载客户端包：wget <a href="https://dev.mysql.com/get/Downloads/MySQL-5.5/MySQL-client-5.5.59-1.el7.x86_64.rpm">https://dev.mysql.com/get/Downloads/MySQL-5.5/MySQL-client-5.5.59-1.el7.x86_64.rpm</a></p>
</li>
<li><p>安装客户端和服务端</p>
<p>rpm -ivh –nodeps MySQL-server-5.5.59-1.el7.x86_64.rpm</p>
<p>rpm -ivh –nodeps MySQL-client-5.5.59-1.el7.x86_64.rpm</p>
<p># –nodeps就是安装时不检查依赖关系</p>
</li>
<li><p>启动服务报错</p>
<p>service mysql start </p>
<img src="/2020/06/17/centosmysql/1592388851553.png" class width="1592388851553">

<p><strong>解决：</strong></p>
<blockquote>
<p> /usr/bin/mysql_install_db –user=mysql</p>
</blockquote>
<p>因为需要初始化，因为新安装的mysql服务后，一般需要执行数据库初始化操作 ，从而生成与权限相关的表，执行命令。</p>
</li>
<li><p>service mysql start 启动数据库</p>
<img src="/2020/06/17/centosmysql/1592389019493.png" class width="1592389019493"></li>
<li><p>设置mysql服务开机自启 ： systemctl enable mysql</p>
<img src="/2020/06/17/centosmysql/1592389090390.png" class width="1592389090390"></li>
<li><p>验证自启动是否成功 : chkconfig mysql on</p>
<img src="/2020/06/17/centosmysql/1592389167311.png" class width="1592389167311"></li>
<li><p>查看mysql的安装位置： ps -ef|grep mysql</p>
<img src="/2020/06/17/centosmysql/1592389464560.png" class width="1592389464560"></li>
</ol>
<hr>
<h1 id="修改字符集"><a href="#修改字符集" class="headerlink" title="修改字符集"></a>修改字符集</h1><ol>
<li>尝试插入中文字符有乱码；</li>
</ol>
<img src="/2020/06/17/centosmysql/1592389859929.png" class width="1592389859929">

<ol start="2">
<li>查看字符集： mysql&gt; show variables like ‘character%’;</li>
</ol>
<img src="/2020/06/17/centosmysql/1592390017618.png" class width="1592390017618">

<ol start="3">
<li><p>修改字符集</p>
<p>修改<code>my.cnf</code><br>在<code>/usr/share/mysql/</code> 中找到<code>my.cnf</code>的配置文件，<br>拷贝其中的my-huge.cnf 到 /etc/  并命名为my.cnf<br>然后修改my.cnf:<br>[client]<br>default-character-set=utf8<br>[mysqld]<br>character_set_server=utf8<br>character_set_client=utf8<br>collation-server=utf8_general_ci<br>[mysql]<br>default-character-set=utf8</p>
<p>但是我的并没有这个文件…</p>
<img src="/2020/06/17/centosmysql/1592390535539.png" class width="1592390535539">

<p>只有上述几个，经查资料发现： 分别用于不同的硬件环境下的配置文件 </p>
<blockquote>
<p>my-small.cnf                （内存 &lt;= 64M）<br>my-medium.cnf               （内存 128M）<br>my-large.cnf                （内存 512M）<br>my-huge.cnf                 （内存 1G-2G）<br>my-innodb-heavy-4G.cnf      （内存 4GB）</p>
</blockquote>
</li>
</ol>
<p> 这里我的内存设置为2G，所以将my-huge.cnf复制到/etc/下并改名字为my.cnf </p>
<p>然后打开修改字符集。 然后重新启动mysql。</p>
<p>但是原库的设定不会发生变化，参数修改只会对新建的数据库生效</p>
<ol start="4">
<li>已生成的库表字符集如何变更<pre><code>修改数据库的字符集：
           `mysql&gt; alter database mydb character set &#39;utf8&#39;;`
   修改数据表的字符集：
       `mysql&gt; alter table mytbl convert to  character set &#39;utf8&#39;;`
</code></pre>
</li>
</ol>
<p> <strong>但是原有的数据如果是用非’utf8’编码的话，数据本身不会发生改变。</strong></p>
<img src="/2020/06/17/centosmysql/1592391403142.png" class width="1592391403142">





<h1 id="开启mysql的远程登录"><a href="#开启mysql的远程登录" class="headerlink" title="开启mysql的远程登录"></a>开启mysql的远程登录</h1><p>1 . 设置权限</p>
<blockquote>
<p><code>grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;root&#39;;</code> #权限放大到任何一台机器都可以远程登录</p>
<p><code>flush privileges;</code></p>
</blockquote>
<ol start="2">
<li><p>关闭防火墙：systemctl stop firewall</p>
</li>
<li><p>设置开机禁用防火墙：systemctl disable firewalld.service</p>
</li>
<li><p>最重要一步： </p>
<p>打开文件查找到 [mysqld] ，在其下方添加上一行 <strong>skip-grant-tables</strong>，然后保存。 这样才可以成功连接。</p>
<img src="/2020/06/17/centosmysql/1592392281754.png" class width="1592392281754"></li>
</ol>
<p>  systemctl和防火墙firewalld命令 见下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">一、防火墙的开启、关闭、禁用命令</span><br><span class="line"> </span><br><span class="line">（1）设置开机启用防火墙：systemctl enable firewalld.service</span><br><span class="line"> </span><br><span class="line">（2）设置开机禁用防火墙：systemctl disable firewalld.service</span><br><span class="line"> </span><br><span class="line">（3）启动防火墙：systemctl start firewalld</span><br><span class="line"> </span><br><span class="line">（4）关闭防火墙：systemctl stop firewalld</span><br><span class="line"> </span><br><span class="line">（5）检查防火墙状态：systemctl status firewalld </span><br><span class="line"> </span><br><span class="line">二、使用firewall-cmd配置端口</span><br><span class="line"> </span><br><span class="line">（1）查看防火墙状态：firewall-cmd --state</span><br><span class="line"> </span><br><span class="line">（2）重新加载配置：firewall-cmd --reload</span><br><span class="line"> </span><br><span class="line">（3）查看开放的端口：firewall-cmd --list-ports</span><br><span class="line"> </span><br><span class="line">（4）开启防火墙端口：firewall-cmd --zone=public --add-port=9200/tcp --permanent</span><br><span class="line"> </span><br><span class="line">　　命令含义：</span><br><span class="line"> </span><br><span class="line">　　–zone #作用域</span><br><span class="line"> </span><br><span class="line">　　–add-port=9200/tcp #添加端口，格式为：端口/通讯协议</span><br><span class="line"> </span><br><span class="line">　　–permanent #永久生效，没有此参数重启后失效</span><br><span class="line"> </span><br><span class="line">　　注意：添加端口后，必须用命令firewall-cmd --reload重新加载一遍才会生效</span><br><span class="line"> </span><br><span class="line">（5）关闭防火墙端口：firewall-cmd --zone=public --remove-port=9200/tcp --permanent</span><br></pre></td></tr></table></figure>



<h1 id="MySQL密码设置和开机启动"><a href="#MySQL密码设置和开机启动" class="headerlink" title="MySQL密码设置和开机启动"></a>MySQL密码设置和开机启动</h1><p>设置密码： /usr/bin/mysqladmin -u root password 123456</p>
<p>自启动 ：查看</p>
<p><img src="/2020/06/17/centosmysql/Users\ZHLAS\AppData\Roaming\Typora\typora-user-images\1595840276715.png" alt="1595840276715"></p>
<p>以上是mysql的运行级别</p>
<p>我们运行： ntsysv</p>
<img src="/2020/06/17/centosmysql/1595840500862.png" class width="1595840500862">

<p>可以看到开机自启的服务，mysql服务前面有一个*号，表示开机自启</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li> <a href="https://blog.csdn.net/u012402177/article/details/82870433">https://blog.csdn.net/u012402177/article/details/82870433</a> </li>
<li> <a href="https://blog.csdn.net/IndexMan/article/details/84641233">https://blog.csdn.net/IndexMan/article/details/84641233</a> </li>
<li> <a href="https://blog.csdn.net/qq_22227087/article/details/80946894">https://blog.csdn.net/qq_22227087/article/details/80946894</a> </li>
<li> <a href="https://www.cnblogs.com/weibanggang/p/11230528.html">https://www.cnblogs.com/weibanggang/p/11230528.html</a> </li>
<li> <a href="https://www.cnblogs.com/nxmxl/p/11766671.html">https://www.cnblogs.com/nxmxl/p/11766671.html</a> </li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>deeplabv1和deeplabv2</title>
    <url>/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/</url>
    <content><![CDATA[<p>来自： <a href="https://towardsdatascience.com/review-deeplabv1-deeplabv2-atrous-convolution-semantic-segmentation-b51c5fbde92d">review-deeplabv1-deeplabv2-atrous-convolution-semantic-segmentation</a></p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>在本文中，回顾了DeepLabv1和DeepLabv2网络，因为他们都使用带孔卷积 Atrous Convolution和全连接的条件随机场（Conditional Random Field，CRF），除了DeepLabv2有一个额外的技术叫做空间金字塔池化Atous Spatial Pyramid Pooling（ASPP），这是DeepLabv2与DeepLabv1的主要区别。 （当然，还有其他差别，例如：DeepLabv2使用ResNet和VGGNet进行实验，但DeepLabv1仅使用VGGNet。） </p>
 <img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1551686251739905.png" class title="img">

<p>上图是DeepLab模型架构。首先，输入图像通过网络中的atrous卷积和ASPP。然后，网络的输出图进行双线性插值bilinearly interpolated，并通过完全连接的CRF来微调结果并获得最终输出。</p>
<p>DeepLabv1和DeepLabv2已经在2015 ICLR和2018 TPAMI上发布。</p>
<p>本文涉及的内容：</p>
<ol>
<li>带孔卷积</li>
<li>空间金字塔池化</li>
<li>全连接的条件随机场</li>
<li>实验结果</li>
</ol>
<h1 id="Atrous-卷积"><a href="#Atrous-卷积" class="headerlink" title="Atrous 卷积"></a>Atrous 卷积</h1><p>“Atrous”这个词确实来自法语“àtrous”意思：洞。因此Atrous conv.也被称为“空洞卷积”。一些论文也称之为”dilated convolution”。它通常用于小波变换，现在它被应用于卷积中以进行深度学习。</p>
<p>下面是atrous卷积的表达式：</p>
 <img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1551686248702748.png" class title="img"> 

<p> 1维的带孔卷积（r &gt; 1：atrous卷积，r = 1：标准卷积） </p>
<ul>
<li>当r = 1时，它是我们通常使用的标准卷积。</li>
<li>当r &gt; 1时，它是一个带孔的卷积，r是在卷积过程中对输入样本进行采样的步幅。</li>
</ul>
<p>下图说明这一点：</p>
 <img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1551686248741066.png" class title="img"> 

<p>标准卷积（a）空洞卷积（b）</p>
<p>atrous卷积的想法很简单。在上图的顶部是标准卷积。</p>
<p>在图(b)，它是一个空洞卷积。我们可以看到，当rate = 2时，输入信号被交替采样。首先，pad = 2 意味着我们在左侧和右侧填充2个零。然后，在 rate = 2的情况下，我们有每2个输入就对输入信号进行采样以进行卷积。因此，在输出端，我们将有5个输出，这使得输出的特征图增大。如果我们还记得<a href="https://towardsdatascience.com/review-fcn-semantic-segmentation-eb8c9b50d2d1">FCN</a>一文中，一系列的卷积和池化会使输出特征图非常小，因此最后需要32倍的上采样，这是有些放大过度的上采样。</p>
<p>此外，atrous卷积使我们扩大卷积核filter的视野以包含更大的感受域信息。同时，它提供了一种有效的机制来控制感受野的大小，并找到精确定位（小视野）和通过前后信息修复（大视场）细节之间的最佳平衡。</p>
<p>在DeepLab中，使用VGG-16或ResNet-101，最后一个池化（pool5）或卷积conv5_1的步幅分别设置为1，以避免信号被过度抽取。并且使用rate=2的空洞卷积替换所有后续卷积层。这使得输出变大很多。我们只需要进行8次上采样即可对输出要求的尺寸。并且双线性插值对于8×上采样具有相当好的性能。</p>
<h1 id="带孔空间金字塔池化-ASPP"><a href="#带孔空间金字塔池化-ASPP" class="headerlink" title="带孔空间金字塔池化 (ASPP)"></a>带孔空间金字塔池化 (ASPP)</h1> <img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1551686249408404.png" class title="img">

<p>上图是ASPP模型 （ 带孔的空间金字塔池化 ： Atrous Spatial Pyramid Pooling ）</p>
<p>为了分类中间像素（橘色），利用多个不同rate并行的filter，使用了多尺度信息。</p>
<p> ASPP实际上是空间金字塔池的一个版本，其中的概念已经在SPPNet中描述。在ASPP中，在输入特征映射中应用不同rate的并行空洞卷积，并融合在一起。由于同一类的物体在图像中可能有不同的比例，ASPP有助于考虑不同的物体比例，这可以提高准确性。 </p>
<h1 id="完全连接的条件随机场-CRF"><a href="#完全连接的条件随机场-CRF" class="headerlink" title="完全连接的条件随机场(CRF)"></a>完全连接的条件随机场(CRF)</h1><p>完全连接的CRF在双线性插值后应用于网络输出上</p>
 <img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1551686249151719.png" class title="img">

<p> $x$是像素的标签分配。 $P(x_i)$是在像素$i$处的标签分配的概率。因此，第一项$\theta_i$是对数概率。<br>对于第二项，$\theta_{ij}$，它是一个滤波器。当$x_i != x_j$  时，μ= 1。当$x_i = x_j$时，μ= 0。在括号中，它是两个内核的加权和。第一个核取决于像素值差和像素位置差，这是一种双边的filter。双边滤波器具有保留边缘的特性。第二个内核仅取决于像素位置差异，这是一个高斯滤波器。那些σ和w，通过交叉验证找到。迭代次数为10。 </p>
 <img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1551686249830173.png" class title="img"> 

<p>上：得分图（softmax函数前的输入），下图：置信图（softmax函数的输出）</p>
<p>通过10倍的CRF，飞机周围不同颜色的小区域变得平滑起来。</p>
<p>但是，CRF是一个后阶段的处理过程，它使DeepLabv1和DeepLabv2变为不是端到端的学习框架。并且它是不在DeepLabv3和DeepLabv3 +中使用。</p>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><h2 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h2> <img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1551686249429498.png" class title="img"> 

<p>DeepLab-LargeFOV（左：即仅单个atrous conv），DeepLab-ASPP（右，即ASPP）</p>
 <img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1551686249139876.png" class title="img"> 

<p> 在PASCAL VOC 2012验证集中使用ResNet-101的每个模型组件的结果</p>
<ul>
<li>简单使用ResNet-101: 68.72%</li>
<li>MSC: 多尺度输入</li>
<li>COCO: 由COCO数据集预训练的模型</li>
<li>Aug: 通过随机缩放（从0.5到1.5）输入图像进行数据增强</li>
<li>LargeFOV: 使用一次空洞卷积上采样的DeepLab模型</li>
<li>ASPP: 使用并行的空洞卷积的DeepLab模型</li>
<li>CRF: 全连接的条件随机场做最后处理</li>
</ul>
<h2 id="与最先进的方法对比"><a href="#与最先进的方法对比" class="headerlink" title="与最先进的方法对比"></a>与最先进的方法对比</h2><img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1586405306975.png" class title="PASCAL VOC 2012测试集">

<p>​                                                     PASCAL VOC 2012测试集</p>
<img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1586405374772.png" class title="PASCAL-Context">

<p>​                                                            PASCAL-Context </p>
<img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1586405431371.png" class width="1586405431371">

<img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1586405458213.png" class width="1586405458213">

<p>如上所述测试四个数据集。结果表明，与最先进的方法相比，DeepLabv2具有竞争力。 </p>
<h2 id="定性的结果-Qualitative-Results"><a href="#定性的结果-Qualitative-Results" class="headerlink" title="定性的结果 (Qualitative Results)"></a>定性的结果 (Qualitative Results)</h2><img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1586405535851.png" class width="1586405535851">

<p>但DeepLab也有一些失败的例子，其中自行车和椅子由多个细小的部分组成，如自行车和椅腿的部分： </p>
<img src="/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/1586405566301.png" class width="1586405566301">

<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.leiphone.com/news/201903/4qqzNxc4PaQKMgij.html">https://www.leiphone.com/news/201903/4qqzNxc4PaQKMgij.html</a> </li>
<li> <a href="http://liangchiehchen.com/projects/DeepLab.html">http://liangchiehchen.com/projects/DeepLab.html</a> </li>
<li> <a href="https://www.jianshu.com/p/9184455a4bd3">https://www.jianshu.com/p/9184455a4bd3</a> </li>
</ol>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>papers</tag>
      </tags>
  </entry>
  <entry>
    <title>deeplabv3-空洞卷积(语义分割)</title>
    <url>/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>《Rethinking Atrous Convolution for Semantic Image Segmentation》</p>
<p>deeplab-ppt：<a href="/source/Rethinking-Atrous-Convolution-for-Semantic-Image-Segmentation-1.pdf">Rethinking-Atrous-Convolution-for-Semantic-Image-Segmentation</a></p>
<p>深层卷积神经网络(DCNNs)应用于语义分割的任务，我们考虑了面临的两个挑战：</p>
<p>第一个挑战：连续池化操作或卷积中的stride导致的特征分辨率降低。这使得DCNN能够学习更抽象的特征表示。然而，这种不变性可能会阻碍密集预测任务，因为不变性也导致了详细空间信息的不确定。为了克服这个问题，我们提倡使用空洞卷积。</p>
<p>第二个挑战：多尺度物体的存在。几种方法已经被提出来处理这个问题，在本文中我们主要考虑了这些工作中的四种类型，如图所示。</p>
<img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1586417056825.png" class width="1586417056825">

<ul>
<li>第一种：Image Pyramid，将输入图片放缩成不同比例，分别应用在DCNN上，将预测结果融合得到最终输出</li>
<li>第二种：Encoder-Decoder，将Encoder阶段的多尺度特征运用到Decoder阶段上来恢复空间分辨率</li>
<li>第三种：在原始模型的顶端叠加额外的模块，以捕捉像素间长距离信息。例如Dense CRF，或者叠加一些其他的卷积层</li>
<li>第四种：Spatial Pyramid Pooling空间金字塔池化，使用不同采样率和多种视野的卷积核，以捕捉多尺度对象</li>
</ul>
<p>Deeplabv3的主要创新点就是改进了ASPP模块，一个1x1的卷积和3个3x3的空洞卷积，每个卷积核有256个且都有BN层，包含图像及特征（全局平均池化）。</p>
<ul>
<li>提出了更通用的框架，适用于任何网络；</li>
<li>复制了resnet最后的block，并级联起来</li>
<li>在ASPP中使用BN层</li>
<li>没有随机向量场</li>
</ul>
<p>在DeepLabv1和DeepLabv2发表之后，作者试图去重新构造DeepLab结构，并最终提出了一个更加强大的结构DeepLabv3。甚至去掉在DeepLabv1和DeepLabv2中使用的后处理过程(条件随机场)，DeepLabv3的表现依然超过了DeepLabv1和DeepLabv2。 </p>
<p> 因此，论文的名称叫做“针对图像语义分割的空洞卷积网络重构”。使用“重构”这个词，就是在致敬Inception-v3，Inception-v3的原文章名称就叫“ Rethinking the Inception Architecture for Computer Vision  ”，inception-v3是在Inception-v1和inception-v2的基础上重新构造而得的。现在，DeepLabv2被重构成DeepLabv3。它是一份2017年ARXIV的技术报告，超过200次引用。 </p>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ol>
<li>空洞卷积</li>
<li>使用多网格的深层空洞卷积</li>
<li>Atrous空间金字塔</li>
<li>在 PASCAL VOC 2012 进行验证</li>
<li>和PASCAL VOC 2012上最优的方法进行比较</li>
<li>和Cityscape上最优秀的方法进行比较</li>
</ol>
<hr>
<h1 id="空洞卷积"><a href="#空洞卷积" class="headerlink" title="空洞卷积"></a>空洞卷积</h1><p>不同扩张率r的空洞卷积：</p>
 <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772073759270.png" class title="img"> 

 <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772075429185.png" class title="img"> 

<ul>
<li>对于输出y上的每个位置$i$以及滤波核，空洞卷积应用在输入特征$x$上，扩张率$r$和对输入信号的采样步长相关.</li>
<li>这相当于在输入$x$上进行上采样，在空间维度连续两个元素之间插入r-1个0</li>
<li>当r=1时这就是一个标准的卷积了</li>
<li>通过调整r，我们可以调整滤波器的视野</li>
<li>他也被称之为扩张卷积(扩张网络)或空洞算法</li>
</ul>
 <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772076268689.png" class title="img"> 

<p>上面：标准卷积</p>
<p>下面：Atrous卷积(空洞卷积)。我们可以看到不当rate=2时，信号时交替采样的。首先pad=2意味这在边界的两边会加上2个0。又因为rate=2，我们对输入的信号每2个进行抽样计算卷积。Atrous卷积允许我们去拓宽感受野，关联更多的上下文信息。因此它给我们提供了 一个高效的控制感受野的机制，能更好的在精确定位(小的感受野)和上下文语义相关性(达的感受野)之间找到平衡。</p>
<h1 id="使用多网格-Multi-Grid-的深层空洞卷积"><a href="#使用多网格-Multi-Grid-的深层空洞卷积" class="headerlink" title="使用多网格(Multi Grid)的深层空洞卷积"></a>使用多网格(Multi Grid)的深层空洞卷积</h1><img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1586406842654.png" class width="1586406842654">

<ul>
<li>(a)、非空洞卷积：标准卷积和池化使得输出维度的缩小倍数增加，如：当层次增加时输出特征维度变小。然而特征维度不断的缩小对语义分割是不利的，因为位置和空间信息在深层次中丢失的太多了。</li>
<li>(b)、空洞卷积：使用空洞卷积，我们可以保持步幅不变，在不增加参数数量的情况下获得更大的感受野。最终，我们可以得到更大的输出特征，这个对与语义分割是非常好的。</li>
<li>举个例子，当输出的缩小倍数stride=16时，多个网格为(1,2,4)，三个卷积的空洞率为rates =2X(1,2,4)=(2,4,8)。</li>
</ul>
<h1 id="Atrous空间金字塔池-ASPP"><a href="#Atrous空间金字塔池-ASPP" class="headerlink" title="Atrous空间金字塔池(ASPP)"></a>Atrous空间金字塔池(ASPP)</h1> <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772100140583.png" class title="img"> 

<ul>
<li>ASPP 已经被用在DeepLabv2了。这次，来自Inception-v2的批量归一化(BN)也会引入到ASPP中。</li>
<li>使用ASPP的原因是，发现随着扩张率增加，有效的滤波权重会变小（相同个数的权重被应用到较大的视野范围中）。</li>
<li>一个1X1的卷积和三个扩张率为(6,12,18)的3X3的卷积核，输出的缩小倍数为16。</li>
<li>都使用256个滤波器和批量归一化(BN)。</li>
<li>当输出的缩小倍数为8时，扩张率是加倍的。</li>
<li>所有分支连接起来先通过另一个1X1的卷积(256个滤波器和批量归一化)，最后使用1X1的卷积核卷积产生概率值。</li>
</ul>
<h2 id="Upsampling-Logits"><a href="#Upsampling-Logits" class="headerlink" title="Upsampling Logits"></a>Upsampling Logits</h2><ul>
<li>在DeepLabv2中，训练过程中，真实目标被下采样了8倍。</li>
<li>在DeepLabv3中，发现，最重要的是保证真实背景的完整性，而不是对最终值的上采样。</li>
</ul>
<hr>
<h1 id="图像金字塔-Image-pyramid"><a href="#图像金字塔-Image-pyramid" class="headerlink" title="图像金字塔(Image pyramid)"></a><strong>图像金字塔(Image pyramid)</strong></h1><p>同样的模型，通常使用共享权重，使用多尺度的输入。小尺寸的输入特征响对应长距离语义，大尺寸输入的相应修正细节。通过拉普拉斯金字塔对输入图像进行变换，将不同尺度的图片输入到DCNN，并将所有比例的特征图合并。有人将多尺度输入按顺序从粗到细依次应用，也有人直接将输入调整成不同的大小，并融合所有大小的特征。这类模型的主要缺点是由于GPU内存，较大/更深的DCNN不方便应用，因此通常在推理阶段应用。 </p>
<h1 id="编码器-解码器-Encoder-decoder"><a href="#编码器-解码器-Encoder-decoder" class="headerlink" title="编码器-解码器(Encoder-decoder)"></a><strong>编码器-解码器(Encoder-decoder)</strong></h1><p> 该模型由两部分组成：</p>
<p>(a)编码器中，特征映射的空间维度逐渐减小，从而更容易捕获较长范围内的信息；</p>
<p>(b)解码器中，目标细节和空间维度逐渐恢复。例如，有人反卷积来学习对低分辨率特征响应进行上采样。SegNet复用编码器中的池化索引，学习额外的卷积层来平滑特征响应；U-net将编码器中的特征层通过跳跃连接添加到相应的解码器激活层中；LRR使用了一个拉普拉斯金字塔重建网络。最近，RefineNet等证明了基于编码-解码结构的有效性。这类模型也在对象检测的领域得到了应用。 </p>
<h1 id="在PASCAL-VOC-2012上进行实验验证"><a href="#在PASCAL-VOC-2012上进行实验验证" class="headerlink" title="在PASCAL VOC 2012上进行实验验证"></a>在PASCAL VOC 2012上进行实验验证</h1><h3 id="Output-Stride"><a href="#Output-Stride" class="headerlink" title="Output Stride"></a>Output Stride</h3> <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772079514810.png" class title="img"> 

<p>使用带空洞卷积的ResNet-50模型，在不同的下采样倍数条件下的平均交并比(mIOU)的对比</p>
<ul>
<li>当使用的ResNet-50，如上面表格所示，这种情况下输出下采样256倍时表现是最糟糕的。</li>
<li>当输出维度变大时使用空洞卷积，mIou从20.29%增加到了75.18%。这显示了，当使用更多的blocks级联时，空洞卷积是必不可少的。</li>
</ul>
<h3 id="ResNet-101"><a href="#ResNet-101" class="headerlink" title="ResNet-101"></a>ResNet-101</h3><p> ResNet-50 vs ResNet-101 :</p>
 <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772080719876.png" class title="img"> 

<ul>
<li>ResNet-101的平均交并比始终比ResNet-50高。</li>
<li>显然，7层网络之后ResNet-50下平均交并比轻微下降而ResNet-101效果仍在上升。</li>
</ul>
<h3 id="Multi-Grid"><a href="#Multi-Grid" class="headerlink" title="Multi-Grid"></a>Multi-Grid</h3><p>受到了采用不同大小网格层次结构的多重网格方法的启发，我们提出的模型在block4和block7中采用了不同的空洞率。</p>
<p>特别的，我们定义<em>Multi_Grid</em> =(r1, r2, r3) 为block4到block7内三个卷积层的unit rates。卷积层的最终空洞率等于unit rate和corresponding rate的乘积。例如，当<em>output_stride</em> = 16 ，<em>Multi_Grid</em> = (1, 2, 4)，三个卷积就会在block4有 <em>rates</em> = 2 · (1, 2, 4) = (2, 4, 8) 。</p>
<p> Employing multi-grid method for ResNet-101 with different number of cascaded blocks at output stride = 16. 当输出缩小倍数为16时，采用多层网格的ResNet-101在不同串联块数下的平均交并比。</p>
 <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772082900394.png" class title="img"> 

<ul>
<li>一般情况下，采用多层网格方法效果要好于采用（r1,r2,r3）=(1,1,1)的单一网格方法。</li>
<li>仅加倍单位扩张率（例如（r1,r2,r3）=(2,2,2)）并不会增强分割效果。<br>在多层网格下加深网络层数可以增强分割表现。</li>
<li>最佳模型的结构是采用7层网络，且（r1,r2,r3）=（1，2，1）。增加网络的深度配合multi-grid可以提升网络的性能。</li>
</ul>
<h3 id="Inference-Strategy"><a href="#Inference-Strategy" class="headerlink" title="Inference Strategy"></a>Inference Strategy</h3> <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772084821653.png" class title="img"> 

<ul>
<li>在数据集上的测试方案：MG：multi grid。OS：output stride。MS：在测试过程中的多尺度输入。Flip：对输入图片添加左右翻转操作。</li>
<li>模型训练时的 output stride 是16。</li>
<li>测试时，可以得到更多特征细节的 output stride 8相较于 output stride 16，平均交并比提升了1.39%。</li>
<li>当同时使用多尺度输入如{0.5，0.75，1.0，1.25，1.5，1.75}和左右翻转输入图片操作时，效果提升到79.35%。</li>
</ul>
<h3 id="ASPP"><a href="#ASPP" class="headerlink" title="ASPP"></a>ASPP</h3> <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772086844737.png" class title="img"> 

<p>当output stride为16时，不同空洞卷积池化操作及多层网格参数的平均交并比结果对比。</p>
<ul>
<li>ParseNet下的图像池化或者图像层级特征也是考虑到全局上下文信息。</li>
<li>当采用ASPP=(6,12,18)时，多层网格结构（1，2，4）效果要优于（1，1，1）和（1，2，1）。</li>
<li>采用ASPP（6，12，18）效果优于ASPP=（6，12，18，24）。</li>
<li>采用池化操作，平均交并比可以提升到77.21%。</li>
</ul>
<h3 id="Crop-Size-Upsampling-Logits-Batch-Norm-Batch-Size-Train-amp-Test-Output-Stride"><a href="#Crop-Size-Upsampling-Logits-Batch-Norm-Batch-Size-Train-amp-Test-Output-Stride" class="headerlink" title="Crop Size, Upsampling Logits, Batch Norm, Batch Size, Train &amp; Test Output Stride"></a>Crop Size, Upsampling Logits, Batch Norm, Batch Size, Train &amp; Test Output Stride</h3><p>裁切大小，上采样，批量归一化，批次大小，训练和测试的输出步长</p>
 <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772090167085.png" class title="img"> 

<ul>
<li>使用更大的裁剪大小为513结果要好裁剪大小为321.</li>
<li>采用上采样和批量归一化，精度达到77.21%。</li>
<li>批次大小分别设置4,8,12,16，其中16结果最好。</li>
<li>训练和测试集的输出步长为（8,8）时精度为77.21%，而使用步长为（16,8）时，精度为78.51%。</li>
</ul>
<h3 id="采用所有技巧"><a href="#采用所有技巧" class="headerlink" title="采用所有技巧"></a>采用所有技巧</h3> <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772094237859.png" class title="img"> 

<ul>
<li>MG(1, 2, 4) + ASPP(6, 12, 18) + Image Pooling：精度为77.21%.</li>
<li>输出步长为8时，精度为78.51%。</li>
<li>多尺度测试，精度为79.45%。</li>
<li>水平翻转，精度为79.77%。</li>
<li>采用COCO数据集预训练，精度为82.7%。</li>
<li>经过对网络的重新构建，没有使用之前在<a href="https://towardsdatascience.com/review-deeplabv1-deeplabv2-atrous-convolution-semantic-segmentation-b51c5fbde92d">DeepLabv2</a>中采用的条件随机场后处理，精度已经超过了采用COCO数据集预训练和条件随机场的精度, 其精度为77.69%。</li>
</ul>
<h1 id="Comparison-with-State-of-the-art-Approaches"><a href="#Comparison-with-State-of-the-art-Approaches" class="headerlink" title="Comparison with State-of-the-art Approaches"></a>Comparison with State-of-the-art Approaches</h1><h2 id="PASCAL-VOC-2012-Test-Set"><a href="#PASCAL-VOC-2012-Test-Set" class="headerlink" title="PASCAL VOC 2012 Test Set"></a>PASCAL VOC 2012 Test Set</h2><p> <img src="https://static.leiphone.com/uploads/new/sns/article/201903/1551772102157580.png" alt="img"> </p>
<p> DeepLabv3：在PASCAL VOC 2012训练验证集上微调，输出步长8，在困难样本上采取bootstrapping方法。特别是包含困难类别的进行复制，到达精度85.7%。 </p>
 <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772105896687.png" class title="img"> 

<ul>
<li>上面示例图显示了bootstrapping方法在困难样本上的效果，提升了稀少样本如自行车等类别的精度和分割效果。</li>
<li>DeepLabv3分割效果优于<a href="https://towardsdatascience.com/review-pspnet-winner-in-ilsvrc-2016-semantic-segmentation-scene-parsing-e089e5df177d">PSPNet</a>,而后者是ILSVRC 2016场景分割比赛中的冠军。</li>
<li>deepLabv3-JFT采用了在ImageNet和JFT-300M数据集上训练的ResNet101权重模型，达到精度为86.9%。</li>
</ul>
<p> PASCAL VOC 2012量化结果（最后一行，失败的例子） </p>
<img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772533150652.png" class title="1_3Q5zbNSFruHPvhAjlMrN_Q.png">

<h1 id="在Cityscape数据集上表现最佳的方法对比"><a href="#在Cityscape数据集上表现最佳的方法对比" class="headerlink" title="在Cityscape数据集上表现最佳的方法对比"></a>在Cityscape数据集上表现最佳的方法对比</h1><h2 id="Different-Settings"><a href="#Different-Settings" class="headerlink" title="Different Settings"></a>Different Settings</h2> <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772095913989.png" class title="img"> 

<p>类似于测试时采用output stride 8，多尺度输入和水平翻转操作的PASCAL VOC 2012数据集，平均交并比逐渐提升。 </p>
<h2 id="Cityscape-测试集"><a href="#Cityscape-测试集" class="headerlink" title="Cityscape 测试集"></a>Cityscape 测试集</h2> <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772096529951.png" class title="img"> 

<ul>
<li>测试集为了在对比中获得更佳的效果，DeepLabv3在粗糙训练集中进一步训练（例如，3475张精确标记的图片和额外的20000张粗略标记的图片）。</li>
<li>在测试过程中，要求多尺度输入和精确维度输出。其中，输入尺度范围为{0.75，1，1.25，1.5，1.75，2}，并且评估输出维度为4，这在验证集中分别贡献了0.8%和0.1%的提升。</li>
<li>最后，在测试集中达到了81.3%的平均交并比，这稍高于PSPNet。</li>
</ul>
<p>在cityspace中的分割结果：</p>
 <img src="/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/1551772163910291.png" class title="img"> 

<p>DeepLabv3仅比PSPNet效果高一点，这可能也是为什么它在arXiv中仅作为技术报告。但是后来提出的DeepLabv3+远优于DeepLabv3。希望后续有机会可以学习DeepLabv3+。 </p>
<hr>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>提出的模型DeepLab V3采用atrous convolution的上采样滤波器提取稠密特征映射和去捕获大范围的上下文信息。具体来说，编码多尺度信息，提出了级联模块逐步翻倍的atrous rates，提出了ASPP模块增强图像级的特征，探讨了多采样率和有效视场下的滤波器特性。实验结果表明，该模型在Pascal voc 2012语义图像分割基准上比以前的DeppLab版本有了明显的改进，并取得了SOAT精度。 </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li> <a href="https://zhuanlan.zhihu.com/p/40470298">https://zhuanlan.zhihu.com/p/40470298</a> </li>
<li> <a href="https://towardsdatascience.com/review-deeplabv3-atrous-convolution-semantic-segmentation-6d818bfd1d74">https://towardsdatascience.com/review-deeplabv3-atrous-convolution-semantic-segmentation-6d818bfd1d74</a> </li>
<li> <a href="https://www.yanxishe.com/TextTranslation/1536">https://www.yanxishe.com/TextTranslation/1536</a> </li>
<li> <a href="https://www.yanxishe.com/columnDetail/15197">https://www.yanxishe.com/columnDetail/15197</a> </li>
</ol>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>papers</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA搭建MyBatis项目使用jndi异常org.apache.ibatis.builder.BuilderException:Error parsing SQL Mapper Configuration. Cause:java.io.IOException:Could not find resource com/hongliang/dao/UserDao.xml</title>
    <url>/2020/03/31/idea%E4%B8%ADMyBatis%E7%9A%84JNDI%E5%B7%A5%E7%A8%8B%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在idea中创建的Maven的webapp工程，使用jndi连接数据库发生了如下错误：</p>
<img src="/2020/03/31/idea%E4%B8%ADMyBatis%E7%9A%84JNDI%E5%B7%A5%E7%A8%8B%E9%94%99%E8%AF%AF/1585645523704.png" class width="1585645523704">

<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>网上有人说： IDEA的锅：<strong>IDEA的Maven是不会编译src的java目录的xml文件，所以在Mybatis的配置文件中找不到xml文件！</strong> </p>
<ol>
<li>把pom文件拿出来；</li>
<li>把下面这段代码复制到前面去 <build>
    <resources>
        <resource>
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.xml</include>
            </includes>
        </resource>
    </resources>
</build></li>
</ol>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p> <strong>mapper resource</strong> 这种方式加载不到资源，其他的url class和package都可以，如果想解决问题的话，可以不使用resource这种方式！ </p>
<p>我使用的package方式可以。</p>
<img src="/2020/03/31/idea%E4%B8%ADMyBatis%E7%9A%84JNDI%E5%B7%A5%E7%A8%8B%E9%94%99%E8%AF%AF/1585645763050.png" class width="1585645763050">

<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><img src="/2020/03/31/idea%E4%B8%ADMyBatis%E7%9A%84JNDI%E5%B7%A5%E7%A8%8B%E9%94%99%E8%AF%AF/1585645838825.png" class width="1585645838825">





<p><em>推荐方法二</em>！！！！！！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p> <a href="https://blog.csdn.net/u010648555/article/details/70880425?depth_1-utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/u010648555/article/details/70880425?depth_1-utm_source=distribute.pc_relevant.none-task</a> </p>
</li>
<li><p><a href="https://blog.csdn.net/qq_23184291/article/details/78089115">https://blog.csdn.net/qq_23184291/article/details/78089115</a> </p>
</li>
</ol>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>errors</tag>
        <tag>mybatis</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>idea插件开发首次体验</title>
    <url>/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h1><p><img src="/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%5C1595382541790.png" alt="1595382541790"></p>
<p>创建的是一个插件工程，使用idea的SDK。</p>
<p>创建之后在目录下有一个文件</p>
<p><img src="/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%5C1595382858947.png" alt="1595382858947"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">idea-plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  插件的id--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>com.hongliang.first.id<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  插件名称--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>first Plugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  版本号--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  作者和提供方的信息--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vendor</span> <span class="attr">email</span>=<span class="string">&quot;zhl396740445@163.com&quot;</span> <span class="attr">url</span>=<span class="string">&quot;http://hongliangzhu.cn&quot;</span>&gt;</span>Castile<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  插件的描述--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">      Enter short description for your ss plugin here.&lt;br&gt;</span><br><span class="line">      &lt;em&gt;most HTML tags  may be used&lt;/em&gt;</span><br><span class="line">    ]]&gt;<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 变更日志  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">change-notes</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">      Add change notes  here.&lt;br&gt;</span><br><span class="line">      &lt;em&gt;most HTML tags  may be used&lt;/em&gt;</span><br><span class="line">    ]]&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">change-notes</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  插件支持的版本号--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- please see http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/build_number_ranges.html for description --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">idea-version</span> <span class="attr">since-build</span>=<span class="string">&quot;173.0&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- please see http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/plugin_compatibility.html</span></span><br><span class="line"><span class="comment">       on how to target different products --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- uncomment to enable plugin in all products</span></span><br><span class="line"><span class="comment">  &lt;depends&gt;com.intellij.modules.lang&lt;/depends&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  相关的其他依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depends</span>&gt;</span>com.intellij.modules.lang<span class="tag">&lt;/<span class="name">depends</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  扩展内容--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">&quot;com.intellij&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  菜单动作 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">id</span>=<span class="string">&quot;firstPluginActionID&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hongliang.first.firstPluginAction&quot;</span> <span class="attr">text</span>=<span class="string">&quot;测试&quot;</span> <span class="attr">description</span>=<span class="string">&quot;测试描述&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">add-to-group</span> <span class="attr">group-id</span>=<span class="string">&quot;ToolsMenu&quot;</span> <span class="attr">anchor</span>=<span class="string">&quot;first&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">keyboard-shortcut</span> <span class="attr">keymap</span>=<span class="string">&quot;$default&quot;</span> <span class="attr">first-keystroke</span>=<span class="string">&quot;ctrl I&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">idea-plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="创建一个Action"><a href="#创建一个Action" class="headerlink" title="创建一个Action"></a>创建一个Action</h1><p><img src="/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%5C1595382945490.png" alt="1595382945490"></p>
<p>我们创建一个在ToolsMenu的插件，在tools工具栏里面有一个“测试”的插件，点击之后在idea的右下角显示一个通知。</p>
<p><img src="/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%5C1595383085436.png" alt="1595383085436"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang.first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intellij.notification.Notification;</span><br><span class="line"><span class="keyword">import</span> com.intellij.notification.NotificationDisplayType;</span><br><span class="line"><span class="keyword">import</span> com.intellij.notification.NotificationGroup;</span><br><span class="line"><span class="keyword">import</span> com.intellij.notification.Notifications;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.actionSystem.AnAction;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.actionSystem.AnActionEvent;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.ui.MessageType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-22 8:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">firstPluginAction</span> <span class="keyword">extends</span> <span class="title">AnAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(AnActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> insert action logic here</span></span><br><span class="line">        NotificationGroup notificationGroup = <span class="keyword">new</span> NotificationGroup(<span class="string">&quot;我的第一个插件&quot;</span>, NotificationDisplayType.BALLOON, <span class="keyword">true</span>);</span><br><span class="line">        Notification notification = notificationGroup.createNotification(<span class="string">&quot;点击测试&quot;</span>, MessageType.INFO);</span><br><span class="line">        Notifications.Bus.notify(notification);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>点击运行，与普通的java类运行一样，但是插件运行的话会打开一个新的idea</p>
<p><img src="/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%5C1595383208023.png" alt="1595383208023"></p>
<p>可以看见在Tools工具栏里面有一个“测试”的插件，点击之后可以看到在右下角出现了一个通知</p>
<p><img src="/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%5C1595383328138.png" alt="1595383328138"></p>
<p>到此，一个简单的插件入门程序就完成了，接下来我们对插件进行打包。</p>
<h1 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h1><p><img src="/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%5C1595383719746.png" alt="1595383719746"></p>
<p>可以发现在项目目录下生成了一个jar包。</p>
<p><img src="/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%5C1595383773902.png" alt="1595383773902"></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Files-&gt;plugin</p>
<p><img src="/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%5C1595383905095.png" alt="1595383905095"></p>
<p><img src="/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%5C1595384007268.png" alt="1595384007268"></p>
<p>然后重启idea</p>
<p><img src="/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%5C1595384082604.png" alt="1595384082604"></p>
<p>大功告成。但是，这只是初步涉猎，任重而道远。</p>
]]></content>
      <tags>
        <tag>plugin</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>idea插件开发之鸡血大师</title>
    <url>/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B9%8B%E9%B8%A1%E8%A1%80%E5%A4%A7%E5%B8%88/</url>
    <content><![CDATA[<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>在idea启动，也就是要开启我们这一天<del>苦逼</del>充满激情的编码工作时候，展示一碗鸡汤，给你打鸡血，当点击再干一碗的时候可以切换下一条内容。</p>
<p>问题：</p>
<ol>
<li><p>怎么抓住idea启动这个时间点</p>
</li>
<li><p>如何显示一个对话框</p>
</li>
<li><p>怎么添加按钮的点击事件</p>
</li>
<li><p>鸡血从何处来？？</p>
</li>
</ol>
<h1 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h1><p>Components组件</p>
<table>
<thead>
<tr>
<th>组件类型</th>
<th align="left">描述</th>
<th>接口</th>
<th>plugin.xml加载配置元素</th>
</tr>
</thead>
<tbody><tr>
<td>ApplicationComponent</td>
<td align="left">在IDEA启动的时候初始化。整个idea只有一个实例。</td>
<td>ApplicationComponent</td>
<td><application-component></application-component></td>
</tr>
<tr>
<td>ProjectComponent</td>
<td align="left">Idea会为每个project实例创建对应级别的component。</td>
<td>ProjectComponent</td>
<td><project-component></project-component></td>
</tr>
<tr>
<td>ModuleComponent</td>
<td align="left">Idea会为每一个已经加载的project中的每一个模块创建module级别的component。</td>
<td>ModuleComponent</td>
<td><module-component></module-component></td>
</tr>
</tbody></table>
<p>先写一个类实现ApplicationComponent接口，整个idea只有一个实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang.cheer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.components.ApplicationComponent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-22 11:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicatioComponent</span> <span class="keyword">implements</span> <span class="title">ApplicationComponent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InitComponnet&quot;</span>);</span><br><span class="line">        CheerUpDialog cheerUpDialog = <span class="keyword">new</span> CheerUpDialog();</span><br><span class="line">        cheerUpDialog.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disposeComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后写一个对话框出来，和JavaSwing编写的差不多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang.cheer;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.ui.DialogWrapper;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.Nullable;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-22 11:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheerUpDialog</span> <span class="keyword">extends</span> <span class="title">DialogWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JLabel label;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CheerUpDialog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">true</span>);</span><br><span class="line">        setTitle(<span class="string">&quot;每天一碗毒鸡汤&quot;</span>);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JComponent <span class="title">createCenterPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line">        String contentAsString = ContentUtils.getContentAsString();</span><br><span class="line">        label = <span class="keyword">new</span> JLabel(contentAsString);</span><br><span class="line">        panel.add(label);</span><br><span class="line">        <span class="keyword">return</span> panel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JComponent <span class="title">createSouthPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line">        JButton btn = <span class="keyword">new</span> JButton();</span><br><span class="line">        btn.setText(<span class="string">&quot;再干一碗&quot;</span>);</span><br><span class="line">        btn.addActionListener(e -&gt; &#123;</span><br><span class="line">            String contentAsString = ContentUtils.getContentAsString();</span><br><span class="line">            label.setText(contentAsString);</span><br><span class="line">        &#125;);</span><br><span class="line">        panel.add(btn);</span><br><span class="line">        <span class="keyword">return</span> panel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中用到了一个ContentUtils工具类，用来获取得到的鸡汤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang.cheer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestClientException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-22 13:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getContentAsString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String content = <span class="keyword">null</span>;</span><br><span class="line">            RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">            ResponseEntity&lt;Map&gt; entity = restTemplate.getForEntity(<span class="string">&quot;https://api.nextrt.com/V1/Dutang&quot;</span>, Map.class);</span><br><span class="line">            HttpStatus statusCode = entity.getStatusCode();</span><br><span class="line">            <span class="keyword">if</span>(statusCode.is2xxSuccessful())&#123;</span><br><span class="line">                Map body = entity.getBody();</span><br><span class="line">                List data = (List) body.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">                Map map = (Map) data.get(<span class="number">0</span>);</span><br><span class="line">                content = (String) map.get(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> content;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RestClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然还需要去xml中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application-components</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">implementation-class</span>&gt;</span>com.hongliang.cheer.MyApplicatioComponent<span class="tag">&lt;/<span class="name">implementation-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">application-components</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h1><img src="/2020/07/22/idea%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B9%8B%E9%B8%A1%E8%A1%80%E5%A4%A7%E5%B8%88/1595407337144.png" class width="1595407337144">

]]></content>
      <tags>
        <tag>plugin</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm01-类加载机制</title>
    <url>/2020/06/13/jvm01/</url>
    <content><![CDATA[<h1 id="JVM-学习"><a href="#JVM-学习" class="headerlink" title="JVM 学习"></a>JVM 学习</h1><p>今天终于决定要学学JVM了，一方面对于面试来说，这个是必考的，另一方面，深入了解jvm对于一个标准的java程序员来说，是很有必要的，知其然还要知其所以然。</p>
<h1 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h1><img src="/2020/06/13/jvm01/1592032035841.png" class width="1592032035841">

<p>可以看到JVM是在操作系统之上的， 它与硬件没有直接的交互。</p>
<h1 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h1><img src="/2020/06/13/jvm01/1592032108017.png" class width="1592032108017">

<p>它分为上、中、下三层，类加载系统、运行时数据区，执行引擎。</p>
<h1 id="类装载器ClassLoader"><a href="#类装载器ClassLoader" class="headerlink" title="类装载器ClassLoader"></a>类装载器ClassLoader</h1><img src="/2020/06/13/jvm01/1592032179887.png" class width="1592032179887">

<p>负责加载<code>class</code>文件，<code>class</code>文件在文件开头有<strong>特定的文件标示</strong>，将class文件字节码内容加载到内存中，并将这些内容转换<strong>成方法区中的运行时数据结构</strong>。并且<code>ClassLoader</code>只负责class文件的加载，至于它是否可以运行，则由<code>Execution Engine</code>决定 。</p>
<p>对于上面这段话，我们详细来理解一下。首先明确以下，类加载器只负责加载class文件，也就是java程序编译之后的字节码文件。这个字节码文件在文件开头有特定的文件标识，看下图：（cafe babe）。</p>
<img src="/2020/06/13/jvm01/1592032349564.png" class width="1592032349564">

<p>java的图标不就是一杯咖啡吗哈哈哈哈、、、</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>当<code>java</code>源代码文件被<code>javac</code>编译成<code>class</code>文件后，并不能直接运行， 而是需要经过加载，连接和初始化这几个阶段后才能使用。 在使用完类或JVM被销毁后，JVM会将类卸载掉。 </p>
<img src="/2020/06/13/jvm01/1592121218744.png" class width="1592121218744">

<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>类加载过程需要经过3个阶段:</p>
<ol>
<li>加载</li>
<li>连接</li>
<li>初始化</li>
</ol>
<p>其中连接又可分为3个阶段: 验证 ， 准备 ， 解析。</p>
<h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p><strong>在加载阶段，类加载器将类的class文件的二进制数据读取到内存， 并保存到方法区，并在堆区生成该类的Class对象。</strong></p>
<p>通常有多种方式可以获取类的二进制数据:</p>
<ul>
<li>通过javac编译器编译java源文件，读取在本地磁盘上生成的class文件。</li>
<li>从Jar，ZIP等归档文件中读取class文件。</li>
<li>通过网络读取类的字节流。</li>
<li>通过动态生成字节码的技术(如使用动态代理，cglib)来生成class。</li>
</ul>
<h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><p>1.验证 <strong>验证阶段是为了确保类的字节流符合虚拟机规范，并且不会对虚拟机造成恶意损害。</strong> JVM会对字节流进行如下验证:</p>
<ul>
<li>文件格式验证:会验证class文件是否符合虚拟机规范，如是否以<code>0×CAFEBABE</code>开头， 主次版本号是否在虚拟机规定范围类，常量池中的类型是否有JVM不支持的类型。</li>
<li>元数据验证: 会对类的元信息进行语义分析，确保符合Java语法规范。</li>
<li>字节码验证: 通过分析数据流和控制流，确保类的方法体的程序语义是合法的， 符合逻辑的。</li>
<li>符号引用验证: 确保常量池中的符号引用能在解析阶段正常解析。</li>
</ul>
<p>2.准备: 准备阶段会为类的静态变量初始化零值，如(0,0L,null,false).</p>
<p>3.解析: 解析阶段会将常量池中的符号引用转为直接引用。 符号引用包括类的全限定名，方法名和描述符，字段名和描述符。<br>直接引用是指向目标的指针，可以简单理解为目标的内存地址。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><blockquote>
<p>初始化阶段是类加载过程的最后一个阶段。</p>
</blockquote>
<p>在这个阶段,<strong>只有主动使用类才会初始化类，总共有8种情况会涉及到主动使用类。</strong></p>
<ol>
<li>当jvm执行<code>new</code>指令时会初始化类，即当程序创建一个类的实例对象。</li>
<li>当jvm执行<code>getstatic</code>指令时会初始化类，即程序访问类的静态变量(不是静态常量，常量归属于运行时常量池)。</li>
<li>当jvm执行<code>putstatic</code>指令时会初始化类，即程序给类的静态变量赋值。</li>
<li>当jvm执行<code>invokestatic</code>指令时会初始化类，即程序调用类的静态方法。</li>
<li>当使用<strong>反射</strong>主动访问这个类时,也会初始化类,如Class.forname(“…”),newInstance()等等。</li>
<li>当初始化一个子类的时候，会先初始化这个子类的所有父类，然后才会初始化这个子类。</li>
<li>当一个类是启动类时，即这个类拥有<code>main</code>方法，那么<code>jvm</code>会首先初始化这个类。</li>
<li><code>MethodHandle</code>和<code>VarHandle</code>可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用<code>findStatic</code>/<code>findStaticVarHandle</code>来初始化要调用的类。</li>
</ol>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>在类被初始化完成后，就可以使用类了。</p>
<h5 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h5><p>类被卸载(<code>Class</code>对象被<code>GC</code>掉)需要满足3个条件:</p>
<ol>
<li>该类的实例对象都已被<code>GC</code>，也就是说堆中不存在该类的实例对象。</li>
<li>该类没有在其它任何地方被使用。</li>
<li>加载该类的类加载器实例已被<code>GC</code>。</li>
</ol>
<p><strong>在JVM的生命周期中，被JVM自带的类加载器所加载的类是不会被卸载的。 而被我们自定义的类加载器所加载的类是可能会被卸载的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        Main m = <span class="keyword">new</span> Main();</span><br><span class="line">        System.out.println(m.getClass().getClassLoader());</span><br><span class="line">        System.out.println(m.getClass().getClassLoader().getParent());</span><br><span class="line">        System.out.println(m.getClass().getClassLoader().getParent().getParent());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2020/06/13/jvm01/1592122335436.png" class width="1592122335436">

<p>通过参数-XX:+TraceClassLoading 来打印类加载的信息。</p>
<img src="/2020/06/13/jvm01/1592032431105.png" class width="1592032431105">

<p>类加载有如下几类：</p>
<h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><ol>
<li>启动类加载器（Bootstrap）C++， 用来加载jdk自带的类。</li>
</ol>
<p>打开jdk， 里面有一个<code>jre</code>（<code>java runtime environment</code>）中 <code>rt.jar</code>文件，来看看里面是啥玩意：</p>
<img src="/2020/06/13/jvm01/1592032746124.png" class width="1592032746124">

<img src="/2020/06/13/jvm01/1592032789199.png" class width="1592032789199">

<p>这里面其实就是我们平时使用的JDK自带的类库，包括<code>Object</code>类等。所以<code>Bootstrap</code>类加载器就是加载这些的，正是因为jvm已经帮我们加载好了这些类，我们才可以直接使用。</p>
<ol start="2">
<li>扩展类加载器（Extension）Java： 首先要知道为啥有这个扩展类加载器，顾名思义就是加载扩展类的加载器，由于java是一门不断发展的语言，jdk也在快速的迭代，由java1.5， 1.6 然后1.8， 现在好像出了jdk14.。。。，还有就是java jdk中有很多以<code>javax</code>开头的包，在jre/lib/ext/*下的包就时使用扩展类加载器加载的。</li>
</ol>
<img src="/2020/06/13/jvm01/1592033161507.png" class width="1592033161507">



<ol start="3">
<li>应用程序类加载器（<code>AppClassLoader</code>）Java也叫系统类加载器，加载当前应用的classpath的所有类。也就是自己写的类。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        Main m = <span class="keyword">new</span> Main();</span><br><span class="line">        System.out.println(m.getClass().getClassLoader());</span><br><span class="line">        System.out.println(m.getClass().getClassLoader().getParent());</span><br><span class="line">        System.out.println(m.getClass().getClassLoader().getParent().getParent());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@4554617c</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>上面输出表示，<code>Object</code>的加载器是<code>null</code>表示是启动类加载器（<code>BootStrap</code>）。<code>sun.misc.Launcher</code>是<code>java</code>虚拟机的一个入口应用。</p>
<h3 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h3><p><code>Java.lang.ClassLoader</code>的子类，用户可以定制类的加载方式。</p>
<img src="/2020/06/13/jvm01/1592033659463.png" class width="1592033659463">



<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。 </p>
<p> 双亲委派机制是指在加载一个类的时候，JVM会判断这个类是否已经被其类加载器加载过了。 如果已经加载过了，那么直接返回这个类。 <strong>如果没有加载，就使用这个类对应的加载器的父类加载器判断， 一层一层的往上判断，最终会由BootstrapClassLoader判断。</strong> 如果BootstrapClassLoader判断都没有加载这个类, <strong>那么就由BootstrapClassLoader尝试加载。 如果BootstrapClassLoader加载失败了， 就由BootstrapClassLoader的子类加载器们加载。</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-06-13 15:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/13/jvm01/1592034074114.png" class width="1592034074114">

<p>上面的自己写的<code>String</code>类，会一层一层向上去找父类加载器去加载，而<code>jdk</code>自带的就有<code>java.lang.String</code> 类，所以<code>jvm</code>会调用启动类加载器加载<code>java.lang.String</code>类，而这个类中没有main函数，随意会报错。所以双亲委派机制的作用是保证安全性，保证沙箱安全。防止原生类被覆盖。</p>
<p>总结： 采用双亲委派的一个好处是比如加载位于 <code>rt.jar</code> 包中的类 <code>java.lang.Object</code>，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 <code>Object</code>对象。 </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li> <a href="https://guang19.github.io/framework-learning/gitbook_doc/jdk-jvm-juc">https://guang19.github.io/framework-learning/gitbook_doc/jdk-jvm-juc</a> </li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm03-方法区和栈</title>
    <url>/2020/06/13/jvm03/</url>
    <content><![CDATA[<h1 id="Method-Area-方法区"><a href="#Method-Area-方法区" class="headerlink" title="Method Area 方法区"></a><strong>Method Area</strong> <strong>方法区</strong></h1><p>在<code>jvm01</code>中，谈到了类加载， 类加载器 负责加载<code>class</code>文件，<code>class</code>文件在文件开头有特定的文件标示，将<code>class</code>文件字节码内容加载到内存中，并将这些内容<strong>转换成方法区中</strong>的运行时<strong>数据结构</strong>  。</p>
<p>注意上面说的方法区和数据结构。所谓方法区，里面供各线程共享的运行时内存区域。它存储了每一个类的<strong>结构信息</strong>，这个结构信息也就是class模板。例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的<strong>字节码内容</strong>。上面讲的是<strong>规范</strong>，在不同虚拟机里头实现是不一样的，最典型的就是永久代(<code>PermGen space</code>)和元空间(<code>Metaspace</code>)。</p>
<p>这里理解一下，啥是永久代，啥又是元空间，懵逼。。。这个考科一这样理解，上面说到这个方法区是个规范，在不同虚拟机里头实现是不一样的，相当于多态的思想。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法区 f = <span class="keyword">new</span> 永久代() <span class="comment">// java7</span></span><br><span class="line">方法区 f = <span class="keyword">new</span> 元空间() <span class="comment">// java8</span></span><br></pre></td></tr></table></figure>

<img src="/2020/06/13/jvm03/1592049671251.png" class width="1592049671251">

<p>上图中，运行时数据区中亮色的是有GC的，灰色的不存在GC且线程私有。<strong>实例变量存在堆内存中,和方法区无关</strong>。</p>
<p><strong>总结： 方法区：1. 存储了每一个类的结构信息。 2. 方法区是规范，不同的虚拟机有不同的实现。</strong></p>
<hr>
<h1 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h1><blockquote>
<p>记住一句话： 栈管运行，堆管存储。</p>
</blockquote>
<p>栈也叫栈内存，主管<code>Java</code>程序的<strong>运行</strong>，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，<strong>对于栈来说不存在垃圾回收问题</strong>，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。<strong>8种基本类型的变量+对象的引用变量+实例方法</strong>都是在函数的栈内存中分配。  </p>
<h2 id="栈存储什么"><a href="#栈存储什么" class="headerlink" title="栈存储什么"></a>栈存储什么</h2><p>栈帧中主要保存3 类数据：</p>
<ol>
<li><p>本地变量（<code>Local Variables</code>）:输入参数和输出参数以及方法内的变量；</p>
</li>
<li><p>栈操作（<code>Operand Stack</code>）:记录出栈、入栈的操作；</p>
</li>
<li><p>栈帧数据（<code>Frame Data</code>）:包括类文件、方法等等。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getsss</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> result = x+y;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>x, y ,result 就是输入参数， 方法内的变量。</p>
<h2 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h2><p>栈中的数据都是以栈帧（<code>Stack Frame</code>）的格式存在，栈帧是一个<strong>内存区块</strong>，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧 F1，并被压入到栈中，</p>
<p>A方法又调用了 B方法，于是产生栈帧 F2 也被压入栈，</p>
<p>B方法又调用了 C方法，于是产生栈帧 F3 也被压入栈，</p>
<p>……</p>
<p>执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧……</p>
<p>遵循“先进后出”/“后进先出”原则。</p>
<p>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体<code>JVM</code>的实现有关，通常在256K~756K之间,与等于1Mb左右。</p>
<img src="/2020/06/13/jvm03/1592055682557.png" class width="1592055682557">

<p>图示在一个栈中有两个栈帧：栈帧 2是最先被调用的方法，先入栈，然后方法 2 又调用了方法1，栈帧 1处于栈顶的位置，栈帧 2 处于栈底，执行完毕后，依次弹出栈帧 1和栈帧 2，线程结束，栈释放。 </p>
<p>每执行一个方法都会产生一个栈帧，保存到栈(后进先出)的<strong>顶部，顶部栈就是当前的方法，该方法执行完毕 后会自动将此栈帧出栈。</strong></p>
<h2 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TT &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        m();</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    public static void m()&#123;</span><br><span class="line">        m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/13/jvm03/1592057418637.png" class width="1592057418637">

<img src="/2020/06/13/jvm03/1592057444022.png" class width="1592057444022">

<img src="/2020/06/13/jvm03/1592057522756.png" class width="1592057522756">

<img src="/2020/06/13/jvm03/1592057561547.png" class width="1592057561547">

<p>所以，StackOverflowerror是一个Error。</p>
<h2 id="堆、栈、方法区的关系"><a href="#堆、栈、方法区的关系" class="headerlink" title="堆、栈、方法区的关系"></a>堆、栈、方法区的关系</h2><img src="/2020/06/13/jvm03/1592057680004.png" class width="1592057680004">

<p>引用在栈中，<code>new</code>出来的实例对象在堆中。模板在方法区。</p>
<p><code>HotSpot</code>是使用指针的方式来访问对象：</p>
<p><code>Java</code>堆中会存放访问<strong>类元数据</strong>的地址，（元数据： 描述数据的数据，也就是类的模板，模板在方法区中，堆中会访问方法区模板的地址，根据模板来生成不同的实例对象）</p>
<p><code>reference</code>存储的就直接是对象的地址。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm02-Native Interface本地接口</title>
    <url>/2020/06/13/jvm02/</url>
    <content><![CDATA[<h1 id="本地接口"><a href="#本地接口" class="headerlink" title="本地接口"></a>本地接口</h1><img src="/2020/06/13/jvm02/1592034663649.png" class width="1592034663649">

<p>我们所说的栈，指的是上面的java栈，而不是本地方法栈。。。</p>
<p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序，Java 诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies。</p>
<p> 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<p>来看个例子。Thread类中的start()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)  <span class="comment">// 这个表示线程的状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;  <span class="comment">// 本地方法</span></span><br></pre></td></tr></table></figure>

<p>在一个Thread中，不能调用两次start方法，否则会报错：<code>Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException</code>。 在调用start方法，实际上调用的是start0() 方法，看上面的源代码，<code>start0（）</code>是一个native方法，native方法表示这哥不归java语言本身管了，需要调用外部的方法，比如是C语言写的方法，native方法存放在本地方法栈里面，普通方法的调用存放在java栈里面。</p>
<p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p>
<p><code>native</code>是一个关键字，有声明，无实现。一个方法标记成native表示这个函数是去调用C语言的函数库，第三方的函数库。native方法的运行和装载是在本地方法栈中装载和运行的。</p>
<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>每个线程都有一个程序计数器，是线程私有的, 就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。</p>
<p>这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>如果执行的是一个<code>Native</code>方法<strong>，那这个计数器是空的</strong>。</p>
<p>用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出(OutOfMemory=OOM)错误。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm04-Heap堆结构和JVM常量池</title>
    <url>/2020/06/14/jvm04/</url>
    <content><![CDATA[<h1 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap 堆"></a>Heap 堆</h1><p> <strong>堆是JVM中内存占用最大的一块区域，它是所有线程共享的一块区域。 堆的作用是为对象分配内存并存储和回收它们。 堆是垃圾回收的主要区域，所以堆区也被成为GC堆。</strong> </p>
<p>一个<code>JVM</code>实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分 ：</p>
<img src="/2020/06/14/jvm04/1592098366192.png" class width="1592098366192">

<p>堆区可以划分为新生代、老年代、永久代(java7)/元空间(java8)。元空间保存的是类的元数据信息，所谓元数据口哈斯描述数据的数据，这里指的是类元数据，而就是说保存的是类的描述信息，即类的结构信息。</p>
<p>新生代可以继续划分为伊甸园区(Eden区)，幸存者0区（Survivor 0【from】），幸存者1区(survivor 1 【to】)。</p>
<p>在默认情况下，新生代栈堆区的1/3, 老年代占堆区的2/3。 Eden区栈新生代的80%，Survivor区占20%， 其中<code>from</code>和to<code>比例</code>为1:1</p>
<blockquote>
<p>(通过<code>-XX:NewRatio</code>参数可以调整新生代和老年代的空间占比) </p>
<p>(通过<code>-XX:SurvivorRatio</code>参数可以调整<code>eden</code>和<code>survivor</code>的空间占比) </p>
</blockquote>
<h1 id="Java7之前"><a href="#Java7之前" class="headerlink" title="Java7之前"></a>Java7之前</h1><p>堆内存<strong>逻辑</strong>上分为三部分：新生+养老+永久，物理上由新生+养老区</p>
<img src="/2020/06/14/jvm04/1592098468261.png" class width="1592098468261">

<p>新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分： 伊甸区（<code>Eden space</code>）和幸存者区（<code>Survivor pace</code>） ，所有的类都是在伊甸区被<code>new</code>出来的。幸存区有两个： 0区（<code>Survivor 0 space</code>）和1区（<code>Survivor 1 space</code>）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(<code>Minor GC</code>)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。若幸存 0区也满了，再对该区进行垃圾回收，然后移动到 1 区。那如果1 区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生<code>MajorGC</code>（<code>FullGC</code>），进行养老区的内存清理。若养老区执行了<code>Full GC</code>之后发现依然无法进行对象的保存，就会产生<code>OOM</code>异常“<code>OutOfMemoryError</code>”。</p>
<blockquote>
<p>如果出现<code>java.lang.OutOfMemoryError: Java heap space</code>异常，说明<code>Java</code>虚拟机的堆内存不够。原因有二：</p>
<p>（1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。</p>
<p>（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。</p>
</blockquote>
<p> <strong>发生在新生代的GC叫做Young GC或Minor GC, 发生在老年代的GC叫做Old GC或Major GC</strong> </p>
<p>在java8之后，<strong>永久区换成了元空间</strong>。其他不变、</p>
<p>永久区(<code>java7</code>之前有)</p>
<p> 永久存储区是一个常驻内存区域，用于存放<code>JDK</code>自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。</p>
<p>实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，<strong>虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。</strong></p>
<p> 对于<code>HotSpot</code>虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)” ，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区(相当于是一个接口interface)的一个实现，jdk1.7的版本中，已经将原本放在永久代的字符串常量池移走。</p>
<img src="/2020/06/14/jvm04/1592125653449.png" class width="1592125653449">

<hr>
<h1 id="JVM常量池"><a href="#JVM常量池" class="headerlink" title="JVM常量池"></a>JVM常量池</h1><p>Jvm常量池分为:</p>
<ol>
<li>Class常量池(静态常量池)</li>
<li>运行时常量池</li>
<li>字符串常量池(全局常量池)</li>
<li>包装类型缓存池</li>
</ol>
<h2 id="Class常量池-静态常量池"><a href="#Class常量池-静态常量池" class="headerlink" title="Class常量池(静态常量池)"></a>Class常量池(静态常量池)</h2><p>当Java源文件被编译后，就会生成Class字节码文件。</p>
<p><strong>Class常量池就存在于Class文件中(Class文件的Constant Pool中)。</strong></p>
<p><strong>Class文件常量池主要存放两大常量:字面量和符号引用。</strong></p>
<ol>
<li>字面量: 字面量分为文本字符串(如: “abc”,1等)和用final修饰的成员变量(实例变量和静态变量)</li>
<li>符号引用: 符号引用包括三种：类的全限定名，方法名和描述符，字段名和描述符。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-06-14 16:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String sss = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = add(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(sss);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = x + y;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用命令：javap  -v ClassTest.class 反编译</p>
<img src="/2020/06/14/jvm04/1592124483817.png" class width="1592124483817">

<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行是常量池是在<strong>类加载阶段</strong>，将<code>class</code>二进制数据加载到内存， 并将数据保存到方法区,其中<code>class</code>文件中的常量池将保存到 运行时常量池(<strong>数据都在方法区，常量池肯定也在方法区</strong>)。 也就是说一个Class文件常量池对应一个运行时常量池。</p>
<h2 id="字符串常量池-全局常量池"><a href="#字符串常量池-全局常量池" class="headerlink" title="字符串常量池(全局常量池)"></a>字符串常量池(全局常量池)</h2><p>字符串常量池在<code>jdk7</code>之前都是存于永久代(永久代)之中, jdk7以后存于 <strong>堆区</strong>之中。</p>
<h2 id="包装类型缓存池"><a href="#包装类型缓存池" class="headerlink" title="包装类型缓存池"></a>包装类型缓存池</h2><p>包装类缓存池并不是所有的包装类都有，并且缓存池缓存的是一定范围内的数据。 拥有包装类型缓存池的类有:<code>Integer</code>,<code>Byte</code>,<code>Character</code>,<code>Long</code>,<code>Short</code>， 而<code>Float</code>，<code>Double</code>，<code>Boolean</code>都不具有缓存池。</p>
<p><strong>包装类的缓存池缓存的范围基本都为: -128 - 127之间， Character的缓存范围为 0 - 127(也就是全部字符都缓存了-对应的ASCII码表）。</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">boolean</span> <span class="string">values true and false        //布尔类型中的两个取值  true和false</span></span><br><span class="line"><span class="attr">all</span> <span class="string">byte values                    //byte类型所有数据，即-128～127</span></span><br><span class="line"><span class="attr">short</span> <span class="string">values between -128 and 127    //short类型大小范围-128~127</span></span><br><span class="line"><span class="attr">char</span> <span class="string">in the range \u0000 to \u007F   //char类型所有数据，即所有字符</span></span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li> <a href="https://guang19.github.io/framework-learning/gitbook_doc/jdk-jvm-juc">https://guang19.github.io/framework-learning/gitbook_doc/jdk-jvm-juc</a> </li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1-两数之和</title>
    <url>/2020/01/23/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<ul>
<li><input checked disabled type="checkbox"> 你可以假设每种输入只会对应一个答案。但是，<strong>你不能重复利用这个数组中同样的元素</strong>。</li>
</ul>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]<br>链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a></p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>暴力方法： 直接两层循环，时间复杂度较高：O(n^2^)</p>
</li>
<li><p>哈希方法：使用哈希表可以实现O(1)级别的存取。存储每个数对应的下标，复杂度    O(n)    </p>
<p>参考：</p>
<p>HashMap的时间复杂度O(1)的思考：</p>
<p>​    原文链接：<a href="https://blog.csdn.net/donggua3694857/article/details/64127131">https://blog.csdn.net/donggua3694857/article/details/64127131</a></p>
</li>
</ol>
<h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-23 21:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode_1_twoSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    a[<span class="number">0</span>] = i;</span><br><span class="line">                    a[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; mymap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;  i++)&#123;</span><br><span class="line">            mymap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(mymap.containsKey(t) &amp;&amp; mymap.get(t) != i )&#123;<span class="comment">// 注意后面这个条件，题目要求</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,mymap.get(t)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] nums = &#123; <span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line">       <span class="keyword">int</span> target = <span class="number">9</span>;</span><br><span class="line">       <span class="keyword">int</span> []result = twoSum1(nums, target);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; result.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           System.out.println(result[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考HashMap：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247486169&amp;idx=2&amp;sn=9818c995d51a19cd4a40c2605bdcfa5d&amp;chksm=ebd74bd8dca0c2cefe86f54bcdd7f799ceda0a14deb72a4fcec7efa29fc3deffbc6e80d8a90f&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1575479594341&amp;sharer_shareid=2d7d0e474d11d42bad66b1f70e2c85ff&amp;key=688085f24308deb8e963b43a687ea8ed3be23533e2ae4e751f02a336bb46979d39e6c74e731daa5fc22d9e719338c7f0f98152a12a38beef1d0023e2939dd0eda93264a9d032b8cc555448c332453c25&amp;ascene=1&amp;uin=MjA3NDA5MzU4MQ==&amp;devicetype=Windows%2010&amp;version=62070158&amp;lang=zh_CN&amp;exportkey=A5ZIZKTn0EuksyOXwEiV+Ek=&amp;pass_ticket=Nb/JBXAYTcQup5FBKcfsQy6kFv5X2eJwQ333U4h1UYJmrnawwezuSj8nX18XzQ8s">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247486169&amp;idx=2&amp;sn=9818c995d51a19cd4a40c2605bdcfa5d&amp;chksm=ebd74bd8dca0c2cefe86f54bcdd7f799ceda0a14deb72a4fcec7efa29fc3deffbc6e80d8a90f&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1575479594341&amp;sharer_shareid=2d7d0e474d11d42bad66b1f70e2c85ff&amp;key=688085f24308deb8e963b43a687ea8ed3be23533e2ae4e751f02a336bb46979d39e6c74e731daa5fc22d9e719338c7f0f98152a12a38beef1d0023e2939dd0eda93264a9d032b8cc555448c332453c25&amp;ascene=1&amp;uin=MjA3NDA5MzU4MQ==&amp;devicetype=Windows%2010&amp;version=62070158&amp;lang=zh_CN&amp;exportkey=A5ZIZKTn0EuksyOXwEiV%2bEk=&amp;pass_ticket=Nb/JBXAYTcQup5FBKcfsQy6kFv5X2eJwQ333U4h1UYJmrnawwezuSj8nX18XzQ8s</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-104-二叉树的最大深度</title>
    <url>/2020/02/12/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><h2 id="leetcode-104：-二叉树的最大深度【简单】"><a href="#leetcode-104：-二叉树的最大深度【简单】" class="headerlink" title="leetcode-104： 二叉树的最大深度【简单】"></a>leetcode-104： 二叉树的最大深度【简单】</h2><blockquote>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<p>​    3</p>
<p>   / <br>  9  20<br>    /  <br>   15   7<br>返回它的最大深度 3 。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol>
<li>很直观想到递归来解决，根节点的数的高度等于 1 加上 左子树的高度与右子数高度的最大值。</li>
</ol>
<p>$$<br>Root_h = 1 + \max(Sub_L + Sub_R)<br>$$</p>
<ol start="2">
<li>迭代： BFS广度优先遍历，因为BFS是按层次遍历，所以二叉树有多少层，二叉树的高度就等于层数。</li>
<li>dfs： 其实是按照二叉树的前序遍历顺序，将每个节点的当前深度记录下来，这里使用了Pair结构</li>
</ol>
<p>时间复杂度均为O(n)， 空间复杂度均为O(n)，如果是平衡二叉树的话，时间复杂度最好情况为O(logN)。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>github:  <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/Tree/leetcode104_MaximumDepthofBinaryTree.java">https://github.com/Castile/algorithm/blob/master/leetcode/src/Tree/leetcode104_MaximumDepthofBinaryTree.java</a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.util.IntegerArray;</span><br><span class="line"><span class="keyword">import</span> javafx.util.Pair;</span><br><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.commons.InstructionAdapter;</span><br><span class="line"><span class="keyword">import</span> sun.awt.TracedEventQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-06 22:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode104_MaximumDepthofBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    static  int i =0;</span></span><br><span class="line"><span class="comment">//    static  int j = 0;   // 不能在这里定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> j = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(i, j) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * BFS 层次遍历， 记录层数，即为深度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树的深度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDepth_BFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 队列</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            maxDepth++;<span class="comment">// 层数加1</span></span><br><span class="line">            <span class="comment">// 将当前层出队列</span></span><br><span class="line">            <span class="keyword">int</span> currSize = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currSize; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDepth_DFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 栈</span></span><br><span class="line">        stack.push(<span class="keyword">new</span> Pair&lt;&gt;(root, <span class="number">1</span>));  <span class="comment">// 根节点的深度为1</span></span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Pair&lt;TreeNode, Integer&gt; currNode = stack.pop(); <span class="comment">// 当前节点</span></span><br><span class="line">            maxDepth = Math.max(maxDepth, currNode.getValue()); <span class="comment">// 与当前节点的深度比较</span></span><br><span class="line">            <span class="comment">// 左右子树进栈</span></span><br><span class="line">            <span class="keyword">if</span> (currNode.getKey().left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> Pair&lt;&gt;(currNode.getKey().left, currNode.getValue() + <span class="number">1</span>)); <span class="comment">// 深度加1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currNode.getKey().right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(<span class="keyword">new</span> Pair&lt;&gt;(currNode.getKey().right, currNode.getValue() + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        TreeNode t2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        TreeNode t3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        TreeNode t4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        TreeNode t5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root.left = t2;</span><br><span class="line">        root.right = t3;</span><br><span class="line">        t2.left = t4;</span><br><span class="line">        t2.right = t5;</span><br><span class="line"></span><br><span class="line">        System.out.println(maxDepth(root));  <span class="comment">// 3</span></span><br><span class="line">        System.out.println(maxDepth_BFS(root));  <span class="comment">// 3</span></span><br><span class="line">        System.out.println(maxDepth_DFS(root)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-118-杨辉三角1</title>
    <url>/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p>示例:</p>
<p>输入: 5<br>输出:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
<p>链接：<a href="https://leetcode-cn.com/problems/pascals-triangle">https://leetcode-cn.com/problems/pascals-triangle</a></p>
</blockquote>
 <img src="/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/PascalTriangleAnimated2.gif" alt="img" style="zoom:80%;" align="center"> 



<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol>
<li><p>暴力递归：basecase：可以看到，每行的最左边和最右边的数字是1。因此，我们可以将基本情况定义如下:  <code>f(i, j)=1   where  j=1 or j==i</code></p>
<p>递推关系：</p>
<p>​        首先，我们定义一个函数 <code>f(i,j)</code>它将会返回帕斯卡三角形<code>第 i 行</code>、<code>第 j 列</code>的数字。</p>
<p>我们可以用下面的公式来表示这一递推关系：<code>f(i,j)=f(i−1,j−1)+f(i−1,j)</code></p>
</li>
<li><p>动态规划：因为暴力递归还有很多值会重复计算，所以使用一个数组保存已经计算过的值。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>源码：  <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode118_PascalTriangle.java">https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode118_PascalTriangle.java</a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力递归： 但是会超时</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; triangle = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span>(numRows == <span class="number">0</span>) <span class="keyword">return</span> triangle;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= numRows; i++)&#123;</span><br><span class="line">           List&lt;Integer&gt; list =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i ; j++)&#123;</span><br><span class="line">               list.add(calc(i, j));</span><br><span class="line">           &#125;</span><br><span class="line">           triangle.add(list);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> triangle;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>( j == <span class="number">1</span> || i == j)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> calc(i - <span class="number">1</span>, j - <span class="number">1</span>) + calc(i - <span class="number">1</span>, j);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>动态规划：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; triangle = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[numRows+<span class="number">1</span>][numRows+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(numRows == <span class="number">0</span>) <span class="keyword">return</span> triangle;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= numRows; i++)&#123;</span><br><span class="line">                List&lt;Integer&gt; list =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i ; j++)&#123;</span><br><span class="line">                    list.add(calc(dp, i, j));</span><br><span class="line">                &#125;</span><br><span class="line">                triangle.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> triangle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span>[][] dp, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( j == <span class="number">1</span> || i == j)&#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)   <span class="keyword">return</span> dp[i][j];</span><br><span class="line">            dp[i][j] = calc(dp, i - <span class="number">1</span>, j - <span class="number">1</span>) + calc(dp, i - <span class="number">1</span>, j);</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>相似题目：  <a href="https://castile.github.io/Castile.github.io/2020/02/06/leetcode-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922/">leetcode-119-杨辉三角2</a> </p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>递归</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-119-杨辉三角2</title>
    <url>/2020/02/06/leetcode-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>leetcode119： 杨辉三角2 【简单】</p>
<p> 给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。 </p>
<img src="/2020/02/06/leetcode-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922/blog\source\_posts\leetcode-119-杨辉三角2\PascalTriangleAnimated2.gif" alt="img" style="zoom:80%;">

<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol>
<li> 这题和前一题一样，只不过返回特定层，同样的思路</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; triangle = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rowIndex+<span class="number">2</span>][rowIndex+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(rowIndex+<span class="number">1</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= rowIndex+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; list =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i ; j++)&#123;</span><br><span class="line">                list.add(calc(dp, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">            triangle.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle.get(rowIndex);  <span class="comment">// 注意返回的是指定层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span>[][] dp, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( j == <span class="number">1</span> || i == j)&#123;</span><br><span class="line">            dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>)   <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        dp[i][j] = calc(dp, i - <span class="number">1</span>, j - <span class="number">1</span>) + calc(dp, i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>这题和<a href="%5Bhttps:/Castile.github.io/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/%5D(%5Bhttps:/Castile.github.io/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/)">杨辉三角1</a>的题目差不多，118题需要保存所有的，但是这题只需要返回指定层，因为当前层的值只依赖于上一层的值，故使用一个list来保存上一层的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; pre = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; i++)&#123;</span><br><span class="line">            cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span> || i == j)&#123;</span><br><span class="line">                    cur.add(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur.add(pre.get(j - <span class="number">1</span>) + pre.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>基于2可以继续优化：以把 pre 的 List 省去。这样的话，cur每次不去新建 List，而是把cur当作pre。</p>
<p>又因为更新当前 <code>j</code> 的时候，就把之前<code>j</code>的信息覆盖掉了。而更新 <code>j + 1</code> 的时候又需要之前j的信息，所以在更新前，我们需要一个变量把之前<code>j</code>的信息保存起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">       List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       cur.add(<span class="number">1</span>); <span class="comment">// j == 0</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">               <span class="keyword">int</span> tmp = cur.get(j);</span><br><span class="line">               cur.set(j, pre + cur.get(j));</span><br><span class="line">               pre = tmp;</span><br><span class="line">           &#125;</span><br><span class="line">           cur.add(<span class="number">1</span>);  <span class="comment">// j == i</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cur;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>除了上边优化的思路，还有一种想法，那就是倒着进行，这样就不会存在覆盖的情况了。因为更新完j的信息后，虽然把<code>j</code>之前的信息覆盖掉了。但是下一次我们更新的是<code>j - 1</code>，需要的是<code>j - 1</code>和<code>j - 2</code> 的信息，<code>j</code>信息覆盖就不会造成影响了。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode119_PascalTriangle2.java">https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode119_PascalTriangle2.java</a> </p>
<p>相似题目：<a href="https://castile.github.io/2020/02/06/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%921/">杨辉三角</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
        <tag>递归</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-128-最长连续序列</title>
    <url>/2020/01/22/leetcode-128-LongestConsecutiveSequence/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>LeetCode128: 最长连续序列longest-consecutive-sequence</p>
<p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的时间复杂度为 ==<strong>O(n)</strong>==。 【困难】</p>
<p>示例:</p>
<p>输入: [100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence">https://leetcode-cn.com/problems/longest-consecutive-sequence</a></p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>​    如果允许O(nlogn)的复杂度，那么可以先排序，可是本题要求    O(n)    。<br>由于序列里的元素是无序的，又要求    O(n)    ，首先要想到用哈希表。<br>用一个哈希表存储所有出现过的元素，对每个元素，以该元素为中心，往左右扩张，直到不连续为止，记 录下最长的长度。</p>
<h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-22 18:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定一个未排序的整数数组，找出最长连续序列的长度。</span></span><br><span class="line"><span class="comment">要求算法的时间复杂度为 O(n)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode128_LongestConsecutiveSequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; myset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: nums)&#123;</span><br><span class="line">            myset.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; myset.contains(j); j++)&#123;</span><br><span class="line">                myset.remove(j);</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; myset.contains(j); j--)&#123;</span><br><span class="line">                myset.remove(j);</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            longest = Math.max(longest, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []nums = &#123;<span class="number">100</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = longestConsecutive(nums);</span><br><span class="line">        System.out.println(len);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出4</p>
<p>时间复杂度为O(n) ， 空间复杂度O(n)</p>
<p>Leetcode官方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> longestStreak = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[i-<span class="number">1</span>]+<span class="number">1</span>) &#123;</span><br><span class="line">                    currentStreak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">                    currentStreak = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(longestStreak, currentStreak);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>哈希</tag>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-130-被围绕的区域</title>
    <url>/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>Leetcode-130： 被围绕的区域</p>
<p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例:</p>
<p>X X X X<br>X O O X<br>X X O X<br>X O X X<br>运行你的函数后，矩阵变为：</p>
<p>X X X X<br>X X X X<br>X X X X<br>X O X X<br>解释:</p>
<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/surrounded-regions">https://leetcode-cn.com/problems/surrounded-regions</a></p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>dfs搜索：将边界上的‘O’及其连通的先设置成‘#’标识，这些是不会被填充的，等搜索完毕之后再将这些标志换回‘O’。而在里面的‘O’就是被包围的区域，通过双层循环将里面的’O‘替换成’X‘即可。</p>
</li>
<li><p>并查集：并查集的思想就是，同一个连通区域内的所有点的根节点是同一个。将每个点映射成一个数字。先假设每个点的根节点就是他们自己，然后我们以此输入连通的点对，然后将其中一个点的根节点赋成另一个节点的根节点，这样这两个点所在连通区域又相互连通了。</p>
<p>并查集代码：UF</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-25 21:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 并查集 UF</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">// 新增一个数组记录树的“重量”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// n个元素</span></span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        size = <span class="keyword">new</span>  <span class="keyword">int</span>[n];</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 一开始每一个节点自成一个集合，都不连通</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; n;  i++)&#123;</span><br><span class="line">            parent[i]  = i; <span class="comment">// 自己的父节点指向自己</span></span><br><span class="line">            size[i] = <span class="number">1</span>; <span class="comment">// 每隔几何只有自身一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = parent[x];</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x)&#123; <span class="comment">// 路径压缩</span></span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(a) == find(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = find(a);</span><br><span class="line">        <span class="keyword">int</span> rootB = find(b);</span><br><span class="line">        <span class="keyword">if</span>(rootA == rootB)&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 同一个集合不能合并</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(size[rootA] &gt; size[rootB])&#123;</span><br><span class="line">                parent[rootB] = rootA;</span><br><span class="line">                size[rootA] += size[rootB];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootA] = rootB;</span><br><span class="line">                size[rootB] += size[rootA];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--; <span class="comment">// 连通分量个数减一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>可以把那些不需要被替换的</strong> <strong><code>O</code></strong> <strong>看成一个拥有独门绝技的门派，它们有一个共同祖师爷叫</strong> **<code>dummy</code>**<strong>，这些</strong> <strong><code>O</code></strong> <strong>和</strong> <strong><code>dummy</code></strong> <strong>互相连通，而那些需要被替换的</strong> <strong><code>O</code></strong> <strong>与</strong> <strong><code>dummy</code></strong> <strong>不连通</strong>。 如下图:</p>
<img src="/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/1580027256551.png" style="zoom:80%;">



<p>​        首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。</p>
<p>​        这个很简单，二维坐标 <code>(x,y)</code> 可以转换成 <code>x * n + y</code> 这个数（<code>m</code> 是棋盘的行数，<code>n</code> 是棋盘的列数）。敲黑板，<strong>这是将二维坐标映射到一维的常用技巧</strong>。</p>
<p>​        其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引 <code>[0.. m*n-1]</code> 都是棋盘内坐标的一维映射，那就让这个虚拟的 <code>dummy</code> 节点占据索引 <code>m * n</code> 好了。</p>
<p>​        我们的思路是把所有边界上的 O看做一个连通区域。遇到 O 就执行并查集合并操作，这样所有的 O 就会被分成两类</p>
<ol>
<li>和边界上的 O在一个连通区域内的。这些 O 我们保留。</li>
<li>不和边界上的O 在一个连通区域内的。这些 O 就是被包围的，替换。</li>
</ol>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol>
<li><p>dfs版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//  边缘搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i == <span class="number">0</span> || j == <span class="number">0</span> || i == m-<span class="number">1</span> || j == n-<span class="number">1</span>)  &amp;&amp;  (board[i][j] == <span class="string">&#x27;O&#x27;</span>))&#123;</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                   board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                   board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i,  <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length || board[i][j] != <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] d: directions)&#123;</span><br><span class="line">            dfs(board, i+d[<span class="number">0</span>], d[<span class="number">1</span>]+j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/1580027995406.png" alt="leetcode测试用例" style="zoom:80%;" align="center"></li>
<li><p>并查集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用并查集解决</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solveUF</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(board==<span class="keyword">null</span> || board.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = board.length;</span><br><span class="line">    <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 边界上的‘O’的根节点都是dummy</span></span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(n * m + <span class="number">1</span>);<span class="comment">//  增加一个存储dummy节点</span></span><br><span class="line">    <span class="keyword">int</span> dummy = m * n;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123; <span class="comment">// 目标</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span> || i == m -<span class="number">1</span> || j == n -<span class="number">1</span>) &#123; <span class="comment">// 如果是边界上的&#x27;O&#x27;， 与dummy合并</span></span><br><span class="line">                    uf.union(i*n+j, dummy);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// 里面的</span></span><br><span class="line">                    <span class="comment">// 方向数组 d 是上下左右搜索的常用手法</span></span><br><span class="line">                    <span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">                    <span class="comment">// 将此 O 与上下左右的 O 连通</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                            uf.union(x * n + y, i * n + j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">1</span>;  i &lt; m-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!uf.isSameSet(i*n+j, dummy))&#123;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<img src="/2020/01/26/leetcode-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/1580043663800.png" alt="1580043663800" style="zoom:80%;" align="center"></li>
</ol>
<p>参考：</p>
<ol>
<li> <a href="https://cyc2018.github.io/CS-Notes">https://cyc2018.github.io/CS-Notes</a></li>
<li> <a href="https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/unionfind-suan-fa-ying-yong#yi-dfs-de-ti-dai-fang-an">https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/unionfind-suan-fa-ying-yong#yi-dfs-de-ti-dai-fang-an</a> </li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>dfs</tag>
        <tag>并查集</tag>
        <tag>搜索</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-200-岛屿数量</title>
    <url>/2020/02/02/leetcode-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<p>输入:<br>11110<br>11010<br>11000<br>00000</p>
<p>输出: 1<br>示例 2:</p>
<p>输入:<br>11000<br>11000<br>00100<br>00011</p>
<p>输出: 3<br>链接：<a href="https://leetcode-cn.com/problems/number-of-islands">https://leetcode-cn.com/problems/number-of-islands</a></p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>dfs： 深度优先搜索，很明显，这是一个连通问题，求出的连通分量的个数就是岛屿的数量</li>
<li>并查集： 这个是并查集的一个应用，求连通分量的个数。</li>
<li>bfs： 使用队列解决</li>
</ol>
<p>这里有一个大佬的题解，非常详细： <a href="https://leetcode-cn.com/problems/number-of-islands/solution/dfs-bfs-bing-cha-ji-python-dai-ma-java-dai-ma-by-l/">https://leetcode-cn.com/problems/number-of-islands/solution/dfs-bfs-bing-cha-ji-python-dai-ma-java-dai-ma-by-l/</a> </p>
<p>官方题解也可。主要是理解算法思想</p>
<p>直接看代码吧</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>并查集：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] parents = <span class="keyword">new</span> <span class="keyword">int</span>[n*m];</span><br><span class="line">        <span class="keyword">int</span>[] rank = <span class="keyword">new</span> <span class="keyword">int</span> [n*m];</span><br><span class="line">        makeSet(grid, parents, rank);</span><br><span class="line">        <span class="comment">// 方向数组 d 是上下左右搜索的常用手法</span></span><br><span class="line">        <span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>( grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                   grid[i][j] = <span class="string">&#x27;0&#x27;</span>;  <span class="comment">//  已经联合的点不需要连接了。</span></span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                       <span class="keyword">int</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">                       <span class="keyword">int</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">                       <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                           unoin(parents, rank, x *n +y,  i *n + j);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建并查集的结构：注意这里的技巧</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSet</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> []parents, <span class="keyword">int</span> []rank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    parents[i * grid[<span class="number">0</span>].length + j] = i * grid[<span class="number">0</span>].length + j;</span><br><span class="line">                    rank[i * grid[<span class="number">0</span>].length + j] = <span class="number">1</span>;</span><br><span class="line">                    count++;  <span class="comment">// 连通分量 </span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    parents[i * grid[<span class="number">0</span>].length + j] = -<span class="number">1</span>;</span><br><span class="line">                    rank[i * grid[<span class="number">0</span>].length + j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;    </span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parents, <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = parents[a];</span><br><span class="line">        <span class="keyword">while</span>(root != parents[root])&#123;</span><br><span class="line">           root = parents[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unoin</span><span class="params">(<span class="keyword">int</span>[] parents, <span class="keyword">int</span> []rank, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ra  = find(parents, a);</span><br><span class="line">        <span class="keyword">int</span> rb  = find(parents, b);</span><br><span class="line">        <span class="keyword">if</span>(ra != rb)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rank[ra] &gt; rank[rb])&#123;</span><br><span class="line">                parents[rb] =  ra;</span><br><span class="line">                rank[ra] += rank[rb];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 parents[rb] =  ra;</span><br><span class="line">                rank[ra] += rank[rb];</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dfs：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    cnt++; <span class="comment">// 岛屿的个数加一</span></span><br><span class="line">                    infect(grid, i, j, grid.length, grid[<span class="number">0</span>].length); <span class="comment">// 感染函数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 感染函数： 将i， j位置的上下左右位置进行检查，是否为同一个岛屿</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m： 岛屿矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i： 下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j：  下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> R: 行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> C： 列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">char</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> R, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= R || j &lt; <span class="number">0</span> || j &gt;= C || m[i][j] != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        m[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        <span class="comment">// 依次感染上下左右位置</span></span><br><span class="line">        infect(m, i+<span class="number">1</span>, j, R, C);</span><br><span class="line">        infect(m, i-<span class="number">1</span>, j, R, C);</span><br><span class="line">        infect(m, i, j-<span class="number">1</span>, R, C);</span><br><span class="line">        infect(m, i, j+<span class="number">1</span>, R, C);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BFS： 使用队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 广度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> ||  grid.length == <span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    q.offer(i * n + j); <span class="comment">//  入队</span></span><br><span class="line">                    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> cur = q.poll(); <span class="comment">// 出队</span></span><br><span class="line">                    <span class="keyword">int</span> cx = cur / n;</span><br><span class="line">                    <span class="keyword">int</span> cy = cur % n;</span><br><span class="line">                    grid[cx][cy] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span>[] dd: d)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = cx + dd[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = cy + dd[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                            q.offer(x * n + y);</span><br><span class="line">                            grid[x][y] = <span class="string">&#x27;0&#x27;</span>;   <span class="comment">// 要标志已访问，不然会严重超时</span></span><br><span class="line">                        &#125;</span><br><span class="line">                            </span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>dfs</tag>
        <tag>并查集</tag>
        <tag>搜索</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-206-反转链表</title>
    <url>/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>leetcode206： 反转链表 【简单】</p>
<p>反转一个单链表。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<p>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list">https://leetcode-cn.com/problems/reverse-linked-list</a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul>
<li><p>迭代： 如下图：</p>
<img src="/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1580982171220.png" alt="1580982171220" style="zoom:80%;" align="center"></li>
</ul>
<img src="/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1580982209880.png" alt="1580982209880" style="zoom:80%;" align="center">

<p>​    时间复杂度：O(n) 。 假设 <em>n</em> 是列表的长度，时间复杂度是 O(n)。</p>
<p>​    空间复杂度：O(1)。</p>
<ol start="2">
<li><p>递归</p>
<p>1、找到递归出口</p>
<p>2、确定返回值</p>
<p>3、分析单次递归需要做的事情</p>
<p>下面，我们来具体分析一下：</p>
<p>首先，找到递归出口，这个还是非常简单的，就是当前即将反转的节点为 null 或者是 反转链表 为 null 时（一轮递归其实就只有两个节点，后面会讲），说明已经全部反转完毕了，即递归出口；<br>其次，确定返回值，我们只需要返回反转链表的头结点即可；<br>最后，分析单次递归需要做的事情，递归其实每一轮做的事情都是一样的，我们不需要去重复考虑，这样反而会很乱，只需要考虑单轮递归需要做什么就可以了。在这里，我们就只有两个节点，一个是即将反转的节点元素，一个是已经反转完毕的链表头结点。 我们要做的一轮递归只是 将当前节点加入到反转链表中，仅此而已。<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/bang-zhu-da-jia-li-jie-di-gui-zuo-fa-by-jeromememo/">https://leetcode-cn.com/problems/reverse-linked-list/solution/bang-zhu-da-jia-li-jie-di-gui-zuo-fa-by-jeromememo/</a></p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/LinkedList/leetcode206_ReverseLinkedList.java">https://github.com/Castile/algorithm/blob/master/leetcode/src/LinkedList/leetcode206_ReverseLinkedList.java</a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LinkedList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-06 17:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    反转单链表： 要求时间复杂度为O((n) ，空间复杂度为O(1)；</span></span><br><span class="line"><span class="comment">    Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span></span><br><span class="line"><span class="comment">    Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode206_ReverseLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)   <span class="keyword">return</span> head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归版本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  ListNode <span class="title">reverdeList_Recur</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> help(head, <span class="keyword">null</span>, head.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">help</span><span class="params">(ListNode head, ListNode pre, ListNode next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)    <span class="keyword">return</span> pre;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">        <span class="keyword">return</span> help(head, pre, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优美递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseListRR</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)   <span class="keyword">return</span> head;</span><br><span class="line">        ListNode p = reverseListRR(head.next);</span><br><span class="line">        <span class="comment">//这里的cur就是最后一个节点</span></span><br><span class="line">        ListNode cur = reverseList(head.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line">        <span class="comment">//而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line">        <span class="comment">//所以head.next.next 就是5-&gt;4</span></span><br><span class="line">        head.next.next = head; <span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">        head.next  = <span class="keyword">null</span>; <span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkedList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(p.val +<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        ListNode n1 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        ListNode n2 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        ListNode n3 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        ListNode n4 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        head.next = n1;</span><br><span class="line">        n1.next = n2;</span><br><span class="line">        n2.next = n3;</span><br><span class="line">        n3.next = n4;</span><br><span class="line"></span><br><span class="line">        printLinkedList(head);</span><br><span class="line"></span><br><span class="line">        ListNode re = reverseListRR(head);</span><br><span class="line"></span><br><span class="line">        printLinkedList(re);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2020/02/06/leetcode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1580982603520.png" alt="1580982603520" align="center">



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-21-合并两个有序的链表</title>
    <url>/2020/02/16/leetcode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>​    </p>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>Leetcode-21： 合并两个有序的链表</p>
<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol>
<li><p>迭代：这题目是简单题，其实就是归并排序中的归并操作。不再赘述。</p>
</li>
<li><p>递归：</p>
<p>​    终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束</p>
<p>​    返回值：每一层调用都返回排序好的链表头<br>​    本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理</p>
<p>时间复杂度： O(n+m)   空间复杂度：O(n+m)</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>github： <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/LinkedList/Leetcode21_MergeLinkedList.java">https://github.com/Castile/algorithm/blob/master/leetcode/src/LinkedList/Leetcode21_MergeLinkedList.java</a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy= <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode list = dummy;</span><br><span class="line">        ListNode p1 = l1;</span><br><span class="line">        ListNode p2 = l2;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val &gt; p2.val)&#123;</span><br><span class="line">                list.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                list.next = p1;</span><br><span class="line">                p1 =  p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            list = list.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理p1</span></span><br><span class="line">        <span class="keyword">if</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.next = p2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists_Cur</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)  <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)  <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &gt; l2.val)&#123;</span><br><span class="line">            l2.next = mergeTwoLists_Cur(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l1.next = mergeTwoLists_Cur(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-24-两两交换链表中的节点</title>
    <url>/2020/02/03/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例：</p>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3<br>链接：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs">https://leetcode-cn.com/problems/swap-nodes-in-pairs</a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol>
<li><p>递归：</p>
<p>​        我们可以定义函数 swap(head) 以实现解决方案，其中输入的参数 head 指向链表的头节点。* 而该函数应当返回将链表中每两个相邻节点交换后得到的新列表的头节点 head 。</p>
<p>​        按照我们上面列出的步骤，我们可以按下面的流程来实现函数：</p>
<p>​        （1）首先，我们交换列表中的前两个节点，也就是 head 和 head.next；</p>
<p>​        （2）然后我们以 swap(head.next.next) 的形式调用函数自身，以交换头两个节点之后列表的其余部分。</p>
<p>​        （3）最后，我们将步骤（2）中的子列表的返回头与步骤（1）中交换的两个节点相连，以形成新的链                    表。</p>
</li>
<li><p>迭代</p>
<p>新增一个头节点 dummy node， dummy.next = head； 更好操作链表。流程图如下：</p>
<img src="/2020/02/03/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/1580719129953.png" alt="1580719790068" style="zoom:80%;"></li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>源码： <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/LinkedList/leetcode24_SwapNodesInPairs.java">https://github.com/Castile/algorithm/blob/master/leetcode/src/LinkedList/leetcode24_SwapNodesInPairs.java</a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-03 15:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      ListNode next;</span><br><span class="line">      ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode24_SwapNodesInPairs</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 递归解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)     <span class="keyword">return</span> head;</span><br><span class="line">        ListNode n = head.next.next;  <span class="comment">// 下一次要传递的节点</span></span><br><span class="line">        <span class="comment">//交换这两个节点</span></span><br><span class="line">        ListNode p = head.next;</span><br><span class="line">        p.next = head;</span><br><span class="line">        head.next = swapPairs(n); <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">return</span> p; <span class="comment">// 返回交换之后的头结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs_it</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode first = head;</span><br><span class="line">            ListNode second = head.next;</span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            first.next = second.next;</span><br><span class="line">            second.next = first;</span><br><span class="line">            pre.next = second;</span><br><span class="line">            <span class="comment">// 初始化头</span></span><br><span class="line">            head = first.next;</span><br><span class="line">            pre = first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>中等</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-268-缺失的数字</title>
    <url>/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p>
<p>示例 1:</p>
<p>输入: [3,0,1]<br>输出: 2<br>示例 2:</p>
<p>输入: [9,6,4,2,3,5,7,0,1]<br>输出: 8<br>链接：<a href="https://leetcode-cn.com/problems/missing-number">https://leetcode-cn.com/problems/missing-number</a></p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>题目说从0<del>n的数字，所以直接累加数组得到和为sum， 加入数组没有缺失数据，那么完整数组的元素个数为原数组大小加1，利用等差数列的性质，得到从0</del>n的和len，然后len - sum 就是缺失的那个数字了。</p>
<p>时间复杂度：O(n)。求出数组中所有数的和的时间复杂度为 O(n)，等差数列公式的时间复杂度为 O(1)，因此总的时间复杂度为 O(n)。<br>空间复杂度：O(1)。算法中只用到了O(1) 的额外空间，用来存储答案。</p>
</li>
<li><p>位操作： 异或</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th align="center">异或结果</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td align="center">0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td align="center">1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td align="center">1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p> 其他数字 与 0 异或都得到它自己。</p>
<p>此外异或运算满足交换律.  如：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>4</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p> 下标与数组值异或操作：  4 ^ 0 ^ 3 ^ 1 ^  4 ^ 2 ^ 0 ^ 3 ^ 1 ( 前面的4是为了添加最后一位数字，为原数组的长度) —-&gt; 可得到缺失的值为2。</p>
<p>时间复杂度：O(n)。这里假设异或运算的时间复杂度是常数的，总共会进行O(n) 次异或运算，因此总的时间复杂度为 O(n)。<br>空间复杂度：O(1)。算法中只用到了O(1) 的额外空间，用来存储答案。</p>
</li>
<li><p>哈希表</p>
<p>将数组中的元素放入HashSet哈希表中， 插入哈希表的时间复杂度为O(1)， N个数时间复杂度为O(n)， 然后从0到数组放长度区间内遍历， 判断哈希表中是否存在此数字，若不存在， 则此数字就是缺失的数字。遍历时间复杂度为O(n)，  故总体时间复杂度为O(n)。空间复杂度为O(n)。</p>
</li>
<li><p>还可以先排序，再找出缺失的数字，但是排序的时间复杂度不是线性时间， 为O(logN)</p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>方法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length; i++)&#123; <span class="comment">//数组的和</span></span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缺失一个数字： 本来的和应该是：  </span></span><br><span class="line">        <span class="keyword">int</span> len = (nums.length + <span class="number">1</span>) * nums.length / <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">return</span> len - sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/1580614821325.png" alt="1580614821325" style="zoom:80%;">



<p>位操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; nums.length; i++)&#123;</span><br><span class="line">            m ^= i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/1580614957343.png" alt="1580614957343" style="zoom:80%;">

<p>哈希表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length; i++)&#123;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( !set.contains(i))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/1580615699820.png" alt="1580615699820" style="zoom:80%;">

<p>排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      Arrays.sort(nums);</span><br><span class="line">      <span class="comment">// 判断末尾</span></span><br><span class="line">      <span class="keyword">if</span>(nums[nums.length - <span class="number">1</span>] !=  nums.length)&#123;</span><br><span class="line">          <span class="keyword">return</span> nums.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断0 是否在首位</span></span><br><span class="line">      <span class="keyword">if</span>(nums[<span class="number">0</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length ; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(i != nums[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/02/leetcode-268-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/1580616038690.png" alt="1580616038690" style="zoom:80%;">]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
        <tag>位操作</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-344-反转字符串</title>
    <url>/2020/02/03/leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p>
<p>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p>
<p>来源：力扣（LeetCode）</p>
</blockquote>
<blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/reverse-string">https://leetcode-cn.com/problems/reverse-string</a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol>
<li><p>就地操作，而且要是O(1)的空间，可以使用迭代方法，首尾指针解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length;</span><br><span class="line">        <span class="keyword">char</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span> ; i++)&#123;</span><br><span class="line">            tmp = s[i];</span><br><span class="line">            s[i] =  s[len - i - <span class="number">1</span>]; <span class="comment">//这是末尾的值</span></span><br><span class="line">            s[len-i-<span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>也可以用递归来做，但是使用了辅助栈，不满足O(1)的空间要求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        help(s, <span class="number">0</span>, s.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">char</span> tmp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">        help(s, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/Str/leetcode344_ReverseStr.java">https://github.com/Castile/algorithm/blob/master/leetcode/src/Str/leetcode344_ReverseStr.java</a> </p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
        <tag>递归</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-399-除法求值</title>
    <url>/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。</p>
<p>示例 :<br>给定 a / b = 2.0, b / c = 3.0<br>问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?<br>返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]</p>
<p>输入为: vector&lt;pair&lt;string, string&gt;&gt; equations, vector<double>&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries(方程式，方程式结果，问题方程式)， 其中 equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。 返回vector<double>类型。</double></double></p>
<p>基于上述例子，输入如下：</p>
<p>equations(方程式) = [ [“a”, “b”], [“b”, “c”] ],<br>values(方程式结果) = [2.0, 3.0],<br>queries(问题方程式) = [ [“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”] ].<br>输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。<br>链接：<a href="https://leetcode-cn.com/problems/evaluate-division">https://leetcode-cn.com/problems/evaluate-division</a></p>
</blockquote>
<p>此题难度为中等，但是我做了一天….， 太菜了。。。对于我来说还是比较复杂的题目了。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>dfs：使用深度优先搜索就比较直观。每个字母相当于一个节点，在给定的equations中建立合适的数据结构，建图，要求方程式的结果相当于求两个节点之间是否可以到达，可以到达则求出其代价，不能到达就设为-1.0.</p>
<p>我觉得此题的关键就是建图。</p>
<img src="/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/1580483374980.png" alt="1580483374980" style="zoom:80%;">

<p>a/c = (a/b) * (b/c)，所以我们可以用<strong>图</strong>来解决 。</p>
</li>
<li><p>并查集： 比较特殊，在路径压缩那块比较复杂。。。以后补上吧</p>
<img src="/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/1580483517613.png" class width="1580483517613"></li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Leetcode AC 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="comment">// 使用map的数据结构更好</span></span><br><span class="line">        <span class="comment">// 表示 a-&gt;b 的权重 即 a / b 的值</span></span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt; g = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        buildGraph(g, equations, values);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        Arrays.fill(res, -<span class="number">1.0</span>);</span><br><span class="line">        <span class="keyword">int</span> index= <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; q: queries)&#123;</span><br><span class="line">            String a = q.get(<span class="number">0</span>);</span><br><span class="line">            String b = q.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!g.containsKey(a) || !g.containsKey(b))&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dfs(g, a, b, res, <span class="keyword">new</span> HashSet&lt;&gt;(), index, <span class="number">1.0</span>);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建图</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(Map&lt;String, Map&lt;String, Double&gt;&gt; g, List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; e: equations)&#123;</span><br><span class="line">            String a = e.get(<span class="number">0</span>);</span><br><span class="line">            String b = e.get(<span class="number">1</span>);</span><br><span class="line">            g.putIfAbsent(a, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            g.putIfAbsent(b, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            g.get(a).put(b, values[index]);   <span class="comment">// a / b</span></span><br><span class="line">            g.get(b).put(a, <span class="number">1.0</span> / values[index]); <span class="comment">//  b / a</span></span><br><span class="line">            index++;</span><br><span class="line">            g.get(a).put(a, <span class="number">1.0</span>);</span><br><span class="line">            g.get(b).put(b, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;String, Map&lt;String, Double&gt;&gt; g, String a, String b, <span class="keyword">double</span>[] res, Set&lt;String&gt; visited, <span class="keyword">int</span> index,  <span class="keyword">double</span>  tmp)</span>       </span>&#123;</span><br><span class="line">        visited.add(a);</span><br><span class="line">        <span class="keyword">if</span>(g.get(a) == <span class="keyword">null</span> || g.get(a).size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明a没有与其他点相连</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(g.get(a).containsKey(b))&#123;  <span class="comment">//  刚好有a-&gt;b的路径</span></span><br><span class="line">            res[index] = g.get(a).get(b) * tmp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String next: g.get(a).keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(next))  <span class="keyword">continue</span>;</span><br><span class="line">            dfs(g, next, b, res, visited, index, g.get(a).get(next)*tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/31/leetcode-399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/1580483055463.png" alt="1580483055463" style="zoom:80%;">



<p>还有一些问题未解决，比如下面是自己写的代码，在idea上运行没毛病，但是在leetcode上就出错了。具体原因不详，欢迎大家提出问题进行交流，不胜感激！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution_DFS</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt;  g = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 图</span></span><br><span class="line">        bulidGraph(g, equations, values);</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()]; <span class="comment">//   结果集合</span></span><br><span class="line"></span><br><span class="line">        Arrays.fill(res, -<span class="number">1.0</span>); <span class="comment">// 全部设置成-1.0；</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历问题式子</span></span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; q: queries)&#123;</span><br><span class="line">            String a = q.get(<span class="number">0</span>);</span><br><span class="line">            String b = q.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!g.containsKey(a) || !g.containsKey(b))&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dfs(g, a, b, res, index, <span class="keyword">new</span> HashSet&lt;&gt;(), <span class="number">1.0</span>);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个方法在leetcode行不通</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation_dfs(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt; g = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        bulidGraph(g, equations, values);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; q: queries)&#123;</span><br><span class="line">            String x = q.get(<span class="number">0</span>);</span><br><span class="line">            String y = q.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!g.containsKey(x) || !g.containsKey(y))&#123;</span><br><span class="line">                ans[index] = -<span class="number">1.0</span>;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            HashSet&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            ans[index] = divide(x, y, g, visited);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a / b</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">divide</span><span class="params">(String a, String b, Map&lt;String, Map&lt;String, Double&gt;&gt; g, Set&lt;String&gt; visitied)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( a == b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visitied.add(a);</span><br><span class="line">        <span class="keyword">for</span>(String next: g.get(a).keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(visitied.contains(next)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">double</span> d = divide(next, b, g, visitied); <span class="comment">//  d = next / b</span></span><br><span class="line">            <span class="comment">//  a /b =  next /b * a / next</span></span><br><span class="line">            <span class="keyword">if</span>(d &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> d * g.get(a).get(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;String, Map&lt;String, Double&gt;&gt; g, String a, String b, <span class="keyword">double</span>[] res, <span class="keyword">int</span> index, Set&lt;String&gt; visited, <span class="keyword">double</span> tmp)</span></span>&#123;</span><br><span class="line">        visited.add(a);</span><br><span class="line">        <span class="keyword">if</span>(g.get(a) == <span class="keyword">null</span> || g.get(a).size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(g.get(a).containsKey(b)) &#123;</span><br><span class="line">            <span class="comment">//  刚好存在 a-&gt;b</span></span><br><span class="line">            res[index] = g.get(a).get(b) * tmp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String next: g.get(a).keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(next))  <span class="keyword">continue</span>;</span><br><span class="line">            dfs(g, next, b, res, index, visited, g.get(a).get(next) * tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bulidGraph</span><span class="params">(Map&lt;String, Map&lt;String, Double&gt;&gt;  g , List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; e: equations)&#123;</span><br><span class="line">            String a = e.get(<span class="number">0</span>);</span><br><span class="line">            String b = e.get(<span class="number">1</span>);</span><br><span class="line">            g.putIfAbsent(a, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            g.putIfAbsent(b, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            g.get(a).put(b, values[index]);   <span class="comment">//  a -&gt; b  : a / b</span></span><br><span class="line">            g.get(b).put(a, <span class="number">1.0</span> / values[index]); <span class="comment">//  b -&gt; a : b / a;</span></span><br><span class="line">            index++;</span><br><span class="line">            g.get(a).put(a, <span class="number">1.0</span>);</span><br><span class="line">            g.get(b).put(b, <span class="number">1.0</span>);  <span class="comment">//  自己到自己的权重为1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>dfs</tag>
        <tag>并查集</tag>
        <tag>搜索</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-50-幂函数</title>
    <url>/2020/02/12/leetcode-50-%E5%B9%82%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><h2 id="leetcode-50-Pow-x-n"><a href="#leetcode-50-Pow-x-n" class="headerlink" title="leetcode-50 Pow(x, n)"></a>leetcode-50 Pow(x, n)</h2><blockquote>
<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
<p>示例 1:</p>
<p>输入: 2.00000, 10<br>输出: 1024.00000<br>示例 2:</p>
<p>输入: 2.10000, 3<br>输出: 9.26100<br>示例 3:</p>
<p>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25<br>说明:</p>
<p>-100.0 &lt; x &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/powx-n">https://leetcode-cn.com/problems/powx-n</a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol>
<li><p>暴力求解： 这个会超时，这里要处理一下n小于0的情况， 当n小于0的时候，将x变成1/x， n = -n； </p>
</li>
<li><p>快速幂： <a href="https://blog.csdn.net/qq_19782019/article/details/85621386">https://blog.csdn.net/qq_19782019/article/details/85621386</a> </p>
<p>​        快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode50_pow.java">https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode50_pow.java</a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> RecurrenceAndDynamicProgramming;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-12 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode50_pow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            N = -N;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            ans *= x;</span><br><span class="line">            ans %= <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  快速幂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 底数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 指数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  结果   求最后三位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">fast_pow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="comment">//            if(n % 2 == 0)&#123;</span></span><br><span class="line"><span class="comment">//                // 如果指数为偶数</span></span><br><span class="line"><span class="comment">//                n /= 2;</span></span><br><span class="line"><span class="comment">//                x = x * x % 1000;</span></span><br><span class="line"><span class="comment">//            &#125;if(n % 2 != 0 )&#123;</span></span><br><span class="line"><span class="comment">//                // 指数为奇数</span></span><br><span class="line"><span class="comment">//                n--; //  指数减一为偶数</span></span><br><span class="line"><span class="comment">//                result = result * x % 1000;</span></span><br><span class="line"><span class="comment">//                n /= 2;</span></span><br><span class="line"><span class="comment">//                x = x * x % 1000;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="keyword">if</span>( (n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;  <span class="comment">// n%2 == 1  奇数   使用位运算更加高效</span></span><br><span class="line">                result = result * x % <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// n /= 2;</span></span><br><span class="line">            n &gt;&gt;= <span class="number">2</span>; <span class="comment">// 右移</span></span><br><span class="line">            x = x * x % <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result % <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start =  System.nanoTime();</span><br><span class="line"><span class="comment">//        double ans = pow(2, 1000000000);</span></span><br><span class="line">        <span class="keyword">double</span> anss = fast_pow(<span class="number">2</span>, <span class="number">10000000</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        System.out.println(anss);</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> +  (end - start)   +<span class="string">&quot; ns&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>附上AC的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastPow(x, N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span> ) == <span class="number">1</span>)&#123;</span><br><span class="line">                ans = ans*x;</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            x = x * x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2020/02/12/leetcode-50-%E5%B9%82%E5%87%BD%E6%95%B0/1581498031170.png" alt="1581498031170" style="zoom:80%;" align="center">

<p>快速幂很巧妙！值得学习！加油！！！</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>中等</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-547-朋友圈</title>
    <url>/2020/01/30/leetcode-547-%E6%9C%8B%E5%8F%8B%E5%9C%88/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>Leetcode547：Friend_Circles 朋友圈</p>
<p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是<strong>传递性</strong>。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p>
<p>示例 1:</p>
<p>输入:<br>[[1,1,0],<br> [1,1,0],<br> [0,0,1]]<br>输出: 2<br>说明：已知学生0和学生1互为朋友，他们在一个朋友圈。<br>第2个学生自己在一个朋友圈。所以返回2。<br>示例 2:</p>
<p>输入:<br>[[1,1,0],<br> [1,1,1],<br> [0,1,1]]<br>输出: 1<br>说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。<br>注意：</p>
<p>N 在[1,200]的范围内。<br>对于所有学生，有M[i][i] = 1。<br>如果有M[i][j] = 1，则有M[j][i] = 1。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/friend-circles">https://leetcode-cn.com/problems/friend-circles</a></p>
<p>并查集、dfs、bfs</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>并查集：转化为求连通个数。 好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，</p>
<p>那么 M[0][1]和 M[1][0]的值都为 1。 很简单直观。</p>
<p>并查集：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集 UF</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">// 新增一个数组记录树的“重量”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// n个元素</span></span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        size = <span class="keyword">new</span>  <span class="keyword">int</span>[n];</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// 一开始每一个节点自成一个集合，都不连通</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; n;  i++)&#123;</span><br><span class="line">            parent[i]  = i; <span class="comment">// 自己的父节点指向自己</span></span><br><span class="line">            size[i] = <span class="number">1</span>; <span class="comment">// 每隔几何只有自身一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = parent[x];</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x)&#123; <span class="comment">// 路径压缩</span></span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(a) == find(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = find(a);</span><br><span class="line">        <span class="keyword">int</span> rootB = find(b);</span><br><span class="line">        <span class="keyword">if</span>(rootA == rootB)&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 同一个集合不能合并</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(size[rootA] &gt; size[rootB])&#123;</span><br><span class="line">                parent[rootB] = rootA;</span><br><span class="line">                size[rootA] += size[rootB];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent[rootA] = rootB;</span><br><span class="line">                size[rootB] += size[rootA];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--; <span class="comment">// 连通分量个数减一</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>dfs：  给定的矩阵可以看成图的邻接矩阵。这样我们的问题可以变成无向图连通块的个数。 </p>
<blockquote>
<p>M=</p>
<p> [1 1 0 0 0 0<br> 1 1 0 0 0 0<br> 0 0 1 1 1 0<br> 0 0 1 1 0 0<br> 0 0 1 0 1 0<br> 0 0 0 0 0 1]</p>
</blockquote>
<p>​     如果我们把 M 看成图的邻接矩阵，则图为： </p>
</li>
</ol>
<img src="/2020/01/30/leetcode-547-%E6%9C%8B%E5%8F%8B%E5%9C%88/1580390918176.png" alt="连通分量" style="zoom:80%;">

<p>​             在这个图中，点的编号表示矩阵 M 的下标，i 和 j之间有一条边当且仅当M[i][j]为 1。 </p>
<p>​                    为了找到连通块的个数，一个简单的方法就是使用深度优先搜索，从每个节点开始，我们使用一个大        小为 N 的 visited数组（M大小为 N×N ），这样 visited[i] 表示第 i 个元素是否被深度优先搜索访问过。每使        用一次深度优先搜索，即重新选择了一个点进行dfs，连通分量的个数就加一。</p>
<ol start="3">
<li>bfs:  方法与dfs类似，只是遍历方式是层次遍历， 使用的数据结构是队列。在广度优先搜索中，我们从一个特定点开始，访问所有邻接的节点。然后对于这些邻接节点，我们依然通过访问邻接节点的方式，知道访问所有可以到达的节点。因此，我们按照一层一层的方式访问节点。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> search;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-29 20:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode547_FriendCircles</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span>[] visited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) &#123; <span class="comment">// 是连通的并且还未访问</span></span><br><span class="line">                visited[j] = <span class="number">1</span>;</span><br><span class="line">                dfs(M, visited, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findCircleNum_DFS</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = M.length;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(M, visited, i);</span><br><span class="line">                count++;  <span class="comment">// 执行一次dfs表示增加了一个连通块</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        下面使用并查集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> []parents;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> []size;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> count1 = <span class="number">0</span>; <span class="comment">//  连通分量</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeSet</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">         parents = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">         size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">         count1 = n;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; n; i++)&#123;</span><br><span class="line">             size[i] = <span class="number">1</span>;</span><br><span class="line">             parents[i] = i;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> root = parents[a];</span><br><span class="line">         <span class="keyword">while</span>(root!= parents[root])&#123;</span><br><span class="line">             root = parents[root];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> root;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> roota = find(a);</span><br><span class="line">         <span class="keyword">int</span> rootb = find(b);</span><br><span class="line">         <span class="keyword">if</span>(roota != rootb)&#123;</span><br><span class="line">             <span class="keyword">if</span>(size[roota] &gt; size[rootb])&#123;</span><br><span class="line">                 parents[rootb] = roota;</span><br><span class="line">                 size[roota] = size[roota]+size[rootb];</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 parents[roota] = rootb;</span><br><span class="line">                 size[rootb] = size[roota]+size[rootb];</span><br><span class="line">             &#125;</span><br><span class="line">             count1--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = M.length;</span><br><span class="line">        makeSet(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i&lt; n; i++)&#123;</span><br><span class="line">             <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(M[i][j] == <span class="number">1</span>)<span class="comment">// 朋友</span></span><br><span class="line">                 &#123;</span><br><span class="line">                     union(i, j);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count1;  <span class="comment">// 返回连通分量的个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 广度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findCircleNum_BFS</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = M.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> k = queue.remove();</span><br><span class="line">                    visited[k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(M[k][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>)</span><br><span class="line">                            queue.add(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] M = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(findCircleNum_DFS(M));  <span class="comment">// 2</span></span><br><span class="line">        System.out.println(findCircleNum_BFS(M));<span class="comment">// 2</span></span><br><span class="line">        System.out.println(findCircleNum(M));<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注： 使用并查集速度最快。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>dfs</tag>
        <tag>并查集</tag>
        <tag>搜索</tag>
        <tag>中等</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-684-冗余连接</title>
    <url>/2020/01/27/leetcode-684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>Leetcode684:RedundantConnection 冗余连接①：</p>
<p>在本问题中, 树指的是一个连通且无环的无向图。</p>
<p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p>
<p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p>
<p>示例 1：</p>
<p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的无向图为:<br>  1<br> / <br>2 - 3<br>示例 2：</p>
<p>输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>输出: [1,4]<br>解释: 给定的无向图为:<br>5 - 1 - 2<br>    |   |<br>    4 - 3<br>注意:</p>
<p>输入的二维数组大小在 3 到 1000。<br>二维数组中的整数在1到N之间，其中N是输入数组的大小。<br>链接：<a href="https://leetcode-cn.com/problems/redundant-connection">https://leetcode-cn.com/problems/redundant-connection</a></p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>并查集的应用：</p>
<img src="/2020/01/27/leetcode-684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/1580095232083.png" alt="时间复杂度分析" style="zoom:80%;" align="center">

<p>直接看代码，一次AC</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-27 10:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Leetcode684:RedundantConnection 冗余连接①</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode684_RedundantConnection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">if</span>(edges == <span class="keyword">null</span> || edges.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> n = edges.length;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge: edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!uf.isSameSet(edge[<span class="number">0</span>], edge[<span class="number">1</span>]))&#123;</span><br><span class="line">                uf.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [][]edges = &#123;&#123; <span class="number">1</span>,<span class="number">2</span> &#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123; <span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> []res = findRedundantConnection(edges);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>并查集</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-695-岛屿的最大面积</title>
    <url>/2020/02/02/leetcode-695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p>
<p>示例 1:</p>
<p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</p>
<p>示例 2:</p>
<p>[[0,0,0,0,0,0,0,0]]<br>对于上面这个给定的矩阵, 返回 0。</p>
<p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/max-area-of-island">https://leetcode-cn.com/problems/max-area-of-island</a></p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>dfs： 岛屿问题，看到连通区域，想到dfs来做。 用DFS搜索每个value为1的位置，递归检查相邻的位置，如果访问过，则将value设为0（避免重复访问） </p>
<p>直接看代码注释</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> search;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-02 17:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode_695_MaxAreaIsland</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span>[][] d = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j++)&#123;</span><br><span class="line">                result = Math.max(result, dfs(grid, i, j)); <span class="comment">//求最大的面积</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    int[][] d = new int[][]&#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>; <span class="comment">// 面积加1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123; <span class="comment">//  注意使用不同的变量，如果使用x、y会报错</span></span><br><span class="line">            <span class="keyword">int</span> i = x + d[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> j = y + d[k][<span class="number">1</span>];</span><br><span class="line">            c += dfs(grid, i, j);  <span class="comment">// 搜索上下左右</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int[] dd: d)&#123;</span></span><br><span class="line">        <span class="comment">//     c += dfs(grid, x + dd[0], y + dd[1]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>dfs</tag>
        <tag>搜索</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-779-第k个语法符号</title>
    <url>/2020/02/16/leetcode-779-%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>leetcode： 779 第K个语法符号</p>
<p>在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。</p>
<p>给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）</p>
<p>例子:</p>
<p>输入: N = 1, K = 1<br>输出: 0</p>
<p>输入: N = 2, K = 1<br>输出: 0</p>
<p>输入: N = 2, K = 2<br>输出: 1</p>
<p>输入: N = 4, K = 5<br>输出: 1</p>
<p>解释:<br>第一行: 0<br>第二行: 01<br>第三行: 0110<br>第四行: 01101001</p>
<p>链接：<a href="https://leetcode-cn.com/problems/k-th-symbol-in-grammar">https://leetcode-cn.com/problems/k-th-symbol-in-grammar</a></p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>既然每一行都是根据上一行来生成的，把这样的上下两行写成比特形式找一下规律。</p>
 <img src="/2020/02/16/leetcode-779-%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/parent.png" alt="img" style="zoom:80%;"> 

<p>如果当前行为 <code>&quot;0110&quot;</code>，由此生成的下一行为 <code>&quot;01101001&quot;</code>。 </p>
<p> <img src="/2020/02/16/leetcode-779-%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/leetcode-779-%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7%5Clink.png" alt="img"> </p>
<p>据此可以总结出规律，第 K 个数字是上一行第 (K+1) / 2 个数字生成的。如果上一行的数字为 0，被生成的数字为 1 - (K%2)，如果上一行的数字为 1，被生成的数字为 K%2。</p>
<p> 如果k是偶数，表明是右子树，奇数为左子树。 </p>
<blockquote>
<p>  还有其他方法，见官方题解： <a href="https://leetcode-cn.com/problems/k-th-symbol-in-grammar/solution/di-kge-yu-fa-fu-hao-by-leetcode/">https://leetcode-cn.com/problems/k-th-symbol-in-grammar/solution/di-kge-yu-fa-fu-hao-by-leetcode/</a> </p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>github： <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode799_kthGrammar.java">https://github.com/Castile/algorithm/blob/master/leetcode/src/RecurrenceAndDynamicProgramming/leetcode799_kthGrammar.java</a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> RecurrenceAndDynamicProgramming;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-16 14:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode799_kthGrammar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">kthGrammar</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = kthGrammar(N-<span class="number">1</span>, (K+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> K%<span class="number">2</span>==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> K%<span class="number">2</span>==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-80-删除排序数组的重复项2</title>
    <url>/2020/01/22/leetcode-80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B92/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>leetcode-80-删除排序数组的重复项2：</p>
<blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii</a><br>相似题目： <a href="https://castile.github.io/Castile.github.io/2020/01/21/leetcode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">https:/Castile.github.io/2020/01/21/leetcode26-删除排序数组的重复项/</a> </p>
<p><strong>==tag：双指针思想==</strong></p>
</blockquote>
<p>示例 1:</p>
<p>给定 nums = [1,1,1,2,2,3],</p>
<p>函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</p>
<p>你不需要考虑数组中超出新长度后面的元素。<br>示例 2:</p>
<p>给定 nums = [0,0,1,1,1,1,2,3,3],</p>
<p>函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<hr>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>​    覆盖多余的重复项。由于题目要求原地操作，设置两个指针，一个为快指针，用来遍历整个数组，一个慢指针，用来记录数组的长度以及覆盖数组的位置下标。题目要求每个元素最多出现两次，则应该引入一个计数变量，记录元素出现的次数。</p>
<p>​    特别地，题目给的数组为已经排好序的数组，如果未排序，则需要引入一个hashmap来记录出现次数。</p>
<p>​    从下标1开始遍历，nums[i-1]  ?= nums[i] ：如果相等，则更新</p>
<p> 时间复杂度O(n)， 空间复杂度O(1)</p>
<h2 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-22 10:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode_80_remove_duplicates_from_sorted_array_ii</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>; <span class="comment">// 计数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length;  i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                c = <span class="number">1</span>;  <span class="comment">//复位</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( c &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                nums[p] = nums[i];</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> []nums = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">0,0,1,1,2,3,3,</span><br></pre></td></tr></table></figure>



<p>另外：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[index-<span class="number">2</span>] != nums[i])&#123;</span><br><span class="line">            nums[index++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展性，例如将上面的数字2    改为    3    ， 就变成了允许重复最多3次。</p>
<p>**相似题目： <a href="https://castile.github.io/Castile.github.io/2020/01/21/leetcode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">https:/Castile.github.io/2020/01/21/leetcode26-删除排序数组的重复项/</a> </p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>中等</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-990-等式方程的可满足性</title>
    <url>/2020/01/28/leetcode-990-%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 </p>
<p>示例 1：</p>
<p>输入：[“a==b”,”b!=a”]<br>输出：false<br>解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。<br>示例 2：</p>
<p>输出：[“b==a”，     “a==b”]<br>输入：true<br>解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。<br>示例 3：</p>
<p>输入：[“a==b”,”b==c”,”a==c”]<br>输出：true<br>示例 4：</p>
<p>输入：[“a==b”, “b!=c”,”c==a”]<br>输出：false<br>示例 5：</p>
<p>输入：[“c==c”, “b==d”, “x!=z”]<br>输出：true</p>
<p>链接：<a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations">https://leetcode-cn.com/problems/satisfiability-of-equality-equations</a></p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li><p>根据等式的传递性，可以想到使用并查集非常快速可以解决此题。动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，其实 <code>==</code> 关系也是一种等价关系，具有这些性质。所以这个问题用 Union-Find 算法就很自然。</p>
<p><strong>核心思想</strong>是，<strong>将</strong> <strong><code>equations</code></strong> <strong>中的算式根据</strong> <strong><code>==</code></strong> <strong>和</strong> <strong><code>!=</code></strong> <strong>分成两部分，先处理</strong> <strong><code>==</code></strong> <strong>算式，使得他们通过相等关系各自勾结成门派；然后处理</strong> <strong><code>!=</code></strong> <strong>算式，检查不等关系是否破坏了相等关系的连通性</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-28 21:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode990_SatisfiabilityOfEqualityEquations</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并查集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        UF uf = <span class="keyword">new</span> UF(<span class="number">26</span>); <span class="comment">// 26个字母</span></span><br><span class="line">        <span class="comment">// 所有等式连通</span></span><br><span class="line">        <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;=&#x27;</span>) &#123; <span class="comment">// 判断为等式</span></span><br><span class="line">                <span class="keyword">char</span> x = eq.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">char</span> y = eq.charAt(<span class="number">3</span>);</span><br><span class="line">                uf.union(x - <span class="string">&#x27;a&#x27;</span>, y - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断不等式会不会破坏连通性</span></span><br><span class="line">        <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;!&#x27;</span>) &#123; <span class="comment">// 判断为不等式</span></span><br><span class="line">                <span class="keyword">char</span> x = eq.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">char</span> y = eq.charAt(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">if</span> (uf.isSameSet(x - <span class="string">&#x27;a&#x27;</span>, y - <span class="string">&#x27;a&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] equations1 = &#123;<span class="string">&quot;c==c&quot;</span>, <span class="string">&quot;b==d&quot;</span>, <span class="string">&quot;x!=z&quot;</span>&#125;; </span><br><span class="line">        System.out.println(equationsPossible(equations1)); <span class="comment">// true</span></span><br><span class="line">        String[] equations2 = &#123;<span class="string">&quot;a==b&quot;</span>, <span class="string">&quot;b==c&quot;</span>, <span class="string">&quot;a==c&quot;</span>&#125;;</span><br><span class="line">        System.out.println(equationsPossible(equations2)); <span class="comment">// true</span></span><br><span class="line">        String[] equations3 = &#123;<span class="string">&quot;b==a&quot;</span>, <span class="string">&quot;a!=b&quot;</span>&#125;;</span><br><span class="line">        System.out.println(equationsPossible(equations3)); <span class="comment">// fasle</span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>dfs，图的联通性，染色问题，这是leetcode官方题解：</p>
<p>​        思路： 所有相互等于的变量能组成一个联通分量。举一个例子，如果 <code>a=b, b=c, c=d</code>，那么 <code>a, b, c, d</code> 就在同一个联通分量中，因为它们必须相等。 </p>
</li>
</ol>
<p>​        第一步，我们基于给定的等式，用深度优先遍历将每一个变量按照联通分量染色。</p>
<p>​    将联通分量染色之后，我们分析形如 a != b 的不等式。如果两个分量有相同的颜色，那么它们一定相等，因此    如果说它们不相等的话，就一定无法满足给定的方程组。返回false。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-28 21:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcode990_SatisfiabilityOfEqualityEquations</span> </span>&#123;</span><br><span class="line">    <span class="comment">//连通 染色</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equationsPossible_DFS</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[<span class="number">26</span>]; <span class="comment">// 26个字母</span></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等式进行连通</span></span><br><span class="line">        <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> x = eq.charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">char</span> y = eq.charAt(<span class="number">3</span>);</span><br><span class="line">                graph[x - <span class="string">&#x27;a&#x27;</span>].add(y - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                graph[y - <span class="string">&#x27;a&#x27;</span>].add(x - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] color = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]; <span class="comment">// 准备26种颜色</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[i] == <span class="number">0</span>) &#123; <span class="comment">// 第i个字母还没染色</span></span><br><span class="line">                t++; <span class="comment">// 增加一种颜色</span></span><br><span class="line">                Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">                s.push(i);</span><br><span class="line">                <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> node = s.pop();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> nn : graph[node]) &#123;<span class="comment">// 取出与node连通的所有点， 即取出等式两边的字母</span></span><br><span class="line">                        <span class="keyword">if</span> (color[nn] == <span class="number">0</span>) &#123;</span><br><span class="line">                            color[nn] = t; <span class="comment">// 连通的节点设置成相同的颜色</span></span><br><span class="line">                            s.push(nn); <span class="comment">//  将与之连通的节点进栈，实现等式传递性的功能</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查不等式的合法性</span></span><br><span class="line">        <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = eq.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> y = eq.charAt(<span class="number">3</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (x == y || color[x] != <span class="number">0</span> &amp;&amp; color[x] == color[y]) &#123; <span class="comment">// 字母相等，颜色相同的一定不满足不等关系</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] equations1 = &#123;<span class="string">&quot;c==c&quot;</span>, <span class="string">&quot;b==d&quot;</span>, <span class="string">&quot;x!=z&quot;</span>&#125;;</span><br><span class="line">       </span><br><span class="line">        String[] equations2 = &#123;<span class="string">&quot;a==b&quot;</span>, <span class="string">&quot;b==c&quot;</span>, <span class="string">&quot;a==c&quot;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        String[] equations3 = &#123;<span class="string">&quot;b==a&quot;</span>, <span class="string">&quot;a!=b&quot;</span>&#125;;</span><br><span class="line">     </span><br><span class="line">        System.out.println(equationsPossible_DFS(equations1)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(equationsPossible_DFS(equations2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(equationsPossible_DFS(equations3)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度： O(N)，其中 N是方程组 equations 的数量。</p>
<p>空间复杂度： O(1），认为字母表的大小是 O(1) 的。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>dfs</tag>
        <tag>并查集</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode26-删除排序数组的重复项</title>
    <url>/2020/01/21/leetcode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a></p>
</blockquote>
<p>示例 1:</p>
<p>给定数组 nums = [1,1,2], </p>
<p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2:</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以采用快慢指针，即双指针思路，这种方法在线性表查重，判断环上用的比较多。</p>
<img src="/2020/01/21/leetcode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/1579619435618.png" class title="双指针算法流程">

<p>​    数组完成排序后，我们可以放置两个指针 p 和q，其中p是慢指针，而 q 是快指针。只要 nums[p] = nums[q]，我们就增加 q以跳过重复项。当我们遇到 nums[p] ≠ nums[q] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[q]）的值复制到 nums[p+1]。然后递增 p，接着我们将再次重复相同的过程，直到q到达数组的末尾为止。</p>
<p>​    时间复杂度O(n),  空间复杂度O(1)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(q &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p] == nums[q])&#123;</span><br><span class="line">                q++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                nums[p+<span class="number">1</span>] = nums[q];</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span> ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关： <a href="https://castile.github.io/Castile.github.io/2020/01/22/leetcode-80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B92/">https:/Castile.github.io/2020/01/22/leetcode-80-删除排序数组的重复项2/</a> </p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode287_寻找重复数字</title>
    <url>/2020/09/02/leetcode287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="寻找重复数字"><a href="#寻找重复数字" class="headerlink" title="寻找重复数字"></a>寻找重复数字</h1><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p>示例 1:</p>
<p>输入: [1,3,4,2,2]<br>输出: 2<br>示例 2:</p>
<p>输入: [3,1,3,4,2]<br>输出: 3</p>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>使用环形链表II的方法解题（142.环形链表II），使用 142 题的思想来解决此题的关键是要理解如何将输入的数组看作为链表。</p>
<p>首先明确前提，整数的数组 nums 中的数字范围是 [1,n]。考虑一下两种情况：</p>
<p>如果数组中没有重复的数，以数组 [1,3,4,2]为例，我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)f(n)f(n)，<br>其映射关系 n-&gt;f(n)为：<br>0-&gt;1<br>1-&gt;3<br>2-&gt;4<br>3-&gt;2<br>我们从下标为 0 出发，根据 f(n)f(n)f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推，直到下标超界。这样可以产生一个类似链表一样的序列。<br>0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;null</p>
<p>如果数组中有重复的数，以数组 [1,3,4,2,2] 为例,我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)f(n)f(n)，<br>其映射关系 n-&gt;f(n) 为：<br>0-&gt;1<br>1-&gt;3<br>2-&gt;4<br>3-&gt;2<br>4-&gt;2<br>同样的，我们从下标为 0 出发，根据 f(n)计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推产生一个类似链表一样的序列。<br>0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;2-&gt;4-&gt;2-&gt;……</p>
<p><img src="/2020/09/02/leetcode287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/leetcode287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%5C1599056330724.png" alt="1599056330724"></p>
<p>从理论上讲，数组中如果有重复的数，那么就会产生多对一的映射，这样，形成的链表就一定会有环路了。</p>
<p>综上:</p>
<p>1.数组中有一个重复的整数-&gt;链表中存在环</p>
<p>2.找到数组中的重复整数 -&gt;找到链表的环入口</p>
<p>至此，问题转换为 142 题。那么针对此题，快、慢指针该如何走呢。根据上述数组转链表的映射关系，可推出<br>142 题中慢指针走一步 slow = slow.next ==&gt; 本题 slow = nums[slow]<br>142 题中快指针走两步 fast = fast.next.next ==&gt; 本题 fast = nums[nums[fast]]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = slow;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != q)&#123;</span><br><span class="line">            p = nums[p];</span><br><span class="line">            q = nums[q];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><p>二分法的思路是先猜一个数（有效范围 [left, right]里的中间数 mid），然后统计原始数组中小于等于这个中间数的元素的个数 cnt，如果 cnt 严格大于 mid，（注意我加了着重号的部分「小于等于」、「严格大于」）。根据抽屉原理，重复元素就在区间 [left, mid] 里；</p>
<p>以 [2, 4, 5, 2, 3, 1, 6, 7] 为例，一共 8 个数，n + 1 = 8，n = 7，根据题目意思，每个数都在 1 和 7 之间。</p>
<p>例如：区间[1,7]的中位数是 4，遍历整个数组，统计小于等于 4 的整数的个数，如果不存在重复元素，最多为 4 个。等于 4 的时候区间 [1,4] 内也可能有重复元素。但是，如果整个数组里小于等于 4 的整数的个数严格大于 4 的时候，就可以说明重复的数存在于区间[1,4]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="comment">// 在 Java 里可以这么用，当 left + right 溢出的时候，无符号右移保证结果依然正确</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据抽屉原理，小于等于 4 的个数如果严格大于 4 个</span></span><br><span class="line">            <span class="comment">// 此时重复元素一定出现在 [1, 4] 区间里</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; mid) &#123;</span><br><span class="line">                <span class="comment">// 重复元素位于区间 [left, mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// if 分析正确了以后，else 搜索的区间就是 if 的反面</span></span><br><span class="line">                <span class="comment">// [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/">https://leetcode-cn.com/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/</a></li>
<li><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/">https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode42接雨水</title>
    <url>/2020/10/04/leetcode42%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="/2020/10/04/leetcode42%E6%8E%A5%E9%9B%A8%E6%B0%B4/leetcode42%E6%8E%A5%E9%9B%A8%E6%B0%B4%5C1601803740558.png" alt="1601803740558"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）</p>
<p>示例:</p>
<p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]</p>
<p>输出: 6</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于每一个位置，该位置能装最大的雨水与两边中最大高度中的最小值有关系。</p>
<p>即要先求出min{lmax， rmax}。我们只需要找到左边的最大和右边的最大高度就行。</p>
<p>该位置能接到的雨水就是其高度差。</p>
<p>注意： 第一个格子和最后一个格子不能接到雨水。</p>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>时间复杂度为O(N^2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n -<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> lmax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> rmax = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//找右边的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">                rmax = Math.max(rmax, height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左边的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                lmax = Math.max(lmax, height[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res += Math.min(lmax, rmax)- height[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种太暴力了，每次都得重新计算当前位置的左边最大和右边最大，不如先将每个位置的左边最大和右边最大都保存下来啊，这样就不用每次重新计算了，可能降低时间复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height == <span class="keyword">null</span> || height.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">int</span>[] lmax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] rmax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        lmax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        rmax[n-<span class="number">1</span>] = height[n-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 从左往右计算lmax</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            lmax[i] = Math.max(height[i], lmax[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右往左计算右边最大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            rmax[i] = Math.max(height[i], rmax[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n -<span class="number">1</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">            res += Math.min(lmax[i], rmax[i])- height[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>使用双指针边走边算，减少空间 复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.length == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">int</span>  left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right  = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l_max=height[<span class="number">0</span>], r_max = height[n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            l_max = Math.max(l_max, height[left]);</span><br><span class="line">            r_max = Math.max(r_max, height[right]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l_max &lt; r_max)&#123;</span><br><span class="line">                ans += l_max - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans +=  r_max  - height[right];     </span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>CVPR2017:Learning Video Object Segmentation with Visual Memory</title>
    <url>/2021/07/23/lvo/</url>
    <content><![CDATA[<h1 id="Learning-Video-Object-Segmentation-with-Visual-Memory"><a href="#Learning-Video-Object-Segmentation-with-Visual-Memory" class="headerlink" title="Learning Video Object Segmentation with Visual Memory"></a>Learning Video Object Segmentation with Visual Memory</h1><p>此论文也是旨在解决运动目标分割任务。引入<code>two-stream</code>网络，同时带有一个memory module。Memory module用来捕获视频中目标的演化，由<code>convolutional gated recurrent     units</code>（<code>ConvGRU</code>）构成。Two stream包括appearance stream和temporal stream。 网络的两个流分别在视频序列中学习空间和时序特征。</p>
<p> 使用双流网络的思路是利用外观和运动的互补性来构建随着时间推移而发展的对象的强大表示。例如，当一个物体在场景中移动时，外观和运动网络都是同样有效的，但是一旦它变成静止的，运动网络就不能像外观网络一样估计这个物体。 </p>
<h1 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h1><ol>
<li><p>present an approach for moving object segmentation in unconstrained videos that does not require any manually-annotated frames in the input video。网络结构包含 memory unit，this is the first recurrent network based approach to accomplish the video segmentation task。</p>
</li>
<li><p>在DAVIS和Freiburg-Berkeley两个数据集上得到state-of-the-art的结果。</p>
</li>
</ol>
<h1 id="Networks"><a href="#Networks" class="headerlink" title="Networks"></a>Networks</h1><p><img src="/2021/07/23/lvo/lvo%5C1589620901182.png" alt="1589620901182"></p>
<ol>
<li><p>Appearance stream：采用DeepLab网络，在PASCAL VOC上预训练过。取视频的一帧作为输入,输出一个大小为 128 x w/8 x h/8的预测特征。deeplab网络的aspp模块使得特征保持了一个相对较高的特征空间分辨率，并且在每个像素的表示中包含上下文信息。 </p>
<p>使用fc6层，每个像素的特征维度为1024， 然后经过两个1x1的卷积层，tanh非线性操作，将通道降至128维。这些层和ConvGRU一起训练。</p>
</li>
<li><p>Temporal stream：是一个motion prediction network，网络采用MPNet（作者之前的工作），在FlyingThings3D 上预训练过。光流作为motion network的输入，产生一个w/4 x h/4 的运动预测， 其中每个值表示对应像素运动的可能性。 </p>
</li>
<li><p>Memory module：由convolutional gated units (ConvGRU)构成。两条分支的输出结果concat在一起，作为Conv GRU的输入。</p>
</li>
<li><p>Bidirectional processing：考虑到视频存在这样的情况：目标前几帧是静止的，后面才开始移动。作者的方法前向处理不能分割好初始帧的目标，因为缺少prior memory representation of the object in the first frame。所以采取双向处理的方式。</p>
</li>
</ol>
<h1 id="Visual-memory-module"><a href="#Visual-memory-module" class="headerlink" title="Visual memory module"></a>Visual memory module</h1><img src="/2021/07/23/lvo/1589625015211.png" class width="1589625015211">

<p> ConvGRU模块的关键部分是是状态矩阵h ，对于帧 $ t $  , ConvGRU使用双流网络中融合后的特征 $x_t$ 和 前一个状态 $h_{t-1} $ 来计算新的状态 $ h_t $。 通过一个更新门 $z_t$ 和遗忘门 $r_t$ 来进行动态的计算。这些状态和门都是3D的张量，可以刻画视频序列中的时空特征，有效的记忆运动的目标个目标的位置。公式如下：</p>
<p><img src="/2021/07/23/lvo/lvo%5C1589625514607.png" alt="1589625514607"></p>
<p>更新门 $z_t$   决定将多少记忆合并到新状态 ，遗忘门 $r_t$ 控制前一个状态的影响。 也就是说有多少先前的状态被允许进入候选记忆。  如果$r_t$接近于零，则该单元将忘记先前计算的状态 $ h_{t-1}$ </p>
<p> 一个像素的视觉记忆表示不仅取决于输入和该像素处的前一状态，还取决于它的局部邻域。增加卷积内核的大小允许模型处理更大运动的时空模式。 </p>
<p> 综上所述，该模型学习将当前帧的外观特征与记忆的视频表示相结合，以细化运动预测，甚至在运动对象变为静止时的情况下，他可以完全恢复之前的观察结果到的状态。</p>
<h1 id="Bidirectional-processing"><a href="#Bidirectional-processing" class="headerlink" title="Bidirectional processing"></a>Bidirectional processing</h1><p> 考虑这样一个例子:一个物体在视频序列的开始是静止的，然后在后面的帧中开始移动。 前面描述的方法，即按顺序处理视频帧(正向)，不能在初始帧中分割对象。这是因为在第一帧中缺少对象的预先记忆表示。受双向循环模型在语音领域的应用启发，我们使用双向处理步骤来改进我们的框架。</p>
<img src="/2021/07/23/lvo/1589629589848.png" class width="1589629589848">

<p>由两个并行的ConvGRU，第一个从第一帧开始前向处理，第二个从最后一帧开始后向处理。  为了生成一个128 x w/8 x h/8 的输出，在每一个时间步将来自两个方向的激活输出被串接起来。然后通过一个3x3的卷积操作，产生一个64 x w/8 x h/8 的特征图，最后连接一个1x1的卷积层和softmax分类层得到最终的二值分割掩码。这个双向的ConvGRU在训练和测试中均会用到。这考虑了整个视频序列的信息。【<strong>ps: 但是对于场景发生变化的情况下，这样的似乎不太合理。。。</strong>】</p>
<p>在实验部分展示了双向处理能够带来将近3%的提升（在DAVIS数据集上）， 双向处理对FBMS数据集的影响更为突出，在FBMS数据集中，前景目标在视频开始时可以是静态的，比单向处理改进了5% 。</p>
<h1 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h1><p>一个ConvGRU 模型有6个卷积层，视频序列长度为n，一共需要6n个卷积层，双向的话，就需要12n个卷积层。 这种内存需求使得端到端训练整个模型(包括外观和运动流)变得不可行。我们求助于使用预先训练过的外观和运动网络，并对ConvGRU进行训练。 </p>
<p> 使用DAVIS数据集的训练集来学习ConvGRU权重 ，Davis数据集中视频序列的每一帧都是运动的， 这使记忆模块倾向于不间断运动流的存在。 当一个对象在测试序列中停止移动时， 这导致了ConvGRU从失败的数据中学到的教训 。  我们增加了训练数据来模拟这种走走停停的场景，从而为真实的视频学习一个更健壮的模型。 </p>
<p>创建一个新的训练序列，最后5帧是重复的，用来模拟目标停止运动，其他帧的ground-truth不变， 最后五帧没有使用任何运动输入。这些收工处理的数据以一个固定比例的迭代代替常规的样本。 </p>
<p> 鉴于ground truth segmentation决定了训练的损失，即，它用于所有的帧，ConvGRU显式地记忆序列的初始部分的移动对象，然后在运动缺失的帧分割它。 </p>
<p> 我们通过在批处理中复制前五帧来进行类似的训练集扩展，以模拟在视频开始时对象是静态的情况。 </p>
<h1 id="其他训练细节"><a href="#其他训练细节" class="headerlink" title="其他训练细节"></a>其他训练细节</h1><ol>
<li><p>loss：   binary cross entropy   </p>
</li>
<li><p>optimzier： RMSProp</p>
</li>
<li><p>lr : 1e-4</p>
</li>
<li><p>weight decay:0.005</p>
</li>
<li><p>所有卷积层(ConvGRU内部的层除外)的初始化都是使用标准的xavier方法完成的.</p>
</li>
<li><p>在每次更新参数之前，进行梯度裁剪，使其位于预定义的范围内，以避免数值问题 。</p>
</li>
<li><p>数据： 随机选择一个视频序列，选择连续的14帧作为一个batch</p>
</li>
<li><p>7 × 7 convolutions in all the ConvGRU operations  </p>
</li>
<li><p>对模型进行30000次迭代训练，并将含有附加序列的批次比例设置为20%。</p>
</li>
<li><p> 使用一个完全连接的CRF来在后处理步骤中细化边界。 </p>
</li>
</ol>
<h1 id="Ablation-Study"><a href="#Ablation-Study" class="headerlink" title="Ablation Study"></a>Ablation Study</h1><p>在Davis数据集中不同的组件的影响：</p>
<img src="/2021/07/23/lvo/1589638571306.png" class width="1589638571306">



<h1 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h1><h2 id="On-Davis2016"><a href="#On-Davis2016" class="headerlink" title="On Davis2016"></a>On Davis2016</h2><img src="/2021/07/23/lvo/1589637907049.png" class width="1589637907049">



<h2 id="On-FBMS"><a href="#On-FBMS" class="headerlink" title="On FBMS"></a>On FBMS</h2><img src="/2021/07/23/lvo/1589637950756.png" class width="1589637950756">



<p><img src="/2021/07/23/lvo/lvo%5C1589638822304.png" alt="1589638822304"></p>
<img src="/2021/07/23/lvo/1589638874575.png" class width="1589638874575">

]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>papers</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis代理Dao的执行过程-源码分析</title>
    <url>/2020/06/20/mybatis%E4%BB%A3%E7%90%86dao/</url>
    <content><![CDATA[<h1 id="代理Dao执行过程"><a href="#代理Dao执行过程" class="headerlink" title="代理Dao执行过程"></a>代理Dao执行过程</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取配置文件，生成字节输入流</span></span><br><span class="line">    in = Resources.getResourceAsStream(<span class="string">&quot;SQLMapConfig.xml&quot;</span>);  <span class="comment">//名字不区分大小写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建SQLSessionfactory</span></span><br><span class="line">    builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    factory = builder.build(in);</span><br><span class="line">    <span class="comment">// 构建SQLSession</span></span><br><span class="line">    sqlSession = factory.openSession();</span><br><span class="line">    dao = sqlSession.getMapper(UserDao.class);  <span class="comment">// 获取 代理Dao</span></span><br></pre></td></tr></table></figure>

<img src="/2020/06/20/mybatis%E4%BB%A3%E7%90%86dao/1592630241162.png" class width="1592630241162">

<ol>
<li><p>首先进入DefaultSqlSession类里面的getMapper()f方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> configuration.&lt;T&gt;getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进入到configuration类中去调用getMapper方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>mapperRegistry.getMapper(type, sqlSession) 通过一个代理工厂返回一个代理对象。</p>
</li>
</ol>
<img src="/2020/06/20/mybatis%E4%BB%A3%E7%90%86dao/1592630806594.png" class width="1592630806594">

<ol start="4">
<li><p>来看看这个代理工厂内部做了啥子: <code>MapperProxyFactory.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 动态代理</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy); <span class="comment">// mapperProxy代理的对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);  <span class="comment">// 调用了上面的newInstance方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2020/06/20/mybatis%E4%BB%A3%E7%90%86dao/1592631216795.png" class width="1592631216795">

<p>MapperProxy实现了InvocationHandler接口。重写invoke方法，内部调用被代理类的对应方法。</p>
<img src="/2020/06/20/mybatis%E4%BB%A3%E7%90%86dao/1592635173908.png" class width="1592635173908"></li>
<li><p>最后执行这个方法的execute方法，看看这个方法：</p>
<img src="/2020/06/20/mybatis%E4%BB%A3%E7%90%86dao/1592635440415.png" class width="1592635440415">

<p>可以看到会调用对应的CRUD操作。</p>
</li>
<li><p>调用Dao的findByName方法， 返回一个User对象，所以执行SelectOne方法</p>
<img src="/2020/06/20/mybatis%E4%BB%A3%E7%90%86dao/1592635622302.png" class width="1592635622302">

<p>里面是调用SelectList方法，然后返回结果的第一个</p>
</li>
</ol>
<img src="/2020/06/20/mybatis%E4%BB%A3%E7%90%86dao/1592635692160.png" class width="1592635692160">





<h1 id="完整过程图"><a href="#完整过程图" class="headerlink" title="完整过程图"></a>完整过程图</h1><img src="/2020/06/20/mybatis%E4%BB%A3%E7%90%86dao/%E4%BB%A3%E7%90%86dao%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" class>





]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis缓存</title>
    <url>/2020/06/20/mybatis%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h1><p>像大多数的持久化框架一样，<code>Mybatis</code> 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提 高性能。 <code>Mybatis</code> 中缓存分为一级缓存，二级缓存。 但是在默认的情况下， 只开启一级缓存 。</p>
<h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><p>一级缓存是 <code>SqlSession</code> 级别的缓存，只要 <code>SqlSession</code> 没有 <code>flush</code> 或 <code>close</code>，它就存在。 </p>
<h2 id="1-证明一级缓存的存在"><a href="#1-证明一级缓存的存在" class="headerlink" title="1. 证明一级缓存的存在"></a>1. 证明一级缓存的存在</h2><p>首先在一个test里面重复两次相同的查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;第一次查询&quot;</span>);</span><br><span class="line">       User castille = dao.findByName(<span class="string">&quot;Castille&quot;</span>);</span><br><span class="line">       System.out.println(castille);</span><br><span class="line">       System.out.println(<span class="string">&quot;第二次查询&quot;</span>);</span><br><span class="line">       User castille1 = dao.findByName(<span class="string">&quot;Castille&quot;</span>);</span><br><span class="line">       System.out.println(castille1);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后执行查询，查看日志输出：</p>
<img src="/2020/06/20/mybatis%E7%BC%93%E5%AD%98/1592642475121.png" class width="1592642475121">

<p>我们可以发现，虽然在上面的代码中我们查询了两次，但最后只执行了一次数据库操作，这就是 Mybatis 提 供给我们的一级缓存在起作用了。因为一级缓存的存在，导致第二次查询 name为castille 的记录时，并没有发出sql语句 从数据库中查询数据，而是从一级缓存中查询。 </p>
<h2 id="2-一级缓存的分析"><a href="#2-一级缓存的分析" class="headerlink" title="2. 一级缓存的分析"></a>2. 一级缓存的分析</h2><p>一级缓存是 <code>SqlSession</code> 范围的缓存，当调用 <code>SqlSession</code> 的修改，添加，删除，<code>commit()</code>，<code>close()</code>等方法时，就会清空一级缓存。 </p>
<img src="/2020/06/20/mybatis%E7%BC%93%E5%AD%98/1592642980076.png" class width="1592642980076">

<p>第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从<strong>数据库</strong>查 询用户信息。 得到用户信息，将用户信息存储到<strong>一级缓存</strong>中。  如果 <code>sqlSession</code> 去执行 commit 操作（执行插入、更新、删除），清空 <code>SqlSession</code> 中的一级缓存，<strong>这样 做的目的为了让缓存中存储的是最新的信息，避免脏读</strong>。 第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存 中获取用户信息。</p>
<h2 id="3-测试一级缓存的清空"><a href="#3-测试一级缓存的清空" class="headerlink" title="3. 测试一级缓存的清空"></a>3. 测试一级缓存的清空</h2><h3 id="使用-sqlSession-clearCache-清空缓存"><a href="#使用-sqlSession-clearCache-清空缓存" class="headerlink" title="使用 sqlSession.clearCache()清空缓存"></a>使用 sqlSession.clearCache()清空缓存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次查询&quot;</span>);</span><br><span class="line">        User castille = dao.findByName(<span class="string">&quot;Castille&quot;</span>);</span><br><span class="line">        System.out.println(castille);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        dao = sqlSession.getMapper(UserDao.class); //  重新获得SQLSession</span></span><br><span class="line">        sqlSession.clearCache(); <span class="comment">// 清空缓存</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第二次查询&quot;</span>);</span><br><span class="line">        User castille1 = dao.findByName(<span class="string">&quot;Castille&quot;</span>);</span><br><span class="line">        System.out.println(castille1);</span><br></pre></td></tr></table></figure>

<img src="/2020/06/20/mybatis%E7%BC%93%E5%AD%98/1592643351825.png" class width="1592643351825">

<p>可以看到上述结果，执行了两次的sql语句的查询。因为一级缓存被清空了，所以第二次查询需要在数据库中查询。</p>
<h3 id="做了更新操作"><a href="#做了更新操作" class="headerlink" title="做了更新操作"></a>做了更新操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;第一次查询&quot;</span>);</span><br><span class="line">       User ke = dao.findByName(<span class="string">&quot;keke&quot;</span>);</span><br><span class="line">       System.out.println(ke);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 更新操作</span></span><br><span class="line">       dao.updateStatus(ke);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;第二次查询&quot;</span>);</span><br><span class="line">       User keke = dao.findByName(<span class="string">&quot;keke&quot;</span>);</span><br><span class="line">       System.out.println(keke);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2020/06/20/mybatis%E7%BC%93%E5%AD%98/1592643670164.png" class width="1592643670164">

<h3 id="不同的sqlSession"><a href="#不同的sqlSession" class="headerlink" title="不同的sqlSession"></a>不同的sqlSession</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCache1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次查询&quot;</span>);</span><br><span class="line">        User ke = dao.findByName(<span class="string">&quot;keke&quot;</span>);</span><br><span class="line">        System.out.println(ke);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        再次获得sqlSession</span></span><br><span class="line">        sqlSession = factory.openSession();</span><br><span class="line">        dao = sqlSession.getMapper(UserDao.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第二次查询&quot;</span>);</span><br><span class="line">        User keke = dao.findByName(<span class="string">&quot;keke&quot;</span>);</span><br><span class="line">        System.out.println(keke);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/20/mybatis%E7%BC%93%E5%AD%98/1592643910357.png" class width="1592643910357">



<hr>
<h1 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h1><h2 id="1-二级缓存结构图"><a href="#1-二级缓存结构图" class="headerlink" title="1. 二级缓存结构图"></a>1. 二级缓存结构图</h2><img src="/2020/06/20/mybatis%E7%BC%93%E5%AD%98/1592644273859.png" class width="1592644273859">

<p>二级缓存是 <code>mapper</code> 映射级别的缓存，多个 <code>SqlSession</code> 去操作同一个 <code>Mapper</code> 映射的 <code>sql</code> 语句，多个 <code>SqlSession</code> 可以共用二级缓存，二级缓存是跨 <code>SqlSession</code> 的。或者说 二级缓存存在于 <code>SqlSessionFactory</code> 生命周期中。 </p>
<p>首先开启 <code>mybatis</code> 的二级缓存。  <code>sqlSession1</code>去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。</p>
<p>如果 <code>SqlSession3</code> 去执行相同 <code>mapper</code> 映射下 <code>sql</code>，执行 <code>commit</code> 提交，将会清空该 <code>mapper</code> 映射下的二级缓存区域的数据。 </p>
<p><code>sqlSession2</code> 去查询与 <code>sqlSession1</code> 相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从 缓存中取出数据。</p>
<h2 id="2-二级缓存的开启与关闭"><a href="#2-二级缓存的开启与关闭" class="headerlink" title="2.  二级缓存的开启与关闭"></a>2.  二级缓存的开启与关闭</h2><ul>
<li><p>第一步：在 <code>SqlMapConfig.xml</code> 文件开启二级缓存 </p>
<p>因为 <code>cacheEnabled</code> 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为 false 代表不开启二级缓存。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span> </span><br><span class="line"> <span class="comment">&lt;!-- 开启二级缓存的支持 --&gt;</span>  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">settings</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
<li><p>第二步：配置相关的 <code>Mapper</code> 映射文件 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>     <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>     <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.hongliang.dao.UserDao&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 开启二级缓存的支持 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line">&lt;/mapper</span><br></pre></td></tr></table></figure>

<p><cache>标签表示当前这个 <code>mapper</code> 映射将使用二级缓存，区分的标准就看 <code>mapper</code> 的 <code>namespace</code> 值。 </cache></p>
</li>
<li><p>第三步：配置 <code>statement</code> 上面的 <code>useCache</code> 属性 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;cn.hongliang.beans.User&quot;</span>  <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">       select * from tab_user where username = #&#123;username&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将 <code>UserDao.xml</code> 映射文件中的<select>标签中设置 <code>useCache=”true”</code>代表当前这个 <code>statement</code> 要使用 二级缓存，如果不使用二级缓存可以设置为 <code>false</code></select></p>
<p><strong>注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。</strong> </p>
</li>
</ul>
<h2 id="3-二级缓存测试"><a href="#3-二级缓存测试" class="headerlink" title="3. 二级缓存测试"></a>3. 二级缓存测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCachelevel2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次查询&quot;</span>);</span><br><span class="line">        User ke = dao.findByName(<span class="string">&quot;keke&quot;</span>);</span><br><span class="line">        System.out.println(ke);</span><br><span class="line"></span><br><span class="line">        sqlSession.close(); <span class="comment">// 一级缓存关闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        再次获得sqlSession</span></span><br><span class="line">        SqlSession sqlSession2 = factory.openSession();</span><br><span class="line">        dao = sqlSession2.getMapper(UserDao.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;第二次查询&quot;</span>);</span><br><span class="line">        User keke = dao.findByName(<span class="string">&quot;keke&quot;</span>);</span><br><span class="line">        System.out.println(keke);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/06/20/mybatis%E7%BC%93%E5%AD%98/1592647257025.png" class width="1592647257025">

<p>经过上面的测试，我们发现执行了两次查询，并且在执行第一次查询后，我们关闭了一级缓存，再去执行第二 次查询时，我们发现并没有对数据库发出 <code>sql</code> 语句，所以此时的数据就只能是来自于我们所说的二级缓存。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--     开启二级缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>&gt;</span>&lt;/cac</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意上面的<code>readonly</code>。readOnly 为只读属性， 默认为 false</p>
<blockquote>
<p>false: 可读写， 在创建对象时， 会通过反序列化得到缓存对象的拷贝。 因此在速度上会相对慢一点， 但重在安全。</p>
<p>true: 只读， 只读的缓存会给所有调用者返回缓存对象的相同实例。 因此性能很好， 但如果修改了对象， 有可能会导致程序出问题。</p>
</blockquote>
<p>所以使用readOnly=true的话，返回的是同一个实例，如果为false的话，则会反序列一个新的实例，则是不同的对象。</p>
<p><strong>注意</strong>：<strong>当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化 方式来保存对象</strong>。</p>
<h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h2><ol>
<li><p>由于在更新时会刷新缓存， 因此需要注意使用场合：查询频率很高， 更新频率很低时使用， 即经常使用 <code>select</code>, 相对较少使用<code>delete</code>, <code>insert</code>, <code>update</code>。</p>
</li>
<li><p>缓存是以 <code>namespace</code> 为单位的，不同 <code>namespace</code> 下的操作互不影响。但刷新缓存是刷新整个 <code>namespace</code> 的缓存， 也就是你 <code>update</code> 了一个， 则整个缓存都刷新了。</p>
</li>
<li><p>最好在 <strong>「只有单表操作」</strong> 的表的 <code>namespace</code> 使用缓存， 而且对该表的操作都在这个 <code>namespace</code> 中。 否则可能会出现数据不一致的情况。</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/weixin_37139197/article/details/82908377">https://blog.csdn.net/weixin_37139197/article/details/82908377</a> </li>
</ol>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL语句执行过程</title>
    <url>/2021/07/23/mysql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="查询语句执行过程分析"><a href="#查询语句执行过程分析" class="headerlink" title="查询语句执行过程分析"></a>查询语句执行过程分析</h1><h2 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h2><img src="/2021/07/23/mysql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/MySQL%E6%9E%B6%E6%9E%84.png" class width="1599038113904">

<p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。 </p>
 <img src="/2021/07/23/mysql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/0d2070e8f84c4801adbfa03bda1f98d9.png" class title="img">

<p> Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 </p>
<p> 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。 </p>
<h2 id="1-MySQL的框架有几个组件-各是什么作用"><a href="#1-MySQL的框架有几个组件-各是什么作用" class="headerlink" title="1. MySQL的框架有几个组件, 各是什么作用?"></a>1. MySQL的框架有几个组件, 各是什么作用?</h2><p>连接器：负责跟客户端建立连接、获取权限、维持和管理连接。</p>
<p>查询缓存：查询请求先访问缓存(key 是查询的语句，value 是查询的结果)。命中直接返回。不推荐使用缓存，更新会把缓存清除(关闭缓存：参数 query_cache_type 设置成 DEMAND)。</p>
<p>分析器：对 SQL 语句做解析，判断sql是否正确。</p>
<p>优化器：决定使用哪个索引，多表关联（join）的时候，决定各个表的连接顺序。</p>
<p>执行器：执行语句，先判断用户有无查询权限，使用表定义的存储引擎。</p>
<h2 id="2-使用查询缓存就一定好么？"><a href="#2-使用查询缓存就一定好么？" class="headerlink" title="2. 使用查询缓存就一定好么？"></a>2. 使用查询缓存就一定好么？</h2><p>大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利</p>
<p><strong>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空</strong>。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。 </p>
<p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。分析器 </p>
<h2 id="3-Server层和存储引擎层各是什么作用"><a href="#3-Server层和存储引擎层各是什么作用" class="headerlink" title="3. Server层和存储引擎层各是什么作用?"></a>3. Server层和存储引擎层各是什么作用?</h2><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
<h2 id="3-you-have-an-error-in-your-SQL-syntax-这个保存是在词法分析里还是在语法分析里报错"><a href="#3-you-have-an-error-in-your-SQL-syntax-这个保存是在词法分析里还是在语法分析里报错" class="headerlink" title="3. you have an error in your SQL syntax 这个保存是在词法分析里还是在语法分析里报错?"></a>3. you have an error in your SQL syntax 这个保存是在词法分析里还是在语法分析里报错?</h2><p>语法分析</p>
<h2 id="4-对于表的操作权限验证在哪里进行"><a href="#4-对于表的操作权限验证在哪里进行" class="headerlink" title="4. 对于表的操作权限验证在哪里进行?"></a>4. 对于表的操作权限验证在哪里进行?</h2><p>执行器</p>
<h2 id="5-执行器的执行查询语句的流程是什么样的"><a href="#5-执行器的执行查询语句的流程是什么样的" class="headerlink" title="5. 执行器的执行查询语句的流程是什么样的?"></a>5. 执行器的执行查询语句的流程是什么样的?</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>先判断是否有该表的操作权限，有则进行下面的操作，没有则报错</p>
<p>1）调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</p>
<p>2)调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</p>
<p>3）执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p>
<p>答案： 分析器。 有人回答执行器，原因是这个时候才打开表获取数据，但是表的字段不是数据啊，是事先定义好的，所以可以直接读取的，不需要打开表。</p>
<p>那么，分析器的作用就是就是对你输入的sql字符串进行词法分析，这时候会检查你的表名，列名等。在Oracle数据库中会在分析阶段判断语句是否正确，表是否存在，列是否存在，mysql也借鉴了其设计思想。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的连接查询</title>
    <url>/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="MySQL中的连接查询"><a href="#MySQL中的连接查询" class="headerlink" title="MySQL中的连接查询"></a>MySQL中的连接查询</h1><p>一共有7大连接查询，如下图所示</p>
<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/join.png" class width="1595849491367">

<p>通过举例来理解吧。</p>
<h1 id="建库建表"><a href="#建库建表" class="headerlink" title="建库建表"></a>建库建表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE test;</span><br><span class="line">CREATE TABLE `t_dept` (</span><br><span class="line"> `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line"> `deptName` VARCHAR(30) DEFAULT NULL,</span><br><span class="line"> `address` VARCHAR(40) DEFAULT NULL,</span><br><span class="line"> PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"> </span><br><span class="line">CREATE TABLE `t_emp` (</span><br><span class="line"> `id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line"> `name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">  `age` INT(3) DEFAULT NULL,</span><br><span class="line"> `deptId` INT(11) DEFAULT NULL,</span><br><span class="line">empno INT  NOT NULL,</span><br><span class="line"> PRIMARY KEY (`id`),</span><br><span class="line"> KEY `idx_dept_id` (`deptId`)</span><br><span class="line"> #CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">INSERT INTO t_dept(deptName,address) VALUES(&#x27;华山&#x27;,&#x27;华山&#x27;);</span><br><span class="line">INSERT INTO t_dept(deptName,address) VALUES(&#x27;丐帮&#x27;,&#x27;洛阳&#x27;);</span><br><span class="line">INSERT INTO t_dept(deptName,address) VALUES(&#x27;峨眉&#x27;,&#x27;峨眉山&#x27;);</span><br><span class="line">INSERT INTO t_dept(deptName,address) VALUES(&#x27;武当&#x27;,&#x27;武当山&#x27;);</span><br><span class="line">INSERT INTO t_dept(deptName,address) VALUES(&#x27;明教&#x27;,&#x27;光明顶&#x27;);</span><br><span class="line"> INSERT INTO t_dept(deptName,address) VALUES(&#x27;少林&#x27;,&#x27;少林寺&#x27;);</span><br><span class="line"> </span><br><span class="line">INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;风清扬&#x27;,90,1,100001);</span><br><span class="line">INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;岳不群&#x27;,50,1,100002);</span><br><span class="line">INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;令狐冲&#x27;,24,1,100003);</span><br><span class="line"> </span><br><span class="line">INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;洪七公&#x27;,70,2,100004);</span><br><span class="line">INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;乔峰&#x27;,35,2,100005);</span><br><span class="line">INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;灭绝师太&#x27;,70,3,100006);</span><br><span class="line">INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;周芷若&#x27;,20,3,100007);</span><br><span class="line">INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;张三丰&#x27;,100,4,100008);</span><br><span class="line">INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;张无忌&#x27;,25,5,100009);</span><br><span class="line">INSERT INTO t_emp(NAME,age,deptId,empno) VALUES(&#x27;韦小宝&#x27;,18,NULL,100010);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_emp;  # 10</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595849668178.png" class width="1595849668178">

<p>一共有10条记录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_dept; # 6</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595849721471.png" class width="1595849721471">

<p>部门有6条记录，表示六大门派</p>
<h1 id="七大连接查询"><a href="#七大连接查询" class="headerlink" title="七大连接查询"></a>七大连接查询</h1><h2 id="AB共同"><a href="#AB共同" class="headerlink" title="AB共同"></a>AB共同</h2><p>即查询两张表中共同的部分，即上图的交集。</p>
<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595849830472.png" class width="1595849830472">

<p>查询所有 有门派的人员信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_emp a INNER JOIN t_dept b ON a.`deptId` = b.`id`;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595849891913.png" class width="1595849891913">

<p>从结果中发现，门派表中的“少林”与员工表的“韦小宝”不在查询结果中。只查询了两表的交集部分。<strong>因为韦小宝不属于任何门派，而员工表中没有少林派的人员。</strong></p>
<hr>
<h2 id="A的全集"><a href="#A的全集" class="headerlink" title="A的全集"></a>A的全集</h2><img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595850195107.png" class width="1595850195107">



<p>列出<strong>所有用户</strong>，并显示其机构信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_emp a LEFT JOIN t_dept b ON a.`deptId` = b.`id`;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595850168894.png" class width="1595850168894">

<p>要求列出所有的用户，应该使用<strong>左连接</strong>， 员工表为主表，将主表 中的数据全部查询出来，从表是部门表，与员工表不对应的部分查询为NULL。</p>
<hr>
<h2 id="B的全集"><a href="#B的全集" class="headerlink" title="B的全集"></a>B的全集</h2><img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595850318926.png" class width="1595850318926">

<p>列出<strong>所有门派</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_emp a RIGHT JOIN t_dept b ON a.`deptId` = b.`id`;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595850437923.png" class width="1595850437923">

<p>上述结果中，将所有的门派查询出来了，右边的表为主表，而左边的员工表中，有匹配的就查询，无匹配的就填充NULL。</p>
<h2 id="A的独有"><a href="#A的独有" class="headerlink" title="A的独有"></a>A的独有</h2><p>所谓A的独占就是说查询出来的结果中只在A表中出现的记录，B表中无匹配。</p>
<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595850639381.png" class width="1595850639381">

<p>相当于A的全集中将中间的“抠掉”,  也就是说将两表的公共部分去掉。其标准查询模板是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select &lt;select list&gt; from A left join B on a.key = b.key where b.key IS NULL;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595850944340.png" class width="1595850944340">

<p>如： 查询所有不入门派的人员, 我们需要做的就是将上面红框部分的去掉，获取剩下的蓝色框部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_emp a LEFT JOIN t_dept b ON a.`deptId` = b.`id` WHERE b.`id` IS NULL;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595851034531.png" class width="1595851034531">

<hr>
<h2 id="B的独有"><a href="#B的独有" class="headerlink" title="B的独有"></a>B的独有</h2><img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595851127637.png" class width="1595851127637">

<p>同上的分析。相当于B的全集中将中间的“抠掉”,  也就是说将两表的公共部分去掉，或者说我要去的B的独有部分，A 就没啥事情了，将B全集中结果去掉A的那部分就是B的独有了。其标准查询模板是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select &lt;select list&gt; from A right join B on a.key = b.key where a.key IS NULL;</span><br></pre></td></tr></table></figure>

<p>查询所有没人入的门派：</p>
<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595851300616.png" class width="1595851300616">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_emp a RIGHT JOIN t_dept b ON a.`deptId` = b.`id` WHERE a.`deptId` IS NULL;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595851389654.png" class width="1595851389654">

<p>查出来的是少林派，的确是少林派没有人加入。</p>
<hr>
<h2 id="AB全有"><a href="#AB全有" class="headerlink" title="AB全有"></a>AB全有</h2><img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595853279736.png" class width="1595853279736">

<p>其标准查询模板是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &lt;select list &gt; from A FULL OUTER JOIN B ON A.key = B.key;</span><br></pre></td></tr></table></figure>

<p>列出所有人员和门派的对应关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_emp a FULL OUTER JOIN t_dept b ON a.`deptId` = b.`id`;</span><br></pre></td></tr></table></figure>

<p>保存如下：</p>
<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595853554044.png" class width="1595853554044">

<p>这是因为MYSQL不支持<code>FULL JOIN</code>。</p>
<p>可以使用UNION， 可以去重</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT	* FROM t_emp a LEFT JOIN t_dept  b ON a.`deptId` = b.`id`</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM t_emp a RIGHT JOIN t_dept  b ON a.`deptId` = b.`id`;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595853864813.png" class width="1595853864813">

<p>分析一下, 一目了然，就是三个的并集：</p>
<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595854050609.png" class width="1595854050609">

<hr>
<h2 id="A的独有-B的独有"><a href="#A的独有-B的独有" class="headerlink" title="A的独有+B的独有"></a>A的独有+B的独有</h2><img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595854203724.png" class width="1595854203724">

<p>列出所有没入派的人员和没人入的门派</p>
<p>没入派的就是韦小宝，没人入的门派是少林派</p>
<p>和上面一样，就是A的独有并上B的独有，也可以使用UNION关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 7. 列出所有没入派的人员和没人入的门派</span><br><span class="line">SELECT * FROM t_emp a LEFT JOIN t_dept b ON a.`deptId` = b.`id` WHERE b.`id` IS NULL </span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM t_emp a RIGHT JOIN t_dept b ON a.`deptId` = b.`id` WHERE a.`deptId` IS NULL;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595854316872.png" class width="1595854316872">



<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>如果在上面的部门表上加上对应的门派掌门字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t_dept ADD CEO INT(11);</span><br><span class="line"></span><br><span class="line">UPDATE t_dept SET CEO=2 WHERE id=1;</span><br><span class="line">UPDATE t_dept SET CEO=4 WHERE id=2;</span><br><span class="line">UPDATE t_dept SET CEO=6 WHERE id=3;</span><br><span class="line">UPDATE t_dept SET CEO=8 WHERE id=4;</span><br><span class="line">UPDATE t_dept SET CEO=9 WHERE id=5;</span><br><span class="line">SELECT * FROM t_dept;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595854670926.png" class width="1595854670926">

<ol>
<li><p>求各个门派对应的掌门人名称:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_dept b LEFT JOIN t_emp a ON  a.`id`= b.`CEO`;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595854986754.png" class width="1595854986754"></li>
<li><p>求所有当上掌门人的平均年龄:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT AVG(a.`age`) FROM t_emp a INNER JOIN t_dept b ON a.`id` = b.`CEO`;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595855195365.png" class width="1595855195365"></li>
<li><p>求所有人物对应的掌门名称:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT c.`name` NAME, ab.name ceoName FROM t_emp c LEFT JOIN </span><br><span class="line">(SELECT b.`id`, a.`name` FROM t_dept b LEFT JOIN t_emp a ON  a.`id`= b.`CEO`) ab</span><br><span class="line">ON c.`deptId`= ab.id;</span><br></pre></td></tr></table></figure>

<p>这里涉及到了三表连接。在第一题中我们已经查询到了每一个门派的掌门姓名，然后我们需要查询每一个人对应的掌门姓名，可以利用第一题查询 到的结果作为另一张表，然后使用员工表去左连接查询。</p>
<img src="/2020/07/27/mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/1595856000455.png" class width="1595856000455"></li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>网易秋招编程题-回文序列</title>
    <url>/2020/05/31/netease/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>如果一个数字序列逆置之后跟原序列是一样的就称这样的数字序列为回文序列。例如：<br> {1, 2, 1}, {15, 78, 78, 15} , {112} 是回文序列,<br> {1, 2, 2}, {15, 78, 87, 51} ,{112, 2, 11} 不是回文序列。<br> 现在给出一个数字序列，允许使用一种转换操作：<br> 选择任意两个相邻的数，然后从序列移除这两个数，并用这两个数字的和插入到这两个数之前的位置(只插入一个和)。<br> 现在对于所给序列要求出最少需要多少次操作可以将其变成回文序列。 </p>
</blockquote>
<p>输入：</p>
<blockquote>
<p>输入为两行，第一行为序列长度n ( 1 ≤ n ≤ 50) 第二行为序列中的n个整数item[i] (1 ≤ item[i] ≤ 1000)，以空格分隔。</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>输出一个数，表示最少需要的转换次数</p>
</blockquote>
<p>示例：</p>
<blockquote>
<p>输入</p>
<p>4 1 1 1 3</p>
<p>输出</p>
<p>2</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先回文序列一定是两端相等，对于这样的问题，选用双端队列来处理，或者双向链表，便于首尾操作。首先判断首尾是否相等，如果相等的话，则让首尾元素出队，在剩下的元素中进一步判断，减小问题的规模。 那么由于题目说需要的最少操作次数，所以需要在小的一端进行相邻元素的加操作。如果首 &lt; 尾，则将首元素的以及其相邻的元素加起来，然后这两个元素出队，加和进队。如果首&gt; 尾， 则在尾部元素进行相加的操作，操作和首部类似。然后在进行下一步的判断，看看首尾元素是否相等，如若还不相等，则继续操作，如果相等，则首尾出队，直至队列中元素的个数只有一个，此时一定是回文序列。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回文序列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-31 16:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">netease01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();  <span class="comment">// 个数</span></span><br><span class="line">        LinkedList&lt;Integer&gt; items = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            items.offer(scanner.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 计数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (items.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = items.getFirst();</span><br><span class="line">            <span class="keyword">int</span> end = items.getLast();</span><br><span class="line">            <span class="keyword">if</span>(first == end)&#123;</span><br><span class="line">                <span class="comment">// 首尾出队列</span></span><br><span class="line">                items.poll();</span><br><span class="line">                items.removeLast();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(first &lt;= end)&#123; <span class="comment">// 队首小 ，加上其相邻的元素</span></span><br><span class="line">                    count++;</span><br><span class="line">                    add+=first;</span><br><span class="line">                    items.removeFirst();</span><br><span class="line">                    add+=items.removeFirst();</span><br><span class="line">                    <span class="comment">//  插入</span></span><br><span class="line">                    items.addFirst(add);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 队尾小</span></span><br><span class="line">                    count++;</span><br><span class="line">                    add+=end;</span><br><span class="line">                    items.removeLast();</span><br><span class="line">                    add+=items.removeLast();</span><br><span class="line">                    <span class="comment">// 插入</span></span><br><span class="line">                    items.addLast(add);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2020/05/31/netease/1590916740319.png" class width="1590916740319">



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>困难</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>pageHelper分页插件踩坑</title>
    <url>/2020/06/12/pageHelper/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近一个项目中使用了pageHelper分页插件。项目地址 : <a href="http://git.oschina.net/free/Mybatis_PageHelper%E3%80%82">http://git.oschina.net/free/Mybatis_PageHelper。</a> 在controller中使用该插件进行分页查询遇到如下两个问题：</p>
<ol>
<li>找不到分页插件pagehelper的class: NotFoundClass exception 。。。</li>
<li>在controller中return分页查询的结果，浏览器响应的json对象为空。。。奇了怪了！</li>
</ol>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ol>
<li><p>首先在common-service模块中的pom引入pageHelper的jar包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.miemiedev<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-paginator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意上面的mybatis-paginator 是pagehelper所依赖的包， 也需要一并引入。</p>
<p>为了程序的优雅性，并不推荐网上一些解决方案，直接再web层的pom引用分页的jar包。使用分布式模块，远程调用service，在service层引入jar包</p>
</li>
<li><p>这个错误。。。其实，就是分页的结果pojo需要写上get和set方法！！！！需要符合一个标准的java bean对象的标准。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qingcheng.entity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 分页结果的封装实体类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-06-11 16:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageResult</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">//  泛型类 ： 可以封装任何数据的分页查询结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long total; <span class="comment">// 总记录数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; rows; <span class="comment">// 数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">(Long total, List&lt;T&gt; rows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">        <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(Long total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getRows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRows</span><span class="params">(List&lt;T&gt; rows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PageResult&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;total=&quot;</span> + total +</span><br><span class="line">                <span class="string">&quot;, rows=&quot;</span> + rows +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这错误太坑了。。。怪自己！ 之后成功解决，也该睡了，心累。</p>
<img src="/2020/06/12/pageHelper/1591976264057.png" class width="1591976264057"></li>
</ol>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>网易秋招编程题-优雅的点</title>
    <url>/2020/05/31/point/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>小易有一个圆心在坐标原点的圆，小易知道圆的半径的平方。小易认为在圆上的点而且横纵坐标都是整数的点是优雅的，小易现在想寻找一个算法计算出优雅的点的个数，请你来帮帮他。<br> 例如：半径的平方如果为25<br> 优雅的点就有：(+/-3, +/-4), (+/-4, +/-3), (0, +/-5) (+/-5, 0)，一共12个点。 </p>
</blockquote>
<p>输入：</p>
<blockquote>
<p>输入为一个整数，即为圆半径的平方,范围在32位int范围内。</p>
</blockquote>
<p>输出：</p>
<blockquote>
<p>输出为一个整数，即为优雅的点的个数</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>醉了，现场做不得劲，回过头来看发现真简单。。。可能心态不行吧。稳重点！</p>
<p>分两种情况：1. 能被完整开平方的 ，这种需要加上横坐标为0的四个点。 2. 不能完整开平方的，也就是数开出来会有小数，此时可用floor函数向下取个整，这样就会比半径更小了。</p>
<p>在第一个象限遍历横坐标的范围，满足勾股定理，且纵坐标也是整数的就是满足条件，即“优雅的点”, 最后别忘了有四个象限，需要乘以4。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-31 16:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> radius = sc.nextInt();</span><br><span class="line">        <span class="keyword">double</span> r = Math.sqrt(radius);</span><br><span class="line">        <span class="keyword">int</span> range = (<span class="keyword">int</span>)Math.floor(r);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= range; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= range;  j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( i*i + j*j == radius)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        count*=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(range == r)&#123;</span><br><span class="line">            count+=<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(Math.sqrt(25)== (int)Math.floor(Math.sqrt(25) ));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>简单</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>网易秋招编程题-跳石板</title>
    <url>/2020/05/31/skipstone/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>小易来到了一条石板路前，每块石板上从1挨着编号为：1、2、3…….<br> 这条石板路要根据特殊的规则才能前进：对于小易当前所在的编号为K的 石板，小易单次只能往前跳K的一个约数(不含1和K)步，即跳到K+X(X为K的一个非1和本身的约数)的位置。 小易当前处在编号为N的石板，他想跳到编号恰好为M的石板去，小易想知道最少需要跳跃几次可以到达。<br> 例如：<br> N = 4，M = 24：<br> 4-&gt;6-&gt;8-&gt;12-&gt;18-&gt;24<br> 于是小易最少需要跳跃5次，就可以从4号石板跳到24号石板 </p>
</blockquote>
<p>输入：</p>
<blockquote>
<p>输入为一行，有两个整数N，M，以空格隔开。 (4 ≤ N ≤ 100000) (N ≤ M ≤ 100000)</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>输出小易最少需要跳跃的步数,如果不能到达输出-1</p>
</blockquote>
<p>示例：</p>
<blockquote>
<p>4 24</p>
<p>5</p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>一看到题干上说要求最小、最少。。等字眼，就要想到是动态规划类型的题目，要明确状态转移方程，还有个小难点就是一个数的约数怎么求。</p>
<p>设 $dp[i]$  表示从初始石板到目标石板需要跳跃的最少次数。首先dp数组应该初始化一个很大的值，表示都不可达，除了自己到自己需要跳0次，即 $dp[N] = 0$. </p>
<p>求出当前石块编号的所有约数，对约数们遍历，则有一下状态转移方程(c为约数)：<br>$$<br>dp[i + c] = Min{ dp[i + c], dp[i]+1}.  —&gt; dp[i + c] != Integer.MaxValue<br>$$</p>
<p>$$<br>dp[i + c] = dp[i]+1;  —&gt;dp[i+c] = Integet.MaxValue<br>$$</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [编程题]跳石板  网易秋招</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-31 21:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">skipStone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = sc.nextInt(); <span class="comment">// 起始位置</span></span><br><span class="line">        <span class="keyword">int</span> M = sc.nextInt(); <span class="comment">//  终止位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span>[M+<span class="number">1</span>]; <span class="comment">//  dp[i] ： 到第i个石块最少需要跳多少次。</span></span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE); <span class="comment">//  均初始化为无穷大</span></span><br><span class="line">        dp[N] = <span class="number">0</span>; <span class="comment">// 自己到自己跳0次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N; i &lt;= M; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == Integer.MAX_VALUE) <span class="keyword">continue</span>; <span class="comment">//  不可达</span></span><br><span class="line">            <span class="comment">// 遍历 当前i的约数</span></span><br><span class="line">            ArrayList&lt;Integer&gt; factors = getFactors(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;  j &lt; factors.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> skip = i+factors.get(j);</span><br><span class="line">                <span class="keyword">if</span>(skip &gt; M)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[skip] == Integer.MAX_VALUE)&#123;</span><br><span class="line">                    dp[skip] = dp[i]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[skip] = Math.min(dp[skip], dp[i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[M] == Integer.MAX_VALUE)</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(dp[M]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得当前数的约数 ， 除了1和它自己</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">getFactors</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(n); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">                <span class="keyword">if</span>(n / i != i)&#123;</span><br><span class="line">                    list.add(n / i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>困难</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring01-对Ioc控制反转的理解</title>
    <url>/2020/06/20/spring01/</url>
    <content><![CDATA[<h1 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h1><p>你如何理解IOC？</p>
<p>这个问题首先要从程序的“高内聚、低耦合”开始说起。</p>
<p>那么，什么是程序的耦合？</p>
<p>因为耦合这个概念在各个行业都有相关自己的概念，这里只从软件行业的角度来说说。简单说耦合就是多个程序的模块之间的依赖关系。好的程序应该有较低的耦合，耦合是无法消除的，完全没有任何耦合的程序是没有意义的。而高耦合就是说“牵一发而动全身”，这显然不是我们想看到的。各个模块应该要尽量独立，当某个模块出问题了就直接修改这一个模块就可以了，不要让程序大改。。。代价人工消耗。。</p>
<h1 id="程序的耦合"><a href="#程序的耦合" class="headerlink" title="程序的耦合"></a>程序的耦合</h1><p>耦合有很多种， 它们之间的耦合度由高到低排列如下 ：</p>
<ol>
<li><strong>内容耦合</strong>。当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另 一个模块时，这样的耦合被称为内容耦合。<strong>内容耦合是最高程度的耦合，应该避免使用之。</strong>  </li>
<li><strong>公共耦合</strong>。两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大 量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。 </li>
<li>外部耦合 。一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传 递该全局变量的信息，则称之为外部耦合。  </li>
<li> <strong>控制耦合</strong> 。一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进 行适当的动作，这种耦合被称为控制耦合。  </li>
<li>标记耦合 。若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间 存在一个标记耦合。  </li>
<li> <strong>数据耦合</strong>。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形 式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。 </li>
<li>非直接耦合 。两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实 现的。</li>
</ol>
<p>重点关注加粗部分的耦合，即内容耦合、公共耦合、控制耦合、数据耦合。</p>
<p><strong>耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须 存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。</strong> </p>
<h1 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h1><p>那么，还有个“高内聚”，所谓高内聚是从模块的内部结构角度来观察的，就是说内聚表示了一个模块的内部各个元素彼此结合的紧密程度。内聚是从 <strong>功能角度</strong>来度量<strong>模块内</strong>的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</p>
<p>高内聚简单来说就是自己尽量自己完成自己的事情，不要麻烦别人。自己得事情内部解决，对外只提供公共的接口来访问功能。</p>
<p><strong>程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之 间的相互依存度却不要那么紧密。</strong> </p>
<p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。 </p>
<h1 id="高耦合举例"><a href="#高耦合举例" class="headerlink" title="高耦合举例"></a>高耦合举例</h1><p>下面来举几个例子来说明一下。</p>
<p>在传统的基于MVC三层架构开发模式下，我们会写一个DAO接口，这是一个数据访问对象，用来作为持久层接口，还会写一个service来处理业务逻辑，表示业务层，但是业务层需要持久层接口来实现各种业务逻辑。就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao dao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译将不能通过。这种编译期依赖关系，应该在我们开发中杜绝。我们需要优化代码解决。 这就是一个典型的耦合。</p>
<p>再来一个例子吧：</p>
<p><code>JDBC</code>都学过，使用JDBC来操作数据库的时候，我们首先需要加载驱动，然后创建连接，执行sql。。。， 注册驱动的时候我们可以通过<code>DriverManager</code> 的 <code>register</code> 方法来注册驱动，也可以使用Class.forName（Class…） 通过反射去加载驱动类完成注册。但是我们一般推荐使用Class.forName（）的方式，为啥呢？？？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">    <span class="comment">//1.注册驱动   		</span></span><br><span class="line">    <span class="comment">//riverManager.registerDriver(new com.mysql.jdbc.Driver());</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); </span><br><span class="line">  	<span class="comment">//2.获取连接   </span></span><br><span class="line">   <span class="comment">//3.获取预处理 sql 语句对象   </span></span><br><span class="line">    <span class="comment">//4.获取结果集   </span></span><br><span class="line">    <span class="comment">//5.遍历结果集 </span></span><br><span class="line">	 </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>我们知道JDBC 是 sun 公司提供一套用于数据库操作的接口。java 程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</p>
<p> java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口，每个厂商实现的方式不一样，在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类 (java.sql.DriverManager) 去调用这些 Driver 实现。</p>
<blockquote>
<p>Oracle 的驱动：oracle.jdbc.driver.OracleDriver<br>        mySql 的驱动： com.mysql.jdbc.Driver</p>
</blockquote>
<p>如果使用<code>DriverManager.registerDriver</code>方式会依赖某种具体的数据库(<code>mysql</code>)，需要在编译的时候就要导入对应的包，这样程序的耦合行较高。如果这时候更换了数据库品牌（比如 <code>Oracle</code>），需要 修改源码来重新数据库驱动。这显然不是我们想要的。 </p>
<p>而采用<code>Class.forName（）</code>的方式是在运行时动态加载的。看如下源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// ~ Static fields/initializers  </span></span><br><span class="line">    <span class="comment">// ---------------------------------------------  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//  </span></span><br><span class="line">    <span class="comment">// Register ourselves with the DriverManager  </span></span><br><span class="line">    <span class="comment">//  </span></span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<p>静态代码块的方式来注册驱动，也就是说通过class.forName的方式是通过直接加载字节码的。根据类加载原理，一个class加载进内存，连接，初始化，会先执行类的静态代码块和对静态变量的初始化操作，所以在加载的时候就可以注册数据库驱动。</p>
<p>好了，刚刚分析了数据库驱动注册使用DriverManager.registerDriver的方式会导致程序的耦合性提高，我们使用Class.forName()的方式来对程序解耦，他是通过反射的方式来注册驱动的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//此处只是一个字符串 </span></span><br></pre></td></tr></table></figure>

<p>此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 <code>mysql</code> 的驱动 jar 包，依然可以编译（运 行就不要想了，没有驱动不可能运行成功的）。 同时，也产生了一个新的问题，<code>mysql</code> 驱动的全限定类名字符串是在 <code>java</code> 类中写死的，一旦要改还是要修改源码。 解决这个问题也很简单，使用<strong>配置文件配置</strong>。 </p>
<h1 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h1><p>在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的</p>
<p>方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。 那么，这个读取配置文件，创建和获取三层对象的类就是工厂。</p>
<h1 id="Ioc控制反转Inversion-Of-Control"><a href="#Ioc控制反转Inversion-Of-Control" class="headerlink" title="Ioc控制反转Inversion Of Control"></a>Ioc控制反转Inversion Of Control</h1><p>通过以上的分析，我们大概对解耦有了一个基本的思路，就是我们的对象要存起来，放在一个地方，然后谁要用就去取。</p>
<p>那么问题来了，对象要存在哪里呢？我们学过集合框架，使用List还是用<code>Map</code>来存储呢？其实这是根据我们是否有查找的需求，有查找需求，肯定使用Map效率更高一些。</p>
<p>所以，<code>Spring</code>的解决思路就是在应用加载的时候，使用Map来存放<code>MVC</code>三层使用到的对象，这个<code>Map</code>就是<code>Spring</code>的容器。</p>
<p>刚刚我们说了工厂模式可以解耦，啥是工厂模式呢？</p>
<p>我么以前创建对象的方式就是通过<code>new</code>关键字来创建的，是主动的获取。所谓工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。 不再是<code>new</code>了。交给工厂去帮我们获得。有工厂为我们查找或者创建对象。是被动的。 </p>
<img src="/2020/06/20/spring01/1592660795840.png" class width="1592660795840">



<img src="/2020/06/20/spring01/1592660830989.png" class width="1592660830989">

<p><strong>这种被动接收的方式获取对象的思想就是控制反转，它是 spring 框架的核心之一。</strong></p>
<p><strong>到这里了，我们需要明确，<code>Ioc</code>解决的问题就是降低程序的耦合。</strong>也就是削减我们代码中的依赖关系。</p>
<p>控制反转，就是<code>java</code>对象不再有我们自己来控制管理了，全部交给<code>Spring</code>的容器来管理！</p>
<p>所以称为“控制反转”， 精髓： <strong>反转</strong>！！！</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发之Java内存模型</title>
    <url>/2020/06/19/synchronized%E5%92%8Cvolatile/</url>
    <content><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>在讲解<code>synchronized</code>和<code>volatie</code>之前，我们首先需要了解<code>Java</code>内存模型(<code>JMM</code>)</p>
<p>《Java虚拟机规范》中曾试图定义一种“Java内存模型”（Java Memory Model，JMM）来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到<strong>一致的内存访问</strong>效果。</p>
<h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。</p>
<p>每条线程还有自己的工作内存（<code>Working Memory</code>），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示。</p>
<img src="/2020/06/19/synchronized%E5%92%8Cvolatile/synchronized%E5%92%8Cvolatile.png" class width="1592527521175">



<p>这是因为处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。线程的工作线程一般就是用高速缓存或者寄存器来实现的。</p>
<p>加入高速缓存带来了一个新的问题：<strong>缓存一致性</strong>。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p>
<h2 id="内存之间的交互操作"><a href="#内存之间的交互操作" class="headerlink" title="内存之间的交互操作"></a>内存之间的交互操作</h2><img src="/2020/06/19/synchronized%E5%92%8Cvolatile/1592529422405.png" class width="1592529422405">

<ul>
<li>read：把一个变量的值从主内存传输到工作内存中</li>
<li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量，它把一个变量标识为一条线程独占的状态</li>
<li>unlock 它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
</ul>
<p>比较繁琐，目前简化了。将Java内存模型的操作简化为read、write、lock和unlock四种，但这只是语言描述上的等价化简，Java内存模型的基础设计并未改变。</p>
<h2 id="内存模型的三大特性"><a href="#内存模型的三大特性" class="headerlink" title="内存模型的三大特性"></a>内存模型的三大特性</h2><ul>
<li><p>原子性</p>
</li>
<li><p>可见性</p>
</li>
<li><p>有序性</p>
</li>
</ul>
<p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。</p>
<h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1.原子性（Atomicity）"></a>1.原子性（Atomicity）</h3><p>Java内存模型要求lock、unlock、read、load、assign、use、store、write这八种操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的“long和double的非原子性协定”（Non-Atomic Treatment of doubleand long Variables）。</p>
<p>如果有多个线程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的代表了“半个变量”的数值。不过这种读取到“半个变量”的情况是非常罕见的，经过实际测试[插图]，在目前主流平台下商用的64位Java虚拟机中并不会出现非原子性访问行为，但是对于32位的Java虚拟机，譬如比较常用的32位x86平台下的HotSpot虚拟机，对long类型的数据确实存在非原子性访问的风险。</p>
<p>可以大致认为基本数据类型的访问、读写都是具备原子性的。原子性保证可以用原子操作如 <code>AtomicInteger</code>  和<code>AtomicDoouble</code>等…,  除了使用原子类之外，也可以使用 <code>synchronized</code> 互斥锁来保证操作的原子性。它对应的内存间交互操作为：<code>lock</code> 和 <code>unlock</code>，在虚拟机实现上对应的字节码指令为 <code>monitorenter</code> 和 <code>monitorexit</code>。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-06-19 9:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Atomic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//        AtomicAdd atomicAdd = new AtomicAdd();</span></span><br><span class="line">        AddNotSafe addNotSafe = <span class="keyword">new</span> AddNotSafe();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threadNums = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        CountDownLatch  latch = <span class="keyword">new</span> CountDownLatch(threadNums);</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNums; i++)&#123;</span><br><span class="line">            service.execute(()-&gt;&#123;</span><br><span class="line"><span class="comment">//                atomicAdd.add();</span></span><br><span class="line">                addNotSafe.add();</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.await();</span><br><span class="line">        service.shutdown();</span><br><span class="line">        System.out.println(addNotSafe.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicAdd</span></span>&#123;  <span class="comment">// 每次执行结果都是1000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddNotSafe</span></span>&#123;  <span class="comment">// 每次得出的结果都不一样 976/954 ，比1000小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cnt+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-可见性（Visibility）"><a href="#2-可见性（Visibility）" class="headerlink" title="2.可见性（Visibility）"></a>2.可见性（Visibility）</h3><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。 Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。在下文的<code>volatile</code>讲解会了解到，**<code>volatile</code>可以保证变量的可见性，但是<code>volatile</code> 并不能保证操作的原子性。**</p>
<p>主要有三种实现可见性的方式：</p>
<ul>
<li><code>volatile</code></li>
<li><code>synchronized</code>，对一个变量执行 <code>unlock</code> 操作之前，必须把变量值同步回主内存。</li>
<li><code>final</code>，被 <code>final</code> 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。<strong>注意：final可以在class里面先定义，但是必须在构造器中为其初始化！！！</strong></li>
</ul>
<h3 id="3-有序性（Ordering）"><a href="#3-有序性（Ordering）" class="headerlink" title="3.有序性（Ordering）"></a>3.有序性（Ordering）</h3><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p><code>volatile</code> 关键字通过添加<strong>内存屏障</strong>的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p>
<p>也可以通过 <code>synchronized</code> 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码</p>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>“先行发生”（Happens-Before）的原则。这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的非常有用的手段。</p>
<p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p> 可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。 </p>
<p>下面是Java内存模型下一些“<strong>天然的</strong>”先行发生关系，这些先行发生关系无须任何<strong>同步器</strong>协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p>
<h3 id="1-程序次序规则"><a href="#1-程序次序规则" class="headerlink" title="1.  程序次序规则"></a>1.  程序次序规则</h3><p>程序次序规则（Program Order Rule）：在一个线程内，按照<strong>控制流顺序</strong>，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p>
<h3 id="2-管程锁定规则"><a href="#2-管程锁定规则" class="headerlink" title="2.管程锁定规则"></a>2.管程锁定规则</h3><p>管程锁定规则（Monitor Lock Rule）：一个<code>unlock</code>操作先行发生于后面对同一个锁的<code>lock</code>操作。这里必须强调的是“<strong>同一个锁</strong>”，而“<strong>后面</strong>”是指时间上的先后。</p>
<p>也就是说先获得的锁需要先解锁才能被后面的线程获得锁。</p>
<img src="/2020/06/19/synchronized%E5%92%8Cvolatile/1592534021635.png" class width="1592534021635">

<h3 id="3-volatile变量规则"><a href="#3-volatile变量规则" class="headerlink" title="3.volatile变量规则"></a>3.volatile变量规则</h3><p><code>volatile</code>变量规则（Volatile Variable Rule）：对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。<strong>先写进去主内存，然后才能从主内存中读取到工作内存中。</strong></p>
<img src="/2020/06/19/synchronized%E5%92%8Cvolatile/1592534100497.png" class width="1592534100497">

<h3 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4. 线程启动规则"></a>4. 线程启动规则</h3><p>线程启动规则（Thread Start Rule）：Thread对象的<code>start()</code>方法先行发生于此线程的每一个动作。</p>
<img src="/2020/06/19/synchronized%E5%92%8Cvolatile/1592534150646.png" class width="1592534150646">

<h3 id="5-线程终止规则"><a href="#5-线程终止规则" class="headerlink" title="5.线程终止规则"></a>5.线程终止规则</h3><p>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过<code>Thread::join()</code>方法是否结束、<code>Thread::isAlive()</code>的返回值等手段检测线程是否已经终止执行。</p>
<h3 id="6-线程中断规则"><a href="#6-线程中断规则" class="headerlink" title="6.线程中断规则"></a>6.线程中断规则</h3><p>线程中断规则（Thread Interruption Rule）：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过<code>Thread::interrupted()</code>方法检测到是否有中断发生。</p>
<p>也就是说，interrupt() 方法只是标记线程的中断，也就是线程设置一个中断标记，然后他可以通过interrupted() 方法来检测是否有中断发生。所以应该是先标记中断在检测中断。</p>
<h3 id="7-对象终结规则"><a href="#7-对象终结规则" class="headerlink" title="7.对象终结规则"></a>7.对象终结规则</h3><p>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的<code>finalize()</code>方法的开始。</p>
<h3 id="8-传递性"><a href="#8-传递性" class="headerlink" title="8.传递性"></a>8.传递性</h3><p>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p>
<p>Java语言无须任何同步手段保障就能成立的先行发生规则有且只有上面这些..</p>
<h3 id="先行发生原则举例"><a href="#先行发生原则举例" class="headerlink" title="先行发生原则举例"></a>先行发生原则举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>假设存在线程A和B，线程A先（时间上的先后）调用了setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值是什么？</p>
<p>我们依次分析一下先行发生原则中的各项规则。由于两个方法分别由线程A和B调用，不在一个线程中，所以程序次序规则在这里不适用；由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，因此我们可以判定，尽管线程A在操作时间上先于线程B，但是无法确定线程B中getValue()方法的返回结果，换句话说，<strong>这里面的操作不是线程安全的</strong>。</p>
<p>那怎么修复这个问题呢？我们至少有两种比较简单的方案可以选择：要么把getter/setter方法都定义为<code>synchronized</code>方法，这样就可以套用管程锁定规则；要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足<code>volatile</code>关键字使用场景，这样就可以套用volatile变量规则来实现先行发生关系。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Java</code>内存模型的目标是为了屏蔽操作系统和硬件之间对内存的不同访问差异，让Java程序在各种平台下都能对数据达到一致的访问效果。也就是说，Java内存模型就是想定义变量的访问规则，关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。</p>
<p>我们知道， 处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。 但是引入高速缓存会带来一个新的问题：缓存一致性。因为Java内存模型中，每一个线程都有一个自己的工作内存，变量都是存储在主存中的，线程只能操作自己工作内存中的变量，不同线程之间的变量传递需要通过主存来完成。线程的工作内存是高速缓存实现的，当多个缓存通过访问主存中的同一块内存区域的话，多个缓存的数据可能会不一致，所以就需要一些规则或者说协议来约定来解决缓存不一致的问题。</p>
<p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存的细节实现，java内存模型定义了八种操作。 内存中的交互操作包括read、write、load、store、sign、lock、unlock。</p>
<p> Java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的。所谓原子性就是说 一个操作是不可中断的，要么全部执行成功要么全部执行失败，原子性可以通过jdk自带的原子类来实现；可见性就是如果有一个线程修改了一个共享变量的值，那么其他的线程也能看到修改的结果， Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的，实现可见性可以通过volatile、synchronized、final关键字来实现。有序性，即程序执行的顺序按照代码的先后顺序执行。因为编译器会对代码进行<code>指令重排序优化</code> ，带来了有序性问题，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。可以使用volatile关键字来禁止指令重排序，内部是通过内存屏障来实现。还可以通过 <code>synchronized</code> 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p>
<p> 除了可以用 volatile 和 synchronized 来保证有序性，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。 有程序次序规则，管程锁定规则，volatile变量规则，线程启动规则，线程终止规则、线程中断规则，对象终结规则，传递性。</p>
<p>Java内存模型就先到这里，后面如果与其他感想的话会补充一下，接下来就要学习synchronized和volatile的原理，也就是Java并发机制的底层实现原理，这个比较重要。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li> <a href="https://cyc2018.github.io/CS-Notes">https://cyc2018.github.io/CS-Notes</a> </li>
<li>周志华：《深入理解Java虚拟机》第三版</li>
</ol>
]]></content>
      <categories>
        <category>Java高并发</category>
      </categories>
      <tags>
        <tag>juc</tag>
        <tag>synchronized</tag>
        <tag>volatile</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>初探ThreadLocal</title>
    <url>/2021/07/23/theadlocal/</url>
    <content><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>当调用theadlocal的set的方法的时候， </p>
<p>set方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      Thread t = Thread.currentThread(); <span class="comment">// 获取当前的线程</span></span><br><span class="line">      ThreadLocalMap map = getMap(t); <span class="comment">// 获取当前线程的ThreadLocalMap： threadlocals</span></span><br><span class="line">      <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">          map.set(<span class="keyword">this</span>, value); <span class="comment">// 往map里面put值，key为threadlocal对象，value是threadlocal里面的值</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>进一步看一下getMap里面的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在Thread类里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap底层是一个Map结构。在ThreadLocal里面的一个静态内部类，ThreadLocalMap里面又包含一个Entry的静态内部类，是一个k-v键值对的结构，key为threadlocal对象，value是里面的值。还继承了WeakReference， 所以这个Entry是一个弱引用对象，当垃圾收集器看到他的时候会直接回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">         * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们new了一个threadlocal对象，调用set方法的时候，先拿到 当前的线程的ThreadLocalMap threadlocals， 这是一个Map结构，key为threadlocal对象，value是threadlocal对象里面的值，key是通过一个弱引用指向threadlocal对象的。如下图所示。</p>
<p><img src="/2021/07/23/theadlocal/image-20200826215617400.png" alt="image-20200826215617400"></p>
<p>为什么是弱引用呢？ 假如这是个强引用，当tl的引用置为null的时候，key的引用不为null，还指向了threadlocal对象，所以这时threadlocal将不会被回收，就可能发生内存泄漏。如果是弱引用的话，当JVM虚拟机运行gc的时候，发现threadlocal是一个弱引用，则直接将其回收，这样就可以解决内存泄漏问题。</p>
<p>还有一个问题，假如，这时候key为null了，要想通过get方法获得value的话是不可能获取到的，这个value对象的值怎么释放呢？所以，这也会产生内存泄漏 的情况，良好的编程习惯是将这一条记录remove掉，这样就防止了value这部分的内存泄漏。</p>
<p>假如使用的线程池，如果不清理掉旧的记录，当线程复用的时候，会导致数据混乱。所以，线程池的底层源码就是每次开启一个线程的时候都会将当前线程的ThreadLocalMap置为null。</p>
<h1 id="ThreadLocal的使用场景"><a href="#ThreadLocal的使用场景" class="headerlink" title="ThreadLocal的使用场景"></a>ThreadLocal的使用场景</h1><p>spring关于事务的管理</p>
<p>mybatis中分页的处理。</p>
]]></content>
      <categories>
        <category>Java高并发</category>
      </categories>
      <tags>
        <tag>Thread</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>topK问题</title>
    <url>/2020/09/07/topK%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>leetcode上有不少topK的问题，而且topK问题也是面试必问的，所以在此做一个总结。</p>
<h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h1><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 </p>
<blockquote>
<p>示例 1:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2</p>
<p>输出: [1,2]</p>
<p>示例 2:</p>
<p>输入: nums = [1], k = 1</p>
<p>输出: [1]</p>
</blockquote>
<p>要求时间复杂度为<code>O(nlogn)</code></p>
<h2 id="堆排序思想"><a href="#堆排序思想" class="headerlink" title="堆排序思想"></a>堆排序思想</h2><p>先统计每一个数字出现的次数，然后维护一个大小为k的小根堆，小根堆按照数字出现 的频率排序，当堆中元素小于k时，加入小根堆当中，如果小根堆元素=k，则比较堆顶与当前元素的频率，如果比堆顶小，说明，当前堆中已经有k个元素出现的频率比这个数大；如果堆顶元素的频率比当前元素出现的频率小的话，则堆顶弹出，新元素进堆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line"><span class="comment">//        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = IntStream.of(nums).boxed().collect(Collectors.toMap(e -&gt; e, e -&gt; <span class="number">1</span>, Integer::sum));</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b)-&gt;map.get(a) - map.get(b)); <span class="comment">// 小根堆</span></span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; integers = map.keySet();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: integers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q.size() &lt; k)&#123;</span><br><span class="line">                q.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( map.get(q.peek()) &lt; map.get(num))&#123;</span><br><span class="line">                    q.poll();</span><br><span class="line">                    q.offer(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            res[i++] = q.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="基于二叉搜索树"><a href="#基于二叉搜索树" class="headerlink" title="基于二叉搜索树"></a>基于二叉搜索树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; counterMap = IntStream.of(nums).boxed().collect(Collectors.toMap(e -&gt; e, e -&gt; <span class="number">1</span>, Integer::sum));</span><br><span class="line">        <span class="comment">// 定义二叉搜索树：key 是数字出现的次数，value 是出现了key次的数字列表。</span></span><br><span class="line">        TreeMap&lt;Integer, List&lt;Integer&gt;&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 维护一个有 k 个数字的二叉搜索树：</span></span><br><span class="line">        <span class="comment">// 不足 k 个直接将当前数字加入到树中；否则判断当前树中的最小次数是否小于当前数字的出现次数，若是，则删掉树中出现次数最少的一个数字，将当前数字加入树中。</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry: counterMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> cnt = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (count &lt; k) &#123;</span><br><span class="line">                treeMap.computeIfAbsent(cnt, ArrayList::<span class="keyword">new</span>).add(num);</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; firstEntry = treeMap.firstEntry();</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; firstEntry.getKey()) &#123;</span><br><span class="line">                    treeMap.computeIfAbsent(cnt, ArrayList::<span class="keyword">new</span>).add(num);</span><br><span class="line">                    List&lt;Integer&gt; list = firstEntry.getValue();</span><br><span class="line">                    <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                        treeMap.pollFirstEntry();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造返回结果</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list: treeMap.values()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num: list) &#123;</span><br><span class="line">                res[idx++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="基于桶排序"><a href="#基于桶排序" class="headerlink" title="基于桶排序"></a>基于桶排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = IntStream.of(nums).boxed().collect(Collectors.toMap(e -&gt; e, e -&gt; <span class="number">1</span>, Integer::sum));</span><br><span class="line">        <span class="comment">// 每个桶 存放当前频率的元素</span></span><br><span class="line">        List&lt;Integer&gt;[]  bucket = <span class="keyword">new</span> ArrayList[nums.length+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//        Arrays.fill(bucket, new ArrayList());</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i&lt; bucket.length; i++)&#123;</span><br><span class="line">            bucket[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.forEach((key, count)-&gt;&#123;</span><br><span class="line">            bucket[count].add(key);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从后往前遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = bucket.length-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : bucket[i])&#123;</span><br><span class="line">                res[n++] = num;</span><br><span class="line">                <span class="keyword">if</span>(n == k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于快速选择算法"><a href="#基于快速选择算法" class="headerlink" title="基于快速选择算法"></a>基于快速选择算法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 基于快速排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span>  <span class="keyword">int</span>[] topKFrequent2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">       <span class="comment">// 统计每个数字出现的次数</span></span><br><span class="line">       Map&lt;Integer, Integer&gt; map = IntStream.of(nums).boxed().collect(Collectors.toMap(e -&gt; e, e -&gt; <span class="number">1</span>, Integer::sum));</span><br><span class="line">       Pair[] p = <span class="keyword">new</span> Pair[nums.length];</span><br><span class="line">       Pair[] pairs = IntStream.of(nums).distinct().boxed().map(num -&gt; <span class="keyword">new</span> Pair(num, map.get(num))).toArray(Pair[]::<span class="keyword">new</span>);</span><br><span class="line">       Pair[] ans = qselect(pairs, <span class="number">0</span>, pairs.length-<span class="number">1</span>, k-<span class="number">1</span>); <span class="comment">// 下标为k-1</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(Pair pair: ans)&#123;</span><br><span class="line">           res[i++] = pair.key;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Pair[] qselect(Pair[] pairs, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> aux) &#123;</span><br><span class="line">       <span class="keyword">if</span>( l &lt;= r)&#123;</span><br><span class="line">           <span class="keyword">int</span> p = partition(pairs, l, r);</span><br><span class="line">           <span class="keyword">if</span>( p == aux)&#123;</span><br><span class="line">               <span class="keyword">return</span> Arrays.copyOf(pairs, aux+<span class="number">1</span>); <span class="comment">// 包头不包尾</span></span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p &lt; aux)&#123;</span><br><span class="line">               <span class="comment">// 答案在其右边</span></span><br><span class="line">               <span class="keyword">return</span> qselect(pairs, p+<span class="number">1</span>, r, aux);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> qselect(pairs, l, p-<span class="number">1</span>, aux);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Pair[<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Pair[] pairs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = l;</span><br><span class="line">       <span class="keyword">int</span> j = r;</span><br><span class="line">       <span class="keyword">int</span> p = l;</span><br><span class="line">       <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">           <span class="keyword">while</span> (pairs[i].count &gt; pairs[p].count &amp;&amp; i &lt; j)&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (pairs[j].count &lt;= pairs[p].count &amp;&amp; i &lt; j)&#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           swap(pairs, i ,j);</span><br><span class="line">       &#125;</span><br><span class="line">       swap(pairs, p, i);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Pair[] pairs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">       Pair t = pairs[l];</span><br><span class="line">       pairs[l] = pairs[r];</span><br><span class="line">       pairs[r] = t;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> key;</span><br><span class="line">       <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.count = count;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h1><h2 id="基于快排"><a href="#基于快排" class="headerlink" title="基于快排"></a>基于快排</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> QuickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, k);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] QuickSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">int</span> partition = partition(arr, low, high);</span><br><span class="line">        <span class="keyword">if</span>(partition == k-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(arr, partition+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(partition &gt; k-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> QuickSort(arr, low, partition-<span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> QuickSort(arr, partition+<span class="number">1</span>, high, k);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = arr[low];</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[high] &gt; p &amp;&amp; low &lt; high) high--;</span><br><span class="line">            <span class="keyword">while</span>(arr[low] &lt;= p &amp;&amp; low &lt; high) low++;</span><br><span class="line">            </span><br><span class="line">            swap(arr, low, high);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[low];</span><br><span class="line">        arr[low] = p;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="直接排序"><a href="#直接排序" class="headerlink" title="直接排序"></a>直接排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> []res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            res[i++] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于堆"><a href="#基于堆" class="headerlink" title="基于堆"></a>基于堆</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        </span><br><span class="line">        PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;b-a); <span class="comment">// 大根堆</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;  <span class="comment">//  避免空指针异常</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q.size() &lt; k)&#123;</span><br><span class="line">                q.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( q.peek() &gt; num)&#123;</span><br><span class="line">                    q.poll();</span><br><span class="line">                    q.offer(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: q)&#123;</span><br><span class="line">            res[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/solution/4-chong-fang-fa-miao-sha-topkji-shu-pai-xu-kuai-pa/">https://leetcode-cn.com/problems/top-k-frequent-elements/solution/4-chong-fang-fa-miao-sha-topkji-shu-pai-xu-kuai-pa/</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>中等</tag>
        <tag>topK</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie和Session会话技术</title>
    <url>/2020/03/19/%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h1><ol>
<li>会话：一次会话中包含多次请求和响应。 ​    一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</li>
<li>功能：在一次会话的范围内的多次请求间，共享数据</li>
<li>方式：<ol>
<li>客户端会话技术：<code>Cookie</code></li>
<li>服务器端会话技术：<code>Session</code></li>
</ol>
</li>
</ol>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>客户端会话技术，将数据保存到客户端</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ul>
<li>使用步骤：<ol>
<li>创建Cookie对象，绑定数据<ul>
<li><code>new Cookie(String name, String value)</code> </li>
</ul>
</li>
<li>发送Cookie对象<ul>
<li><code>response.addCookie(Cookie cookie)</code> </li>
</ul>
</li>
<li>获取Cookie，拿到数据<ul>
<li><code>Cookie[]  request.getCookies()</code>  </li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li><p>基于响应头<code>set-cookie</code>和请求头<code>cookie</code>实现</p>
<p><img src="/%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/Cookie%E5%8E%9F%E7%90%86.bmp" alt="Cookie原理"></p>
</li>
</ul>
<h2 id="cookie的细节"><a href="#cookie的细节" class="headerlink" title="cookie的细节"></a>cookie的细节</h2><ol>
<li><p><strong>一次可不可以发送多个cookie?</strong></p>
<ul>
<li>可以</li>
<li>可以创建多个Cookie对象，使用response调用多次<code>addCookie</code>方法发送cookie即可。</li>
</ul>
</li>
<li><p><strong>cookie在浏览器中保存多长时间？</strong></p>
<ol>
<li>默认情况下，当浏览器关闭后，Cookie数据被销毁</li>
<li>持久化存储：<ul>
<li><code>setMaxAge(int seconds)</code><ol>
<li>正数：将<code>Cookie</code>数据写到硬盘的文件中。持久化存储。并指定<code>cookie</code>存活时间，时间到后，<code>cookie</code>文件自动失效</li>
<li>负数：默认值</li>
<li>零：删除<code>cookie</code>信息</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>cookie能不能存中文？</strong></p>
<ul>
<li>在<code>tomcat 8</code> 之前 cookie中不能直接存储中文数据。<ul>
<li>需要将中文数据转码—一般采用<code>URL</code>编码(%E3)</li>
</ul>
</li>
<li>在<code>tomcat 8</code> 之后，<code>cookie</code>支持中文数据。特殊字符还是不支持，建议使用<code>URL</code>编码存储，URL解码解析</li>
</ul>
</li>
<li><p><strong>cookie共享问题？</strong></p>
<ol>
<li>假设在一个<code>tomcat</code>服务器中，部署了多个web项目，那么在这些web项目中<code>cookie</code>能不能共享？</li>
</ol>
<ul>
<li>默认情况下<code>cookie</code>不能共享</li>
<li><code>setPath(String path):</code>设置<code>cookie</code>的获取范围。默认情况下，设置当前的虚拟目录<ul>
<li><strong>如果要共享，则可以将path设置为”/“</strong></li>
</ul>
</li>
</ul>
<ol start="2">
<li>不同的<code>tomcat</code>服务器间cookie共享问题？<pre><code>* `setDomain(String path)`:如果设置一级域名相同，那么多个服务器之间`cookie`可以共享
       * `setDomain(&quot;.baidu.com&quot;),`那么`tieba.baidu.com`和`news.baidu.com`中`cookie`可以共享
</code></pre>
</li>
</ol>
</li>
<li><p><strong>Cookie的特点和作用</strong></p>
<ol>
<li><code>cookie</code>存储数据在<strong>客户端浏览器</strong></li>
<li>浏览器对于单个<code>cookie</code> 的大小有限制(<strong>4kb)</strong> 以及 对同一个域名下的总<code>cookie</code>数量也有限制(<strong>20个</strong>)</li>
</ol>
<ul>
<li>作用：<ol>
<li><code>cookie</code>一般用于存储少量的<strong>不太敏感的数据</strong></li>
<li>在不登录的情况下，完成服务器对客户端的身份识别</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="案例：记住上一次访问时间"><a href="#案例：记住上一次访问时间" class="headerlink" title="案例：记住上一次访问时间"></a>案例：记住上一次访问时间</h2><ol>
<li><p>需求：</p>
<ol>
<li>访问一个<code>Servlet</code>，如果是第一次访问，则提示：您好，欢迎您首次访问。</li>
<li>如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串</li>
</ol>
</li>
<li><p>分析：</p>
<ol>
<li>可以采用<code>Cookie</code>来完成</li>
<li>在服务器中的<code>Servlet</code>判断是否有一个名为<code>lastTime</code>的<code>cookie</code><ol>
<li>有：不是第一次访问<ol>
<li>响应数据：欢迎回来，您上次访问时间为:<strong>2018年6月10日11:50:20</strong></li>
<li>写回<strong>Cookie：lastTime=2018年6月10日11:50:01</strong></li>
</ol>
</li>
<li>没有：是第一次访问<ol>
<li>响应数据：您好，欢迎您首次访问</li>
<li>写<strong>回Cookie：lastTime=2018年6月10日11:50:01</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="/%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/Cookie%E6%A1%88%E4%BE%8B_%E8%AE%B0%E4%BD%8F%E4%B8%8A%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4.bmp" alt="原理"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码实现：</span></span><br><span class="line">		<span class="keyword">package</span> cn.itcast.cookie;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line">		<span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line">		<span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line">		<span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line">		<span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line">		<span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line">		<span class="keyword">import</span> java.io.IOException;</span><br><span class="line">		<span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line">		<span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line">		<span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line">		<span class="keyword">import</span> java.util.Date;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/cookieTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieTest</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//设置响应的消息体的数据格式以及编码</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取所有Cookie</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//没有cookie为lastTime</span></span><br><span class="line">        <span class="comment">//2.遍历cookie数组</span></span><br><span class="line">        <span class="keyword">if</span>(cookies != <span class="keyword">null</span> &amp;&amp; cookies.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="comment">//3.获取cookie的名称</span></span><br><span class="line">                String name = cookie.getName();</span><br><span class="line">                <span class="comment">//4.判断名称是否是：lastTime</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;lastTime&quot;</span>.equals(name))&#123;</span><br><span class="line">                    <span class="comment">//有该Cookie，不是第一次访问</span></span><br><span class="line"></span><br><span class="line">                    flag = <span class="keyword">true</span>;<span class="comment">//有lastTime的cookie</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//设置Cookie的value</span></span><br><span class="line">                    <span class="comment">//获取当前时间的字符串，重新设置Cookie的值，重新发送cookie</span></span><br><span class="line">                    Date date  = <span class="keyword">new</span> Date();</span><br><span class="line">                    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">                    String str_date = sdf.format(date);</span><br><span class="line">                    System.out.println(<span class="string">&quot;编码前：&quot;</span>+str_date);</span><br><span class="line">                    <span class="comment">//URL编码</span></span><br><span class="line">                    str_date = URLEncoder.encode(str_date,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;编码后：&quot;</span>+str_date);</span><br><span class="line">                    cookie.setValue(str_date);</span><br><span class="line">                    <span class="comment">//设置cookie的存活时间</span></span><br><span class="line">                    cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>);<span class="comment">//一个月</span></span><br><span class="line">                    response.addCookie(cookie);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">            <span class="comment">//响应数据</span></span><br><span class="line">            <span class="comment">//获取Cookie的value，时间</span></span><br><span class="line">            String value = cookie.getValue();</span><br><span class="line">            System.out.println(<span class="string">&quot;解码前：&quot;</span>+value);</span><br><span class="line">            <span class="comment">//URL解码：</span></span><br><span class="line">            value = URLDecoder.decode(value,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;解码后：&quot;</span>+value);</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;&lt;h1&gt;欢迎回来，您上次访问时间为:&quot;</span>+value+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">	</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(cookies == <span class="keyword">null</span> || cookies.length == <span class="number">0</span> || flag == <span class="keyword">false</span>)&#123;</span><br><span class="line">    <span class="comment">//没有，第一次访问</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置Cookie的value</span></span><br><span class="line">    <span class="comment">//获取当前时间的字符串，重新设置Cookie的值，重新发送cookie</span></span><br><span class="line">    Date date  = <span class="keyword">new</span> Date();</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">    String str_date = sdf.format(date);</span><br><span class="line">    System.out.println(<span class="string">&quot;编码前：&quot;</span>+str_date);</span><br><span class="line">    <span class="comment">//URL编码</span></span><br><span class="line">    str_date = URLEncoder.encode(str_date,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;编码后：&quot;</span>+str_date);</span><br><span class="line">	</span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;lastTime&quot;</span>,str_date);</span><br><span class="line">    <span class="comment">//设置cookie的存活时间</span></span><br><span class="line">    cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>);<span class="comment">//一个月</span></span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line">	</span><br><span class="line">    response.getWriter().write(<span class="string">&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>    &#125;
    
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;
            this.doPost(request, response);
        &#125;
    &#125;
</code></pre>
<hr>
<h1 id="Session：主菜"><a href="#Session：主菜" class="headerlink" title="Session：主菜"></a>Session：主菜</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession。</p>
<h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><ol>
<li>获取HttpSession对象：<br> HttpSession session = request.getSession();</li>
<li>使用HttpSession对象：<br> Object getAttribute(String name)<br> void setAttribute(String name, Object value)<br> void removeAttribute(String name)  </li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li><p>Session的实现是依赖于Cookie的。</p>
<p><img src="/%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/Session%E5%8E%9F%E7%90%86.bmp" alt="Session原理"></p>
</li>
</ul>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ol>
<li><strong>当客户端关闭后，服务器不关闭，两次获取session是否为同一个？</strong><ul>
<li>默认情况下。不是。</li>
<li>如果需要相同，则可以创建<code>Cookie</code>,键为<code>JSESSIONID</code>，设置最大存活时间，让cookie持久化保存。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie c = <span class="keyword">new</span> Cookie(<span class="string">&quot;JSESSIONID&quot;</span>,session.getId());</span><br><span class="line"> c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line"> response.addCookie(c);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><strong>客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</strong><ul>
<li>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作<ul>
<li>session的钝化：<ul>
<li>在服务器正常关闭之前，将session对象序列化到硬盘上</li>
</ul>
</li>
<li>session的活化：<ul>
<li>在服务器启动后，将session文件转化为内存中的session对象即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>session什么时候被销毁？</strong><ol>
<li>服务器关闭</li>
<li>session对象调用<code>invalidate()</code> 。</li>
<li>session默认失效时间 30分钟<br> 选择性配置修改     <session-config>
     <session-timeout>30</session-timeout>
 </session-config></li>
</ol>
</li>
</ol>
<h2 id="session的特点"><a href="#session的特点" class="headerlink" title="session的特点"></a>session的特点</h2><ol>
<li><code>session</code>用于存储一次会话的多次请求的数据，存在服务器端</li>
<li><code>session</code>可以存储任意类型，任意大小的数据</li>
</ol>
<ul>
<li><code>session</code>与<code>Cookie</code>的区别：<ol>
<li>session存储数据在服务器端，Cookie在客户端</li>
<li>session没有数据大小限制，Cookie有</li>
<li>session数据安全，Cookie相对于不安全</li>
</ol>
</li>
</ul>
<p>​    </p>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>区间调度算法</title>
    <url>/2020/10/05/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="区间调度算法"><a href="#区间调度算法" class="headerlink" title="区间调度算法"></a>区间调度算法</h1><p>区间调度问题是一个很经典的贪心算法问题。  贪⼼算法可以认为是动态规划算法的⼀个特例， 相⽐动态规划， 使⽤贪⼼算法需要满⾜更多的条件（贪⼼选择性质），但是效率⽐动态规划要⾼ 。</p>
<h2 id="leetcode435-无重叠区间"><a href="#leetcode435-无重叠区间" class="headerlink" title="leetcode435. 无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">leetcode435. 无重叠区间</a></h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<blockquote>
<p>注意:</p>
<ol>
<li><p>可以认为区间的终点总是大于它的起点。</p>
</li>
<li><p>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。<br>示例 1:</p>
</li>
</ol>
<p>输入: [ [1,2], [2,3], [3,4], [1,3] ]</p>
<p>输出: 1</p>
<p>解释: 移除 [1,3] 后，剩下的区间没有重叠。<br>示例 2:</p>
<p>输入: [ [1,2], [1,2], [1,2] ]</p>
<p>输出: 2</p>
<p>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。<br>示例 3:</p>
<p>输入: [ [1,2], [2,3] ]</p>
<p>输出: 0</p>
<p>解释: 你不需要移除任何区间，因为它们已经是无重叠的了</p>
</blockquote>
<p>这个问题有许多看起来不错的贪⼼思路， 却都不能得到正确答案。 ⽐如说：也许我们可以每次选择可选区间中开始最早的那个？ 但是可能存在某些区间开始很早， 但是很⻓， 使得我们错误地错过了⼀些短的区间。 或者我们每次选择可选区间中最短的那个？ 或者选择出现冲突最少的那个区间？ 这些⽅案都能很容易举出反例， 不是正确的⽅案。</p>
<p>正确的思路其实很简单， 可以分为以下三步：</p>
<ol>
<li>从区间集合 intvs 中选择⼀个区间 x， 这个 x 是在当前所有区间中结束早的（end 最⼩） </li>
<li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li>
<li>重复步骤 1 和 2， 直到 intvs 为空为⽌。 之前选出的那些 x 就是最⼤不<br>相交⼦集。  </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(intervals, (a, b)-&gt; a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x_end = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] a: intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] &lt; x_end )&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               x_end =  a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="leetcode452-用最少数量的箭引爆气球"><a href="#leetcode452-用最少数量的箭引爆气球" class="headerlink" title="leetcode452. 用最少数量的箭引爆气球"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">leetcode452. 用最少数量的箭引爆气球</a></h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在10^4个气球。</p>
<p>一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p><strong>Example:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。</span><br></pre></td></tr></table></figure>

<p>这个问题和区间调度算法⼀模⼀样！ 如果最多有 n 个不重叠的区间， 那么就⾄少需要 n 个箭头穿透所有区间。只是有⼀点不⼀样， 在 intervalSchedule 算法中， 如果两个区间的边界触碰， 不算重叠； ⽽按照这道题⽬的描述， 箭头如果碰到⽓球的边界⽓球也会爆炸， 所以说相当于区间的边界触碰也算重叠。</p>
<p>在上道题目的基础上稍微修改即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 无重叠的+1 </span></span><br><span class="line">         <span class="keyword">if</span>(points.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(points, (a, b)-&gt; a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x_end = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] a: points)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] &gt; x_end )&#123;</span><br><span class="line">                count++;</span><br><span class="line">           </span><br><span class="line">               x_end =  a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="区间调度问题之区间合并"><a href="#区间调度问题之区间合并" class="headerlink" title="区间调度问题之区间合并"></a>区间调度问题之区间合并</h1><h2 id="leetcode56-合并区间"><a href="#leetcode56-合并区间" class="headerlink" title="leetcode56. 合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">leetcode56. 合并区间</a></h2><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: intervals = [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>

<p>⼀个区间可以表⽰为 [start, end] ， 前⽂聊的区间调度问题， 需要按 end排序， 以便满⾜贪⼼选择性质。 ⽽对于区间合并问题， 其实按 end 和start 排序都可以， 不过为了清晰起⻅， 我们选择按 start 排序。  </p>
<p>显然， 对于⼏个相交区间合并后的结果区间 x ， x.start ⼀定是这些相交区间中 start 最⼩的， x.end ⼀定是这些相交区间中 end 最⼤的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">          <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = intervals.length;</span><br><span class="line">        <span class="keyword">int</span> n = intervals[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]  &gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       </span><br><span class="line">        Arrays.sort(intervals, (a, b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        res.add(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = intervals[i];</span><br><span class="line">            <span class="keyword">int</span>[] last = res.get(res.size()-<span class="number">1</span>); <span class="comment">// 注意这里是引用</span></span><br><span class="line">            <span class="keyword">if</span>(curr[<span class="number">0</span>] &lt;= last[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">// 找到最大的end</span></span><br><span class="line">                last[<span class="number">1</span>] = Math.max(last[<span class="number">1</span>], curr[<span class="number">1</span>]); <span class="comment">//  会修改list中值</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               res.add(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="区间交集问题"><a href="#区间交集问题" class="headerlink" title="区间交集问题"></a>区间交集问题</h1><h2 id="leetcode986-区间列表的交集"><a href="#leetcode986-区间列表的交集" class="headerlink" title="leetcode986. 区间列表的交集"></a><a href="https://leetcode-cn.com/problems/interval-list-intersections/">leetcode986. 区间列表的交集</a></h2><p>给定两个由一些 <strong>闭区间</strong> 组成的列表，每个区间列表都是成对不相交的，并且已经排序。</p>
<p>返回这两个区间列表的交集。</p>
<p><em>（形式上，闭区间 <code>[a, b]</code>（其中 <code>a &lt;= b</code>）表示实数 <code>x</code> 的集合，而 <code>a &lt;= x &lt;= b</code>。两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3]。）</em></p>
 <img src="/2020/10/05/%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/1601885690911.png" class width="1601885690911">

<p>输入：A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]</p>
<p>输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</p>
<p>画图可知规律。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[] &gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>  i =<span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; A.length &amp;&amp; j &lt; B.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> a1 = A[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> a2 = A[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> b1 = B[j][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> b2 = B[j][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(b2 &gt;= a1 &amp;&amp; a2 &gt;= b1)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Math.max(a1,b1), Math.min(a2, b2)&#125;);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b2 &lt; a2)&#123;</span><br><span class="line">                j++;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/qu-jian-jiao-ji-wen-ti">https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/qu-jian-jiao-ji-wen-ti</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题解之单调栈和单调队列</title>
    <url>/2020/10/02/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>栈是很简单的⼀种数据结构， 先进后出的逻辑顺序， 符合某些问题的特点， ⽐如说函数调⽤栈。</p>
<p>单调栈实际上就是栈， 只是利⽤了⼀些巧妙的逻辑， 使得每次新元素⼊栈后， 栈内的元素都保持有序（单调递增或单调递减） 。</p>
<p><code>leetcode</code>有一些题目可以使用单调栈来解决。</p>
<h2 id="leetcode496-下一个更大元素-I"><a href="#leetcode496-下一个更大元素-I" class="headerlink" title="leetcode496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">leetcode496. 下一个更大元素 I</a></h2><p>给定两个没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</p>
<p>输出: [-1,3,-1]</p>
<p>解释:</p>
<p>对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。</p>
<p>对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。</p>
<p>对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。</p>
<p>示例 2:</p>
<p>输入: nums1 = [2,4], nums2 = [1,2,3,4].</p>
<p>输出: [3,-1]</p>
<p>解释:</p>
<p>对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。</p>
<p>对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums2.length];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums2.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums2[i] &gt;= stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">int</span> tmp =  stack.isEmpty()? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            map.put(nums2[i], tmp ); </span><br><span class="line">            stack.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++)&#123;</span><br><span class="line">            res[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="leetcode739-每日温度"><a href="#leetcode739-每日温度" class="headerlink" title="leetcode739. 每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/">leetcode739. 每日温度</a></h2><p>请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p><strong>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</strong></p>
<p>这个问题本质上也是找 Next Greater Number， 只不过现在不是问你 Next Greater Number 是多少， ⽽是问你当前距离 Next Greater Number 的距离⽽已。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = T.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>( !stack.isEmpty() &amp;&amp; T[stack.peek()] &lt;= T[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = stack.isEmpty()? <span class="number">0</span> : stack.peek()-i;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何处理「循环数组」"><a href="#如何处理「循环数组」" class="headerlink" title="如何处理「循环数组」"></a>如何处理「循环数组」</h2><p>同样是 <code>Next Greater Number</code>， 现在假设给你的数组是个环形的， 如何处理？  </p>
<h3 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<blockquote>
<p>示例 1:</p>
<p>输入: [1,2,1]</p>
<p>输出: [2,-1,2]</p>
<p>解释: 第一个 1 的下一个更大的数是 2；</p>
<p>数字 2 找不到下一个更大的数； </p>
<p>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</p>
<p><strong>注意: 输入数组的长度不会超过 10000。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> * nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>( !stack.isEmpty() &amp;&amp; stack.peek()  &lt;= nums[i % nums.length])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i % nums.length] = stack.isEmpty() ? -<span class="number">1</span>: stack.peek() ;</span><br><span class="line">            stack.push(nums[i % nums.length]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者开辟一个新数组，将原数组复制两份。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*nums.length];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">           arr[i] = nums[i % nums.length];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">       Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">           <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; arr[i] &gt;= stack.peek())&#123;</span><br><span class="line">               stack.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           res[i % nums.length  ] = stack.isEmpty()?-<span class="number">1</span>: stack.peek();</span><br><span class="line"></span><br><span class="line">           stack.push(arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="腾讯笔面试题：逛街"><a href="#腾讯笔面试题：逛街" class="headerlink" title="腾讯笔面试题：逛街"></a><a href="https://www.nowcoder.com/question/next?pid=21283868&qid=830860&tid=38202672">腾讯笔面试题：逛街</a></h2><p>2021校招亲身经历的面试题，可惜了，当时没做出来</p>
<p>小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。</p>
<p>小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住）</p>
<h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入第一行将包含一个数字n，代表楼的栋数，接下来的一行将包含n个数字wi(1&lt;=i&lt;=n)，代表每一栋楼的高度。1&lt;=n&lt;=100000;1&lt;=wi&lt;=100000; </span><br></pre></td></tr></table></figure>

<h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出一行，包含空格分割的n个数字vi，分别代表小Q在第i栋楼时能看到的楼的数量。</span><br></pre></td></tr></table></figure>

<h5 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a><strong>输入例子1:</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5 3 8 3 2 5</span><br></pre></td></tr></table></figure>

<h5 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a><strong>输出例子1:</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3 5 4 4 4</span><br></pre></td></tr></table></figure>

<h5 id="例子说明1"><a href="#例子说明1" class="headerlink" title="例子说明1:"></a><strong>例子说明1:</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当小Q处于位置3时，他可以向前看到位置2,1处的楼，向后看到位置4,6处的楼，加上第3栋楼，共可看到5栋楼。当小Q处于位置4时，他可以向前看到位置3处的楼，向后看到位置5,6处的楼，加上第4栋楼，共可看到4栋楼。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] MaxBuilding(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 从前向后遍历，维持一个递减栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            res[i] = stack.size(); <span class="comment">//前面能看到的数量</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; arr[i] &gt;= arr[stack.peek()])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.clear();</span><br><span class="line">        <span class="comment">// 从后向前遍历，同样维持递减栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length - <span class="number">1</span>;i &gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            res[i] = res[i] + <span class="number">1</span> + stack.size();;<span class="comment">//后面能看到的数量 + 自己</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[i] &gt;= arr[stack.peek()]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> len = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++)&#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = MaxBuilding(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            System.out.print(res[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>所谓单调队列，就是在保持原始队列的先进先出的特性外，添加一个新方法getMax(), 可以以O(1)的时间复杂度获取当前队列的最大值。</p>
<p>字节亲身经历的面试题！！！可惜了</p>
<p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; data = <span class="keyword">null</span>;</span><br><span class="line">    Deque&lt;Integer&gt; maxQ = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        maxQ = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!maxQ.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> maxQ.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!maxQ.isEmpty() &amp;&amp; maxQ.peekLast() &lt; value)&#123;</span><br><span class="line">            maxQ.pollLast(); <span class="comment">// 从后面出队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        maxQ.offerLast(value);</span><br><span class="line">        data.offer(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(data.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> poll = data.peek();</span><br><span class="line">        <span class="keyword">if</span>(poll == maxQ.peek())&#123;</span><br><span class="line">            maxQ.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        data.poll();</span><br><span class="line">        <span class="keyword">return</span> poll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.max_value();</span></span><br><span class="line"><span class="comment"> * obj.push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="leetcode239-滑动窗口最大值"><a href="#leetcode239-滑动窗口最大值" class="headerlink" title="leetcode239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">leetcode239. 滑动窗口最大值</a></h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>示例:</p>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</p>
<p>输出: [3,3,5,5,6,7] </p>
<p>解释: </p>
<p>  滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3</p>
<p>1 [3  -1  -3] 5  3  6  7       3</p>
<p>1  3 [-1  -3  5] 3  6  7       5</p>
<p>1  3  -1 [-3  5  3] 6  7       5</p>
<p>1  3  -1  -3 [5  3  6] 7       6</p>
<p>1  3  -1  -3  5 [3  6  7]      7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MonotonicQueue</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Deque&lt;Integer&gt; q;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MonotonicQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> q.peek();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; value &gt; q.getLast())&#123;</span><br><span class="line">                q.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            q.offer(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!q.isEmpty() &amp;&amp; q.peek() == value)&#123;</span><br><span class="line">                q.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        MonotonicQueue q =  <span class="keyword">new</span> MonotonicQueue();</span><br><span class="line">        <span class="keyword">int</span>[] res  = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i  &lt; k -<span class="number">1</span>)&#123;</span><br><span class="line">                q.push(nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 窗口滑动</span></span><br><span class="line">                q.push(nums[i]);</span><br><span class="line">                res[j++] = q.max();</span><br><span class="line">                q.pop(nums[i- k + <span class="number">1</span>]); <span class="comment">//  移除窗口的最后一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈游戏算法</title>
    <url>/2020/09/01/%E5%8D%9A%E5%BC%88%E6%B8%B8%E6%88%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="leetcode486-预测赢家"><a href="#leetcode486-预测赢家" class="headerlink" title="leetcode486. 预测赢家"></a>leetcode<a href="https://leetcode-cn.com/problems/predict-the-winner/">486. 预测赢家</a></h1><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p>
<p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：[1, 5, 2]<br>输出：False<br>解释：一开始，玩家1可以从1和2中进行选择。<br>如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。<br>所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。<br>因此，玩家 1 永远不会成为赢家，返回 False 。<br>示例 2：</p>
<p>输入：[1, 5, 233, 7]<br>输出：True<br>解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。<br>     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。</p>
</blockquote>
<blockquote>
<p>提示：</p>
<p>1 &lt;= 给定的数组长度 &lt;= 20.<br>数组里所有分数都为非负数且不会大于 10000000 。<br>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pairs</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first; <span class="comment">// 先手</span></span><br><span class="line">    <span class="keyword">int</span> second; <span class="comment">//  后手</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pairs</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个类first表示先手，second表示后手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pairs[][] dp = <span class="keyword">new</span> Pairs[n][n];</span><br></pre></td></tr></table></figure>

<p>dp[i][j] 表示 面对nums[i … j] , 两个选手的所能得到的最高分数</p>
<p>则：</p>
<p>dp[i][j].first = max(nums[i] + dp[i+1][j].second,  nums[j] + dp[i][j-1].second)</p>
<p>dp[i][j].first = max( 选择最左边的⽯头堆 , 选择最右边的⽯头堆 )</p>
<blockquote>
<p>解释： </p>
<p>我作为先⼿， ⾯对 nums[i…j] 时， 有两种选择：</p>
<p>要么我选择最左边的那⼀堆⽯头， 然后⾯对 nums[i+1…j]</p>
<p>但是此时轮到对⽅， 相当于我变成了后⼿；</p>
<p>要么我选择最右边的那⼀堆⽯头， 然后⾯对 nums[i…j-1]</p>
<p>但是此时轮到对⽅， 相当于我变成了后⼿。</p>
</blockquote>
<p>此时，如果 先⼿选择左边:</p>
<p>dp[i][j].second = dp[i+1][j].fir</p>
<p>if 先⼿选择右边:</p>
<p>dp[i][j].sec = dp[i][j-1].fir</p>
<blockquote>
<p>解释： 我作为后⼿， 要等先⼿先选择， 有两种情况：</p>
<p>如果先⼿选择了最左边那堆， 给我剩下了 piles[i+1…j]</p>
<p>此时轮到我， 我变成了先⼿；</p>
<p>如果先⼿选择了最右边那堆， 给我剩下了 piles[i…j-1]</p>
<p>此时轮到我， 我变成了先⼿。  </p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pairs</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pairs</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = nums.length;</span><br><span class="line">       <span class="keyword">if</span>(n == <span class="number">1</span>)   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Pairs[][] dp = <span class="keyword">new</span> Pairs[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;n; j++)&#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">new</span> Pairs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 只有一堆</span></span><br><span class="line">            <span class="comment">// 先手拿到的分数， 后手肯定为0，</span></span><br><span class="line">            dp[i][i].first = nums[i];</span><br><span class="line">            dp[i][i].second = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/// 斜着遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">2</span>; r &lt;= n; r++) &#123; <span class="comment">//对角线</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - r + <span class="number">1</span>; i++) &#123; <span class="comment">// 行控制</span></span><br><span class="line">                <span class="keyword">int</span> j = r + i - <span class="number">1</span>; <span class="comment">// 列</span></span><br><span class="line">                <span class="comment">// 选择拿左边的还是右边的</span></span><br><span class="line">                <span class="keyword">int</span> left = dp[i+<span class="number">1</span>][j].second + nums[i];</span><br><span class="line">                <span class="keyword">int</span> right = dp[i][j-<span class="number">1</span>].second+ nums[j];</span><br><span class="line">                <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                    <span class="comment">// 选择左边</span></span><br><span class="line">                    dp[i][j].first = left;</span><br><span class="line">                    dp[i][j].second = dp[i+<span class="number">1</span>][j].first;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j].first = right;</span><br><span class="line">                    dp[i][j].second = dp[i][j-<span class="number">1</span>].first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>].first &gt;=  dp[<span class="number">0</span>][n-<span class="number">1</span>].second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="leetcode-877-石子游戏"><a href="#leetcode-877-石子游戏" class="headerlink" title="leetcode 877. 石子游戏"></a>leetcode <a href="https://leetcode-cn.com/problems/stone-game/">877. 石子游戏</a></h1><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</p>
<p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p>
<p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p>
<p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p>
<blockquote>
<p>示例：</p>
<p>输入：[5,3,4,5]<br>        输出：true<br>解释：<br>亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。<br>假设他取了前 5 颗，这一行就变成了 [3,4,5] 。<br>如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。<br>如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。<br>这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</p>
<p>提示：</p>
<p>2 &lt;= piles.length &lt;= 500<br>        piles.length 是偶数。<br>        1 &lt;= piles[i] &lt;= 500<br>        sum(piles) 是奇数。</p>
</blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/stone-game">https://leetcode-cn.com/problems/stone-game</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>和上面一样的题目。</p>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stoneGame</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>擦…总是会赢。</p>
<p>这是为什么呢， 因为题⽬有两个条件很重要： ⼀是⽯头总共有偶数堆， ⽯头的总数是奇数。 这两个看似增加游戏公平性的条件， 反⽽使该游戏成为了⼀个割⾲菜游戏。 我们以 piles=[2, 1, 9, 5] 讲解， 假设这四堆⽯头从左到右的索引分别是 1， 2， 3， 4。 </p>
<p>  如果我们把这四堆⽯头按索引的奇偶分为两组， 即第 1、 3 堆和第 2、 4 堆，那么这两组⽯头的数量⼀定不同， 也就是说⼀堆多⼀堆少。 因为⽯头的总数是奇数， 不能被平分。</p>
<p>⽽作为第⼀个拿⽯头的⼈， 你可以控制⾃⼰拿到所有偶数堆， 或者所有的奇数堆。你最开始可以选择第 1 堆或第 4 堆。 如果你想要偶数堆， 你就拿第 4 堆， 这样留给对⼿的选择只有第 1、 3 堆， 他不管怎么拿， 第 2 堆⼜会暴露出来，你就可以拿。 </p>
<p>同理， 如果你想拿奇数堆， 你就拿第 1 堆， 留给对⼿的只有第2、 4 堆， 他不管怎么拿， 第 3 堆⼜给你暴露出来了。也就是说， 你可以在第⼀步就观察好， 奇数堆的⽯头总数多， 还是偶数堆的⽯头总数多， 然后步步为营， 就⼀切尽在掌控之中了。  </p>
<h1 id="leetcode292-Nim-游戏"><a href="#leetcode292-Nim-游戏" class="headerlink" title="leetcode292. Nim 游戏"></a><a href="https://leetcode-cn.com/problems/nim-game/">leetcode292. Nim 游戏</a></h1><p>这是一道简单题？？？？？？？？？？</p>
<p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
<blockquote>
<p>示例:</p>
<p>输入: 4<br>输出: false<br>解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；<br>因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</p>
</blockquote>
<h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><p>当没有石子的话，也就意味着最后的石子被对方拿走了，也就是你输了。</p>
<p>当石子数剩下 <code>1, 2, 3</code> 个的时候，你可以一次性都拿走，也就是你赢了。</p>
<p>然后我们考虑所有的情况。</p>
<p>你拿走 1 个石子，然后不论对方从剩下的石子中拿走 1 个，2 个，还是 3 个，判断一下剩下的石子你是不是有稳赢的策略。</p>
<p>如果上边不行的话，你就拿走 2 个石子，然后再判断不论对方从剩下的石子拿走 1 个，2 个，还是3 个，剩下的石子你是不是都有稳赢的策略。</p>
<p>如果上边还不行的话，你就拿走 3 个石子，然后再判断不论对方从剩下的石子拿走 1 个，2 个，还是3 个，剩下的石子你是不是都有稳赢的策略。</p>
<p>如果上边通通不行，那就是你输了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(canWinNim(n-<span class="number">1</span>-i) &amp;&amp; canWinNim(n-<span class="number">2</span>-i) &amp;&amp; canWinNim(n-<span class="number">3</span>-i) )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>超时时间限制</p>
</blockquote>
<p>使用备忘录的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(n))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(canWinNim(n-<span class="number">1</span>-i) &amp;&amp; canWinNim(n-<span class="number">2</span>-i) &amp;&amp; canWinNim(n-<span class="number">3</span>-i) )&#123;</span><br><span class="line">                map.put(n, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(n, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Stack Overflow 。。。</p>
</blockquote>
<h2 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h2><p>先说结论： </p>
<p>我们解决这种问题的思路⼀般都是反着思考：</p>
<p>如果我能赢， 那么最后轮到我取⽯⼦的时候必须要剩下 1~3 颗⽯⼦， 这样我才能⼀把拿完。如何营造这样的⼀个局⾯呢？ </p>
<p>显然， 如果对⼿拿的时候只剩 4 颗⽯⼦， 那么⽆论他怎么拿， 总会剩下 1<del>3 颗⽯⼦， 我就能赢。如何逼迫对⼿⾯对 4 颗⽯⼦呢？ 要想办法， 让我选择的时候还有 5</del>7 颗⽯⼦， 这样的话我就有把握让对⽅不得不⾯对 4 颗⽯⼦。  </p>
<p>如何营造 5<del>7 颗⽯⼦的局⾯呢？ 让对⼿⾯对 8 颗⽯⼦， ⽆论他怎么拿， 都会给我剩下 5</del>7 颗， 我就能赢。这样⼀直循环下去， 我们发现只要踩到 4 的倍数， 就落⼊了圈套， 永远逃不出 4 的倍数， ⽽且⼀定会输。 所以这道题的解法⾮常简单：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果上来就踩到 4 的倍数， 那就认输吧</span></span><br><span class="line"><span class="comment">// 否则， 可以把对⽅控制在 4 的倍数， 必胜</span></span><br><span class="line"><span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h1 id="电灯开关问题"><a href="#电灯开关问题" class="headerlink" title="电灯开关问题"></a>电灯开关问题</h1><p>这个问题是这样描述的： 有 n 盏电灯， 最开始时都是关着的。 现在要进⾏ n<br>轮操作：</p>
<p>第 1 轮操作是把每⼀盏电灯的开关按⼀下（全部打开） 。</p>
<p>第 2 轮操作是把每两盏灯的开关按⼀下（就是按第 2， 4， 6… 盏灯的开关，它们被关闭） 。</p>
<p>第 3 轮操作是把每三盏灯的开关按⼀下（就是按第 3， 6， 9… 盏灯的开关，有的被关闭， ⽐如3， 有的被打开， ⽐如 6） …</p>
<p>如此往复， 直到第 n 轮， 即只按⼀下第 n 盏灯的开关。<br>现在给你输⼊⼀个正整数 n 代表电灯的个数， 问你经过 n 轮操作后， 这些电灯有多少盏是亮的？</p>
<h2 id="布尔数组统计"><a href="#布尔数组统计" class="headerlink" title="布尔数组统计"></a>布尔数组统计</h2><p>使用一个布尔数组去模拟上述操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isLight</span><span class="params">(<span class="keyword">int</span>  n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j+=i)&#123;</span><br><span class="line">               flag[j] = !flag[j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 统计</span></span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="妙解"><a href="#妙解" class="headerlink" title="妙解"></a>妙解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isLight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">int</span>)Math.sqrt(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⾸先， 因为电灯⼀开始都是关闭的， 所以某⼀盏灯最后如果是点亮的， 必然要被按奇数次开关。</p>
<p>我们假设只有 6 盏灯， ⽽且我们只看第 6 盏灯。 需要进⾏ 6 轮操作对吧， 请问对于第 6 盏灯，会被按下⼏次开关呢？ 这不难得出， 第 1 轮会被按， 第 2轮， 第 3 轮， 第 6 轮都会被按。</p>
<p>为什么第 1、 2、 3、 6 轮会被按呢？ 因为 6=1<em>6=2</em>3 。 ⼀般情况下， 因⼦都是成对出现的， 也就是说开关被按的次数⼀般是偶数次。 但是有特殊情况，⽐如说总共有 16 盏灯， 那么第 16 盏灯会被按⼏次?</p>
<p>  16=1*16=2*8=4*4</p>
<p>其中因⼦ 4 重复出现， 所以第 16 盏灯会被按 5 次， 奇数次。 现在你应该理解这个问题为什么和平⽅根有关了吧？不过， 我们不是要算最后有⼏盏灯亮着吗， 这样直接平⽅根⼀下是啥意思<br>呢？ 稍微思考⼀下就能理解了。</p>
<p>就假设现在总共有 16 盏灯， 我们求 16 的平⽅根， 等于 4， 这就说明最后会有 4 盏灯亮着， 它们分别是第 1*1=1 盏、 第 2*2=4 盏、 第 3*3=9 盏和第4*4=16 盏。</p>
<p>就算有的 n 平⽅根结果是⼩数， 强转成 int 型， 也相当于⼀个最⼤整数上界， ⽐这个上界⼩的所有整数， 平⽅后的索引都是最后亮着的灯的索引。 所以说我们直接把平⽅根转成整数， 就是这个问题的答案。  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://leetcode-cn.com/problems/nim-game/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-54/">https://leetcode-cn.com/problems/nim-game/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-54/</a></li>
<li> <a href="https://labuladong.gitbook.io/algo">https://labuladong.gitbook.io/algo</a> </li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>Java四大引用类型</title>
    <url>/2021/07/23/%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="四大引用类型"><a href="#四大引用类型" class="headerlink" title="四大引用类型"></a>四大引用类型</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>被强引用关联的对象不会被回收。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<p>当内存不足。JVM开始垃圾回收，对于强引用的对象，<strong>就算是出现了OOM也不会对该对象进行回收，死都不收。</strong></p>
<p>强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还活着。垃圾收集器不会碰这种对象。Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，他是不可能被垃圾回收机制回收的。<strong>即使该对象以后永远都不会被用到，jvm也不会回收</strong>。因此，<strong>强引用是造成Java内存泄露的主要原因之一。</strong></p>
<p>对于一个普通对象，如果没有其他的引用关系，只要超过了引用的作用域或者显示的将强引用赋值为null，一般就认为就是可以被垃圾收集的了，当然具体回收时机还要看垃圾收集策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.reference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-26-20:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这样定义的默认是强引用</span></span><br><span class="line">        Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object obj2 = obj1; <span class="comment">// obj2引用赋值</span></span><br><span class="line">        obj1 = <span class="keyword">null</span>;<span class="comment">// 置为null</span></span><br><span class="line">        System.gc(); <span class="comment">// 并不会马上执行垃圾回收 执行System.gc()函数的作用只是提醒或告诉虚拟机，希望进行一次垃圾回收。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>java.lang.Object@1540e19d</p>
</blockquote>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>
<p>使用 SoftReference 类来创建软引用。</p>
<p>软引用通常用在对内存才能敏感的程序中，比如高速缓存就有用到软引用，内存够的时候就保留，不够就回收。</p>
<p>先设置JVM参数： -Xmx20m，  heap内存为20M</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-26-20:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[] &gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1224</span>*<span class="number">10</span>]);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line">        <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>]; <span class="comment">//再分配一个数组，heap将装不下，这时系统会进行垃圾回收，先回收一次，如果不够，就会把软引用回收</span></span><br><span class="line"></span><br><span class="line">        System.out.println(softReference.get());  <span class="comment">// 回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[B@1540e19d<br>[B@1540e19d<br>null</p>
</blockquote>
<p>假如有一个应用需要读取大量的本地图片，如果每一次读取图片都是从硬盘中读取则会严重影响性能；如果一次性全部加载到内存中又可能造成内存溢出。</p>
<p>此时可以使用软引用来解决这个问题。</p>
<p>设计思路： 用一个HashMap来保存图片的路径和相应图片对象的软引用之间的映射关系，在内存不足时候，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imgCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>被弱引用关联的对象<strong>一定会被回收</strong>，也就是说它只能存活到下一次垃圾回收发生之前。</p>
<p>使用 WeakReference 类来创建弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-26-20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakRederenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakReference&lt;M&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> M());</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>cn.hongliang.reference.M@1540e19d<br>null<br>finalize</p>
</blockquote>
<h3 id="weakHashMap"><a href="#weakHashMap" class="headerlink" title="weakHashMap"></a>weakHashMap</h3><p>待补充…</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 PhantomReference 来创建虚引用。</p>
<p>顾名思义，就是<strong>形同虚设</strong>。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。他不能单独使用，也不能通过他访问对象。虚引用必须和引用队列（ReferenceQueue）联合使用。</p>
<p>虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize以后做某些事情的机制。PhantomReference 的get方法总是返回null。因此无法访问对应的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收。用来实现比finalization机制更灵活的回收操作。</p>
<p>换句话说，设置虚引用关联的唯一目的就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步处理。java技术允许使用finalize方法在垃圾收集器将对象从内存中移除出去之前 做必要的清理工作。</p>
<p>实际上，这个和<strong>直接内存</strong>有关。虚引用的作用就是为了管理直接内存。</p>
<p>我们程序的内存通常是由JVM来管理的，垃圾回收器是工作在JVM里面，但是为了提高效率，比如说，当OS收到了网络发送来的数据，会通过OS的系统内核的方法将传来的数据放在OS的内存里面，如果Java程序要用的话，需要从OS的内存中copy过来，这样的效率太低了。所以在新版的JVM中提供了一个直接内存（DirectByteBuffer），他可以通过虚拟机的一个指针直接指向OS管理的内存中。可以直接访问操作系统的内存，这样就不需要copy一份了。</p>
<img src="/2021/07/23/%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/image-20200826210428327.png" class title="image-20200826210428327">

<p>那么JVM怎么回收这部分系统内存呢？</p>
<p>内部机制就是用的虚引用，虚引用new的时候，执指向一个对象，这个对象要回收的时候，会将其放入一个队列里面，相当于跟踪这个对象。主要分为两步，第一步将其放入队列，第二步是通过队列来进行回收的。需要回收的时候发起一个通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-26-20:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Object&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;M&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PhantomReference&lt;M&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> M(), queue);</span><br><span class="line">        System.out.println(phantomReference.get());</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(phantomReference.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Reference&lt;? extends M&gt; poll = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(poll != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;虚引用被JVM回收了...&quot;</span> + poll);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<img src="/2021/07/23/%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/image-20200826211425980.png" class title="image-20200826211425980">
</blockquote>
]]></content>
      <categories>
        <category>Java高并发</category>
      </categories>
      <tags>
        <tag>Thread</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的统计字符串</title>
    <url>/2020/09/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>链接：<a href="https://www.nowcoder.com/questionTerminal/e8b97a6d64ae4304b6f0ff4ecae1589d?orderByHotValue=1&amp;page=1&amp;onlyReference=false%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%89%9B%E5%AE%A2%E7%BD%91">https://www.nowcoder.com/questionTerminal/e8b97a6d64ae4304b6f0ff4ecae1589d?orderByHotValue=1&amp;page=1&amp;onlyReference=false来源：牛客网</a></p>
<p> 给定一个字符串str，返回str的统计字符串。例如“aaabbbbcccd”的统计字符串为“a_3_b_4_c_3_d_1”。 </p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">offerofferzainaliiiiii</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o_1_f_2_e_1_r_1_o_1_f_2_e_1_r_1_z_1_a_1_i_1_n_1_a_1_l_1_i_6</span><br></pre></td></tr></table></figure>

<p>示例2</p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hhhaaa</span><br></pre></td></tr></table></figure>

<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h_3_a_3</span><br></pre></td></tr></table></figure>



<h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a><strong>备注:</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间复杂度O（n） 空间复杂度O（n）</span><br></pre></td></tr></table></figure>



<h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String s = sc.next();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.length(); i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.print(s.charAt(i-<span class="number">1</span>)+<span class="string">&quot;_&quot;</span>+n+<span class="string">&quot;_&quot;</span>);</span><br><span class="line">                n = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s.charAt(s.length()-<span class="number">1</span>)+<span class="string">&quot;_&quot;</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>中等</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序应用之-计算数组的小和</title>
    <url>/2020/02/29/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><blockquote>
<p> <strong>小和问题：</strong> 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。 </p>
<p>数组小和的定义如下：</p>
<p>例如，数组s = [1, 3, 5, 2, 4, 6]</p>
<p>在s[0]的左边小于或等于s[0]的数的和为0；</p>
<p>在s[1]的左边小于或等于s[1]的数的和为1；</p>
<p>在s[2]的左边小于或等于s[2]的数的和为1+3=4；</p>
<p>在s[3]的左边小于或等于s[3]的数的和为1；</p>
<p>在s[4]的左边小于或等于s[4]的数的和为1+3+2=6；</p>
<p>在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15。</p>
<p>所以s的小和为0+1+4+1+6+15=27</p>
<p>给定一个数组s，实现函数返回s的小和</p>
<p>要求时间复杂度为<code>O(logN)</code>， 空间复杂度为<code>O(N).</code></p>
<p>牛客网： <a href="https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469?tpId=101&tqId=33089&tPage=1&rp=1&ru=/ta/programmer-code-interview-guide&qru=/ta/programmer-code-interview-guide/question-ranking">计算数组的小和</a>.</p>
</blockquote>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><blockquote>
<p>第一行有一个整数N。表示数组长度接下来一行N个整数表示数组内的数</p>
</blockquote>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><blockquote>
<p>一个整数，表示答案。</p>
</blockquote>
<p>示例1：</p>
<blockquote>
<p>输入：</p>
<p>6</p>
<p>1 3 5 2 4 6</p>
</blockquote>
<blockquote>
<p>输出：</p>
<p>27</p>
</blockquote>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>$1 \le N \le 10^5$</p>
<p>$-100 \le arr_i \le 100$</p>
<hr>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>可以使用暴力方法，双重for循环，遍历数组中每一个元素，计算它左边比他小的数，累加起来即得答案。</p>
<p>但是题目要求时间复杂度为 $O(log N)$ , 此题可用归并排序思想来解答， 在merge的过程中计算小和。</p>
<ul>
<li><p>a. 将当前序列分为两个子序列，分别求其小和</p>
</li>
<li><p>b. 对a划分得到的两个子序列进行merge操作，得到合并过程产生的小和，再加上a得到的两个子序列的小和之和</p>
</li>
<li><p>c. 递归地执行a和b。</p>
<blockquote>
<p>求一个数组的小和，可以转化为求每个元素在小和累加过程出现的次数，然后将当前元素与出现次数相乘，累加得到小和。<br>假设当前元素为a，a右边比a大的元素个数则为a在小和累加过程出现的次数 。</p>
</blockquote>
</li>
</ul>
<img src="/2020/02/29/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98/xiaohe.png" alt="1582993137181" style="zoom:80%;">

<hr>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> 注意两个细节， 这个题目的小和，当左边的数字和当前的数相等时，也算一个小和。所有循环里面的判断if 应该是 &lt;= 。然后就是help数组的大小应为high-low+1， 注意拷贝回原数组的细节： </p>
<p>github：  <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/Sort/smallSum.java">https://github.com/Castile/algorithm/blob/master/leetcode/src/Sort/smallSum.java</a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-29 22:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 暴力方法 O(N^2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>  <span class="title">smallSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[i])&#123;</span><br><span class="line">                    sum+=arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">samllSum_merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low == high) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算mid的位置</span></span><br><span class="line">        <span class="keyword">int</span> mid = low + (( high - low ) &gt;&gt; <span class="number">1</span>); <span class="comment">// 这样可以避免溢出，而且使用了位运算，效率更高</span></span><br><span class="line">        <span class="keyword">return</span> samllSum_merge(arr, low, mid) + samllSum_merge(arr, mid+<span class="number">1</span>, high) + merge(arr, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归并两个有序的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>]; <span class="comment">// 注意此处数组的大小</span></span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p = low;</span><br><span class="line">        <span class="keyword">int</span> q = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= mid &amp;&amp; q &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[p] &lt;= arr[q])&#123; <span class="comment">//  左边比又变小，产生小和</span></span><br><span class="line">                result += arr[p] * ( high - q + <span class="number">1</span>);</span><br><span class="line">                help[k++] = arr[p++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[p] &gt; arr[q])&#123;</span><br><span class="line">                help[k++] = arr[q++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p &lt;= mid)&#123;</span><br><span class="line">            help[k] = arr[p++];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q &lt;= high)&#123;</span><br><span class="line">            help[k] = arr[q++];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// copy</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; high - low + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            arr[low + i] = help[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n; i++)&#123;</span><br><span class="line">            arr[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sum =  samllSum_merge(arr,<span class="number">0</span>, arr.length -<span class="number">1</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>困难</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序应用之逆序对的个数</title>
    <url>/2020/03/03/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8%E4%B9%8B%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>归并排序的应用，在merge操作的时候就可以计算出逆序对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums,  <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high  - low) &gt;&gt; <span class="number">1</span>);  <span class="comment">// 要加括号</span></span><br><span class="line">        <span class="keyword">return</span> merge(nums, low, mid) + merge(nums, mid+<span class="number">1</span>, high) + mergr_op(nums, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mergr_op</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[high  - low +<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> p1 = low;</span><br><span class="line">        <span class="keyword">int</span> p2 = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// 逆序对的个数</span></span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p1] &lt;= nums[p2])&#123;</span><br><span class="line">                help[k++] = nums[p1++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[p1] &gt; nums[p2])&#123;</span><br><span class="line">                res += (mid - p1  + <span class="number">1</span>);</span><br><span class="line">                help[k++] = nums[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">                help[k++] = nums[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(p2 &lt;= high)&#123;</span><br><span class="line">                help[k++] = nums[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//copy</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; high  - low +<span class="number">1</span>; i++)&#123;</span><br><span class="line">                nums[low + i] = help[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2020/03/03/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8%E4%B9%8B%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E4%B8%AA%E6%95%B0/1583165852834.png" alt="1583165852834" style="zoom:100%;">]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>困难</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序应用-荷兰国旗问题</title>
    <url>/2020/03/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p> 快速排序的思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p>
<p> 快速排序之所以快，是因为它使用了<strong>分治法</strong>。它虽然也是通过不断的<em>比较</em>和<em>移动</em>来实现排序的，只不过它的实现，增大了比较的距离和移动的距离。而冒泡排序只是相邻的比较和交换。 </p>
<img src="/2020/03/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8-%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/1583938108450.png" alt="1583938108450" style="zoom:100%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort.QuickSort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序优化，随机快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-10 22:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">quickS1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arrs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arrs == <span class="keyword">null</span> || arrs.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        quick(arrs, <span class="number">0</span>, arrs.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr  数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边界 0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边界 下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 随机选择一个数域最后一个数进行交换</span></span><br><span class="line">            swap(arr, left+(<span class="keyword">int</span>)(Math.random()*(right-left+<span class="number">1</span>)), right);  <span class="comment">// Math.random() 返回[0, 1) 的随机数</span></span><br><span class="line">            <span class="keyword">int</span>[] pivot = partition(arr, left, right);</span><br><span class="line">            quick(arr, left, pivot[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">            quick(arr, pivot[<span class="number">0</span>]+<span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  以数组最后一个元素为轴枢，将整个数组划分为 小于、等于、大于 三个部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">int</span> less = left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> greater = right;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; greater)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[left] &lt; arr[right])&#123;</span><br><span class="line">                less++;</span><br><span class="line">                swap(arr, less, left);<span class="comment">//</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( arr[left] &gt; arr[right])&#123;</span><br><span class="line">                <span class="comment">// 交换more前一个元素</span></span><br><span class="line">                greater--;</span><br><span class="line">                swap(arr, left, greater);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>, greater&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">43</span>, -<span class="number">31</span>, <span class="number">10</span>, -<span class="number">38</span>, -<span class="number">42</span>, -<span class="number">2</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">15</span>, -<span class="number">60</span>, -<span class="number">50</span>, -<span class="number">13</span>, <span class="number">26</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">27</span>, <span class="number">24</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">42</span>, -<span class="number">40</span>, <span class="number">22</span>, <span class="number">8</span>, <span class="number">33</span>, -<span class="number">52</span>, -<span class="number">70</span>, -<span class="number">55</span>, <span class="number">31</span>, <span class="number">42</span>, <span class="number">82</span>, <span class="number">19</span>, -<span class="number">8</span>, <span class="number">8</span>, <span class="number">41</span>, -<span class="number">35</span>, <span class="number">59</span>, <span class="number">65</span>, -<span class="number">23</span>, <span class="number">3</span>, -<span class="number">34</span>, <span class="number">65</span>&#125;;</span><br><span class="line">        quickSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经典快排和数据的状态有关：当然上述代码是经过优化了</p>
<ul>
<li>当数据是极端情况，比如： <code>9，8，7，6，5，4，3，2，1</code>。 选择最后一个元素为轴枢，会发现，每一个元素都比轴枢大，进行一次快速排序之后，最后会将轴枢放在第一位，复杂度都是：$O(N^2)$ . </li>
</ul>
<p>上面代码减少了不必要的交换，即将轴枢保存了下来， 不用每次都交换，在最终确定位置的时候再交换。</p>
<p>进一步优化： 我们都知道，递归对性能是有一定影响的，<code>quickSort</code>函数尾部有两次递归操作。如果待排序的序列极为极端不平衡，递归的深度几乎接近于n的高度（没有了二分法的优势）。这样的时间复杂度也是达到了最坏的程度$ O (N^2) $ ，而不是平衡时的$O(nlogn)$。</p>
<p>时间慢也就算了，但是栈的大小也是有限的，每次递归操作都消耗一定的栈空间，函数的参数越多，每次递归调用参数耗费的空间也是越多。</p>
<p>如果能减少递归，性能也因此大大提高:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arrs, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arrs == <span class="keyword">null</span> || arrs.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123; <span class="comment">//  改成迭代式 ， 减少递归</span></span><br><span class="line">            <span class="keyword">int</span> Pivot = Patition(arrs, low, high);</span><br><span class="line">            quickSort(arrs, low, Pivot-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//            quickSort(arrs, Pivot + 1, high);</span></span><br><span class="line">            low = Pivot+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很好的方法。我们把if改成while，然后一次递归之后，左边的部门已经排好序了，low已经没有用处了，所以把pivot+1赋值给low作为下一个参数， 对右半部分排序，减少了一半的递归程度。</p>
<p>因此采用迭代而不是递归的方法可以缩减堆栈深度，从而提高了整体性能。</p>
<h2 id="荷兰国旗问题一"><a href="#荷兰国旗问题一" class="headerlink" title="荷兰国旗问题一"></a>荷兰国旗问题一</h2><p>其实荷兰国旗问题就是一个数组划分的问题</p>
<p> 给定一个数组<code>arr</code>，和一个数<code>num</code>，请把<strong>小于等于</strong><code>num</code>的数放在数组的左边，大于<code>num</code>的数放在数组的右边。 要求额外空间复杂度<code>O(1)</code>，时间复杂度<code>O(N)</code>。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>很明显这就是快速排序的一次划分的过程，只不过轴枢是给定的一个数。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort.QuickSort;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 荷兰国旗问题一：</span></span><br><span class="line"><span class="comment"> * 给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，</span></span><br><span class="line"><span class="comment"> * 大于num的数放在数组的右边。 要求额外空间复杂度O(1)，时间复杂度O(N)；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-10 23:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiltArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">splitArray_</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less = left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[left] &lt;= num) &#123;</span><br><span class="line">                swap(arr, ++less, left++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;1, 2, 8, -2, 4, 3, 4, 2, 8, 12, 3, 9, 8, 10, 9, 5, -1, 4, 9, 2&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        splitArray_(arr, <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="荷兰国旗问题二"><a href="#荷兰国旗问题二" class="headerlink" title="荷兰国旗问题二"></a>荷兰国旗问题二</h2><p> 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。 要求额外空间复杂度O(1)，时间复杂度O(N)  。</p>
<p>这题与上面的题目区别是，这个题目是要将数组划分成三个部分，<strong>大于部分，等于部分，小于部分。</strong></p>
<p>参照快速排序代码，很容易解出来。直接看代码就懂了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Sort.QuickSort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 荷兰国旗问题二：</span></span><br><span class="line"><span class="comment"> * 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，</span></span><br><span class="line"><span class="comment"> * 等于num的数放在数组的中间，大于num的数放在数组的右边。</span></span><br><span class="line"><span class="comment"> * 要求额外空间复杂度O(1)，时间复杂度O(N)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-10 22:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitArray2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] SplitArray2(<span class="keyword">int</span>[] arrs, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrs == <span class="keyword">null</span> || arrs.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] p = sort(arrs, <span class="number">0</span>, arrs.length - <span class="number">1</span>, num);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  以数组最后一个元素为轴枢，将整个数组划分为 小于、等于、大于 三个部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> less = left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> greater = right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; greater) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[left] &lt; num) &#123;</span><br><span class="line">                swap(arr, ++less, left++);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[left] &gt; arr[right]) &#123;</span><br><span class="line">                swap(arr, --greater, left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less + <span class="number">1</span>, greater&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;43, -31, 10, -38, -42, -2, 22, 29, 30, 15, -60, -50, -13, 26, 3, 22, 27, 24, 18, 18, 42, -40, 22, 8, 33, -52, -70, -55, 31, 42, 82, 19, -8, 8, 41, -35, 59, 65, -23, 3, -34, 65&#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] p = SplitArray2(arr, <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小于的区域：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等于的区域：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p[<span class="number">0</span>]; i &lt;= p[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;大于的区域：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p[<span class="number">1</span>]+<span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>1 2 3 4 2 6 6 6 9 10 8 12 </p>
<p>小于的区域：</p>
<p>1 2 3 4 2 </p>
<p>等于的区域：</p>
<p>6 6 6 </p>
<p>大于的区域：<br>        9 10 8 12 </p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>中等</tag>
        <tag>快速排序</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>打印出B中不在A中的数</title>
    <url>/2020/02/28/%E6%89%93%E5%8D%B0%E5%87%BAB%E4%B8%AD%E4%B8%8D%E5%9C%A8A%E4%B8%AD%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><blockquote>
<p>一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数 组长度为N，B数组长度为M。</p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>方法一： 暴力求解。 对于数组B中的每一个数，都在A中通过遍历的方式找一下； 相当于：B 中每一个数都要在 A 中遍历一遍，则需要操作 N 遍，而 B 中 M 个数都需要按照上面操作一遍，共操作 M * N 遍，因此时间复杂为：O(M*N)。</p>
<p>方法二：二分法。因为A数组有序， 在A中查找的时候使用二分查找算法，故总体时间复杂度为$O(M* log_2^N)$.</p>
<p>方法三：</p>
<p>​        先把数组B排序，然后用类似外排的方式打印所有不在A中出现的数； 因为可以是会用快速排序对数组 B 进行排序 。所以整体时间复杂度为$O(M*log_2^M)$ 。 </p>
<p>​        具体地， 数组 A 开头放置下标 a，数组 B 开头放置下标 b，比较两个下标指向的值若 b 指向的值 &lt; a 指向的值，则 b++同时打印 b 指向的数，否则a++ , 若等于则a++, b++不打印； 因此整体外排时间复杂度最差O(M+N)。则整个算法时间复杂度为    $O(M*log_2^M) + O(M+N)$  。</p>
<blockquote>
<p> 分析：  当 A 数组较短的时候，方法二较好，当 B 数组较短的时候，方法三较好，因为方法三需要对 B 进行排序； </p>
</blockquote>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一： 暴力 O(M*N)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNotInArrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a: A)&#123;</span><br><span class="line">            list.add(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环遍历B数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(B[i]))&#123;</span><br><span class="line">                res.add(B[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法二： 二分查找  O(M*longN)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNotInArrays_V2</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span></span>&#123;</span><br><span class="line">       List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">boolean</span> contains = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i: B)&#123;</span><br><span class="line">           <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> high = A.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">               <span class="keyword">int</span> mid = (low+high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span>(A[mid] == i ) &#123;</span><br><span class="line">                   contains = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">break</span>;  <span class="comment">//找到了</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &gt; i)&#123; <span class="comment">//  在A的左边， 更改low和high</span></span><br><span class="line">                   high = mid - <span class="number">1</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(A[mid] &lt; i)&#123; <span class="comment">//  在A的右边， 更改low和high</span></span><br><span class="line">                   low = mid + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(!contains)&#123; <span class="comment">//  不存在</span></span><br><span class="line">               res.add(i);</span><br><span class="line">           &#125;</span><br><span class="line">           contains = <span class="keyword">false</span>; <span class="comment">// 复位</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法三： 对B先排序，然后使用外部排序来 求解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNotInArrays_V3</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对B先 排序</span></span><br><span class="line">        Arrays.sort(B);</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((a &lt; A.length) &amp;&amp; (b &lt; B.length)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[a] == B[b]) &#123;</span><br><span class="line">                a++;</span><br><span class="line">                b++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[a] &lt; B[b]) &#123;</span><br><span class="line">                a++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[a] &gt; B[b]) &#123;</span><br><span class="line">                res.add(B[b]);</span><br><span class="line">                b++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (b &lt; B.length)&#123;</span><br><span class="line">            res.add(B[b++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：  <a href="https://github.com/Castile/algorithm/blob/master/leetcode/src/Sort/GetNotInArrays.java">https://github.com/Castile/algorithm/blob/master/leetcode/src/Sort/GetNotInArrays.java</a> </p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>中等</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>新一代垃圾收集器G1</title>
    <url>/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/</url>
    <content><![CDATA[<h1 id="Java-GC介绍"><a href="#Java-GC介绍" class="headerlink" title="Java GC介绍"></a>Java GC介绍</h1><img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599557072461.png" class width="1599557072461">

<p>GC是垃圾搜集的意思，是jvm的一个重要部分。</p>
<h2 id="怎么算是垃圾"><a href="#怎么算是垃圾" class="headerlink" title="怎么算是垃圾"></a>怎么算是垃圾</h2><ol>
<li>废弃的对象</li>
<li>任何时候都不再使用的对象</li>
</ol>
<h2 id="怎么判断是否是垃圾"><a href="#怎么判断是否是垃圾" class="headerlink" title="怎么判断是否是垃圾"></a>怎么判断是否是垃圾</h2><ol>
<li>引用计数法：会有循环引用的问题</li>
<li>GC roots搜索： 可达性分析算法（JVM使用的）</li>
</ol>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599557392320.png" class width="1599557392320">

<p>以上是 HotSpot 虚拟机中的垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<p>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</p>
<p>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ol>
<li><p>mark-sweep： 有内存碎片问题，有些对象分配不到空间</p>
</li>
<li><p>mark-sweep-compact： 内存整理，解决了内存碎片问题</p>
</li>
<li><p>mark-copy：存活的对象复制到另外一块内存中。内存消耗大。</p>
<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599557498842.png" class width="1599557498842"></li>
</ol>
<p>怎么优化？</p>
<h2 id="GC分代假设"><a href="#GC分代假设" class="headerlink" title="GC分代假设"></a>GC分代假设</h2><p>堆分为新生代和老年代，一般创建的对象是在新生代创建，新生代创建的对象大多数都是朝生夕死的，GC也主要发生在新生代，在新生代会会回收大量的垃圾。经过几次新生代的GC后还存活下来的对象会被送入到老年代中。这个是有一个阈值来设置的。</p>
<p>在新生代和老年代分别使用不同的垃圾收集算法。</p>
<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599557769927.png" class width="1599557769927">

<hr>
<h1 id="古典时期的GC算法"><a href="#古典时期的GC算法" class="headerlink" title="古典时期的GC算法"></a>古典时期的GC算法</h1><ol>
<li> Serial  </li>
</ol>
<p>   年轻代Serial </p>
<p>   ⽼年代SerialOld</p>
<ol start="2">
<li><p>Parallel </p>
<p>ParNew</p>
<p>年轻代Parallel Scavenge</p>
<p>⽼年代Parallel Old </p>
</li>
</ol>
<h2 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h2> <img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1592205518320.png" class width="1592205518320">

<p>Serial 收集器为单线程环境设计，并只使用一个线程进行垃圾回收。 在回收时，<strong>会暂停用户线程</strong>，并不适用于并发环境。</p>
<p>Serial 收集器采用复制算法</p>
<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599558333667.png" class width="1599558333667">

<h2 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h2><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3> <img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" class title="img">

<p> 它是 Serial 收集器的多线程版本。</p>
<p>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
<h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p> 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“<strong>吞吐量优先</strong>”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。 </p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3> <img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/278fe431-af88-4a95-a895-9c3b80117de3.jpg" class title="img"> 

<p>是 Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h1 id="中古时代的GC算法"><a href="#中古时代的GC算法" class="headerlink" title="中古时代的GC算法"></a>中古时代的GC算法</h1><h2 id="CMS：-Concurrent-Mark-Sweep"><a href="#CMS：-Concurrent-Mark-Sweep" class="headerlink" title="CMS： Concurrent Mark Sweep"></a>CMS： Concurrent Mark Sweep</h2><blockquote>
<p>Stop The World：当进行垃圾收集的时候，必须暂停所有的用户线程。这种现象叫做Stop The World</p>
</blockquote>
<p>分为以下四个流程：</p>
<ul>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点：</p>
<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 <code>Concurrent Mode Failure</code>。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599559259292.png" class width="1599559259292">

<p>以前的垃圾收集算法想Serial是串行的，垃圾收集的时候必须暂停用户线程，后来有了Parallel的垃圾收集器，目的是降低用户线程等待的时间，所以引入了多线程的垃圾收集器，垃圾收集是并行的多个线程处理。但是感觉还是比较慢，所以有了CMS，搞一个可以让用户线程和垃圾收集线程齐头并进的收集器，用户线程可以和垃圾收集线程并发执行。</p>
<p>CMS有以下特点：</p>
<ol>
<li>低延时的系统</li>
<li>不进行Compact，使用的sweep，可能会产生内存碎片</li>
<li>这是老年代的垃圾收集器</li>
<li>可以配合Serial/ParNew 使用</li>
<li>removed in JEP363</li>
</ol>
<h2 id="为什么新生代不使用-CMS"><a href="#为什么新生代不使用-CMS" class="headerlink" title="为什么新生代不使用 CMS"></a>为什么新生代不使用 CMS</h2><p>新生代使用的copying算法，因为新生代的对象一般是朝生夕死的。复制算法的代价最小。</p>
<hr>
<h1 id="现代的垃圾收集器G1"><a href="#现代的垃圾收集器G1" class="headerlink" title="现代的垃圾收集器G1"></a>现代的垃圾收集器G1</h1><p>G1垃圾收集其实jdk9 的默认垃圾收集器</p>
<ol>
<li><p>软实时、低延时、可设定目标（可以设定最大STW的停顿时间）</p>
<p>-XX：MaxGCPauseMillis=N   250 by default</p>
</li>
<li><p>JDK9+默认的GC (JEP248)</p>
</li>
<li><p>适用于较大的堆（&gt; 4 ~ 6G ）</p>
</li>
<li><p>可用于替代CMS</p>
</li>
</ol>
<p>G1（<code>Garbage-First</code>），它是一款面向<strong>服务端应用</strong>的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。<code>HotSpot</code> 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<p>-XXG1HeapRegionSize=N  2048 by fefault</p>
<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599560640963.png" class width="1599560640963">

<p> G1 把堆划分成多个大小相等的独立区域（<code>Region</code>），新生代和老年代不再物理隔离。 <strong>G1垃圾收集器利用分而治之的思想将堆进行分区，划分为一个个的区域。</strong>每次收集的时候，只收集其中几个区域，以此来控制垃圾回收产生的STW</p>
<p><strong>G1和其他GC算法最大的区别是弱化分代概念，引入分区思想！！！</strong></p>
<h2 id="为什么会有G1"><a href="#为什么会有G1" class="headerlink" title="为什么会有G1"></a>为什么会有G1</h2><p>因为并发、并行和CMS垃圾收集器都有2个共同的问题：</p>
<ol>
<li>老年代收集器大部分操作都必须扫描<strong>整个老年代空间</strong>（标记，清除和压缩）。这就导致了GC随着Java堆空间而线性增加或减少</li>
<li>年轻代和老年代是独立的连续内存块，所以要先决定年轻代和年老代放在虚拟地址空间的位置</li>
</ol>
<h2 id="跨代-跨Region引用"><a href="#跨代-跨Region引用" class="headerlink" title="跨代/跨Region引用"></a>跨代/跨Region引用</h2><p>老年代对象可能持有年轻代的引⽤（跨代引⽤），不同的Region间互相引⽤，怎么处理这样的现象呢？</p>
<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599565035554.png" class width="1599565035554">

<p>G1引入了两种数据结构，一个叫做Remembered Set(RS) 和 Card Table。</p>
<p> Card Table ：表中的每个entry覆盖512Byte的内存空间 ，当对应的内存空间发⽣改变时，标记为dirty。也就是说，当我们写代码的时候，通过一个引用赋值操作，将某个对象指向其引用的时候，将这个对象所在的card置为dirty</p>
<p>比如一个Region有1M，那么每512个字节就有一个Card， 那么这一个Region就有2000个Card。</p>
<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599565282616.png" class width="1599565282616">

<p> RememberedSet： 指向Card Table中的对应entry ，可找到具体内存区域 。引入RS的通就是避免大范围的扫描，避免全堆扫描。</p>
<p> 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 </p>
<p>如上图，一个区域region1，分成若干个卡片，假如其中某个卡片里面的对象引用了其他region里面的对象的话，这个卡片的位置会被记入region2中的RS中，等Region2的对象回收的时候，根据RS去查询那个对象还在引用我，这样就避免了全堆扫描。</p>
<p>这是一个典型的空间换时间的操作。</p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，<strong>使得可预测的停顿时间模型成为可能</strong>。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p>具备如下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h2 id="Write-barrier"><a href="#Write-barrier" class="headerlink" title="Write barrier"></a>Write barrier</h2><p>当一个对象引用了另一个对象是怎么记录下来的呢？ 他有事怎么知道有对象引用了它呢？使用的是Write barrier，写屏障来维护卡表和RS的。</p>
<p>写屏障可以看作在JVM层面上对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环绕通知，供程序执行额外的动作，也就是说赋值前后都在写屏障的覆盖范畴内。</p>
<p>Write barrier其实是 JVM注⼊的⼀⼩段代码，⽤于记录指针变化 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">object.field = &lt;reference&gt; (putfield) </span><br></pre></td></tr></table></figure>

<p> 当更新指针时,标记Card为Dirty , 将Card存⼊Dirty Card Queue, 这个队由 ⽩/绿/⻩/红四个颜⾊。</p>
<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599567972614.png" class width="1599567972614">

<h2 id="更新Remembered-Set"><a href="#更新Remembered-Set" class="headerlink" title="更新Remembered Set"></a>更新Remembered Set</h2><p>By concurrent refinement threads</p>
<p>White： 天下太平，⽆事发⽣</p>
<p>Green zone (-XX:G1ConcRefinementGreenZone=N) ： Refinement线程开始被激活，开始更新RS</p>
<p>Yellow zone (-XX:G1ConcRefinementYellowZone=N) ： 全部Refinement线程开始激活</p>
<p>Red zone (-XX:G1ConcRefinementRedZone=N) ： 应⽤线程也参与排空队列的⼯作</p>
<h2 id="Fully-young-GC"><a href="#Fully-young-GC" class="headerlink" title="Fully young GC"></a>Fully young GC</h2><ol>
<li>STW (Evacuation Pause)  分散</li>
<li>构建CS (Eden+Survivor) </li>
<li>扫描GC Roots </li>
<li>Update RS：排空Dirty  ard Queue </li>
<li>Process RS：找到被哪些那些⽼年代对象所引⽤ </li>
<li>Object Copy </li>
<li>Reference Processing </li>
</ol>
<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599568228923.png" class width="1599568228923">

<blockquote>
<p>记录每个阶段的时间，⽤于⾃动调优 </p>
<p>记录Eden/Survivor的数量和GC时间 </p>
<p>根据暂停⽬标⾃动调整Region的数量 </p>
<p> 暂停⽬标越短，Eden数量越少 </p>
<p>吞吐量下降 </p>
<p>-XX:+PrintAdaptiveSizePolicy </p>
<p>-XX:+PrintTenuringDistribution </p>
</blockquote>
<h2 id="Old-GC"><a href="#Old-GC" class="headerlink" title="Old GC"></a>Old GC</h2><p><strong>当堆⽤量达到⼀定程度时触发</strong></p>
<p>-XX:InitiatingHeapOccupancyPercent=N   45 by default  </p>
<p>Old GC是<strong>并发</strong>(concurrent)进⾏的 、</p>
<p>三⾊标记算法：<strong>不暂停应⽤线程的情况下进⾏标记</strong> </p>
<h2 id="三⾊标记算法"><a href="#三⾊标记算法" class="headerlink" title="三⾊标记算法"></a>三⾊标记算法</h2><p>黑色：表示对象以及被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色就代表对象以及扫描过了，他是安全存活的对象。</p>
<p>灰色：表示对象以及被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</p>
<p>白色： 表示对象还没有被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，表示</p>
<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599568334166.png" class width="1599568334166">

<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599568350313.png" class width="1599568350313">

<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599568365781.png" class width="1599568365781">

<h2 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h2><p>不⼀定⽴即发⽣ </p>
<p>选择若⼲个Region进⾏  </p>
<p>​    默认1/8的Old Region ： -XX:G1MixedGCCountTarget=N </p>
<p>​    Eden+Survivor Region </p>
<p>​    STW, Parallel, Copying </p>
<p>根据暂停⽬标，选择垃圾最多的Old Region优先进⾏ </p>
<p>​    -XX:G1MixedGCLiveThresholdPercent=N (default 85)</p>
<p>​    -XX:G1HeapWastePercent=N  </p>
<h1 id="未来：ZGC-Shenandoah"><a href="#未来：ZGC-Shenandoah" class="headerlink" title="未来：ZGC/Shenandoah"></a>未来：ZGC/Shenandoah</h1><img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599569115217.png" class width="1599569115217">

<p>令⼈恐怖的极低延时，使用了染色指针和多重映射</p>
<img src="/2020/09/08/%E6%96%B0%E4%B8%80%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8G1/1599569161274.png" class width="1599569161274">

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.bilibili.com/video/BV1D741177rV?p=2">https://www.bilibili.com/video/BV1D741177rV?p=2</a></li>
<li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=_7-g1-%e6%94%b6%e9%9b%86%e5%99%a8">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=_7-g1-%e6%94%b6%e9%9b%86%e5%99%a8</a></li>
<li><a href="https://www.cnblogs.com/GrimMjx/p/12234564.html">https://www.cnblogs.com/GrimMjx/p/12234564.html</a></li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>gc</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径算法</title>
    <url>/2020/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h1><p><strong>整理于网络</strong></p>
<ul>
<li>单源最短路<br>不带负权边：<code>Dijkstra</code><br>带负权边：<code>Bellman−Ford</code>、<code>SPFA</code></li>
<li>多源最短路：<code>Floyd</code></li>
</ul>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p> <strong>假设图中顶点V个，边E条，有如下结论</strong> </p>
<ul>
<li>这是求解单元最短路径的经典算法，非常重要</li>
<li>其本质是贪心+<code>BFS</code></li>
<li><code>Dijkstra</code>算法更适合稠密图（边多的）</li>
<li>无论图有没有环，<code>Dijkstra</code> 算法都是可以用的，它只是不能处理负权边，因为它本质上是贪心策略，每个点选择之后就不再更新，如果碰到了负边的存在就会破坏这个贪心的策略就无法处理了。</li>
<li>堆优化+邻接矩阵是常用的解法</li>
</ul>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode-cn.com/problems/network-delay-time/">leetcode-743 网络延迟时间</a></p>
<p>有 N 个网络节点，标记为 1 到 N。</p>
<p>给定一个列表 times，表示信号经过有向边的传递时间。 times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点， w 是一个信号从源节点传递到目标节点的时间。</p>
<p>现在，我们从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。</p>
<img src="/2020/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/1595734815417.png" class width="1595734815417">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>堆优化的Dijkstra算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.util.Pair;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * leetcode-743 网络延迟时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-26 11:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkDelayTime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 建图 , 每个times就是一条边， 每条边包括起始点和终点已经这条边对应的权重</span></span><br><span class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; Graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] time : times) &#123;</span><br><span class="line">            Graph.computeIfAbsent(time[<span class="number">0</span>], k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;()).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;time[<span class="number">1</span>], time[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 优先级队列，小根堆</span></span><br><span class="line">        PriorityQueue&lt;Pair&lt;Integer, Integer&gt;&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(Pair::getValue));</span><br><span class="line">        <span class="comment">// 将源点加入</span></span><br><span class="line">        q.offer(<span class="keyword">new</span> Pair&lt;&gt;(K, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            Pair&lt;Integer, Integer&gt; cur = q.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visited.contains(cur.getKey())) &#123;</span><br><span class="line">                <span class="comment">// 已经访问过了</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(cur.getKey());</span><br><span class="line">            res = Math.max(res, cur.getValue());</span><br><span class="line">            <span class="comment">// 将其相邻的边遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] next : Graph.getOrDefault(cur.getKey(), <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited.contains(next[<span class="number">0</span>])) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q.offer(<span class="keyword">new</span> Pair&lt;&gt;(next[<span class="number">0</span>], next[<span class="number">1</span>] + cur.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.size() == N ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NetworkDelayTime solution = <span class="keyword">new</span> NetworkDelayTime();</span><br><span class="line">        <span class="keyword">int</span>[][] times = &#123;&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> result = solution.networkDelayTime(times, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><h3 id="什么是BF算法"><a href="#什么是BF算法" class="headerlink" title="什么是BF算法"></a>什么是BF算法</h3><img src="/2020/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/1595750234168.png" class width="1595750234168">

<p>BF这个算法也是求单源最短路径的一个算法，算法非常简洁。但是他并不是一个最优的一个方法，他的时间复杂度大于迪杰斯特拉算法。事实上，BF算法的时间复杂度正比于结点的个数和边个数的乘积，即<code>O(V*E)</code>。而迪杰斯特拉算法可以使用一个小根堆来实现，复杂度更小，是<code>O(E+V)log(V)</code>。</p>
<p>我们使用BF算法，是因为有时候迪杰斯特拉他算法在某些情况下不适用，也就是说图中会有负边权。当图中存在着负边时候，就有可能导致<code>negative cycle</code>。这种情况下，我们需要把它检测出来。如果使用迪杰斯特拉算法的话，会陷入一个循环之中，因为算法总能找到一个更短的路径。</p>
<img src="/2020/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/1595764387257.png" class width="1595764387257">

<p>红色的节点表示负环， 经过负环的节点的权重都会是负无穷， 黄色的节点。</p>
<h3 id="BF算法的步骤"><a href="#BF算法的步骤" class="headerlink" title="BF算法的步骤"></a>BF算法的步骤</h3><p>E: 边数</p>
<p>V:顶点数</p>
<p>S:开始节点</p>
<p>D：开始节点到其他节点的单源最短路径，是一个大小为V的数组</p>
<ul>
<li>将每个每个节点到开始节点的最短路径设为﹢无穷</li>
<li>set D[S] = 0, 开始节点到自己为0；</li>
<li>对每一条边进行<code>V-1</code>次松弛操作</li>
</ul>
<p><strong>松弛操作：</strong></p>
<ol>
<li>对于任意一条边 (u -&gt; v)，取出他们存储好的权重 w( u -&gt; v ).</li>
<li>如果 <code>u.distance + w &lt; v.distance</code>，那么做两个赋值操作：<code>v.distance = u.distance + w</code>，<code>v.previous = u</code>；这一步是松弛操作的核心。</li>
<li>如果上面的判断不成立，什么都不做</li>
</ol>
<p>问题来了，为啥是V-1次循环呢？</p>
<p> <strong>做 n - 1 次已经足够了</strong>。算法导论上有证明：</p>
<ol>
<li>从原点开始走，到第 x 个节点，这中间只有 x - 1 条边（不考虑环路）</li>
<li>如果一个图有 n 个节点，那么即使用最啰嗦的走法，到达一个点顶多需要走 n - 1 条边（不考虑环路）。也就是顶多把所有的节点都经过一遍。</li>
<li>在第一轮对所有的边进行松弛的时候，被松弛的点其实只有从原点可以一步到达的点。其他的点所在的边 Edge( u -&gt; v ) 中，u.distance 都是 ∞，v 无法被松弛。只有 start_point.distance 为 0，Edge( start_point -&gt; v ) 中的 v 才可能被松弛。</li>
<li>以此类推，在第 i 轮中，被松弛的点只可能是距离原点 i 步的点。他们利用到的边是 Edge( vi - 1 -&gt; vi)，其中 vi - 1 在上一轮松弛的过程中已经被松弛过，如果他能到达原点的话，vi - 1.distance 就不会是 ∞。</li>
<li>有些点可能有多种不同的到达方式，并且在第 i 步之前也松弛过。这其实没关系。如果第 i 步是最后一次到达他，所有能用来到达这个点的边都已经被计算机探索过（不然这就不是最后一次到达），所以这次松弛也将是它最后一次被松弛，之后到达他的 distance 就已经是最终结果值了。</li>
<li>根据上面提到的 2，不可能有节点出现 n - 1 步还到达不了的地方，即使一个点有多条路径可以到达（除非这个点真的无法到达），他的最多步数路径上的边也都被计算机探索过了。也就是说，他的最后一次被访问已经发生过，他的 distance 肯定已经是最终结果值了。没有任何一个点可以例外。</li>
</ol>
<p>所以 n - 1 次循环已经足够。</p>
<blockquote>
<p>第一次迭代在对所有的边进行松弛之后，得到的是从起点”只能经过一条边“到达其余各顶点的最短路径长度…第k轮迭代得到的就是起始点”最多经过k条边“到达其他各顶点的最短路径长度。 </p>
<p> 迭代的时候使用边进行松弛的<strong>顺序比较随机</strong>。在<strong>最差情况下</strong>，导致第一次迭代后，只更新了从起点出发通过一条边到达的部分顶点的最短路径长度。而没有更新不能通过一条边到达的顶点的最短路径长度，长度还是保持正无穷。 </p>
</blockquote>
<p>所以，可以将leetcode-743使用FB算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE/<span class="number">2</span>);</span><br><span class="line">        dist[K] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环N-1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; times.length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] t = times[j];</span><br><span class="line">                <span class="keyword">int</span> u = t[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> v = t[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> w = t[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">                    dist[v] = dist[u] + w ;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[i] == Integer.MAX_VALUE/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/1595764967773.png" class width="1595764967773">

<p>注意上面的flag操作，可以剪枝不必要的循环。</p>
<p><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">leetcode-787. K 站中转内最便宜的航班</a></p>
<p>有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。</p>
<p>现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。</p>
<img src="/2020/07/26/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/1595776067180.png" class width="1595776067180">

<p>解法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dist =  <span class="keyword">new</span> <span class="keyword">int</span>[K+<span class="number">2</span>][n];</span><br><span class="line">        <span class="keyword">int</span> INF= Integer.MAX_VALUE/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K+<span class="number">2</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">            Arrays.fill(dist[i], INF);</span><br><span class="line">        &#125;</span><br><span class="line">        dist[<span class="number">0</span>][src] = <span class="number">0</span>; <span class="comment">//  经过0个节点到src的距离是0</span></span><br><span class="line">        <span class="keyword">int</span> res = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i &lt; K+<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] next: flights)&#123;</span><br><span class="line">                dist[i][next[<span class="number">1</span>]] = Math.min(dist[i][next[<span class="number">1</span>]], dist[i-<span class="number">1</span>][next[<span class="number">0</span>]] + next[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.min(res, dist[i][dst]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INF ? -<span class="number">1</span>: res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] back = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> INF = Integer.MAX_VALUE/<span class="number">2</span>;</span><br><span class="line">        Arrays.fill(dist, INF );</span><br><span class="line">        Arrays.fill(back, INF ); <span class="comment">// 防止串联？？？</span></span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; n; m++)&#123;</span><br><span class="line">                back[m] = dist[m];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] next: flights)&#123;</span><br><span class="line">                <span class="comment">// 对每条边遍历</span></span><br><span class="line">                <span class="comment">// if(dist[next[0]] + next[2] &lt; dist[next[1]] )&#123;</span></span><br><span class="line">                <span class="comment">//     dist[next[1]] = dist[next[0]] + next[2];</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                dist[next[<span class="number">1</span>]] = Math.min(dist[next[<span class="number">1</span>]],back[next[<span class="number">0</span>]] + next[<span class="number">2</span>] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dist[dst] == INF ? -<span class="number">1</span> : dist[dst];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>FB对边的松弛操作是盲目的，每次循环都将所有的边拿出来看一下。其实，只有当前节点更新了，以他为起点的终点节点才会被更新，不然是无效的。</p>
<p>SPFA 是 Bellman−Ford 的<strong>队列优化</strong>，但是算法时间效率不稳定，时间复杂度为 O(E)，最好情况下，<strong>每个节点只入队一次，就是 BFS</strong>，<strong>最坏情况下，每一个节点都要入队 V−1 次，这时候就退化成 Bellman−Ford了</strong>。SPFA 时间复杂度某种情况下略高于 Dijkstra， 适合稀疏图。</p>
<p>SPFA 是可以用于带有负权图的，在 SPFA 中每一个点松弛过后说明这个点距离更近了，所以有可能通过这个点会再次优化其他点，所以它的策略是将 vis 位置为 false，把这个点入队再判断一次！这就和 Dijkstra 的贪心策略不同了。</p>
<p>SPFA 还有个用处是可以判断图是否存在负环，我们只要用一个 cnt[x] 数组来存放经过这个点的次数，上面提到过，最坏情况下每个节点入队 V−1 次，如果cnt[x] 为 V的个数，那就说明存在负环了。</p>
<p>【算法思想】</p>
<ol>
<li>初始时，只有把起点放入队列中。</li>
<li>遍历与起点相连的边，如果可以松弛就更新距离dis[]，然后判断如果这个点没有在队列中就入队标记。</li>
<li>出队队首，取消标记，循环2-3步，直至队为空。</li>
<li>所有能更新的点都更新完毕，dis[]数组中的距离就是起点到其他点的最短距离。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建图</span></span><br><span class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        dist[K] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] time: times)&#123;</span><br><span class="line">            map.computeIfAbsent(time[<span class="number">0</span>], k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;()).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;time[<span class="number">1</span>], time[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(K);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = q.poll();</span><br><span class="line">            vis[cur] = <span class="keyword">false</span>; <span class="comment">// 可以再次入队</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] next: map.getOrDefault(cur, <span class="keyword">new</span> ArrayList&lt;&gt;()))&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[cur]+next[<span class="number">1</span>] &lt; dist[next[<span class="number">0</span>]])&#123;</span><br><span class="line">                    dist[next[<span class="number">0</span>]] = dist[cur]+next[<span class="number">1</span>]; </span><br><span class="line">                    <span class="comment">// 将这次更新过的节点入队</span></span><br><span class="line">                    <span class="keyword">if</span>(!vis[next[<span class="number">0</span>]])  &#123;</span><br><span class="line">                        q.offer(next[<span class="number">0</span>]);</span><br><span class="line">                        vis[next[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找最大</span></span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[i] == Integer.MAX_VALUE / <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dist[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h1><p>本质是动态规划，能解决任意两点间的最短路径，时间复杂度O*(<em>V</em>3) 。</p>
<p><code>Floyd</code>它是可以判断有没有负权边环的，走N−1 步，如果再走一步，更短了，那么就说明有环。另外 <code>Floyd</code> 是不能处理带有负权的最短路的，因为本质是一个动态规划算法，<strong>有了负边，最优子结构的性质就不满足了</strong>。由此可见，<strong>它能够判断是否存在负环，但是不能够处理带有负权的最短路径</strong>。</p>
<p><code>Floyd</code> 有个神奇的特性，这个是其他算法没有的， Floyd第 k 轮算的结果，是每个源点到每个汇点经过前 k 个点的最短路，这一点可以出题。</p>
<p>对于上题，由于是动态规划，所以都是用邻接矩阵，并且它是不用 dis 数组和 vis 数组的<br>这边注意，初始化邻接矩阵的时候，如果两个顶点没有边，最好初始化为INF，别初始化为-1，上面说过Floyd是不能处理负权边的，只能判断有没有负环！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] g = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化图,注意,一开始距离是初始化为INF的，而不是像 spfa初始化成-1</span></span><br><span class="line">        <span class="comment">// spfa初始化成-1只是为了判断是否为邻居，这里初始化为INF是因为要取min的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">                g[i][j] = i == j ? <span class="number">0</span> : <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] time: times)&#123;</span><br><span class="line">            g[time[<span class="number">0</span>]][time[<span class="number">1</span>]]= time[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++)&#123;</span><br><span class="line">                    g[i][j] = Math.min(g[i][k] + g[k][j], g[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// g[a][b]表示a到b的最短距离</span></span><br><span class="line">        <span class="comment">// 拿结果</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> distance : g[K]) &#123;</span><br><span class="line">            res = Math.max(res, distance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INF ? -<span class="number">1</span> : res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li> <a href="https://www.dazhuanlan.com/2019/12/08/5dec8b7394f9b/">https://www.dazhuanlan.com/2019/12/08/5dec8b7394f9b/</a> </li>
<li> <a href="https://www.bilibili.com/video/BV11b411S79w?from=search&amp;seid=8294149097754810253">https://www.bilibili.com/video/BV11b411S79w?from=search&amp;seid=8294149097754810253</a> </li>
<li> <a href="https://www.bilibili.com/video/BV1gb41137u4?from=search&amp;seid=14565420049859812931">https://www.bilibili.com/video/BV1gb41137u4?from=search&amp;seid=14565420049859812931</a> </li>
<li> <a href="https://www.bilibili.com/video/BV1Yx411a7HX?p=2">https://www.bilibili.com/video/BV1Yx411a7HX?p=2</a> </li>
<li> <a href="https://blog.csdn.net/qq_24884193/article/details/104357889">https://blog.csdn.net/qq_24884193/article/details/104357889</a> </li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列问题</title>
    <url>/2020/01/20/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	最长公共子序列问题</span></span><br><span class="line"><span class="comment">	2019-12-15 12:48:14</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> x[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> y[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">(<span class="keyword">char</span> x[], <span class="keyword">char</span> y[],<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) <span class="comment">// 初始化第一列 </span></span><br><span class="line">	&#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[<span class="number">0</span>][i] = <span class="number">0</span>; <span class="comment">//  初始化第一行</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (x[i] == y[j])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">				b[i][j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt;= dp[i][j - <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">				b[i][j] = <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">				b[i][j] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[m][n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据b矩阵得出最长公共子序列</span></span><br><span class="line">stack&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLCS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// basecase</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">			s.<span class="built_in">push</span>(x[i]);</span><br><span class="line">			<span class="built_in">getLCS</span>(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (b[i][j] == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">getLCS</span>(i - <span class="number">1</span>, j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (b[i][j] == <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">getLCS</span>(i, j - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, n = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; x[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; y[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">LCS</span>(x, y, m, n) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//dp矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; dp[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">getLCS</span>(m, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印最长公共子序列</span></span><br><span class="line">	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个MyBatis项目</title>
    <url>/2020/03/26/%E7%AC%AC%E4%B8%80%E4%B8%AAMyBatis%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>它是我们软件开发中的一套解决方案，不同的框架解决的是不同的问题。</p>
<p>使用框架的<strong>好处</strong>：框架封装了很多的细节，使开发者可以使用极简的方式实现功能。大大提高开发效率。</p>
<h1 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h1><p>表现层：是用于展示数据的</p>
<p>业务层：是处理业务需求</p>
<p>持久层：是和数据库交互的</p>
<h2 id="持久层技术解决方案"><a href="#持久层技术解决方案" class="headerlink" title="持久层技术解决方案"></a>持久层技术解决方案</h2><ol>
<li>JDBC技术：<pre><code>    Connection
       PreparedStatement
       ResultSet
</code></pre>
</li>
<li>Spring的JdbcTemplate：<pre><code>    Spring中对jdbc的简单封装
</code></pre>
</li>
<li>Apache的DBUtils：<pre><code>    它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装
</code></pre>
</li>
</ol>
<p>以上这些都不是框架，JDBC是规范，Spring的JdbcTemplate和Apache的DBUtils都只是工具类。</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p><code>mybatis</code>是一个持久层框架，用<code>java</code>编写的。它封装了<code>jdbc</code>操作的很多细节，使开发者只需要关注<code>sql</code>语句本身，而无需关注注册驱动，创建连接等繁杂过程。它使用了<code>ORM</code>思想实现了结果集的封装。</p>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p><code>Object Relational Mappging</code> 对象关系映射</p>
<p>简单的说就是把数据库表和实体类及实体类的属性对应起来，让我们可以操作实体类就实现操作数据库表。</p>
<h1 id="创建Maven工程"><a href="#创建Maven工程" class="headerlink" title="创建Maven工程"></a>创建Maven工程</h1><img src="/2020/03/26/%E7%AC%AC%E4%B8%80%E4%B8%AAMyBatis%E9%A1%B9%E7%9B%AE/maven" class width="1585211107111">

<h1 id="填写配置文件pom"><a href="#填写配置文件pom" class="headerlink" title="填写配置文件pom"></a>填写配置文件pom</h1><p>导入jar包的坐标：<code>mybatis</code> / <code>mysql</code> / <code>log4j</code> / <code>junit</code> 等</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>zhu.hong<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>LATEST<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>LATEST<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="创建DAO接口"><a href="#创建DAO接口" class="headerlink" title="创建DAO接口"></a>创建DAO接口</h1><p>在对应的包下创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhu.hong.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> zhu.hong.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-26 15:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="添加sqlMapConfig-xml文件"><a href="#添加sqlMapConfig-xml文件" class="headerlink" title="添加sqlMapConfig.xml文件"></a>添加sqlMapConfig.xml文件</h1><p>在<code>main</code>下的<code>resources</code>下创建<code>sqlMapConfig.xml</code>文件, 对数据库的连接进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Mybatis 主配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置环境  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        配置mysql环境       --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            配置事物类型   --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            配置数据源       --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--            配置连接数据库的4个基本信息      --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///test?serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    指定映射配置文件的位置， 映射配置文件指的是每个dao独立的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;zhu/hong/dao/UserDAO.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="添加UserDAO-xml配置文件"><a href="#添加UserDAO-xml配置文件" class="headerlink" title="添加UserDAO.xml配置文件"></a>添加UserDAO.xml配置文件</h1><p>在<code>resources</code>下面创建和<code>main</code>下的相同的目录结构, 添加<code>UserDAO.xml</code>文件。在Mybatis中它把持久层的操作接口名称和映射文件也叫做：<code>Mapper</code>，所以：<code>UserDao</code> 和 <code>UserMapper</code>是一样的</p>
<img src="/2020/03/26/%E7%AC%AC%E4%B8%80%E4%B8%AAMyBatis%E9%A1%B9%E7%9B%AE/1585211467358.png" class width="1585211467358">

<p>注意里面填写的配置信息：映射配置</p>
<p>映射配置文件的<code>mapper</code>标签的<code>namespace</code>属性的取值必须是<code>dao</code>接口的全限定类。</p>
<p>映射配置文件的操作配置（<code>select</code>），<code>id</code>属性的取值必须是<code>dao</code>接口的方法名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;zhu.hong.dao.UserDAO&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置查询所有      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;zhu.hong.entity.User&quot;</span>&gt;</span></span><br><span class="line">        select * from  users</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>resultType=”zhu.hong.entity.User”：</p>
<p>因为需要对结果集封装，所以要指定封装到哪里。</p>
</blockquote>
<p>这样配置之后就无需再写DAO接口的实现类了。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>注意下面的步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhu.hong.test;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> zhu.hong.dao.UserDAO;</span><br><span class="line"><span class="keyword">import</span> zhu.hong.entity.User;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-26 16:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.  读取配置文件</span></span><br><span class="line">        InputStream in = Resources.getResourceAsStream(<span class="string">&quot;SQLMapConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 创建SqlSessionFactory 工厂</span></span><br><span class="line">        SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        SqlSessionFactory factory = builder.build(in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 使用工厂生产sqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = factory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 使用SQLSession创建DAO接口的代理对象</span></span><br><span class="line">        UserDAO userDAO = sqlSession.getMapper(UserDAO.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 使用代理对象执行方法</span></span><br><span class="line">        List&lt;User&gt; users = userDAO.findAll();</span><br><span class="line">        <span class="keyword">for</span> (User user: users)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2020/03/26/%E7%AC%AC%E4%B8%80%E4%B8%AAMyBatis%E9%A1%B9%E7%9B%AE/1585211606001.png" class width="1585211606001">



<h1 id="使用-注解配置"><a href="#使用-注解配置" class="headerlink" title="使用 注解配置"></a>使用 注解配置</h1><p>使用了注解配置后，UserDAO.xml就没啥用了，可以直接删除，不删除会报错…</p>
<p>在DAO接口方法中使用注解声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhu.hong.dao;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> zhu.hong.entity.User;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-26 15:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from users&quot;)</span>  <span class="comment">// select注解</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在sqlMapConfig.xml中修改：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Mybatis 主配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置环境  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        配置mysql环境       --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            配置事物类型   --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            配置数据源       --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--            配置连接数据库的4个基本信息      --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///test?serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    指定映射配置文件的位置， 映射配置文件指的是每个dao独立的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        如果是使用注解配置的话， 应该指定class文件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource=&quot;zhu/hong/dao/UserDAO.xml&quot;&gt;&lt;/mapper&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;zhu.hong.dao.UserDAO&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在实际开发中，都是越简便越好，所以都是采用不写<code>dao</code>实现类的方式。不管使用XML还是注解配置。但是<code>Mybatis</code>它是支持写<code>dao</code>实现类的。</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>算法模板之滑动窗口系列</title>
    <url>/2020/09/07/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E4%B9%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></h1><p>难度:困难</p>
<p>给你一个字符串 S、一个字符串 T 。请你设计一种算法，可以在 O(n) 的时间复杂度内，从字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<blockquote>
<p>  滑动窗⼝算法的思路是这样：<br>1、 我们在字符串 S 中使⽤双指针中的左右指针技巧， 初始化 left = right =0， 把索引闭区间 [left, right] 称为⼀个「窗⼝」 。<br>2、 我们先不断地增加 right 指针扩⼤窗⼝ [left, right]， 直到窗⼝中的字符串符合要求（包含了 T 中的所有字符） 。<br>3、 此时， 我们停⽌增加 right， 转⽽不断增加 left 指针缩⼩窗⼝ [left,right]， 直到窗⼝中的字符串不再符合要求（不包含 T 中的所有字符了） 。同时， 每次增加 left， 我们都要更新⼀轮结果。<br>4、 重复第 2 和第 3 步， 直到 right 到达字符串 S 的尽头。  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; needs = <span class="keyword">new</span> HashMap&lt;&gt;(), window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            needs.put(t.charAt(i), needs.getOrDefault(t.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">// 最小覆盖子串的起始下标</span></span><br><span class="line">        <span class="keyword">int</span> len = Integer.MAX_VALUE; <span class="comment">// 最小覆盖子串的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>; <span class="comment">// 统计有多少字符满足了覆盖的要求</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">// 当前要加入窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            right++; <span class="comment">//  右指针++</span></span><br><span class="line">            <span class="keyword">if</span>(needs.containsKey(c))&#123;</span><br><span class="line">                window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 看看字符数量是否达到要求</span></span><br><span class="line">                <span class="keyword">if</span>(window.get(c).equals(needs.get(c)))   valid++;  <span class="comment">// 千万注意别用 ==  判断...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 看看是否满足要求</span></span><br><span class="line">            <span class="keyword">while</span>(valid == needs.size())&#123;</span><br><span class="line">                <span class="comment">// 在这里更新最小覆盖子串</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; len)&#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> lc = s.charAt(left);</span><br><span class="line">                left++; <span class="comment">//  左指针++</span></span><br><span class="line">                <span class="keyword">if</span>(needs.containsKey(lc))&#123;</span><br><span class="line">                    <span class="comment">// 看看字符数量是否达到要求</span></span><br><span class="line">                    <span class="keyword">if</span>(window.get(lc).equals(needs.get(lc)))   valid--;   </span><br><span class="line">                    window.put(lc, window.getOrDefault(lc, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最小覆盖子串</span></span><br><span class="line">        <span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start+len);</span><br><span class="line"><span class="comment">//        s.substring()</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h1 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h1><p>leetcode438, 难度: 中等</p>
<p>给定一个字符串 <strong>s</strong> 和一个非空字符串 <strong>p</strong>，找到 <strong>s</strong> 中所有是 <strong>p</strong> 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 <strong>s</strong> 和 <strong>p</strong> 的长度都不超过 20100。</p>
<p><strong>说明：</strong></p>
<ul>
<li>字母异位词指字母相同，但排列不同的字符串。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<blockquote>
<p>示例 1:</p>
<p>输入:<br>s: “cbaebabacd” p: “abc”</p>
<p>输出:<br>[0, 6]</p>
<p>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。<br> 示例 2:</p>
<p>输入:<br>s: “abab” p: “ab”</p>
<p>输出:<br>[0, 1, 2]</p>
<p>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的字母异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的字母异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的字母异位词。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; needs = <span class="keyword">new</span> HashMap&lt;&gt;(), window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            needs.put(t.charAt(i), needs.getOrDefault(t.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>; <span class="comment">// 统计有多少字符满足了覆盖的要求</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">// 当前要加入窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            right++; <span class="comment">//  右指针++</span></span><br><span class="line">            <span class="keyword">if</span>(needs.containsKey(c))&#123;</span><br><span class="line">                window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 看看字符数量是否达到要求</span></span><br><span class="line">                <span class="keyword">if</span>(window.get(c).equals(needs.get(c)))   valid++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 看看是否满足要求</span></span><br><span class="line">            <span class="keyword">while</span>(right - left  &gt;= t.length())&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid == needs.size())&#123;</span><br><span class="line">                    res.add(left);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> lc = s.charAt(left);</span><br><span class="line">                left++; <span class="comment">//  左指针++</span></span><br><span class="line">                <span class="keyword">if</span>(needs.containsKey(lc))&#123;</span><br><span class="line">                    <span class="comment">// 看看字符数量是否达到要求</span></span><br><span class="line">                    <span class="keyword">if</span>(window.get(lc).equals(needs.get(lc)))   valid--;</span><br><span class="line">                    window.put(lc, window.getOrDefault(lc, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h1><p>难度中等,leetcode3</p>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       Map&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">       <span class="keyword">while</span>( right &lt; s.length())&#123;</span><br><span class="line">           <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">           right++;</span><br><span class="line">           window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">while</span>( window.get(c).compareTo(<span class="number">1</span>) &gt;  <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="comment">// 有重复 需要缩小窗口</span></span><br><span class="line">               <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">               window.put(l, window.get(l) - <span class="number">1</span>);</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           res = Math.max(res, right - left);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res == Integer.MIN_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] charIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; len; right++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            </span><br><span class="line">            left = Math.max(left, charIndex[c]);</span><br><span class="line">            res = Math.max(res, right - left + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            charIndex[c] =  right+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h1><p>难度：简单</p>
<p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<h2 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h2><p>超时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len  = (<span class="keyword">int</span>)Math.ceil(target/<span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len;i++)&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j  = i; j &lt;= len; j++)&#123;</span><br><span class="line">            sum+= j;</span><br><span class="line">            ans.add(j);</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] a = ans.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">            res.add(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h2><p>滑动窗口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r  = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r  &lt;=  target/<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[r-l+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l ; i &lt;= r; i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = l ; i &lt;= r; i++)&#123;</span><br><span class="line">                a[k++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(a);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义MyBatis</title>
    <url>/2020/03/27/%E8%87%AA%E5%AE%9A%E4%B9%89MyBatis/</url>
    <content><![CDATA[<h1 id="自定义MyBatis"><a href="#自定义MyBatis" class="headerlink" title="自定义MyBatis"></a>自定义MyBatis</h1><img src="/2020/03/27/%E8%87%AA%E5%AE%9A%E4%B9%89MyBatis/%E8%87%AA%E5%AE%9A%E4%B9%89mybatis.png" class>

<p><a href="/source/MyBatis.html">H5版本思维导图</a></p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉中的注意力机制</title>
    <url>/2020/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="计算机视觉中的注意力机制"><a href="#计算机视觉中的注意力机制" class="headerlink" title="计算机视觉中的注意力机制"></a>计算机视觉中的注意力机制</h1><p> 深度学习中的注意力机制借鉴了人类的注意力思维方式。因此，我们首先简单介绍人类视觉的选择性注意力。视觉注意力机制是人类视觉所特有的大脑信号处理机制。人类视觉通过快速扫描全局图像，获得需要重点关注的目标区域，也就是所说的注意力焦点，然后对这一区域投入更多的注意力资源，以获取更多所需要关注目标的细节信息，从而抑制其它无用信息。这是人类利用有限的注意力资源从大量信息中快速筛选出高价值信息的手段，是人类在长期进化中形成的一种生存机制。人类视觉注意力机制极大地提高了视觉信息处理的效率与准确性。 </p>
<ol>
<li> 各种注意力模型： <a href="http://element-ui.cn/news/show-23981.aspx">http://element-ui.cn/news/show-23981.aspx</a> </li>
<li> <a href="https://zhuanlan.zhihu.com/p/79725498">https://zhuanlan.zhihu.com/p/79725498</a> </li>
<li><a href="https://zhuanlan.zhihu.com/p/53010734">Non-local Neural Networks及自注意力机制思考</a></li>
</ol>
<h1 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/88372611">ICCV2019: Segmentation论文</a></li>
</ol>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>Attention</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤器和监听器</title>
    <url>/2020/03/24/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器</h1><ol>
<li><p>概念：</p>
<ul>
<li>生活中的过滤器：净水器,空气净化器，土匪、</li>
<li>web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</li>
<li>过滤器的作用：<ul>
<li><strong>一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤…</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>快速入门：</p>
<ol>
<li>步骤：<ol>
<li>定义一个类，实现接口Filter</li>
<li>复写方法</li>
<li>配置拦截路径<ol>
<li>web.xml</li>
<li>注解</li>
</ol>
</li>
</ol>
</li>
<li>代码：</li>
</ol>
</li>
<li><p>过滤器细节：</p>
<ol>
<li>web.xml配置    <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.itcast.web.filter.FilterDemo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!-- 拦截路径 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>过滤器执行流程<ol>
<li>执行过滤器</li>
<li>执行放行后的资源</li>
<li>回来执行过滤器放行代码下边的代码</li>
</ol>
</li>
<li>过滤器生命周期方法<ol>
<li><code>init</code>:在服务器启动后，会创建Filter对象，然后调用init方法。<strong>只执行一次</strong>。用于加载资源</li>
<li><code>doFilter</code>:每一次请求被拦截资源时，会执行。<strong>执行多次</strong></li>
<li><code>destroy</code>:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行<code>destroy</code>方法。<strong>只执行一次</strong>。用于释放资源</li>
</ol>
</li>
<li>过滤器配置详解<ul>
<li>拦截路径配置：<ol>
<li>具体资源路径： <code>/index.jsp</code>   只有访问<code>index.jsp</code>资源时，过滤器才会被执行</li>
<li>拦截目录： <code>/user/*</code>    访问/user下的所有资源时，过滤器都会被执行</li>
<li>后缀名拦截： *.jsp        访问所有后缀名为jsp资源时，过滤器都会被执行</li>
<li>拦截所有资源：/*        访问所有资源时，过滤器都会被执行</li>
</ol>
</li>
<li>拦截方式配置：资源被访问的方式<ul>
<li>注解配置：</li>
<li>设置<code>dispatcherTypes</code>属性<ol>
<li><code>REQUEST</code>：默认值。浏览器直接请求资源</li>
<li><code>FORWARD</code>：转发访问资源</li>
<li><code>INCLUDE</code>：包含访问资源</li>
<li><code>ERROR</code>：错误跳转资源</li>
<li><code>ASYNC</code>：异步访问资源</li>
</ol>
</li>
<li>web.xml配置<ul>
<li>设置<dispatcher></dispatcher>标签即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>过滤器链(配置多个过滤器)</li>
</ol>
<ul>
<li>执行顺序：如果有两个过滤器：过滤器1和过滤器2<pre><code>  1. 过滤器1
  2. 过滤器2
  3. 资源执行
  4. 过滤器2
  5. 过滤器1 
</code></pre>
<ul>
<li>过滤器先后顺序问题：<ol>
<li>注解配置：按照类名的字符串比较规则比较，值小的先执行<ul>
<li>如： AFilter 和 BFilter，AFilter就先执行了。</li>
</ul>
</li>
<li>web.xml配置： <filter-mapping>谁定义在上边，谁先执行</filter-mapping></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>案例1_登录验证<br>需求：访问资源。验证其是否登录如果登录了，则直接放行。<br>如果没有登录，则跳转到登录页面，提示”您尚未登录，请先登录”。</p>
</li>
<li><p>案例2_敏感词汇过滤</p>
<ul>
<li><p>需求：</p>
<ol>
<li>对录入的数据进行敏感词汇过滤</li>
<li>敏感词汇参考《敏感词汇.txt》</li>
<li>如果是敏感词汇，替换为 *** </li>
</ol>
</li>
<li><p>分析：</p>
<ol>
<li>对<code>request</code>对象进行增强。增强获取参数相关方法</li>
<li>放行。传递代理对象</li>
</ol>
</li>
<li><p>增强对象的功能：</p>
<ul>
<li>设计模式：一些通用的解决固定问题的方式</li>
</ul>
</li>
</ul>
<ol>
<li>装饰模式</li>
<li>代理模式</li>
</ol>
<ul>
<li><p>概念：</p>
<ol>
<li>真实对象：被代理的对象</li>
<li>代理对象：</li>
<li>代理模式：<strong>代理对象代理真实对象，达到增强真实对象功能的目的</strong></li>
</ol>
<ul>
<li>实现方式：<ol>
<li>静态代理：有一个类文件描述代理模式</li>
<li>动态代理：在内存中形成代理类<ul>
<li>实现步骤：<ol>
<li>代理对象和真实对象实现相同的接口</li>
</ol>
</li>
</ul>
<ol start="2">
<li>代理对象 = <code>Proxy.newProxyInstance();</code></li>
<li>使用代理对象调用方法。</li>
</ol>
</li>
</ol>
</li>
</ul>
<ol start="4">
<li><p>增强方法</p>
<ul>
<li><strong>增强方式：</strong><ol>
<li>增强参数列表</li>
<li>增强返回值类型</li>
<li>增强方法体执行逻辑</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="Listener：监听器"><a href="#Listener：监听器" class="headerlink" title="Listener：监听器"></a>Listener：监听器</h2><ul>
<li><p>概念：<code>web</code>的三大组件之一。</p>
<ul>
<li>事件监听机制<ul>
<li>事件    ：一件事情</li>
<li>事件源 ：事件发生的地方</li>
<li>监听器 ：一个对象</li>
<li>注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ServletContextListener</code>:监听<code>ServletContext</code>对象的创建和销毁</p>
<ul>
<li>方法：<ul>
<li><code>void contextDestroyed(ServletContextEvent sce)</code> ：<code>ServletContext</code>对象被销毁之前会调用该方法</li>
<li><code>void contextInitialized(ServletContextEvent sce)</code> ：<code>ServletContext</code>对象创建后会调用该方法</li>
</ul>
</li>
<li>步骤：<ol>
<li>定义一个类，实现<code>ServletContextListener</code>接口</li>
<li>复写方法</li>
<li>配置<ol>
<li>web.xml <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>listener.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>@Weblistener</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>监听器接口：</p>
<p>一、监听对象创建/销毁的监听器接口</p>
<p>​     <code>Interface ServletRequestListener</code>   监听request对象的创建或销毁</p>
<p>​     <code>Interface HttpSessionListener</code>    监听session对象的创建或销毁</p>
<p>​     <code>Interface ServletContextListener</code>   监听servletContext对象的创建或销毁</p>
<p>二、监听对象属性的变化</p>
<p>​     <code>Interface ServletRequestAttributeListener</code> 监听request对象属性变化: 添加、移除、修改</p>
<p>​     <code>Interface HttpSessionAttributeListener</code>   监听session对象属性变化: 添加、移除、修改</p>
<p><code>Interface ServletContextAttributeListener</code>  监听servletContext对象属性变化 </p>
<p>三、session相关监听器</p>
<p>   <code>Interface HttpSessionBindingListener</code>  监听对象绑定到session上的事件   </p>
<p>  <code>Interface HttpSessionActivationListener</code>(了解) 监听session序列化及反序列化的事件</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题-翻转整数</title>
    <url>/2020/08/31/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BF%BB%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>

<p> 示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>如果num小于0， 则需要添加一个-号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-08-31 22:43</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 翻转整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseInteger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverseInteger</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 处理小于0的情况</span></span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            num =  -num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>)&#123;</span><br><span class="line">            s.append(num % <span class="number">10</span>);</span><br><span class="line">            num /=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Integer.valueOf(s.toString());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = -<span class="number">1234</span>;</span><br><span class="line">        System.out.println(reverseInteger(num)); <span class="comment">// -4321</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Http协议</title>
    <url>/2020/03/13/Http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h1><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。 </p>
<p>三个部分：</p>
<ul>
<li>超文本</li>
<li>传输</li>
<li>协议<img src="/2020/03/13/Http%E5%8D%8F%E8%AE%AE/1584091584610.png" alt="1584091584610" style="zoom:80%;"></li>
</ul>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>生活中的协议，本质上与计算机中的协议是相同的，协议的特点:</p>
<ul>
<li>「<strong>协</strong>」字，代表的意思是必须有<strong>两个以上的参与者</strong>。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。</li>
<li>「<strong>仪</strong>」字，代表的意思是对参与者的一种<strong>行为约定和规范</strong>。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等</li>
</ul>
<p>针对 HTTP <strong>协议</strong>，我们可以这么理解。</p>
<p>HTTP 是一个用在计算机世界里的<strong>协议</strong>。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（<strong>两个以上的参与者</strong>），以及相关的各种控制和错误处理方式（<strong>行为约定和规范</strong>）。</p>
<h2 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h2><p>HTTP 协议是一个<strong>双向协议</strong>。</p>
<p>我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。</p>
<img src="/2020/03/13/Http%E5%8D%8F%E8%AE%AE/1584091805505.png" alt="1584091805505" style="zoom:100%;">

<p>针对<strong>传输</strong>，我们可以进一步理解了 HTTP。</p>
<p>HTTP 是一个在计算机世界里专门用来在<strong>两点之间传输数据</strong>的约定和规范。</p>
<h2 id="超文本"><a href="#超文本" class="headerlink" title="超文本"></a>超文本</h2><p>HTTP 传输的内容是「超文本」。</p>
<p>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」。的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算做「文本」。</p>
<p>再来理解「超文本」，它就是<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体最关键有超链接，能从一个超文本跳转到另外一个超文本。</p>
<p>HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，在经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。</p>
<h2 id="什么是Http协议？"><a href="#什么是Http协议？" class="headerlink" title="什么是Http协议？"></a>什么是Http协议？</h2><p> HTTP 是一个在计算机世界里专门在<strong>「两点」</strong>之间<strong>「传输」</strong>文字、图片、音频、视频等<strong>「超文本」</strong>数据的<strong>「约定和规范」</strong>。 </p>
<hr>
<h1 id="Http协议的状态码"><a href="#Http协议的状态码" class="headerlink" title="Http协议的状态码"></a>Http协议的状态码</h1><img src="/2020/03/13/Http%E5%8D%8F%E8%AE%AE/statte.jpg" alt="img" style="zoom:100%;">

<h2 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h2><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p>
<h2 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h2><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p>
<p>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</p>
<p>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p>
<p>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</p>
<h2 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h2><p><code>3xx</code> 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p>
<p>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</p>
<h2 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h2><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<p>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</p>
<p>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</p>
<p>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p>
<h2 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h2><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<p>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</p>
<p>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</p>
<p>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p>
<p>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</p>
<hr>
<h1 id="Http协议的内容"><a href="#Http协议的内容" class="headerlink" title="Http协议的内容"></a>Http协议的内容</h1><h2 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h2><p>浏览器 —–&gt; 服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /myweb/hello HTTP/1.1               -请求行</span><br><span class="line">Host: localhost:8080                    --请求头（多个key-value对象）</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">                                    --一个空行</span><br><span class="line">name=eric&amp;password=123456             --（可选）实体内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>请求行：GET /myweb/hello HTTP/1.1</strong></p>
<blockquote>
<p>包含请求方式、协议版本和请求资源</p>
<p>请求方式： GET</p>
<p>http1.0：当前浏览器客户端与服务器端建立连接之后，只能发送一次请求，一次请求之后连接关闭。</p>
<p>http1.1：当前浏览器客户端与服务器端建立连接之后，可以在一次连接中发送多次请求。（基本都使用1.1）</p>
<p>请求资源：  /myweb/hello</p>
<p>URL: 统一资源定位符。<a href="http://localhost:8080/myweb/testImg.html%E3%80%82%E5%8F%AA%E8%83%BD%E5%AE%9A%E4%BD%8D%E4%BA%92%E8%81%94%E7%BD%91%E8%B5%84%E6%BA%90%E3%80%82">http://localhost:8080/myweb/testImg.html。只能定位互联网资源。</a>                是URI的子集。</p>
<p>URI：统一资源标记符：用于标记任何资源。可以是本地文件系统，局域网的资源</p>
</blockquote>
<p> <strong>请求头</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept: text/html,image/*      -- 浏览器接受的数据类型</span><br><span class="line">Accept-Charset: ISO-8859-1     -- 浏览器接受的编码格式</span><br><span class="line">Accept-Encoding: gzip,compress  --浏览器接受的数据压缩格式</span><br><span class="line">Accept-Language: en-us,zh-       --浏览器接受的语言</span><br><span class="line">Host: www.it315.org:80          --（必须的）当前请求访问的目标地址（主机:端口）</span><br><span class="line">If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT  --浏览器最后的缓存时间</span><br><span class="line">Referer: http://www.it315.org/index.jsp      -- 当前请求来自于哪里</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)  --浏览器类型</span><br><span class="line">Cookie:name=eric                     -- 浏览器保存的cookie信息</span><br><span class="line">Connection: close/Keep-Alive            -- 浏览器跟服务器连接状态。close: 连接关闭  keep-alive：保存连接。</span><br><span class="line">Date: Tue, 11 Jul 2000 18:23:51 GMT      -- 请求发出的时间</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>实体内容</strong>：只有<code>POST</code>提交的参数会放到实体内容中。</p>
<h2 id="Http响应"><a href="#Http响应" class="headerlink" title="Http响应"></a>Http响应</h2><p>服务器—–&gt; 浏览器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK                --响应行</span><br><span class="line">Server: Apache-Coyote/1.1         --响应头（key-vaule）</span><br><span class="line">Content-Length: 24 </span><br><span class="line">Date: Fri, 30 Jan 2015 01:54:57 GMT</span><br><span class="line">                                   --一个空行</span><br><span class="line">this is hello servlet!!!                  --实体内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>响应行：HTTP/1.1 200 OK  协议版本、状态码、状态描述</p>
<p>常见的响应头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Location: http://www.zhuhdha.org/index.jsp   -表示重定向的地址，该头和302的状态码一起使用。</span><br><span class="line">Server:apache tomcat                 ---表示服务器的类型</span><br><span class="line">Content-Encoding: gzip                 -- 表示服务器发送给浏览器的数据压缩类型</span><br><span class="line">Content-Length: 80                    --表示服务器发送给浏览器的数据长度</span><br><span class="line">Content-Language: zh-cn               --表示服务器支持的语言</span><br><span class="line">Content-Type: text/html; charset=GB2312   --表示服务器发送给浏览器的数据类型及内容编码</span><br><span class="line">Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT  --表示服务器资源的最后修改时间</span><br><span class="line">Refresh: 1;url=http://www.it315.org     --表示定时刷新</span><br><span class="line">Content-Disposition: attachment; filename=aaa.zip --表示告诉浏览器以下载方式打开资源（下载文件时用到）</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Set-Cookie:SS=Q0=5Lb_nQ; path=/search   --表示服务器发送给浏览器的cookie信息（会话管理用到）</span><br><span class="line">Expires: -1                          --表示通知浏览器不进行缓存</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Connection: close/Keep-Alive   --表示服务器和浏览器的连接状态。close：关闭连接 keep-alive:保存连接</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h1><p><code>Get</code> 方法的含义是请求<strong>从服务器获取资源</strong>，这个资源可以是静态的文本、页面、图片视频等。</p>
<p>比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。</p>
<img src="/2020/03/13/Http%E5%8D%8F%E8%AE%AE/get.jpg" alt="img" style="zoom:100%;">



<p>而<code>POST</code> 方法则是相反操作，它向 <code>URI</code> 指定的资源提交数据，数据就放在报文的 body 里。 </p>
<p>GET 和 POST 方法都是安全和幂等的吗？ </p>
<blockquote>
<ul>
<li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li>
<li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li>
</ul>
</blockquote>
<p>那么很明显 <strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p>
<p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。</p>
<p>GET方式提交：</p>
<ol>
<li><p> 地址栏（URI）会跟上参数数据。以？开头，多个参数之间以&amp;分割。</p>
</li>
<li><p>GET提交参数数据有限制，不超过1KB。</p>
</li>
<li><p>GET方式不适合提交敏感密码。</p>
<p><strong>注意： 浏览器直接访问的请求，默认提交方式是GET方式</strong></p>
</li>
</ol>
<p>POST方式提交：</p>
<ol>
<li> 参数不会跟着URI后面。而是跟在请求的实体内容中。没有？开头，多个参数之间以&amp;分割。</li>
<li>POST提交的参数数据没有限制。</li>
<li>建议用POST方式提交敏感数据。</li>
</ol>
<hr>
<h1 id="获取请求和响应的信息"><a href="#获取请求和响应的信息" class="headerlink" title="获取请求和响应的信息"></a>获取请求和响应的信息</h1><h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><p><code>HttpServletRequest</code>对象作用是用于获取请求数据。</p>
<p><strong>核心的API：</strong></p>
<p>​                        <strong>请求行：</strong> </p>
<p>​                            <code>request.getMethod();</code>   请求方式</p>
<p>​                            <code>request.getRequetURI()  /  request.getRequetURL()</code>  请求资源</p>
<p>​                            <code>request.getProtocol()</code>  请求http协议版本</p>
<p>​                        <strong>请求头：</strong></p>
<p>​                            <code>request.getHeader(&quot;名称&quot;)</code>  根据请求头获取请求值</p>
<p>​                            <code>request.getHeaderNames()</code>  获取所有的请求头名称</p>
<p>​                        <strong>实体内容:</strong></p>
<p>​                            <code>request.getInputStream()</code>  获取实体内容数据</p>
<p>当请求服务器资源的时候，tomcat服务器已经做了以下两件事情：</p>
<ol>
<li> tomcat服务器接收到浏览器发送的请求数据，然后封装到<code>HttpServetRequest</code>对象</li>
<li> tomcat服务器调用<code>doGet</code>方法，然后把<code>request</code>对象传入到<code>servlet</code>中。</li>
</ol>
<h3 id="获取请求行"><a href="#获取请求行" class="headerlink" title="获取请求行"></a>获取请求行</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式</span></span><br><span class="line">System.out.println(<span class="string">&quot;请求方式：&quot;</span>+ req.getMethod());</span><br><span class="line"><span class="comment">// 请求资源</span></span><br><span class="line">System.out.println(<span class="string">&quot;请求资源 URL：&quot;</span>+ req.getRequestURL());</span><br><span class="line">System.out.println(<span class="string">&quot;请求资源 URI：&quot;</span>+ req.getRequestURI());</span><br><span class="line"><span class="comment">// 协议</span></span><br><span class="line">System.out.println(<span class="string">&quot;协议：&quot;</span>+ req.getProtocol());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请求方式：GET* </p>
<p>请求资源 URL：<a href="http://localhost:8080/web/req">http://localhost:8080/web/req</a></p>
<p>请求资源 URI：/web/req</p>
<p>协议：HTTP/1.1</p>
</blockquote>
<h3 id="获取请求头"><a href="#获取请求头" class="headerlink" title="获取请求头"></a>获取请求头</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请求头</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">System.out.println(<span class="string">&quot;Host:&quot;</span>+ req.getHeader(<span class="string">&quot;Host&quot;</span>));</span><br><span class="line">    <span class="comment">// 获取所有的请求头名称列表</span></span><br><span class="line">    Enumeration&lt;String&gt; headerNames = req.getHeaderNames();</span><br><span class="line">    <span class="keyword">while</span> (headerNames.hasMoreElements())&#123;</span><br><span class="line">        String s = headerNames.nextElement();</span><br><span class="line">        String header = req.getHeader(s);</span><br><span class="line">        System.out.println(s+<span class="string">&quot;:&quot;</span>+header);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Host:localhost:8080<br>        host:localhost:8080<br>connection:keep-alive<br>cache-control:max-age=0<br>upgrade-insecure-requests:1<br>user-agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36<br>sec-fetch-dest:document<br>accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3;q=0.9<br>sec-fetch-site:none<br>sec-fetch-mode:navigate<br>sec-fetch-user:?1<br>accept-encoding:gzip, deflate, br<br>accept-language:zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7<br>cookie:JSESSIONID=EE84B02DC152BC48A5AB12844C5D936F; username-localhost-8888=”2|1:0|10:1583063846|23:username-localhost-8888|44:YTBhNTIyNDJiYzM0NDFjY2FmNDQyNTc2ODM0Zjk2OGU=|eb0fd9674f9abfa8a106b4d0668f717f2e2bf5ebe8efbd907aa0fef7c72e3471”; _xsrf=2|694857a0|0a1d86b5ae8842cd51764b901e8b28b5|1583063846; Idea-e408487e=5418b1fa-da5b-44f8-b6f4-41845ecef50b; Hm_lvt_1c47812cb33835eb048ad943e868a359=1583987228</p>
</blockquote>
<h3 id="获取实体内容"><a href="#获取实体内容" class="headerlink" title="获取实体内容"></a>获取实体内容</h3><p>只有POST提交的参数会放到实体内容中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 实体内容</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ServletInputStream inputStream = req.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(buff) ) != -<span class="number">1</span>) &#123;</span><br><span class="line">            String str = <span class="keyword">new</span> String(buff, <span class="number">0</span>, len);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>POST方式提交<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/web/requestDemo&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  	用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  	密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2020/03/13/Http%E5%8D%8F%E8%AE%AE/1584096688939.png" alt="1584096688939" style="zoom:80%;">



<h3 id="传递的请求参数如何获取"><a href="#传递的请求参数如何获取" class="headerlink" title="传递的请求参数如何获取"></a>传递的请求参数如何获取</h3><p>GET方式： 参数放在URI后面</p>
<p>POST方式： 参数放在实体内容中 </p>
<p>获取GET方式参数：<code>request.getQueryString();</code></p>
<p>获取POST方式参数：<code>request.getInputStream();</code></p>
<p>问题：但是以上两种不通用，而且获取到的参数还需要进一步地解析。所以可以使用统一方便的获取参数的方式：</p>
<blockquote>
<p>核心的API：</p>
<p><code>request.getParameter(&quot;参数名&quot;);</code>  根据参数名获取参数值（注意，只能获取一个值的参数）</p>
<p> <code>request.getParameterValue(&quot;参数名“);</code>根据参数名获取参数值（可以获取多个值的参数）</p>
<p> <code>request.getParameterNames();</code>  获取所有参数名称列表  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String value = req.getQueryString();</span><br><span class="line">      System.out.println(va nlue);</span><br><span class="line">      String name = req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;name:&quot;</span>+name);</span><br><span class="line">      String pass = req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;password：&quot;</span>+pass);</span><br><span class="line"></span><br><span class="line">      Enumeration&lt;String&gt; parameterNames = req.getParameterNames();</span><br><span class="line">      <span class="keyword">while</span> (parameterNames.hasMoreElements())&#123;</span><br><span class="line">          String s = parameterNames.nextElement();</span><br><span class="line">          String parameter = req.getParameter(s);</span><br><span class="line">          System.out.println(s+<span class="string">&quot;：&quot;</span>+parameter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="请求方式的编码问题【中文乱码】"><a href="#请求方式的编码问题【中文乱码】" class="headerlink" title="请求方式的编码问题【中文乱码】"></a>请求方式的编码问题【中文乱码】</h3><p>修改<code>POST</code>方式参数编码：<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code></p>
<p>修改<code>GET</code>方式参数编码：</p>
<p>​            手动解码：<code>String name = new String(name.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;);</code></p>
<p><code>request.setCharacterEncoding(&quot;utf-8&quot;);</code> 只对POST方式有效，GET方式无效。</p>
<p>在idea中，使用GET方式提交数据，使用<code>req.getQueryString()</code> 得到的结果为中文乱码。手动解码也无效。。。。可以使用<strong>java.net.URLDecoder.decode(value, “UTF-8”);</strong> 的方式编码。可以消除中文乱码。</p>
<blockquote>
<p>name=数字图像处理&amp;password=ll</p>
</blockquote>
<h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><p>同样，tomcat已经做了两件事</p>
<ol>
<li> tomcat服务器接收到浏览器发送的请求数据，然后封装到<code>HttpServetRequest</code>对象</li>
<li> tomcat服务器调用<code>doGet</code>方法，然后把<code>request</code>和<code>response</code>对象传入到<code>servlet</code>中。</li>
</ol>
<p>我们可以使用<code>HttpServletResponse</code>设置响应信息。</p>
<ol>
<li><p>响应行：   response.setStatus() 设置状态码</p>
</li>
<li><p>响应头：  response.setHeader(“name”,”value”) 设置响应头</p>
</li>
</ol>
<p>​                                 response.setHeader(“name”,”value”) 设置响应头</p>
<ol start="3">
<li>实体内容：  response.getWriter().writer();  发送字符实体内容</li>
</ol>
<p>​                            response.getOutputStream().writer() 发送字节实体内容 </p>
<hr>
<h3 id="举例：请求重定向【location】"><a href="#举例：请求重定向【location】" class="headerlink" title="举例：请求重定向【location】"></a>举例：请求重定向【location】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">      resp.setStatus(<span class="number">302</span>);</span><br><span class="line">      resp.setHeader(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;/web/testMethod.html&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<img src="/2020/03/13/Http%E5%8D%8F%E8%AE%AE/1584109178963.png" alt="1584109178963" style="zoom:80%;">

<p>重定向 = location+302代码， 与resp.<strong>sendRedirect</strong>(“/web/testMethod.html”);  一样的效果。</p>
<img src="/2020/03/13/Http%E5%8D%8F%E8%AE%AE/1584109334540.png" alt="1584109334540" style="zoom:100%;">

<h3 id="举例：-定时刷新【refresh】"><a href="#举例：-定时刷新【refresh】" class="headerlink" title="举例： 定时刷新【refresh】"></a>举例： 定时刷新【refresh】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定时刷新</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;refresh&quot;</span>,<span class="string">&quot;1&quot;</span>);<span class="comment">// 每隔1秒刷新一次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5秒后跳转到指定页面</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;refresh&quot;</span>,<span class="string">&quot;5;url=/web/testMethod.html&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="举例：-content-Type作用"><a href="#举例：-content-Type作用" class="headerlink" title="举例： content-Type作用"></a>举例： content-Type作用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 图片下载</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;F:/get.jpg&quot;</span>);</span><br><span class="line">        System.out.println(file);</span><br><span class="line"><span class="comment">//        resp.setHeader(&quot;Content-Type&quot;,&quot;image/jpg&quot;);   // 设置传输内容的类型</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;image/jpg&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot; attachment; filename=&quot;</span>+file.getName());  <span class="comment">// 以下载的方式打开</span></span><br><span class="line"></span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = in.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            resp.getOutputStream().write(buff,<span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247487758&idx=1&sn=ac5139f94daf085d7eece81c09cca5a6&chksm=fa0e7e8fcd79f799f2fa8a67561fb331618df547e01295c6050e45dac93e8b1d9545be6c042f&scene=126&sessionid=1584072960&key=94bece7b32125346cc4a34ac99439443d08ac302d7aa2821f753c4f28f9447b749ac8e92e2e72a73a7d1fb80de93b5cda36a04d8a4c1529e087bcc6df889f80cf9870823a47b2bc693659193329283f4&ascene=1&uin=MjY3ODQ2NDEwMA==&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=AcY09txF7kkr9UY2iEOQARg=&pass_ticket=UnXa5ZPO5RG6hqrMNzKdyHHdqvlu5AUHuvP3OWSFmB/zZ46JQYNTSHpR6SzHNdhZ">面试官，别问我 HTTP 了！看这 30 张图就行！</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中字符串原理分析</title>
    <url>/2020/02/23/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E9%94%85%E7%AB%AF%E4%BA%86/</url>
    <content><![CDATA[<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value 数组被声明为 <code>final</code>，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 </p>
<hr>
<h1 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h1><h2 id="1-可以缓存hash值"><a href="#1-可以缓存hash值" class="headerlink" title="1. 可以缓存hash值"></a>1. 可以缓存hash值</h2><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 </p>
<h2 id="2-String-Pool-的需要"><a href="#2-String-Pool-的需要" class="headerlink" title="2. String Pool 的需要"></a>2. String Pool 的需要</h2><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 </p>
<img src="/2020/02/23/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E9%94%85%E7%AB%AF%E4%BA%86/1582459025334.png" alt="1582459025334" style="zoom:100%;">

<h2 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h2><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。 </p>
<h2 id="4-线程安全"><a href="#4-线程安全" class="headerlink" title="4. 线程安全"></a>4. 线程安全</h2><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 </p>
<p> <a href="https://www.programcreek.com/2013/04/why-string-is-immutable-in-java/">Program Creek : Why String is immutable in Java?</a> </p>
<hr>
<h1 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h1><h2 id="1-可变性"><a href="#1-可变性" class="headerlink" title="1. 可变性"></a>1. 可变性</h2><ul>
<li>String 不可变  如果您尝试更改其值，则会创建另一个对象 。地址改变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<h2 id="2-线程安全"><a href="#2-线程安全" class="headerlink" title="2. 线程安全"></a>2. 线程安全</h2><ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的  1.5之后</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<p><a href="https://stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder">StackOverflow : String, StringBuffer, and StringBuilder</a></p>
<p>StringBuffer和StringBuilder的区别在于，StringBuffer是线程安全的。因此，当应用程序需要在单个线程中运行时，最好使用StringBuilder。StringBuilder比StringBuffer更高效。 </p>
<h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h2><ol>
<li>如果你的字符串不会改变，那就使用string类，因为string对象是不可变的。 </li>
<li> 如果您的字符串可以更改（例如：字符串构造中的大量逻辑和操作）并且只能从单个线程访问，则使用StringBuilder就足够了。 </li>
<li> 如果您的字符串可以更改，并且可以从多个线程访问，请使用StringBuffer，因为StringBuffer是同步的，所以具有线程安全性。 </li>
</ol>
<h2 id="4-java-lang-StringBuffer"><a href="#4-java-lang-StringBuffer" class="headerlink" title="4. java.lang.StringBuffer"></a>4. java.lang.StringBuffer</h2><p>代表<strong>可变的字符序列</strong>，可以对字符串内容进行增删。  </p>
<p>很多方法与String相同，但StringBuffer是可变长度的  .</p>
<p>StringBuffer是一个容器。</p>
<p>StringBuffer类有三个构造器:</p>
<blockquote>
<p>1.StringBuffer() 初始容量为16的字符串缓冲区</p>
<p>2.StringBuffer(int <strong>size</strong>)构造指定容量的字符串缓冲区</p>
<p>3.StringBuffer(String  <strong>str</strong>)将内容初始化为指定字符串内容</p>
</blockquote>
<p>StringBuffer类的常用方法:</p>
<blockquote>
<p>StringBuffer <strong>append</strong>(String s),  StringBuffer append(int n) , </p>
<p>StringBuffer append(Object o) , StringBuffer append(char n),</p>
<p>StringBuffer append(long n), StringBuffer append(boolean n),</p>
<p>StringBuffer <strong>insert</strong>(int index, String str) </p>
<p>public StringBuffer <strong>reverse</strong>() </p>
<p>StringBuffer <strong>delete</strong>(int startIndex, int endIndex) </p>
<p>public char <strong>charAt</strong>(int n )</p>
<p>public void <strong>setCharAt</strong>(int n ,char ch)</p>
<p>StringBuffer <strong>replace</strong>( int startIndex ,int endIndex, String str) </p>
<p>public int <strong>indexOf</strong>(String str)</p>
<p>public String <strong>substring</strong>(int start,int end)</p>
<p>public int <strong>length</strong>()</p>
</blockquote>
<hr>
<h1 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h1><p>字符串常量池（<code>String Pool</code>）保存着所有<strong>字符串字面量</strong>（<code>literal strings</code>），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 <code>intern()</code> 方法在运行过程将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 <code>intern()</code> 方法时，如果 <code>String Pool</code> 中已经存在一个字符串和该字符串值相等（使用 <code>equals()</code> 方法进行确定），那么就会返回 <code>String Pool</code> 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 <code>new String()</code> 的方式新建了两个不同字符串，而 s3 和 s4 是通过 <code>s1.intern()</code> 方法取得同一个字符串引用。<code>intern()</code> 首先把 s1 引用的字符串放到 <code>String Pool</code> 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">String s4 = s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p> 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 <code>String Pool</code> 中。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s5 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">String s6 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在 Java 7 之前，<code>String Pool</code> 被放在<strong>运行时常量池</strong>中，它属于永久代。而在 Java 7，<code>String Pool</code> 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 <code>OutOfMemoryError</code> 错误。</p>
<ul>
<li><a href="https://stackoverflow.com/questions/10578984/what-is-string-interning">StackOverflow : What is String interning?</a></li>
<li><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html">深入解析 String#intern</a></li>
</ul>
<p>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中。</p>
<p>如果不是用双引号声明的<code>String</code>对象，可以使用<code>String</code>提供的<code>intern</code>方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p>
<hr>
<h1 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h1><p>使用这种方式一共会创建<strong>两个</strong>字符串对象（前提是 <code>String Pool</code> 中还没有 <code>&quot;abc&quot;</code> 字符串对象）。</p>
<ul>
<li><code>&quot;abc&quot;</code> 属于字符串字面量，因此编译时期会在 <code>String Pool</code> 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewStringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>javap -verbose</code> 进行反编译，得到以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Constant pool:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">18</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">19</span>            <span class="comment">// abc</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               java/lang/String</span><br><span class="line">  #<span class="number">19</span> = Utf8               abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String abc</span></span><br><span class="line">         <span class="number">6</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">9</span>: astore_1</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在 <code>Constant Pool</code> 中，#19 存储这字符串字面量 “abc”，#3 是 <code>String Pool</code> 的字符串对象，它指向 #19 这个字符串字面量。在 <code>main</code> 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> string;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-23 13:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 字面量</span></span><br><span class="line">        String s2 = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;abc&quot;</span> + <span class="string">&quot;def&quot;</span>; <span class="comment">//  字面量</span></span><br><span class="line">        String s4 = s1 + <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        String s5 = <span class="string">&quot;abc&quot;</span> + s2;</span><br><span class="line">        String s6 = s1 + s2;</span><br><span class="line">        String s7 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s7); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">//  fasle</span></span><br><span class="line">        System.out.println(s3 == s5); <span class="comment">//  fasle</span></span><br><span class="line">        System.out.println(s3 == s6); <span class="comment">//  false</span></span><br><span class="line">        System.out.println(s5 == s6);  <span class="comment">//  false</span></span><br><span class="line">        String s8 = s5.intern();</span><br><span class="line">        System.out.println(s3 == s8); <span class="comment">//true</span></span><br><span class="line">        System.out.println(s3 == s5); <span class="comment">// fasle</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong> </p>
<blockquote>
<p>1.常量与常量的拼接结果在常量池中， 且常量池中不会存在相同的常量</p>
<p>2.只要其中有一个是变量， 结果就在堆中， 会重新new一个对象在堆中。 比如上面的s4,s5,s6</p>
<p>3.如果拼接的结果调用<code>intern</code>方法，<em><strong>返回值</strong></em>就在常量池中。</p>
</blockquote>
<p>下列程序运行的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> string;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-23 21:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>[] ch = &#123; <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1 ex = <span class="keyword">new</span> test1();</span><br><span class="line">        ex.change(ex.str, ex.ch); <span class="comment">// good</span></span><br><span class="line">        System.out.print(ex.str + <span class="string">&quot; and &quot;</span>); <span class="comment">//  good and</span></span><br><span class="line">        System.out.println(ex.ch); <span class="comment">// gest</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good and gest</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;123&quot;</span>;  <span class="comment">// 字面量，在常量池中</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>); <span class="comment">//  在堆中创建</span></span><br><span class="line">System.out.println(s1.equals(s2));  <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//  true</span></span><br><span class="line">System.out.println(s3.equals(s4)); <span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s4);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s1.equals(s3)); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>下面的输出是什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(str);</span><br><span class="line"></span><br><span class="line">System.out.println(sb.length());<span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">System.out.println(sb);<span class="comment">//  “null”   实际上是存储的一个&quot;null&quot;字符串</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(str);  <span class="comment">// 抛出空指针异常</span></span><br><span class="line">System.out.println(sb1);<span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractStringBuilder <span class="title">appendNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(count + <span class="number">4</span>);  <span class="comment">//  如果添加的是null，那么会加上4个字节</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">byte</span>[] val = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">if</span> (isLatin1()) &#123;</span><br><span class="line">            val[count++] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">            val[count++] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">            val[count++] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">            val[count++] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count = StringUTF16.putCharsAt(val, count, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的形式去构造字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(str.length() + <span class="number">16</span>);  <span class="comment">// str.length() 如果str数null，根本没有这个方法，所以会报空指针异常</span></span><br><span class="line">        append(str);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="String字符串对象操作"><a href="#String字符串对象操作" class="headerlink" title="String字符串对象操作"></a>String字符串对象操作</h1><blockquote>
<p>public int length()  返回字符串的长度</p>
<p>public char charAt(int index)  指定下标的字符</p>
<p>public boolean equals(Object anObject)</p>
<p>public int compareTo(String anotherString)  比较</p>
<p>public int indexOf(String s) 指定字符或者字符串的下标 第一次出现</p>
<p>public int indexOf(String s ,int startpoint)</p>
<p>public int lastIndexOf(String s)  </p>
<p>public int lastIndexOf(String s ,int startpoint)</p>
<p>public boolean startsWith(String prefix)  是否以指定字符串开始的</p>
<p>public boolean endsWith(String suffix) 是否以指定字符串结束的</p>
<p>public boolean regionMatches(int firstStart,String other,int otherStart ,int length)</p>
</blockquote>
<h1 id="String字符串对象修改"><a href="#String字符串对象修改" class="headerlink" title="String字符串对象修改"></a>String字符串对象修改</h1><p>public String substring(int startpoint)  </p>
<p>public String substring(int start,int end)  //子字符串  包头不包尾  （左闭右开）</p>
<p>pubic String replace(char oldChar,char newChar)</p>
<p>public String replaceAll(String old,String new)</p>
<p>public String trim()  去掉字符串首部和尾部的空格</p>
<p>public String concat(String str)  等价于 “ + ”</p>
<p>public boolean contains(CharSequence s)  是否 包含指定的字符串</p>
<p>public String[] split(String regex)  根据给定正则表达式的匹配拆分此字符串。</p>
<hr>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="构造字符串"><a href="#构造字符串" class="headerlink" title="构造字符串"></a>构造字符串</h2><p>对于String来说：内部创建一个字符数组（JDK8），JDK9之后是一个字节数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> String str1 = <span class="keyword">new</span> String(); <span class="comment">// new char[]&#123;&#125;;</span></span><br><span class="line">String str2 = <span class="keyword">new</span> Strign(<span class="string">&quot;abc&quot;</span>); <span class="comment">// new cahr[] &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于StringBuffer来说：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line"><span class="comment">//char[] value = new char[16], 相当于在底层创建了一个长度为16 的数组。</span></span><br><span class="line">StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;123&quot;</span>); <span class="comment">// </span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk1.8源码：</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a string buffer with no characters in it 			and an initial capacity of 16 characters.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">        append(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// value[0] = &#x27;a&#x27;;</span></span><br></pre></td></tr></table></figure>

<h2 id="StringBuffer-中的-append-扩容"><a href="#StringBuffer-中的-append-扩容" class="headerlink" title="StringBuffer 中的 append + 扩容"></a>StringBuffer 中的 append + 扩容</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> appendNull();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> len = str.length();</span><br><span class="line">       ensureCapacityInternal(count + len); <span class="comment">//  扩容</span></span><br><span class="line">       putStringAt(count, str);</span><br><span class="line">       count += len;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;  <span class="comment">// 方法链原理</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jdk8</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//将原来的数组拷贝到一个新数组中，并且扩容</span></span><br><span class="line">           value = Arrays.copyOf(value,</span><br><span class="line">                   newCapacity(minimumCapacity));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// jdk8</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>; <span class="comment">//扩容为原来的两倍 + 2。</span></span><br><span class="line">       <span class="comment">//如果新的容量比最小容量都小，那么这个新的容量就为最小容量</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果新的容量大于最大的容量</span></span><br><span class="line">       <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           ? hugeCapacity(minCapacity)</span><br><span class="line">           : newCapacity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>jdk12：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="comment">// jdk12</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = value.length &gt;&gt; coder;</span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - oldCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            value = Arrays.copyOf(value,</span><br><span class="line">                    newCapacity(minimumCapacity) &lt;&lt; coder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// jdk12</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = value.length &gt;&gt; coder;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> SAFE_BOUND = MAX_ARRAY_SIZE &gt;&gt; coder;</span><br><span class="line">        <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || SAFE_BOUND - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            ? hugeCapacity(minCapacity)</span><br><span class="line">            : newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果添加的数据在底层数组盛不下了，那就需要扩容数组。默认情况下，扩容为原来的2倍+2， 同时将原有的数组中的元素复制到新数组当中。</p>
<p><strong>建议：</strong> 在实际开发中应该避免频繁的扩容，推荐使用构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(capacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(capacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>指定容量。</p>
<p>同理，StringBuilder底层的append和扩容也是和StringBuffer一样的。</p>
<hr>
<h1 id="StringBuffer和StringBuilder的额外方法"><a href="#StringBuffer和StringBuilder的额外方法" class="headerlink" title="StringBuffer和StringBuilder的额外方法"></a>StringBuffer和StringBuilder的额外方法</h1><p>以StringBuffer为例：</p>
<blockquote>
<p>StringBuffer append() ;</p>
<p>StringBuffer delete(int start, int end) ; //  删除指定位置的内容</p>
<p>StringBuffer insert(int offset,, xxx) ; // 在指定位置插入字符串</p>
<p>String replace(int start, int end, String str);</p>
<p>StringBuffer reverse();  反转字符串</p>
</blockquote>
<hr>
<h1 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">efficientTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">      String text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line">      <span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">      StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      startTime = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20000</span>;i++)&#123;</span><br><span class="line">          buffer.append(String.valueOf(i));&#125;</span><br><span class="line">      endTime = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span>+(endTime-startTime));</span><br><span class="line">      startTime = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20000</span>;i++)&#123;</span><br><span class="line">          builder.append(String.valueOf(i));&#125;</span><br><span class="line">      endTime = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span>+(endTime-startTime));</span><br><span class="line">      startTime = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20000</span>;i++)&#123;</span><br><span class="line">          text = text + i;&#125;</span><br><span class="line">      endTime = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">&quot;String的执行时间：&quot;</span>+(endTime-startTime));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在JDK8中测试：（ms）</p>
<blockquote>
<p>StringBuffer的执行时间：11<br>StringBuilder的执行时间：4<br>String的执行时间：1075</p>
</blockquote>
<p>在JDk12:</p>
<blockquote>
<p>StringBuffer的执行时间：6<br>StringBuilder的执行时间：2<br>String的执行时间：545</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li> <a href="https://cyc2018.github.io/CS-Notes/">https://cyc2018.github.io/CS-Notes/</a> </li>
<li> <a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a> </li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解(Annotation)</title>
    <url>/2020/02/29/Java%E6%B3%A8%E8%A7%A3-Annotation/</url>
    <content><![CDATA[<h1 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h1><p>从 JDK 5.0 开始, Java 增加了对元数据(<code>MetaData</code>) 的支持, 也就是 <code>Annotation</code>(注解)。</p>
<p><code>Annotation</code> 其实就是代码里的<strong>特殊标记</strong>, 这些标记可以在<strong>编译, 类加载, 运行时</strong>被读取, 并执行相应的处理。通过使用 <code>Annotation</code>, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。</p>
<p><code>Annotation</code> 可以像修饰符一样被使用, 可用于修饰包,  类,  构造器,  方法,  成员变量,  参数，局部变量的声明 , 这些信息被保存在 <code>Annotation</code> 的 <code>“name=value”</code> 对中。我们可以通过反射机制编程实现对这些元数据的访问。</p>
<p><code>Annotation</code> 能被用来为程序元素(类, 方法, 成员变量等) 设置元数据。</p>
<p>在<code>Java SE</code>中，注解的使用目的比较简单，例如标记过时的方法，忽略警告等。 在<code>Java EE / Android</code>中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替<code>JavaEE</code>旧版中所遗留的繁冗代码和XML配置。</p>
<p>未来的开发模式都是基于注解的，JPA是基于注解的，<code>Spring2.5</code>以上都是基于注解的，<code>Hibernate3.x</code>以后也都是基于注解的，<code>Struts2</code>也有一部分是基于注解的了。 注解是一种趋势， 一定程度上可以说：</p>
<blockquote>
<p>​     <strong>框架 = 注解  + 反射 + 设计模式。</strong></p>
</blockquote>
<hr>
<h1 id="Annotation-架构"><a href="#Annotation-架构" class="headerlink" title="Annotation 架构"></a>Annotation 架构</h1><img src="/2020/02/29/Java%E6%B3%A8%E8%A7%A3-Annotation/1582946861727.png" alt="1582946861727" style="zoom:80%;">

<p>(1). 1 个 <code>Annotation</code> 和 1 个 <code>RetentionPolicy</code> 关联。 可以理解为：每1个<code>Annotation</code>对象，都会有唯一的<code>RetentionPolicy</code>属性。 </p>
<p>(2).  1 个 <code>Annotation</code> 和 1~n 个 <code>ElementType</code> 关联。 可以理解为：对于每 1 个 <code>Annotation</code> 对象，可以有若干个 <code>ElementType</code> 属性。 </p>
<p>(3).  <code>Annotation</code> 有许多实现类，包括：<code>Deprecated</code>, <code>Documented</code>, <code>Inherited</code>, <code>Override</code> 等等。 <code>Annotation</code> 的每一个实现类，都 “和 1 个 <code>RetentionPolicy</code> 关联” 并且 “ 和 1~n 个 <code>ElementType</code> 关联”。 </p>
<hr>
<h2 id="Annotation-组成部分"><a href="#Annotation-组成部分" class="headerlink" title="Annotation 组成部分"></a>Annotation 组成部分</h2><img src="/2020/02/29/Java%E6%B3%A8%E8%A7%A3-Annotation/1582950102099.png" alt="1582950102099" style="zoom:80%;">

<p>Java<code>Annotation</code> 的组成中有 3 个非常重要的主干类。它们分别是： </p>
<h3 id="Annotation-java："><a href="#Annotation-java：" class="headerlink" title="Annotation.java："></a><strong>Annotation.java：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Annotation 就是个接口。</strong> </p>
<blockquote>
<p>每 1 个 <code>Annotation</code>“ 都与 “1 个 <code>RetentionPolicy</code>“ 关联，并且与 “1～n 个 <code>ElementType</code>“ 关联。可以通俗的理解为：每 1 个 <code>Annotation</code> 对象，都会有唯一的 <code>RetentionPolicy</code> 属性；至于 <code>ElementType</code> 属性，则有 1~n 个。 </p>
</blockquote>
<hr>
<h3 id="ElementType-java："><a href="#ElementType-java：" class="headerlink" title="ElementType.java："></a><strong>ElementType.java：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ElementType 是 <code>Enum</code> 枚举类型，它用来指定 <code>Annotation</code> 的类型。</p>
<p>每 1 个 <code>Annotation</code>“ 都与 “1～n 个 <code>ElementType</code>“ 关联。当 <code>Annotation</code> 与某个 <code>ElementType</code> 关联时，就意味着：<code>Annotation</code>有了某种用途。例如，若一个 <code>Annotation</code> 对象是 <code>METHOD</code> 类型，则该 <code>Annotation</code> 只能用来修饰方法。 </p>
<hr>
<h3 id="RetentionPolicy-java："><a href="#RetentionPolicy-java：" class="headerlink" title="RetentionPolicy.java："></a><strong>RetentionPolicy.java：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RetentionPolicy 是 <code>Enum</code> 枚举类型，它用来指定 <code>Annotation</code> 的策略。通俗点说，就是不同 <code>RetentionPolicy</code> 类型的 <code>Annotation</code> 的作用域不同。</strong> </p>
<p>每 1 个 <code>Annotation</code> 都与 1 个 <code>RetentionPolicy</code>关联 ：</p>
<blockquote>
<p> a)   若 <code>Annotation</code> 的类型为 <code>SOURCE</code>，则意味着：<code>Annotation</code> 仅存在于<strong>编译器处理期间</strong>，编译器处理完之后，该 <code>Annotation</code> 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。 </p>
<p>b） 若 <code>Annotation</code> 的类型为 <code>CLASS</code>，则意味着：编译器将 <code>Annotation</code> 存储于类对应的 <code>.class</code> 文件中，它是 <code>Annotation</code> 的默认行为。 </p>
<p>c)    若 <code>Annotation</code> 的类型为 <code>RUNTIME</code>，则意味着：编译器将 <code>Annotation</code> 存储于 <code>class</code> 文件中，并且可由<code>JVM</code>读入。 也就是说可以通过反射机制来读取。</p>
</blockquote>
<h1 id="JDk中的内置注解"><a href="#JDk中的内置注解" class="headerlink" title="JDk中的内置注解"></a>JDk中的内置注解</h1><p>Java 定义了一套注解，共有 7 个，3 个在 <code>java.lang</code> 中，剩下 4 个在 <code>java.lang.annotation</code> 中。 </p>
<p>使用 <code>Annotation</code> 时要在其前面增加 <code>@</code> 符号, 并把该 <strong>Annotation</strong> <strong>当成一个修饰符使用。</strong>用于修饰它支持的程序元素。</p>
<h2 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h2><p>定义在<code>java.lang.Override</code>中，此注解只适用修饰方法，表示一个方法声明重写父类中的另一个方法声明。  如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 </p>
<h2 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h2><p>定义在<code>java.lang.Deprecated</code>中， 用于表示某个程序元素(类, 方法等)<strong>已过时</strong>。此注解可用于修辞方法、属性、类 ，表示不鼓励程序员使用这样的元素，通常是因为它很危险或存在更好的选择。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@ SuppressWarnings"></a>@ SuppressWarnings</h2><p>定义在<code>java.lang.SuppressWarnings</code>中，用来抑制编译时的警告信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(1) <code>@interface</code> – 它的用来修饰 <code>SuppressWarnings</code>，意味着 <code>SuppressWarnings</code> 实现了<code>java.lang.annotation.Annotation</code> 接口；即 <code>SuppressWarnings</code> 就是一个注解 。</p>
<p>(2) <code>@Retention(RetentionPolicy.SOURCE)</code> – 它的作用是指定 <code>SuppressWarnings</code> 的策略是 <code>RetentionPolicy.SOURCE</code>。这就意味着，<code>SuppressWarnings</code> 信息仅存在于编译器处理期间，编译器处理完之后 <code>SuppressWarnings</code> 就没有作用了。 </p>
<p>(3) <code>@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</code> – 它的作用是指定 <code>SuppressWarnings</code> 的类型同时包括<code>TYPE</code>, <code>FIELD</code>, <code>METHOD</code>, <code>PARAMETER</code>, <code>CONSTRUCTOR</code>, <code>LOCAL_VARIABLE</code>。</p>
<p>(04) <code>String[] value();</code> 意味着，<code>SuppressWarnings</code> 能指定参数 。</p>
<p>与前两个注释有所不同，你需要添加一个参数才能正确使用，这些参数值都是已经定义好了的，我们选择性的使用就好了，参数如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">deprecation  <span class="comment">-- 使用了不赞成使用的类或方法时的警告</span></span><br><span class="line">unchecked    <span class="comment">-- 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。</span></span><br><span class="line">fallthrough  <span class="comment">-- 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。</span></span><br><span class="line">path         <span class="comment">-- 在类路径、源文件路径等中有不存在的路径时的警告。</span></span><br><span class="line">serial       <span class="comment">-- 当在可序列化的类上缺少 serialVersionUID 定义时的警告。</span></span><br><span class="line">finally      <span class="comment">-- 任何 finally 子句不能正常完成时的警告。</span></span><br><span class="line"><span class="keyword">all</span>          <span class="comment">-- 关于以上所有情况的警告。</span></span><br></pre></td></tr></table></figure>

<p>(5) <code>SuppressWarnings</code> 的作用是，让编译器对”它所标注的内容”的某些警告保持静默。例如，”<code>@SuppressWarnings(value=&#123;&quot;deprecation&quot;, &quot;unchecked&quot;&#125;)</code>“ 表示对”它所标注的内容”中的 “<code>SuppressWarnings</code> 不再建议使用警告”和”未检查的转换时的警告”保持沉默。</p>
<hr>
<h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><h2 id="Annotation-通用定义"><a href="#Annotation-通用定义" class="headerlink" title="Annotation 通用定义"></a>Annotation 通用定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义新的 Annotation 类型使用 <strong>@interface</strong> 关键字。</p>
<p>自定义注解自动继承了<code>java.lang.annotation.Annotation</code> 接口。</p>
<p>Annotation的成员变量在 Annotation 定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。称之为配置参数。例如： <code>String[] values();</code> </p>
<p>如果只有一个参数成员，一般参数名为<code>value</code></p>
<p>可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用<code>default</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String  <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;jack&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有成员定义的 <code>Annotation</code> 称为标记, 比如 <code>@Override</code>;  包含成员变量的 Annotation 称为元数据 Annotation, 再使用该注解的时候要使用成员变量，指定值。</p>
<blockquote>
<p>注： 自定义注解必须定义注解信息处理流程才有意义。 (注解信息处理流程，是注解和注释的重大区别 。如果没有注解信息处理流程，则注解毫无意义）。使用反射实现。</p>
</blockquote>
<hr>
<h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>元注解的作用就是负责注解其他注解， 对现有的注解进行解释说明的注解。（注解注解的注解。…晕）</p>
<p><code>JDK5.0</code>提供了专门在注解上的注解类型，分别是：</p>
<blockquote>
<p>@Retention</p>
<p>@Target</p>
<p>@Documented</p>
<p>@Inherited</p>
</blockquote>
<p>元数据：  <code>String name = &quot;zhu&quot;;</code>   其中 String name 就是一个元数据， 用来修饰主要数据（”zhu”）的数据。</p>
<h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p>只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间（生命周期）。</p>
<p><code>@Rentention</code> 包含一个 <strong>RetentionPolicy</strong> 类型的成员变量, 使用 @<code>Rentention</code> 时必须为该 <code>value</code> 成员变量指定值。</p>
<blockquote>
<p><strong>RetentionPolicy.SOURCE</strong> ： 编译器直接丢弃这种策略的注释， 编译成class文件中不会保留该注解信息。</p>
<p><strong>RetentionPolicy.CLASS</strong>:  编译器将把注释记录在 class 文件中。当运行 Java 程序时， <code>JVM</code> 不会保留注解。 这是默认值。</p>
<p><strong>RetentionPolicy.RUNTIME</strong>： 编译器将把注释记录在class文件中。当运行Java程序时,  JVM会保留注解。程序可以通过反射获取该注解。</p>
</blockquote>
<p>可以参考上文[@Retention](#Annotation 组成部分).</p>
<h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>前面我们说过，<code>ElementType</code> 是 <code>Annotation</code> 的类型属性。而 <code>@Target</code> 的作用，就是来指定 <code>Annotation</code> 的类型属性。查看[ElementType ](# ElementType.java:)。</p>
<p>用于修饰 <code>Annotation</code> 定义, 用于指定被修饰的 <code>Annotation</code> 能用于修饰哪些程序元素。<code>@Target</code> 也包含一个名为 <code>value</code> 的成员变量。</p>
<p>定义 <code>Annotation</code> 时，<code>@Target</code> 可有可无。若有 <code>@Target</code>，则该 <code>Annotation</code> 只能用于它所指定的地方；若没有 <code>@Target</code>，则该 <code>Annotation</code> 可以用于任何地方。 </p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line"></span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><p>被它修饰的 <code>Annotation</code> 将具有<strong>继承性</strong>.如果某个类使用了被 <code>@Inherited</code> 修饰的 <code>Annotation</code>, 则其子类将自动具有该注解。 实际开发中应用的较少。</p>
<h2 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h2><p>用于指定被该元 <code>Annotation</code> 修饰的 <code>Annotation</code> 类将被 <code>javadoc</code> 工具提取成文档。</p>
<blockquote>
<p>定义为<code>Documented</code>的注解必须设置<code>Retention</code>值为<code>RUNTIME</code>。</p>
</blockquote>
<hr>
<h1 id="JDK8中注解的新特性"><a href="#JDK8中注解的新特性" class="headerlink" title="JDK8中注解的新特性"></a>JDK8中注解的新特性</h1><h2 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h2><p>在JDK8之前，如果需要使用重复注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-29 12:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String  <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;jack&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要定义一个注解，里面加入要重复注解类型的数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-29 16:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotaionss &#123;</span><br><span class="line">    MyAnnotation[] value(); <span class="comment">// 数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnnotaionss( &#123; @MyAnnotation(name = &quot;tom&quot;), @MyAnnotation(name = &quot;zhu&quot;) &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注解测试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<hr>
<p>在JDk8之后：使用<code>@Repeatable</code> 可以实现可重复注解。</p>
<p>①. 在MyAnnotation上声明<code>@Repeatable</code>， 成员值为<code>@Repeatable</code>.class`。</p>
<p>②. MyAnnotation 的 <code>Target</code> 与 <code>Retention</code>  等元注解和 MyAnnotations的要相同。</p>
<p>③. 使用可重复注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(MyAnnotaionss.class)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String  <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;jack&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotaionss &#123;</span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value = &quot;zhu&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;jerry&quot;)</span>  <span class="comment">// 可重复注解</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;注解测试&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>来看看jdk8中的<code>ElementType</code>的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Method declaration */</span></span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Constructor declaration */</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Local variable declaration */</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Package declaration */</span></span><br><span class="line">    PACKAGE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type parameter declaration</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use of a type</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java8之前， 注解只能是在声明的地方所使用的， Jva8之后， 注解可以应用到任何地方。</p>
<p><code>TYPE_PARAMETER</code> ： 表示该注解能写在类型变量的声明语句中（如： 泛型声明）。</p>
<p><code>TYPE_USE</code> ：  表示该注解能卸载使用类型的任何语句中。</p>
<p>定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(MyAnnotaionss.class)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span> <span class="comment">// 添加ElementType.TYPE_PARAMETER / ElementType.TYPE_USE</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String  <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;jack&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;@<span class="title">MyAnnotation</span> <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;<span class="meta">@MyAnnotation</span> String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = (<span class="meta">@MyAnnotation</span> <span class="keyword">int</span>) <span class="number">10L</span>;  <span class="comment">//  这样在任何类型上都可以使用注解。后面可以通过反射机制来获取信息。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h1><ol>
<li><strong>编译检查</strong>：  <code>@SuppressWarnings,</code> <code>@Deprecated</code> 和 <code>@Override</code> 都具有编译检查作用。 若某个方法被 <code>@Override</code> 的标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被 <code>@Override</code> 标示，但父类中却没有”被 <code>@Override</code> 标注”的同名方法，则编译器会报错。</li>
<li><strong>可以在反射中使用Annotation</strong>： 在反射的 <code>Class</code>, <code>Method</code>, <code>Field</code> 等函数中，有许多于 Annotation 相关的接口。这也意味着，我们可以在反射中解析并使用 <code>Annotation</code>。</li>
<li><strong>根据 Annotation 生成帮助文档</strong>： 通过给 <code>Annotation</code> 注解加上 <code>@Documented</code> 标签，能使该 <code>Annotation</code> 标签出现在 <code>javadoc</code> 中。 </li>
<li><strong>能够帮忙查看代码</strong>： 通过 <code>@Override</code>, <code>@Deprecated</code> 等，我们能很方便的了解程序的大致结构。另外，我们也可以通过自定义 <code>Annotation</code> 来实现一些功能。</li>
</ol>
<hr>
<h1 id="实例：-通过反射模拟注解信息处理流程"><a href="#实例：-通过反射模拟注解信息处理流程" class="headerlink" title="实例： 通过反射模拟注解信息处理流程"></a>实例： 通过反射模拟注解信息处理流程</h1><p>模拟ORM： <code>Object Relation Mapping</code></p>
<p>数据库中表对应着Java中的一个类， 字段对应属性，本例通过读取类上的注解来生成一个sql语句来创建一个数据库中表。</p>
<h2 id="定义类上的注解"><a href="#定义类上的注解" class="headerlink" title="定义类上的注解"></a>定义类上的注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用于注解类的注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-01 14:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> stTable &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="定义字段Field的注解"><a href="#定义字段Field的注解" class="headerlink" title="定义字段Field的注解"></a>定义字段Field的注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解字段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-01 14:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> stField &#123;</span><br><span class="line">    <span class="function">String <span class="title">colunName</span><span class="params">()</span></span>; <span class="comment">//  列名</span></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span></span>; <span class="comment">//类型</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>; <span class="comment">// 长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Person类上使用注解"><a href="#Person类上使用注解" class="headerlink" title="Person类上使用注解"></a>Person类上使用注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person类，对应数据库中的一个表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-01 14:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@stTable(&quot;st_table&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@stField(colunName = &quot;st_name&quot;, type = &quot;varchar&quot;, length = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@stField(colunName = &quot;id&quot;, type = &quot;int&quot;, length = 16)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第三方程序通过反射机制读取注解"><a href="#第三方程序通过反射机制读取注解" class="headerlink" title="第三方程序通过反射机制读取注解"></a>第三方程序通过反射机制读取注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  通过反射机制获取一个类的注解信息。来进行sql语句的拼接，生成一个数据库中的一个表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-01 14:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">getTable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="string">&quot;annotation.Person&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取类的注解信息</span></span><br><span class="line">            Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span>(Annotation a : annotations)&#123;</span><br><span class="line">                System.out.println(a); <span class="comment">// @annotation.stTable(value=st_table)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过指定注解来获得注解信息</span></span><br><span class="line">            stTable a = (stTable) clazz.getAnnotation(stTable.class);</span><br><span class="line">            System.out.println(a); <span class="comment">// @annotation.stTable(value=st_table)</span></span><br><span class="line">            System.out.println(a.value()); <span class="comment">// st_table</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取属性字段的注解信息</span></span><br><span class="line">            <span class="comment">//现获取属性 name</span></span><br><span class="line">            Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            stField sname = name.getAnnotation(stField.class);</span><br><span class="line">            System.out.println(sname); <span class="comment">//  @annotation.stField(colunName=st_name, type=varchar, length=10)</span></span><br><span class="line">            System.out.println(sname.colunName() + <span class="string">&quot;---&quot;</span> + sname.type() + <span class="string">&quot;---&quot;</span> + sname.length()); <span class="comment">//  st_name---varchar---10</span></span><br><span class="line">            <span class="comment">// 获取属性id</span></span><br><span class="line">            Field id = clazz.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            stField sid = id.getAnnotation(stField.class);</span><br><span class="line">            <span class="comment">// @annotation.stField(colunName=id, type=int, length=16)</span></span><br><span class="line">            System.out.println(sid); </span><br><span class="line">            System.out.println(sid.colunName() + <span class="string">&quot;---&quot;</span> + sid.type() + <span class="string">&quot;---&quot;</span> + sid.length()); <span class="comment">//   id---int---16</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//可以拼接ddl语句，使用jdbc执行。</span></span><br><span class="line">            String sql = <span class="string">&quot;CREATE TABLE IF NOT EXISTS\t&quot;</span> +a.value()+<span class="string">&quot;(\n&quot;</span> +</span><br><span class="line">                      sid.colunName()+<span class="string">&quot;\t&quot;</span>+sid.type()+<span class="string">&quot;(&quot;</span>+sid.length()+<span class="string">&quot;)\tNOT NULL\n&quot;</span> +</span><br><span class="line">                    sname.colunName()+<span class="string">&quot;\t&quot;</span>+sname.type()+<span class="string">&quot;(&quot;</span>+sname.length()+<span class="string">&quot;)\n&quot;</span>+</span><br><span class="line">                    <span class="string">&quot;);&quot;</span>;</span><br><span class="line">            System.out.println(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            CREATE TABLE IF NOT EXISTS	st_table(</span></span><br><span class="line"><span class="comment">                id	int(16)	NOT NULL</span></span><br><span class="line"><span class="comment">                st_name	varchar(10)</span></span><br><span class="line"><span class="comment">                );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>@interface</code> 用来声明 <code>Annotation</code>。</p>
<p><code>@Documented</code> 用来表示该 <code>Annotation</code> 是否会出现在 <code>javadoc</code> 。</p>
<p><code>@Target</code> 用来指定 <code>Annotation</code> 的类型。</p>
<p><code>@Retention</code> 用来指定 <code>Annotation</code> 的策略。 </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet详解</title>
    <url>/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Servlet-概述"><a href="#Servlet-概述" class="headerlink" title="Servlet 概述"></a>Servlet 概述</h1><p>狭义的 <code>Servlet</code> 是指 Java 语言实现的一个接口，广义的 <code>Servlet</code> 是指 任何实现了这个 Servlet 接口的类，一般情况下，人们将 <code>Servlet</code> 理解为后者。 <code>Servlet</code> 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服 务器。</p>
<p>Servlet的特点是：运行在支持java的应用服务器上， 并且<code>Servlet</code>的实现遵循了服务器能够识别的规则，也就是服务器会自动 的根据请求调用对应的<code>servlet</code>进行请求处理。</p>
<h1 id="在idea中创建一个Web应用"><a href="#在idea中创建一个Web应用" class="headerlink" title="在idea中创建一个Web应用"></a>在idea中创建一个Web应用</h1><ol>
<li> new–&gt;project–&gt;web Application</li>
</ol>
   <img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/1584079962371.png" alt="1584079962371" style="zoom:80%;">

<ol start="2">
<li>填上项目名称</li>
</ol>
<img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/1584080030391.png" class width="1584080030391">

<ol start="3">
<li><p>可以看到idea的文件目录， 注意和Myeclipse区分</p>
<img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/1584080102181.png" alt="1584080102181" style="zoom:100%;"></li>
<li><p>创建classes和lib文件</p>
<img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/1584080291667.png" alt="1584080291667" style="zoom:80%;">

<p>classes 存放编译好的class文件，lib存放所需要的jar包。所以要进一步配置编译目录和lib目录。</p>
<img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/1584080420535.png" alt="1584080420535" style="zoom:80%;">

<img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/1584080478170.png" alt="1584080478170" style="zoom:80%;">

<img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/1584080537811.png" alt="1584080537811" style="zoom:80%;"></li>
<li><p>配置tomcat服务器</p>
</li>
</ol>
<img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/1584080607561.png" alt="1584080607561" style="zoom:80%;">

<hr>
<h1 id="创建一个Servlet"><a href="#创建一个Servlet" class="headerlink" title="创建一个Servlet"></a>创建一个Servlet</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>编写java类，继承<code>HttpServlet</code>类</p>
</li>
<li><p> 重写<code>doGet</code>和<code>doPost</code>方法</p>
</li>
<li><p><code>Servlet</code>程序交给tomcat服务器运行！！</p>
<p>​    3.1 <code>servlet</code>程序的class码拷贝到<code>WEB-INF/classes</code>目录</p>
<p>​    3.2 在<code>web.xml</code>文件中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置一个servlet --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- servlet的配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!-- servlet的类全名： 包名+简单类名 --&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.first.servlet.FirstServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- servlet的映射配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!-- servlet的映射路径（访问servlet的名称） --&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/first<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="运行一个servlet"><a href="#运行一个servlet" class="headerlink" title="运行一个servlet"></a>运行一个servlet</h2><p>首次访问 URL： <a href="http://localhost:8080/web/first">http://localhost:8080/web/first</a></p>
<p>tomcat服务器启动时，首先加载<code>webapps</code>中的每个web应用的web.xml配置文件。</p>
<p><strong>http://</strong> :  http协议</p>
<p><strong>localhost</strong>:  到本地的<code>hosts</code>文件中查找是否存在该域名对应的IP地址127.0.0.1</p>
<p><strong>8080</strong>：  找到tomcat服务器</p>
<p><strong>/web</strong>：   在tomcat的webapps目录下找 web的目录</p>
<p><strong>/first</strong>  :资源名称。</p>
<blockquote>
<p> 1）在web的<code>web.xml</code>中查找是否有匹配的<code>url-pattern</code>的内容（/first）</p>
<p>2）如果找到匹配的<code>url-pattern</code>,则使用当前<code>servlet-name</code>的名称到<code>web.xml</code>文件中查询是否相同名称的<code>servlet</code>配置</p>
<p>3）如果找到，则取出对应的<code>servlet</code>配置信息中的<code>servlet-class</code>内容：</p>
<p>​        字符串： <strong>com.first.servlet.FirstServlet</strong></p>
</blockquote>
<p><strong>通过反射：</strong></p>
<pre><code>    1.   构造`FirstServlet`的对象
       2.   然后调用`FirstServlet`里面的方法
</code></pre>
<hr>
<h2 id="Servlet的映射路径"><a href="#Servlet的映射路径" class="headerlink" title="Servlet的映射路径"></a>Servlet的映射路径</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>FirstServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!-- servlet的映射路径（访问servlet的名称） --&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/first<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h3><table>
<thead>
<tr>
<th align="center">url-pattern</th>
<th align="center">浏览器输入</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/first</td>
<td align="center"><a href="http://localhost:8080/web/first">http://localhost:8080/web/first</a></td>
</tr>
<tr>
<td align="center">/hello/first</td>
<td align="center"><a href="http://localhost:8080/web/hello/first">http://localhost:8080/web/hello/first</a></td>
</tr>
</tbody></table>
<h3 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h3><p>*代表通配符</p>
<table>
<thead>
<tr>
<th align="center">url-pattern</th>
<th align="center">浏览器输入</th>
</tr>
</thead>
<tbody><tr>
<td align="center">/*</td>
<td align="center"><a href="http://localhost:8080/web/**%E4%BB%BB%E6%84%8F%E8%B7%AF%E5%BE%84">http://localhost:8080/web/**任意路径</a>**</td>
</tr>
<tr>
<td align="center">/hello/*</td>
<td align="center"><a href="http://localhost:8080/web/hello/**%E4%BB%BB%E6%84%8F%E8%B7%AF%E5%BE%84">http://localhost:8080/web/hello/**任意路径</a>**</td>
</tr>
<tr>
<td align="center">*.do</td>
<td align="center"><a href="http://localhost:8080/web/**%E4%BB%BB%E6%84%8F%E8%B7%AF%E5%BE%84.do">http://localhost:8080/web/**任意路径.do</a>**</td>
</tr>
<tr>
<td align="center">*.action</td>
<td align="center"><a href="http://localhost:8080/web/**%E4%BB%BB%E6%84%8F%E8%B7%AF%E5%BE%84.action">http://localhost:8080/web/**任意路径.action</a>**</td>
</tr>
<tr>
<td align="center">*.html</td>
<td align="center"><a href="http://localhost:8080/web/**%E4%BB%BB%E6%84%8F%E8%B7%AF%E5%BE%84.html">http://localhost:8080/web/**任意路径.html</a>**    【伪静态】</td>
</tr>
</tbody></table>
<blockquote>
<p>注意： </p>
<ol>
<li>url-pattern要么以 / 开头，要么以*开头。 例如， hello是非法路径。</li>
<li>不能同时使用两种模糊匹配，例如 /hello/*.do是非法路径</li>
<li>当有输入的URL有多个servlet同时被匹配的情况下：<ol>
<li> 精确匹配优先。（长的最像优先被匹配）</li>
<li> 以后缀名结尾的模糊<code>url-pattern</code>优先级最低！！！</li>
</ol>
</li>
</ol>
</blockquote>
<hr>
<h2 id="Servlet-的缺省路径"><a href="#Servlet-的缺省路径" class="headerlink" title="Servlet 的缺省路径"></a>Servlet 的缺省路径</h2><p>servlet的缺省路径（<url-pattern>/</url-pattern>）是在tomcat服务器内置的一个路径。该路径对应的是一个<strong>DefaultServlet</strong>（缺省Servlet）。这个缺省的Servlet的作用是用于解析web应用的静态资源文件。</p>
<p>比如： URL输入<a href="http://localhost:8080/web/index.html">http://localhost:8080/web/index.html</a> 如何读取文件？</p>
<p>​          1）到当前web应用下的<code>web.xml</code>文件查找是否有匹配的<code>url-pattern</code>。</p>
<p>​          2）如果没有匹配的<code>url-pattern</code>，则交给tomcat的内置的<code>DefaultServlet</code>处理</p>
<p>​          3）DefaultServlet程序到web应用的<strong>根目录</strong>下查找是存在一个名称为<code>index.html</code>的静态文件。</p>
<p>​          4）如果找到该文件，则读取该文件内容，返回给浏览器。</p>
<p>​          5）如果找不到该文件，则返回<strong>404</strong>错误页面。</p>
<p>所以，先找动态的资源，再找静态的资源。</p>
<hr>
<h1 id="Servlet的生命周期【重要！！！】"><a href="#Servlet的生命周期【重要！！！】" class="headerlink" title="Servlet的生命周期【重要！！！】"></a>Servlet的生命周期【重要！！！】</h1><p><code>servlet</code>类对象什么时候创建，什么时候调用什么方法，什么时候销毁。</p>
<p><code>Servlet</code>程序的生命周期由tomcat服务器控制的！！！！   </p>
<blockquote>
<p>Servlet的生命周期：</p>
<p>1、从第一次调用到服务器关闭。 </p>
<p>2、如果Servlet在<code>web.xml</code>中配置了<strong>load-on-startup</strong>，生命周期为 从服务器启动到服务器            关闭  【Servlet 的自动加载】</p>
</blockquote>
<h2 id="Servlet的生命周期方法"><a href="#Servlet的生命周期方法" class="headerlink" title="Servlet的生命周期方法"></a>Servlet的生命周期方法</h2><ol>
<li><strong>构造方法</strong>： 创建<code>servlet</code>对象的时候调用。默认情况下，第一次访问<code>servlet</code>的时候创建<code>servlet</code>对象 只调用1次。<strong>证明servlet对象在tomcat是单实例的。</strong></li>
<li><code>init</code>方法： 创建完<code>servlet</code>对象的时候调用。<strong>只调用1次。</strong></li>
<li><code>service</code>方法： 每次发出请求时调用。调用<strong>n次</strong>。</li>
<li><code>destroy</code>方法： 销毁<code>servlet</code>对象的时候调用。停止服务器或者重新部署web应用时销毁servlet对象。<strong>只调用1次。</strong></li>
</ol>
<h2 id="servlet的生命周期过程"><a href="#servlet的生命周期过程" class="headerlink" title="servlet的生命周期过程"></a>servlet的生命周期过程</h2><img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/servlet.jpg" alt="1584083004335" style="zoom:100%;">

<p>Servlet对象的生命周期是交给Tomcat服务器来管理的。在tomcat服务器内部代码执行过程：</p>
<ol>
<li><p>服务器启动的时候， 加载web.xml文件，通过xml文件的解析，在<servlet-mapping>下得到servlet-class的内容，<strong>字符串</strong>：<code>com.first.servlet.FirstServlet</code>。</servlet-mapping></p>
</li>
<li><p>通过反射机制俩构造FirstServlet对象：</p>
<blockquote>
<ol>
<li><p>得到字节码对象</p>
<p>Class clazz = Class.forName(“com.first.servlet.FirstServlet”)；</p>
</li>
<li><p>调用无参数的构造方法来构造对象</p>
<p>Object obj = clazz.clazz.getDeclaredConstructor().newInstance();    </p>
<p><strong>【servlet的构造方法被调用】</strong></p>
</li>
</ol>
</blockquote>
</li>
<li><p>创建ServletConfig对象，再通过反射调用init方法</p>
<blockquote>
<ol>
<li><p>得到方法对象</p>
<p>Method init = clazz.getDeclaredMethod(“init”, ServletConfig.class);</p>
</li>
<li><p>调用方法</p>
<p>init.invoke(obj, servletConfig);</p>
<p><strong>【servlet 的 init方法被调用】</strong></p>
</li>
</ol>
</blockquote>
<p>4.创建request对象和response对象， 通过反射调用service方法</p>
<blockquote>
<ol>
<li><p>得到方法对象</p>
<p>Method service = clazz.getDeclaredMethod(“service”, HttpServletRequest.class, HttpServletResponse.class);</p>
</li>
<li><p>调用方法</p>
<p>service.invoke(obj, request, response);</p>
<p><strong>【servlet 的 service方法被调用】</strong></p>
</li>
</ol>
</blockquote>
<p>5.当tomcat服务器停止或者web应用重新部署，通过反射调用destroy方法</p>
<blockquote>
<ol>
<li><p>得到方法对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method destroy = clazz.getDeclaredMethod(<span class="string">&quot;destroy&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>调用</p>
<p>destroy.invoke();</p>
<p><strong>【servlet 的 destroy方法被调用】</strong></p>
</li>
</ol>
</blockquote>
<p>下面是一个时序图，完整地描述了<code>Servlet</code>的生命周期</p>
<img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/ServletLife.png" alt="1584083004335" style="zoom:100%;"></li>
</ol>
<h2 id="Servlet的自动加载"><a href="#Servlet的自动加载" class="headerlink" title="Servlet的自动加载"></a>Servlet的自动加载</h2><p>​        默认情况下，第一次访问servlet的时候创建servlet对象。如果servlet的构造方法或init方法中执行了比较多的逻辑代码，那么导致用户第一次访问sevrlet的时候比较慢。</p>
<p>​        可以改变Servlet创建的时机：<strong>提前到加载web应用的时候</strong></p>
<p>​        在Servlet的配置信息中，加上<load-on-startup>即可。</load-on-startup></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletLife<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.first.servlet.ServletLife<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 让servlet对象自动加载 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span>  注意： 整数值越大，创建优先级越低！！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动tomcat的时候，可以看到以下输出信息：</p>
<img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/1584083004335.png" alt="1584083004335" style="zoom:100%;">



<hr>
<h1 id="有参的init方法和无参的init方法"><a href="#有参的init方法和无参的init方法" class="headerlink" title="有参的init方法和无参的init方法"></a>有参的init方法和无参的init方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参数的init和无参的init方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;无参数的init方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有参数的init方法：是servlet的生命周期方法，一定会被tomcat服务器调用</p>
<p>无参数的init方法：该方法是servlet的编写初始化代码的方法。是Sun公司设计出来专门给开发者进行覆盖，然后在里面编写servlet的初始逻辑代码的方法。</p>
<p> <strong>注意：如果要编写初始代码，不需要覆盖有参数的init方法</strong></p>
<p>可以看servlet的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Servlet的多线程并发问题"><a href="#Servlet的多线程并发问题" class="headerlink" title="Servlet的多线程并发问题"></a>Servlet的多线程并发问题</h1><p>Servlet对象在tomcat服务器是单实例多线程的 。</p>
<img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/1584090471897.png" alt="1584090471897" style="zoom:100%;">

<p>因为servlet是多线程的，所以当多个servlet的线程同时访问了servlet的共享数据，如成员变量，可能会引发线程安全问题。</p>
<p>解决办法：</p>
<blockquote>
<p>1）把使用到共享数据的代码块进行同步（使用<code>synchronized</code>关键字进行同步）</p>
<p> 2）建议在servlet类中尽量不要使用成员变量。如果确实要使用成员，必须同步。而且尽量缩小同步代码块的范围。（哪里使用到了成员变量，就同步哪里！！），以避免因为同步而导致并发效率降低。</p>
</blockquote>
<hr>
<h1 id="ServletConfig对象"><a href="#ServletConfig对象" class="headerlink" title="ServletConfig对象"></a>ServletConfig对象</h1><p>Servlet的配置对象，是一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>,</span></span><br><span class="line"><span class="class">        <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><code>ServletConfig</code>对象: 主要是用于加载servlet的初始化参数。在一个web应用可以存在多个<code>ServletConfig</code>对象（<strong>一个Servlet对应一个ServletConfig对象</strong>）。</p>
<h2 id="对象的创建与获取"><a href="#对象的创建与获取" class="headerlink" title="对象的创建与获取"></a>对象的创建与获取</h2><p><strong>创建时机</strong>： 在创建完<code>servlet</code>对象之后，在调用<code>init</code>方法之前创建。</p>
<p><strong>获取对象</strong>： 直接从有参数的<code>init</code>方法中得到。</p>
<h2 id="Servlet的初始化参数配置"><a href="#Servlet的初始化参数配置" class="headerlink" title="Servlet的初始化参数配置"></a>Servlet的初始化参数配置</h2><p>在web.xml的<servlet></servlet>中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>config<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.first.servlet.config.ConfigDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置初始化参数 ,这些参数会封装ServletConfig对象中在init方法初始化 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>path<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>f:/a.txt<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>config<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/cfg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意： <code>servlet</code>的参数只能由当前的这个<code>sevlet</code>获取！！！！</p>
<p>ServletConfig的API：</p>
<blockquote>
<p>java.lang.String getInitParameter(java.lang.String name) 根据参数名获取参数值</p>
<p>java.util.Enumeration getInitParameterNames()  获取所有参数</p>
<p>ServletContext getServletContext()   得到servlet上下文对象</p>
<p>java.lang.String getServletName()    得到servlet的名称</p>
</blockquote>
<p>其实在HttpServlet所继承的GenericServlet类中，直接提供了上述的API，可以直接通过this关键字调用上面的方法，而不需要先获取ServletConfig对象。</p>
<img src="/2020/03/13/Servlet%E8%AF%A6%E8%A7%A3/1584152217374.png" alt="1584152217374" style="zoom:100%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-14 9:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取Servlet的初始化的参数</span></span><br><span class="line"><span class="comment">//        String path = config.getInitParameter(&quot;path&quot;);</span></span><br><span class="line">        String path1 = <span class="keyword">this</span>.getServletConfig().getInitParameter(<span class="string">&quot;path&quot;</span>);  <span class="comment">// 也可以</span></span><br><span class="line">        String path = <span class="keyword">this</span>.getInitParameter(<span class="string">&quot;path&quot;</span>); <span class="comment">//获取初始化参数</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">        String str= <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            String gbk = <span class="keyword">new</span> String(str.getBytes(<span class="string">&quot;GBK&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(gbk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String servletName = <span class="keyword">this</span>.getServletName(); <span class="comment">//当前servlet的名字，在web.xml 中的&lt;servlet-name&gt;&lt;/servlet-name&gt;中的名字</span></span><br><span class="line">        System.out.println(servletName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEMPDIR = <span class="string">&quot;javax.servlet.context.tempdir&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> Servlet 3.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ORDERED_LIBS = <span class="string">&quot;javax.servlet.context.orderedLibs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the main path associated with this context.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The main context path</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> Servlet 2.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContextPath</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p><code>ServletContext</code>对象 ,叫做Servlet的上下文对象。表示一个当前的web应用环境。<strong>一个web应用中只有一个<code>ServletContext</code>对象。</strong></p>
<p>注意与ServletConfig对象区分，一个Servlet对应一个ServletConfig对象，一个web应用里面可以有多个Servlet，但是一个web应用程序只能有一个ServletContext对象。可以将web.xml文件的整个信息封装到ServletContext对象。</p>
<h2 id="对象创建和得到"><a href="#对象创建和得到" class="headerlink" title="对象创建和得到"></a>对象创建和得到</h2><p>创建时机：加载<code>web</code>应用时创建<code>ServletContext</code>对象。</p>
<p>得到对象： 从<code>ServletConfig</code>对象的<code>getServletContext</code>方法得到</p>
<p>那么问题来了，为啥要从ServletConfig对象中得到ServletContext对象呢？因为ServletContext对象是在tomcat服务器启动的时候就已经创建好了，而ServletConfig对象实在Servlet构建之后，调用init方法之前创建的。所以ServletContext是优先于ServletConfig对象创建的。</p>
<p>如果我们自己设计获取ServletContext对象，可能会这样设计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建ServletConfig对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">( ServletConfig config, ServletContext context )</span></span>&#123;  <span class="comment">//多了一个参数</span></span><br><span class="line">	得到ServletConfig对象;</span><br><span class="line">	得到ServletContext对象;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的设计会多了一个参数，因为<code>ServletContext</code>是整个web程序的全局的对象，而每个<code>Servlet</code>各自有自己的<code>ServletConfig</code>对象，如果每个<code>Servlet</code>都要这样这样传递<code>ServletContext</code>对象的话，未免过于麻烦，所以，我觉得<code>sun</code>公司设计的时候应该是如下设计的：</p>
<ol>
<li><p>首先创建<code>ServletContext</code>对象 : <code>ServletContext = context = new ServletContext();</code>   这是在服务器启动的时候就创建了。</p>
</li>
<li><p>创建ServletConfig对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletConfig config = <span class="keyword">new</span> ServletConfig();</span><br><span class="line">config.setServletContext(context); <span class="comment">// 设置ServletContext</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServletConfig</span></span>&#123;</span><br><span class="line">    ServletContext context;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContxt</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> contxt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">( ServletConfig config )</span></span>&#123;</span><br><span class="line">	得到ServletConfig对象</span><br><span class="line">	从ServletConfig对象中得到ServletContext对象</span><br><span class="line">	SerlvetContext context = config.getServletContext();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="ServletContext对象的核心API-作用"><a href="#ServletContext对象的核心API-作用" class="headerlink" title="ServletContext对象的核心API(作用)"></a>ServletContext对象的核心API(作用)</h2><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>String getContextPath()</td>
<td><strong>得到当前web应用的路径</strong></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>String getInitParameter(String name)</td>
<td><strong>得到web应用的初始化参数</strong></td>
</tr>
<tr>
<td>Enumeration getInitParameterNames()</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>void setAttribute(String name, Object object)</td>
<td><strong>域对象有关的方法</strong></td>
</tr>
<tr>
<td>Object getAttribute(String name)</td>
<td></td>
</tr>
<tr>
<td>removeAttribute(String name)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>RequestDispatcher getRequestDispatcher(String path)</td>
<td><strong>转发（类似于重定向）</strong></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>String getRealPath(String path)</td>
<td><strong>得到web应用的资源文件</strong></td>
</tr>
<tr>
<td>InputStream getResourceAsStream(String path)</td>
<td></td>
</tr>
</tbody></table>
<h3 id="得到当前web应用的路径"><a href="#得到当前web应用的路径" class="headerlink" title="得到当前web应用的路径"></a><strong>得到当前web应用的路径</strong></h3><p>String getContextPath()： 通常在请求重定向的时候用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到ServletContext对象</span></span><br><span class="line">   ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">   <span class="comment">// 得到web路径</span></span><br><span class="line">   String contextPath = servletContext.getContextPath();</span><br><span class="line"></span><br><span class="line">   System.out.println(contextPath);</span><br><span class="line"></span><br><span class="line">   resp.sendRedirect(contextPath+<span class="string">&quot;/testMethod.html&quot;</span>); <span class="comment">// 自动找到当前运行的web目录</span></span><br></pre></td></tr></table></figure>

<h3 id="得到web应用的初始化参数"><a href="#得到web应用的初始化参数" class="headerlink" title="得到web应用的初始化参数"></a>得到web应用的初始化参数</h3><p>在web.xml文件中配置web应用参数，是在所有<servlet></servlet>外面配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  配置web应用参数   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>school<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>BJTU<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>context<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.first.servlet.context.contextDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>context<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/text<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 得到web应用参数</span></span><br><span class="line">Enumeration&lt;String&gt; initParameterNames = servletContext.getInitParameterNames();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (initParameterNames.hasMoreElements())&#123;</span><br><span class="line">    String s = initParameterNames.nextElement();</span><br><span class="line">    String initParameter = servletContext.getInitParameter(s);</span><br><span class="line">    System.out.println(s+<span class="string">&quot;:&quot;</span>+initParameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="域对象有关的方法"><a href="#域对象有关的方法" class="headerlink" title="域对象有关的方法"></a>域对象有关的方法</h3><p><strong>域对象</strong>：作用是用于保存数据，获取数据。可以在不同的动态资源之间共享数据。  </p>
<p>两个Servlet之间共享数据可以通过传递参数的方式：</p>
<p>response.sendRedirect（“/servlet2?name=tom”）</p>
<p>然后在servlet2中调用request.getParameter(“name”)；获取数据</p>
<p>但是这种方式只能传递字符串，如果要传递一个对象呢？这就不行了，所以，域对象的作用就凸显了，<strong>域对象可以共享任何类型的数据</strong>。ServletContext就是一个域对象。</p>
<blockquote>
<p>保存数据：void setAttribute(java.lang.String name, java.lang.Object object)                      </p>
<p>获取数据： java.lang.Object getAttribute(java.lang.String name)  </p>
<p>删除数据： void removeAttribute(java.lang.String name) </p>
</blockquote>
<p><strong>ServletContext域对象：作用范围在整个web应用中有效！</strong></p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p><code>RequestDispatcher getRequestDispatcher(java.lang.String path)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 转发</span></span><br><span class="line">RequestDispatcher rd = <span class="keyword">this</span>.getServletContext().getRequestDispatcher(<span class="string">&quot;/testMethod.html&quot;</span>);</span><br><span class="line">rd.forward(req,resp);</span><br></pre></td></tr></table></figure>

<p> 1）<strong>转发</strong></p>
<p>​                    a）地址栏不会改变</p>
<p>​                    b）转发只能转发到当前web应用内的资源</p>
<p>​                    c）可以在转发过程中，可以把数据保存到<code>request</code>域对象中</p>
<p>2）<strong>重定向</strong>             </p>
<p>​                   a）地址栏会改变，变成重定向到地址。</p>
<p>​                   b）重定向可以跳转到当前web应用，或其他web应用，甚至是外部域名网站。</p>
<p>​                   c）不能在重定向的过程中把数据保存到<code>request</code>中。</p>
<blockquote>
<p>结论： 如果要使用<code>request</code>域对象进行数据共享，只能用转发技术！</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动配置原理</title>
    <url>/2020/07/14/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h1><p><code>SpringBoot</code>是<code>Spring</code>系列的延伸，Spring需要自己去配置各种属性。<code>SpringBoot</code> 的出现就是为了简化程序员的配置工作，所谓“约定大于配置”。 所以，<strong>自动配置</strong>是<code>SpringBoot</code>的核心。</p>
<p>SpringBoot能配置什么呢？</p>
<p>查看文档<a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties">common-application-properties</a> .</p>
<img src="/2020/07/14/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/1594716217592.png" class width="1594716217592">



<h1 id="创建SpringBoot项目"><a href="#创建SpringBoot项目" class="headerlink" title="创建SpringBoot项目"></a>创建SpringBoot项目</h1><p>项目目录结构：</p>
<img src="/2020/07/14/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/1594716344112.png" class width="1594716344112">

<h1 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h1><p>首先我们知道SpringBoot有一个启动类，其实也是一个配置类，其有main方法，可以直接运行。使用@SpingBootApplication注解表示它是一个配置类。</p>
<blockquote>
<p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang.springboot;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot02AutoconfigApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Springboot02AutoconfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们点击进去这个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>  <span class="comment">//开启自动配置功能</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure>

<p>我们可以看到有一个@EnableAutoConfiguration的注解，这个注解的作用就是开启自动配置功能。</p>
<img src="/2020/07/14/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/1594716754609.png" class width="1594716754609">

<p>发现里面有一个<code>@Import(AutoConfigurationImportSelector.class)</code>， 作用是给容器中带入一些组件，那么具体导入那些组件呢？我们继续查看<code>AutoConfigurationImportSelector</code>这个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>,</span></span><br><span class="line"><span class="class">		<span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="keyword">new</span> AutoConfigurationEntry();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			<span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">		&#125;</span><br><span class="line">		AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">				.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,</span><br><span class="line">				annotationMetadata);</span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="params"><span class="function">			AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			<span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">		&#125;</span><br><span class="line">		AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">		List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">		configurations = removeDuplicates(configurations);</span><br><span class="line">		Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">		checkExcludedClasses(configurations, exclusions);</span><br><span class="line">		configurations.removeAll(exclusions);</span><br><span class="line">		configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">		fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">	&#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>selectImports方法选择组件进行导入，里面调用了getAutoConfigurationEntry方法来获取哪些配置，返回的是一个AutoConfigurationEntry类， 之后转成一个字符串数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationEntry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; configurations; <span class="comment">// 配置</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; exclusions; <span class="comment">// 排除配置</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">AutoConfigurationEntry</span><span class="params">()</span> </span>&#123; <span class="comment">// 初始化空集合</span></span><br><span class="line">		<span class="keyword">this</span>.configurations = Collections.emptyList();</span><br><span class="line">		<span class="keyword">this</span>.exclusions = Collections.emptySet();</span><br><span class="line">	&#125;</span><br><span class="line">	AutoConfigurationEntry(Collection&lt;String&gt; configurations, Collection&lt;String&gt; exclusions) &#123;</span><br><span class="line">		<span class="keyword">this</span>.configurations = <span class="keyword">new</span> ArrayList&lt;&gt;(configurations);</span><br><span class="line">		<span class="keyword">this</span>.exclusions = <span class="keyword">new</span> HashSet&lt;&gt;(exclusions);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getConfigurations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.configurations;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getExclusions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.exclusions;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看一下<code>getAutoConfigurationEntry</code>这个方法的具体操作：在<code>AutoConfigurationImportSelector</code>这个类里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="params"><span class="function">		AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">		<span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">	&#125;</span><br><span class="line">	AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">	List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">	configurations = removeDuplicates(configurations);</span><br><span class="line">	Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">	checkExcludedClasses(configurations, exclusions);</span><br><span class="line">	configurations.removeAll(exclusions);</span><br><span class="line">	configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">	fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法首先调用了<code>getCandidateConfigurations</code>获取候选配置，返回的是一个List集合，然后封装成<code>AutoConfigurationEntry</code>返回。</p>
<p>所以我们还需要看一下<code>getCandidateConfigurations</code>干了啥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">				getBeanClassLoader());</span><br><span class="line">		Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">				+ <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> configurations;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">		<span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用<code>SpringFactoriesLoader.loadFactoryNames（Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader）</code>里面传入需要返回哪个自动配置类，这里调用了<code>getSpringFactoriesLoaderFactoryClass</code>， 返回的是<code>EnableAutoConfiguration.class</code>。</p>
<p>再看看SpringFactoriesLoader.loadFactoryName() 的具体细节：这个方法在<code>SpringFactoriesLoader</code>这个类里面，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">&quot;META-INF/spring.factories&quot;</span>;	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		String factoryClassName = factoryClass.getName();</span><br><span class="line">		<span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">		MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">		<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">					classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">			result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">			<span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">				URL url = urls.nextElement();</span><br><span class="line">				UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">				Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">				<span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">					String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">					<span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">						result.add(factoryClassName, factoryName.trim());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cache.put(classLoader, result);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">					FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>主要看这一段</p>
<img src="/2020/07/14/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/1594718070933.png" class width="1594718070933">

<p>首先会去加载一个配置文件，这个配置文件在类的开头声明了一个静态的常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>看一下这个配置文件是什么内容：</p>
<img src="/2020/07/14/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/1594718196754.png" class width="1594718196754">

<img src="/2020/07/14/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/1594718270182.png" class width="1594718270182">

<p>看到这里应该对大致的流程有一个清晰的了解了，<code>SpringFactoriesLoader.loadFactoryNames()</code>扫描所有<code>jar</code>包类路径下  <code>META-INF/spring.factories.</code> 把扫描到的这些文件的内容包装成<code>properties</code>对象<br>从<code>properties</code>中获取到<code>EnableAutoConfiguration.class</code>类（类名）对应的值，然后把他们添加在容器中，这些值就是上图中黄色字体部分的<code>XXXAutoConfiguration</code>。每一个自动配置类<code>XXXAutoConfiguration</code> 都是都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p>
<p>然后每一个自动配置类进行自动配置功能。</p>
<h1 id="HttpEncodingAutoConfiguration"><a href="#HttpEncodingAutoConfiguration" class="headerlink" title="HttpEncodingAutoConfiguration"></a>HttpEncodingAutoConfiguration</h1><p>以<code>HttpEncodingAutoConfiguration</code>为例解释自动配置原理</p>
<img src="/2020/07/14/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/1594718692044.png" class width="1594718692044">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HttpProperties.class)</span><span class="comment">// 启动指定类的ConfigurationProperties功能； 将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncordingProperties加入到ioc容器里面。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring底层@Conditional注解, 根据不同的条件。如果满足指定的条件，将整个配置类里面的配置生效； 判断当前应用是否是web应用，如果是，则配置类生效。</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前项目有没有这个CharacterEncodingFilter类。（这是SpringMVC中进行乱码解决的类）</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(CharacterEncodingFilter.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断配置文件中是否存在摸个配置spring.http.encoding.enabled；如果不存在，判断也是成立的（matchIfMissing = true）</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经和SpringBoot的配置文件映射了</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> HttpProperties.Encoding properties;</span><br><span class="line">	<span class="comment">// 只有一个有参构造函数的情况下， 参数的值就会从容器中拿。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpProperties properties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.properties = properties.getEncoding();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span> <span class="comment">//  给容器中添加一个组件，这个组件的某些值需要从properties中去获取</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>  <span class="comment">// //判断容器没有这个组件，没有这个才需要配置</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">		filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">		filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">		filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">		<span class="keyword">return</span> filter;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看上面详细的注释理解每个注解的功能。</p>
<p>根据当前不同的条件判断，决定这个配置类是否生效？</p>
<p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p>
<p>我们看一下properties类中内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.http&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Whether logging of (potentially sensitive) request details at DEBUG and TRACE level</span></span><br><span class="line"><span class="comment">	 * is allowed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> logRequestDetails;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * HTTP encoding properties.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Encoding encoding = <span class="keyword">new</span> Encoding();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLogRequestDetails</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.logRequestDetails;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLogRequestDetails</span><span class="params">(<span class="keyword">boolean</span> logRequestDetails)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.logRequestDetails = logRequestDetails;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Encoding <span class="title">getEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.encoding;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Configuration properties for http encoding.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Encoding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Charset of HTTP requests and responses. Added to the &quot;Content-Type&quot; header if</span></span><br><span class="line"><span class="comment">		 * not set explicitly.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> Charset charset = DEFAULT_CHARSET;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Whether to force the encoding to the configured charset on HTTP requests and</span></span><br><span class="line"><span class="comment">		 * responses.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> Boolean force;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Whether to force the encoding to the configured charset on HTTP requests.</span></span><br><span class="line"><span class="comment">		 * Defaults to true when &quot;force&quot; has not been specified.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> Boolean forceRequest;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Whether to force the encoding to the configured charset on HTTP responses.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> Boolean forceResponse;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Locale in which to encode mapping.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> Map&lt;Locale, Charset&gt; mapping;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Charset <span class="title">getCharset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.charset;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharset</span><span class="params">(Charset charset)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.charset = charset;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isForce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Boolean.TRUE.equals(<span class="keyword">this</span>.force);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setForce</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.force = force;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isForceRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Boolean.TRUE.equals(<span class="keyword">this</span>.forceRequest);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setForceRequest</span><span class="params">(<span class="keyword">boolean</span> forceRequest)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.forceRequest = forceRequest;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isForceResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Boolean.TRUE.equals(<span class="keyword">this</span>.forceResponse);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setForceResponse</span><span class="params">(<span class="keyword">boolean</span> forceResponse)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.forceResponse = forceResponse;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Map&lt;Locale, Charset&gt; <span class="title">getMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.mapping;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMapping</span><span class="params">(Map&lt;Locale, Charset&gt; mapping)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.mapping = mapping;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldForce</span><span class="params">(Type type)</span> </span>&#123;</span><br><span class="line">			Boolean force = (type != Type.REQUEST) ? <span class="keyword">this</span>.forceResponse : <span class="keyword">this</span>.forceRequest;</span><br><span class="line">			<span class="keyword">if</span> (force == <span class="keyword">null</span>) &#123;</span><br><span class="line">				force = <span class="keyword">this</span>.force;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (force == <span class="keyword">null</span>) &#123;</span><br><span class="line">				force = (type == Type.REQUEST);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> force;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			REQUEST, RESPONSE</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>里面包括了可以配置的所有属性。</p>
<p>所有在配置文件中能配置的属性都是封装在<code>xxxxProperties</code>类中，配置文件能配置什么就可以参照某个功能对应的这个属性类。</p>
<h1 id="Conditional派生注解"><a href="#Conditional派生注解" class="headerlink" title="@Conditional派生注解"></a>@Conditional派生注解</h1><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<table>
<thead>
<tr>
<th>@Conditional扩展注解</th>
<th>作用（判断是否满足当前指定条件）</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnJava</td>
<td>系统的java版本是否符合要求</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足SpEL表达式指定</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>系统中有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>系统中没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定的属性是否有指定的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定资源文件</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前是web环境</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前不是web环境</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody></table>
<p><strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p>我们怎么知道哪些自动配置类生效；</p>
<p>**==我们可以通过启用  debug=true属性；来让控制台打印自动配置报告==**，这样我们就可以很方便的知道哪些自动配置类生效；</p>
<img src="/2020/07/14/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/1594733266492.png" class width="1594733266492">



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    <strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p>
<p>​    <strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p>
<p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p>
<p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p>
<p><code>xxxxAutoConfigurartion</code>：自动配置类；</p>
<p>给容器中添加组件</p>
<p><code>xxxxProperties</code>:封装配置文件中相关属性；</p>
<p><strong>spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。</strong></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Zero-Shot Video Object Segmentation via Attentive Graph Neural Networks-ICCV2019</title>
    <url>/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/</url>
    <content><![CDATA[<h1 id="Zero-Shot-Video-Object-Segmentation-via-Attentive-Graph-Neural-Networks（ICCV2019）"><a href="#Zero-Shot-Video-Object-Segmentation-via-Attentive-Graph-Neural-Networks（ICCV2019）" class="headerlink" title="Zero-Shot Video Object Segmentation via Attentive Graph Neural Networks（ICCV2019）"></a>Zero-Shot Video Object Segmentation via Attentive Graph Neural Networks（ICCV2019）</h1><p>  Wenguan Wang1∗,  Xiankai Lu1∗,  Jianbing Shen1y,  David Crandall2,  Ling Shao1<br>       Inception Institute of Artificial Intelligence,   UAE  Indiana University, USA  </p>
<h1 id="通过图注意力神经网络的Zero-Shot视频目标分割"><a href="#通过图注意力神经网络的Zero-Shot视频目标分割" class="headerlink" title="通过图注意力神经网络的Zero-Shot视频目标分割"></a>通过图注意力神经网络的Zero-Shot视频目标分割</h1><h2 id="代码：-https-github-com-Castile-AGNNForVOS"><a href="#代码：-https-github-com-Castile-AGNNForVOS" class="headerlink" title="代码：  https://github.com/Castile/AGNNForVOS"></a>代码：  <a href="https://github.com/Castile/AGNNForVOS">https://github.com/Castile/AGNNForVOS</a></h2><h1 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h1><p>​        提出了一种基于图注意力神经网络的用于Zero-Shot的视频目标分割算法。 AGNN将此任务重新定义为在图上进行迭代信息融合的过程 。 具体来说，AGNN构建一个全连通图，有效地将帧表示为节点，任意帧对之间的关系表示为边。 潜在的两两关系由一个可微分的注意机制来描述。通过参数化消息传递，AGNN能够有效地捕获和挖掘视频帧之间更丰富、更高阶的关系，从而更全面地理解视频内容，更准确地估计前景。大量的实验验证了AGNN能够学习视频帧或相关图像之间潜在的语义或者外观关系，并找出共同的目标。【基于全局的视角】  </p>
<hr>
<h1 id="二、-目前的方法"><a href="#二、-目前的方法" class="headerlink" title="二、 目前的方法"></a>二、 目前的方法</h1><p>​        基于深度学习的方法需要大量的训练数据，利用<strong>双流网络</strong>来结合局部信息和外观信息，使用光流来对连续两帧进行运动的建模，使用RNN对时序建模。但是它们普遍存在两个<strong>局限性</strong>。首先，它们主要关注连续帧之间的局部成对或顺序关系，而忽略了帧之间普遍存在的高阶关系(因为来自同一视频的帧通常是相关的)。其次，由于他们没有充分利用丰富的关系，他们不能完全捕捉视频内容，因此对前景的估计效果很差。从另一个角度来看，由于视频对象通常存在底层对象遮挡、尺度变化大、外观变化大，仅考虑视频中连续关系或局部成对关系时，很难正确推断前景。</p>
<p>Zero-Shot参考：《  <a href="https://arxiv.org/pdf/1903.05612">Rvos: End to-end recurrent network for video object segmentation</a>  》</p>
<p> 采用双流网络结合局部运动和外观信息，采用RNN逐帧建模 ：</p>
<ol>
<li>Segflow: Joint learning for video object segmentation and optical flow. In ICCV, 2017  </li>
<li>Fusionseg: Learning to combine motion and appearance for fully automatic segmention of generic objects in videos. In CVPR,2017.</li>
<li> Learning video object segmentation with visual memory. In ICCV, 2017.  </li>
<li> Unsupervised video object segmentation with motion-based bilateral networks. In ECCV, 2018.  </li>
<li>  Pyramid dilated deeper convlstm for video salient object detection. In ECCV, 2018  </li>
</ol>
<hr>
<h2 id="1-Zero-Shot-solution"><a href="#1-Zero-Shot-solution" class="headerlink" title="1. Zero-Shot solution"></a>1. Zero-Shot solution</h2><ol>
<li><p>Learning to segment moving objects in videos. In CVPR, 2015 ： 设计了一种基于多层感知的运动目标检测系统</p>
</li>
<li><p><strong>Fusionseg</strong>: Learning to combine motion and appearance for fully automatic segmention of generic objects in videos. In CVPR,2017. ： </p>
</li>
<li><p><strong>Learning video object segmentation with visual memory. In <em>ICCV</em>, 2017.</strong> </p>
</li>
<li><p>Segflow: Joint learning for video object segmentation and optical flow. In <em>ICCV</em>, 2017</p>
</li>
<li><p><strong>Instance embedding transfer to unsupervised video object segmentation. In <em>CVPR</em>, 2018.</strong> ： 整合深度学习的实例嵌入和运动显著性来提高性能。</p>
</li>
<li><p><strong>Unsupervised video object segmentation with motion-based bilateral networks. In <em>ECCV</em>, 2018.</strong></p>
</li>
<li><p>Flow guided recurrent neural encoder for video salient object detection. In <em>CVPR</em>, 2018.</p>
</li>
<li><p><strong>See more, know more: Unsupervised video object segmentation with co-attention Siamese networks. In <em>CVPR</em>, 2019.</strong></p>
</li>
<li><p>The graph neural network model. <em>IEEE TNNLS</em>, 20(1):61–80, 2009</p>
</li>
<li><p>Neural message passing for quantum chemistry. In <em>ICML</em>, 2017</p>
</li>
</ol>
<hr>
<h2 id="2-基于FCN的："><a href="#2-基于FCN的：" class="headerlink" title="2. 基于FCN的："></a>2. 基于FCN的：</h2><ol>
<li><p>Triply supervised decoder networks for joint detection and segmentation. In <em>CVPR</em>, 2019</p>
</li>
<li><p>Fully convolutional networks for semantic segmentation. In <em>CVPR</em>, 2015.</p>
</li>
<li><p>Ranet: Ranking attention network for fast video object segmentation. In <em>ICCV</em>, 2019.</p>
</li>
</ol>
<hr>
<h2 id="3-双流网络来融合外观信息和运动信息"><a href="#3-双流网络来融合外观信息和运动信息" class="headerlink" title="3. 双流网络来融合外观信息和运动信息"></a>3. 双流网络来融合外观信息和运动信息</h2><ol>
<li><p>Flow guided recurrent neural encoder for video salient object detection. In <em>CVPR</em>, 2018.</p>
</li>
<li><p><strong>Fusionseg: Learning to combine motion and appearance for fully automatic segmention of generic objects in videos. In <em>CVPR</em>, 2017.</strong></p>
</li>
<li><p>Segflow: Joint learning for video object segmentation and optical flow. In <em>ICCV</em>, 2017</p>
</li>
</ol>
<hr>
<h1 id="三、-提出的方法-ZVOS"><a href="#三、-提出的方法-ZVOS" class="headerlink" title="三、 提出的方法-ZVOS"></a>三、 提出的方法-ZVOS</h1><img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582099550176.png" alt="1582099550176" style="zoom:100%;">

<p>​        提出了一种注意力图神经网络(<code>AGNN</code>)来解决<code>Zero-Shot</code>视频目标分割(ZVOS)问题，将<code>ZVOS</code>重新定义为一种端到端的、基于消息传递的图信息融合过程(如上图b所示)。具体地，构造了一个全连通图，其中视频帧被表示为节点，两帧之间的两两关系被描述为对应节点之间的边。两帧之间的关联被一个注意力机制有效地捕获，这避免了耗时的光流估计。</p>
<hr>
<h1 id="四、-图神经网络GNN"><a href="#四、-图神经网络GNN" class="headerlink" title="四、 图神经网络GNN"></a>四、 图神经网络GNN</h1><p>​        GNN最初是在《 A new model for learning in graph domains. In IJCNN, 2005.》中提出的，并在《         The graph neural network model. IEEE TNNLS, 20(1):61–80, 2009.  》中进一步发展，以处理结构化数据之间的底层关系。</p>
<p>​        在《The graph neural network model》中，使用RNN对每个节点的状态进行建模，通过传递相邻节点的参数化消息来挖掘节点之间的底层关联。近年来，GNNs已成功应用于分子生物学、计算机视觉、机器学习、自然语言处理等诸多领域。GNNs的另一个流行趋势是将卷积体系结构泛化到任意图形结构数据上，即图卷积神经网络(graph convolution neural network, GCNN)</p>
<p>​        提出的AGNN属于前一类;它是一个基于GNN的消息传递，其中所有的节点、边和消息传递函数都由神经网络参数化。它与图上的挖掘关系的一般思想相同，但是有显著的差异。</p>
<p>​        首先，我们的AGNN在空间信息的保留方面是独特的，这与传统的全连通是不同的，而且GNNs对于逐像素预测任务至关重要。其次，为了有效地捕获两个图像帧之间的关系，我们引入了一个可微注意力机制，该机制处理相关信息并产生进一步的鉴别边缘特征。</p>
<h2 id="1-GNN-的-Survey-papers"><a href="#1-GNN-的-Survey-papers" class="headerlink" title="1. GNN 的 Survey papers"></a>1. GNN 的 Survey papers</h2><ol>
<li><p><strong>Graph Neural Networks: A Review of Methods and Applications.</strong> arxiv 2018. <a href="https://arxiv.org/pdf/1812.08434.pdf">paper</a></p>
<p><em>Jie Zhou, Ganqu Cui, Zhengyan Zhang, Cheng Yang, Zhiyuan Liu, Maosong Sun.</em></p>
</li>
<li><p><strong>A Comprehensive Survey on Graph Neural Networks.</strong> arxiv 2019. <a href="https://arxiv.org/pdf/1901.00596.pdf">paper</a></p>
<p><em>Zonghan Wu, Shirui Pan, Fengwen Chen, Guodong Long, Chengqi Zhang, Philip S. Yu.</em></p>
</li>
<li><p><strong>Deep Learning on Graphs: A Survey.</strong> arxiv 2018. <a href="https://arxiv.org/pdf/1812.04202.pdf">paper</a></p>
<p><em>Ziwei Zhang, Peng Cui, Wenwu Zhu.</em></p>
</li>
<li><p><strong>Relational Inductive Biases, Deep Learning, and Graph Networks.</strong> arxiv 2018. <a href="https://arxiv.org/pdf/1806.01261.pdf">paper</a></p>
<p><em>Battaglia, Peter W and Hamrick, Jessica B and Bapst, Victor and Sanchez-Gonzalez, Alvaro and Zambaldi, Vinicius and Malinowski, Mateusz and Tacchetti, Andrea and Raposo, David and Santoro, Adam and Faulkner, Ryan and others.</em></p>
</li>
<li><p><strong>Geometric Deep Learning: Going beyond Euclidean data.</strong> IEEE SPM 2017. <a href="https://arxiv.org/pdf/1611.08097.pdf">paper</a></p>
<p><em>Bronstein, Michael M and Bruna, Joan and LeCun, Yann and Szlam, Arthur and Vandergheynst, Pierre.</em></p>
</li>
<li><p><strong>Computational Capabilities of Graph Neural Networks.</strong> IEEE TNN 2009. <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4703190">paper</a></p>
<p><em>Scarselli, Franco and Gori, Marco and Tsoi, Ah Chung and Hagenbuchner, Markus and Monfardini, Gabriele.</em></p>
</li>
<li><p><strong>Neural Message Passing for Quantum Chemistry.</strong> ICML 2017. <a href="https://arxiv.org/pdf/1704.01212.pdf">paper</a></p>
<p><em>Gilmer, Justin and Schoenholz, Samuel S and Riley, Patrick F and Vinyals, Oriol and Dahl, George E.</em></p>
</li>
<li><p><strong>Non-local Neural Networks.</strong> CVPR 2018. <a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Wang_Non-Local_Neural_Networks_CVPR_2018_paper.pdf">paper</a></p>
<p><em>Wang, Xiaolong and Girshick, Ross and Gupta, Abhinav and He, Kaiming.</em></p>
</li>
<li><p><strong>The Graph Neural Network Model.</strong> IEEE TNN 2009. <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=4700287">paper</a></p>
<p><em>Scarselli, Franco and Gori, Marco and Tsoi, Ah Chung and Hagenbuchner, Markus and Monfardini, Gabriele.</em></p>
</li>
</ol>
<h2 id="2-GNN-的表示"><a href="#2-GNN-的表示" class="headerlink" title="2. GNN 的表示"></a>2. GNN 的表示</h2><p>参考：</p>
<ol>
<li><a href="https://blog.csdn.net/u011748542/article/details/86289511">图神经网络模型 The Graph Neural Network Model</a></li>
<li> <a href="https://zhuanlan.zhihu.com/p/76290138">https://zhuanlan.zhihu.com/p/76290138</a> </li>
</ol>
<h1 id="五、-AGNN"><a href="#五、-AGNN" class="headerlink" title="五、 AGNN"></a>五、 AGNN</h1><h2 id="1-AGNN"><a href="#1-AGNN" class="headerlink" title="1. AGNN"></a>1. AGNN</h2><blockquote>
<p>AGNN ： </p>
<ol>
<li><p>提供统一的、端到端可训练的、基于图模型的ZVOS解决方案;</p>
</li>
<li><p>通过在图上迭代传播和融合消息，有效挖掘视频内部丰富多样的高阶关系;</p>
</li>
<li><p>利用可微注意机制捕获帧对之间的相关信息。</p>
</li>
</ol>
</blockquote>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582102330688.png" alt="1582102330688" style="zoom:100%;">

<h2 id="2-符号表示"><a href="#2-符号表示" class="headerlink" title="2. 符号表示"></a>2. 符号表示</h2><p>训练和测视频序列： ${I = {I_i ∈ R^{w<em>h</em>3} }_{i = 1}^N}$     大小是 473 x 473</p>
<p>ZVOS的目的是：产生相关帧的二值分割掩码:    ${S= { S_i ∈ {0, 1}^{W*H}}_{i = 1}^N }$</p>
<p>AGNN将$I $ 表示成有向图 $G = (V, E)$:</p>
<ul>
<li>节点<code>node</code>  $v_i ∈ V$， 代表第 $i$ 帧 $I_i$  .</li>
<li> 边 <code>edge</code>  $e_{ij} = (v_i,  v_j) ∈ E$ ,  代表 $I_i 到 I_j 的关系$。</li>
</ul>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582104154693.png" alt="1582104154693" style="zoom:80%;">



<p>​        AGNN的核心思想是在G上执行K个消息传播迭代，以有效地挖掘  $ I $  各个节点（帧）间丰富的高阶关系。这有助于更好地从全局视图捕获视频内容，并获得更准确的前景估计。内注意通过关注同一节点嵌入内的所有位置来计算某个位置的响应。</p>
<p>​        然后从最后的节点状态 $ {h_i^K}_{i = 1}^N$  使用读出函数得到 分割的预测 $ \hat{S}$ </p>
<h2 id="FCN-Based-Node-Embedding"><a href="#FCN-Based-Node-Embedding" class="headerlink" title="FCN-Based Node Embedding"></a>FCN-Based Node Embedding</h2><p>我们利用DeepLabV3—一个经典的基于FCN的语义分割架构，提取有效的帧特征，作为节点表示。</p>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582105002179.png" class width="1582105002179">

<p>对于一个节点$v_i$  , 初始的 embedding $h_i^0$ 计算：<br>$$<br>h_i^0 =  V_i =  F_{DeepLab}(I_i) ∈ R^{W * H * C}<br>$$<br>  $h_i^0$是一个三维的Tensor， 保存了一些空间信息和语义信息。</p>
<h2 id="Intra-Attention-Based-Loop-Edge-Embedding"><a href="#Intra-Attention-Based-Loop-Edge-Embedding" class="headerlink" title="Intra-Attention Based Loop-Edge Embedding"></a>Intra-Attention Based Loop-Edge Embedding</h2><p>Loop Edge :  $e_{i,i} ∈ E $ ，  Loop Edge Embeddings :  $e_{i,i}^k$  用于捕捉帧内的节点表示（$ h_i^k$）之间的关系。</p>
<p>把 $e_{i,i}^k$  当做一种   <code>intra-attention mechanism</code>  ：比如（  Non-local neural networks  、Attention is all有need）。 有助于建模的长期，多层次的依赖图像区域 ，即可以捕获图像的长期依赖，属于self-attention（  Self-attention generative adversarial networks. In ICML, 2019. ）。 <code>Intra-Attention</code> 通过关注同一节点Embeddings内的所有位置来计算某个位置的响应 。</p>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582105775054.png" alt="1582105775054" style="zoom:100%;">

<blockquote>
<p>*代表卷积操作</p>
<p>W 代表可以训练的卷积核</p>
<p> α 是可学习的尺度参数 </p>
</blockquote>
<p>上面公式使得 $h_i^k$ 中每个位置的输出元素在对上下文信息进行编码的同时，也对其原始信息进行编码，从而提高了表达能力。</p>
<h2 id="Inter-Attention-Based-Line-Edge-Embedding"><a href="#Inter-Attention-Based-Line-Edge-Embedding" class="headerlink" title="Inter-Attention Based Line-Edge Embedding"></a>Inter-Attention Based Line-Edge Embedding</h2><p>line edge :  $e_{ij} ∈ E$  连接两个不同的节点。 line-edge Embedding： $e_{i,j}^k$ 用于挖掘两个节点之间的关系。</p>
<blockquote>
<p><code>inter-attention mechanism</code>  ：  <a href="https://arxiv.org/pdf/1606.00061.pdf">《Hierarchical question-image co-attention for visual question     answering. In NIPS, 2016.  》</a></p>
</blockquote>
<p>使用inter-attention mechanism来捕获两个节点之间的双向关系：</p>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582111196501.png" alt="1582111196501" style="zoom:100%;">

<p>$ e_{i,j}^k$ =  $e_{j,i}^k$   。 对于节点$v_i$来说，  $ e_{i,j}^k$  表示 输出边的特征，  $e_{j,i}^k$表示输入边的特征。 $W_c  ∈ ^{C * C}$是一个可学习的权重矩阵。</p>
<p>$h_i^k ∈ R^{(WH) * C}$和 $h_j^k ∈ R^{(WH) * C}$  被展平成矩阵的形式。 $ e_{i,j}^k$的每个元素 反映了 $h_i^k$的每一行与$h_j^k$的每一列之间的相似度。</p>
<p>所以，$ e_{i,j}^k$ 就可以看做节点$v_i$的Embedding 对节点 $v_j$的重要性， 反之亦然。</p>
<h2 id="Gated-Message-Aggregation"><a href="#Gated-Message-Aggregation" class="headerlink" title="Gated Message Aggregation"></a>Gated Message Aggregation</h2><p>在AGNN中，对于在loop-edge中传递的message，将环边嵌入向量  $e_{i,j}^{k-1}$  本身视为一个message，因为它已经包含了上下文和原始节点信息 。</p>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582112367589.png" alt="1582112367589" style="zoom:100%;">

<p>$m_{j,i}^k$   : 表示 $v_j$  传递到 $v_i$ 的message， 从而有：</p>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582112571079.png" alt="1582112571079" style="zoom:100%;">

<p>  softmax(·)  normalizes each row of the input  .</p>
<p>因此： $m_{j,i}^k$  的每一行是 $h_i^{k-1}$ 的每一行(位置)的加权组合，其中权值来自 $e_{i, j}^{k-1}$  的对应列。  通过这种方式，消息函数M(·)分配其边缘加权特征(即，消息)到邻居节点 。(  <a href="https://arxiv.org/abs/1710.10903">Graph attention networks</a>. In ICLR, 2018. )</p>
<p>然后$m_{j,i}^k$ 被重新reshape成 一个三维张量 W * H * C。</p>
<p>此外，由于某些节点由于摄像机移位或视野外而产生噪声，因此它们的message可能是无用的甚至有害的。我们应用一个可学习的 门G(·) 来评估一个消息 $m_{j,i}^k$ 的置信度 。</p>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582113546163.png" alt="1582113546163" style="zoom:100%;">

<p>$F_{GAP}(.)$  表示使用全局平均池化来对通道之间作出响应。 $\sigma$  表示 sigmoid函数。$W_g$ 和 $b_g$ 表示卷积核参数和偏置。</p>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582113956308.png" alt="1582113956308" style="zoom:100%;">

<p> 这里，门机制用于过滤噪声帧中不相关的信息。 </p>
<h2 id="ConvGRU-based-Node-State-Update-更新节点状态"><a href="#ConvGRU-based-Node-State-Update-更新节点状态" class="headerlink" title="ConvGRU based Node-State Update[更新节点状态]"></a>ConvGRU based Node-State Update[更新节点状态]</h2><p>在第k次迭代，在收集到所有相邻节点和它自身的信息（$m_i$）后 ，通过将先前的状态$h_i^{k-1}$和 它接收到的消息$m_i^k$   要一起考虑，$v_i$变成一个新的状态$h_i^k$,  为了保留$h_i^{k-1}$和$m_i^k$   的时间信息，使用ConVGRU来更新节点的状态：</p>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582114662750.png" alt="1582114662750" style="zoom:80%;">



<h2 id="Readout-Function-读出函数-预测"><a href="#Readout-Function-读出函数-预测" class="headerlink" title="Readout Function  [读出函数-预测]"></a>Readout Function  [读出函数-预测]</h2><p>在进行了K次迭代的消息传递之后，获得了每个节点$v_i$的最终状态  $ h_i^K $ ,  在读出的阶段通过 <strong>读出函数R()</strong>  获得了分割的预测图 $\hat{S} ∈ [0, 1]^{W * H}$ 。将最终状态节点$ h_i^K $  与 原始节点 $V_i$   concatenate 之后使用读出函数的到预测结果：</p>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582114987509.png" alt="1582114987509" style="zoom:100%;">

<p>再次，为了保存空间信息，将读出函数实现为一个小型的FCN网络，该网络由三个卷积层和一个<code>sigmoid</code>函数将预测归一化为[0， 1]。</p>
<p>​        在intra-attention和update function 中，卷积运算是通过1×1个卷积层来实现的。读出函数由两个3×3个卷积层组成，每个卷积层有一个1×1个卷积层。作为基于GNN模型的消息传递，这些函数在所有节点之间共享权重。此外，以上所有函数都经过精心设计，避免了干扰空间信息，这对于ZVOS是必不可少的，因为它是一个像素级的预测任务 。</p>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582114107708.png" alt="1582114107708" style="zoom:100%;">

<hr>
<h1 id="六、-网络的具体信息"><a href="#六、-网络的具体信息" class="headerlink" title="六、 网络的具体信息"></a>六、 网络的具体信息</h1><p>整个模型是端到端的。</p>
<p>特征提取： DeepLadV3的前5个卷积块 对每个节点 得到初始的状态 $V_i$ =  $h_i^0$  ∈ $R^{60 * 60 * 256}$</p>
<p>然后经过K次迭之后得到分割预测图$\hat{S} ∈ [0 ,1] ^{60 × 60}$。</p>
<h2 id="训练：损失函数"><a href="#训练：损失函数" class="headerlink" title="训练：损失函数"></a>训练：损失函数</h2><p>  binary cross entropy loss   : </p>
<img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582115711854.png" alt="1582115711854" style="zoom:100%;">

<p>值得一提的是，由于AGNN在同一时间处理多个视频帧，因此在组合候选帧数量众多的情况下，它带来了一种非常有效的训练数据扩充策略。在我们的实验中，在训练过程中，由于计算的限制，我们从训练视频集中随机选择2个视频，每个视频采样3帧(N0 = 3)。另外，我们将迭代总数设为K = 3。</p>
<h1 id="七、-结果"><a href="#七、-结果" class="headerlink" title="七、 结果"></a>七、 结果</h1><img src="/2020/02/19/Zero-Shot%20Video%20Object%20Segmentation%20via%20Attentive%20Graph%20Neural%20Networks/1582115863806.png" alt="1582115863806" style="zoom:100%;">



]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>papers</tag>
        <tag>VOS</tag>
      </tags>
  </entry>
  <entry>
    <title>POI及easyExcel操作Excel表格</title>
    <url>/2020/08/04/easyexcel/</url>
    <content><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>​        最近的一个项目需要使用到excel导入功能。比如测试用例，根据里面的案例生成自动化测试脚本文件。那么，首先就要将excel读取程序当中。</p>
<p>​        目前操作excel比较流行的就是Apache POI和阿里巴巴的easyexcel。</p>
<h1 id="Apache-POI"><a href="#Apache-POI" class="headerlink" title="Apache POI"></a>Apache POI</h1><p>​        官网： <a href="http://poi.apache.org/">http://poi.apache.org/</a> </p>
<p>​        POI，全称Apache POI，使用<strong>Java</strong>编写的免费开源的跨平台的Java API。  是创建和维护操作各种符合 Office Open XML（OOXML）标准和微软的 OLE 2 复合文档格式（OLE2）的 Java API。用它可以使用 Java 读取和创建, 修改 MS Excel 文件。而且，还可以使用 Java 读取和创建 MS Word 和 MSPowerPoint 文件。Apache POI 提供 Java 操作 Excel 解决方案（适用于 Excel97-2008）。</p>
<img src="/2020/08/04/easyexcel/1596500391853.png" class width="1596500391853">

<h2 id="POI-Excel写"><a href="#POI-Excel写" class="headerlink" title="POI-Excel写"></a>POI-Excel写</h2><blockquote>
<p>创建项目、导入依赖</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        xls(03)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        xls(07)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        日期自动化工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        junit--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>03版本与07版本的区别：03版是以xls结尾， 07版以xlsx结尾。而且03班最多支持65536行数据，而07版没有限制。</p>
</blockquote>
<p>在一个excel文件里面，有工作表、工作簿、行、列。</p>
<img src="/2020/08/04/easyexcel/1596502228004.png" class width="1596502228004">



<p>所以我们只需要找到这几个对象就可以开始操作excel了！</p>
<blockquote>
<p>03版</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String Path = <span class="string">&quot;F:\\java\\excel\\poiexcel&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite03</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个工作簿</span></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">        <span class="comment">// 创建一个工作表</span></span><br><span class="line">        Sheet sheet = workbook.createSheet(<span class="string">&quot;测试案例&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一行 第一个单元格</span></span><br><span class="line">        Row row1 = sheet.createRow(<span class="number">0</span>);</span><br><span class="line">        Cell cell11 = row1.createCell(<span class="number">0</span>);</span><br><span class="line">        cell11.setCellValue(<span class="string">&quot;案例描述&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell12 = row1.createCell(<span class="number">1</span>);</span><br><span class="line">        cell12.setCellValue(<span class="string">&quot;案例名称&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell13 = row1.createCell(<span class="number">2</span>);</span><br><span class="line">        cell13.setCellValue(<span class="string">&quot;预期结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell14 = row1.createCell(<span class="number">3</span>);</span><br><span class="line">        cell14.setCellValue(<span class="string">&quot;GIVEN&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell15 = row1.createCell(<span class="number">4</span>);</span><br><span class="line">        cell15.setCellValue(<span class="string">&quot;WHEN&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Cell cell16 = row1.createCell(<span class="number">5</span>);</span><br><span class="line">        cell16.setCellValue(<span class="string">&quot;THEN&quot;</span>);</span><br><span class="line">        <span class="comment">// 生成表</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(Path+<span class="string">&quot;测试案例.xls&quot;</span>);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        workbook.write(fileOutputStream);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;生成成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/08/04/easyexcel/1596504326450.png" class width="1596504326450">



<p>对于07版本的，只要在上面的代码，将下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个工作簿</span></span><br><span class="line">Workbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个工作簿</span></span><br><span class="line">Workbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br></pre></td></tr></table></figure>

<p>然后文件的后缀是xlsx。</p>
<h2 id="大文件写入"><a href="#大文件写入" class="headerlink" title="大文件写入"></a>大文件写入</h2><blockquote>
<p>03版： 大文件写HSSF</p>
</blockquote>
<p>缺点：最多只能处理65536行数据。否则会抛出异常。</p>
<p>优点： 过程中写入缓存，不操作磁盘，最后一次性写入磁盘，速度比较快。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite03BigData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建工作簿</span></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">        Sheet sheet = workbook.createSheet(<span class="string">&quot;bigdata03&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65536</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建一行</span></span><br><span class="line">            Row row = sheet.createRow(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">                Cell cell = row.createCell(j);</span><br><span class="line">                cell.setCellValue(<span class="string">&quot;a&quot;</span>+j);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(Path+<span class="string">&quot;bigdata03.xls&quot;</span>);</span><br><span class="line">        workbook.write(fileOutputStream);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println((<span class="keyword">double</span>)(end-begin)/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.577<br>成功！</p>
</blockquote>
<p>将65536 改为65537， 报异常</p>
<img src="/2020/08/04/easyexcel/1596505556488.png" class width="1596505556488">

<blockquote>
<p>07版： 大文件写XSSF</p>
</blockquote>
<p>缺点：写数据时速度非常慢，非常耗内存，也会发生内存溢出。如一百万条。</p>
<p>优点：可以写较大的数据量。比如说20万条。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite07BigData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建工作簿</span></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line">        Sheet sheet = workbook.createSheet(<span class="string">&quot;bigdata07&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65536</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建一行</span></span><br><span class="line">            Row row = sheet.createRow(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">                Cell cell = row.createCell(j);</span><br><span class="line">                cell.setCellValue(<span class="string">&quot;a&quot;</span>+j);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(Path+<span class="string">&quot;bigdata07.xlsx&quot;</span>);</span><br><span class="line">        workbook.write(fileOutputStream);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println((<span class="keyword">double</span>)(end-begin)/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>12.815<br>成功！</p>
</blockquote>
<p>他可以写大量的数据，没有65536 的限制，比如写100000行数据</p>
<blockquote>
<p>17.968<br>成功！</p>
</blockquote>
<img src="/2020/08/04/easyexcel/1596505802750.png" class width="1596505802750">



<p>可以看到XSSF的速度极慢！下面可以改进，通过SXSSF</p>
<blockquote>
<p>大文件写SXSSF</p>
</blockquote>
<p>优点： 可以写非常大的数据量，如一百万条，甚至更多条。写数据速度快，占用更少的内存。</p>
<p>但是在过程中会产生临时文件，需要清理临时文件。默认由100条记录被保存到内存中。如果超过这数量，则最前面的数据被写入临时文件。如果想自定义内存中数据的数量，可以使用new SXSSFWorkbook(数量)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWrite07BigDataS</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 创建工作簿</span></span><br><span class="line">       SXSSFWorkbook workbook = <span class="keyword">new</span> SXSSFWorkbook();</span><br><span class="line">       Sheet sheet = workbook.createSheet(<span class="string">&quot;bigdataSSS07&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65536</span>; i++) &#123;</span><br><span class="line">           <span class="comment">// 创建一行</span></span><br><span class="line">           Row row = sheet.createRow(i);</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">               Cell cell = row.createCell(j);</span><br><span class="line">               cell.setCellValue(<span class="string">&quot;a&quot;</span>+j);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(Path+<span class="string">&quot;bigdata07S.xlsx&quot;</span>);</span><br><span class="line">       workbook.write(fileOutputStream);</span><br><span class="line">       fileOutputStream.close();</span><br><span class="line">       <span class="comment">// 清除临时文件</span></span><br><span class="line">       workbook.dispose();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">       System.out.println((<span class="keyword">double</span>)(end-begin)/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;成功！&quot;</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.17<br>成功！</p>
</blockquote>
<p>即使写入100000条记录</p>
<blockquote>
<p>1.719<br>成功！</p>
</blockquote>
<p>​        官方解释。实现big green demo策略的流逝版本，这允许写入非常大的文件，而不会耗尽内存，因为任何时候只有可配置的行部分。被保存在内存中。请注意。仍然可能会消耗大量内存。这些内存基于您正在使用的功能，例如合并区域、注释…….仍然只存在内存中。因此，如果广泛使用，可能需要大量内存。</p>
<h2 id="POI-读取Excel"><a href="#POI-读取Excel" class="headerlink" title="POI 读取Excel"></a>POI 读取Excel</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">excelReadTest</span> </span>&#123;</span><br><span class="line">    String Path = <span class="string">&quot;F:\\java\\excel\\poiexcel&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(Path+<span class="string">&quot;测试案例.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建工作簿</span></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> HSSFWorkbook(in);</span><br><span class="line">        Sheet sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 获取行</span></span><br><span class="line">        Row row = sheet.getRow(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            Cell cell = row.getCell(i);</span><br><span class="line">            String stringCellValue = cell.getStringCellValue();</span><br><span class="line">            System.out.println(stringCellValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>案例描述<br>案例名称<br>预期结果<br>GIVEN<br>WHEN<br>THEN</p>
</blockquote>
<h2 id="读取不同的数据类型"><a href="#读取不同的数据类型" class="headerlink" title="读取不同的数据类型"></a>读取不同的数据类型</h2><img src="/2020/08/04/easyexcel/1596507684507.png" class width="1596507684507">

<p>里面包含了字符串、数字、日期等数据类型。</p>
<p>看几个API</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Row.java  –&gt; int getPhysicalNumberOfCells();</td>
<td>获取当前行的单元格数量</td>
</tr>
<tr>
<td>Cell.java  –&gt; int getCellType();</td>
<td>获取当前单元格的类型，是一个枚举类型。  CELL_TYPE_BLANK                            CELL_TYPE_NUMERIC                              CELL_TYPE_STRING                          CELL_TYPE_FORMULA                      CELL_TYPE_BOOLEAN                             CELL_TYPE_ERROR</td>
</tr>
<tr>
<td>Sheet.java – &gt; int getPhysicalNumberOfRows();</td>
<td>获取工作表中的行数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead07</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileInputStream in = <span class="keyword">new</span> FileInputStream(Path+<span class="string">&quot;明细.xlsx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建工作簿</span></span><br><span class="line">        Workbook workbook = <span class="keyword">new</span> XSSFWorkbook(in);</span><br><span class="line">        Sheet sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// // 获取标题内容</span></span><br><span class="line">        Row rowTitle = sheet.getRow(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(rowTitle != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> cells = rowTitle.getPhysicalNumberOfCells();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cells; i++) &#123;</span><br><span class="line">                Cell cell = rowTitle.getCell(i);</span><br><span class="line">                <span class="keyword">if</span>(cell != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> cellType = cell.getCellType(); <span class="comment">// 获取类型</span></span><br><span class="line">                    String stringCellValue = cell.getStringCellValue();</span><br><span class="line">                    System.out.print(stringCellValue + <span class="string">&quot; | &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取表中的内容</span></span><br><span class="line">        <span class="keyword">int</span> rows = sheet.getPhysicalNumberOfRows();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            Row rowData = sheet.getRow(i);</span><br><span class="line">            <span class="keyword">if</span>(rowData != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//读取列</span></span><br><span class="line">                <span class="keyword">int</span> cells = rowData.getPhysicalNumberOfCells();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cells; j++) &#123;</span><br><span class="line">                    Cell cell = rowData.getCell(j);</span><br><span class="line">                    <span class="keyword">if</span>(cell != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> cellType = cell.getCellType();</span><br><span class="line">                        String cellValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 匹配列的数据类型</span></span><br><span class="line">                        <span class="keyword">switch</span> (cellType)&#123;</span><br><span class="line">                            <span class="keyword">case</span> XSSFCell.CELL_TYPE_STRING: <span class="comment">// 字符串</span></span><br><span class="line"><span class="comment">//                                System.out.println(&quot;【String】&quot;);</span></span><br><span class="line">                                cellValue = cell.getStringCellValue();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> XSSFCell.CELL_TYPE_BOOLEAN:</span><br><span class="line"><span class="comment">//                                System.out.println(&quot;【Boolean】&quot;);</span></span><br><span class="line">                                cellValue = String.valueOf(cell.getBooleanCellValue());</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">case</span> XSSFCell.CELL_TYPE_NUMERIC:</span><br><span class="line"><span class="comment">//                                System.out.println(&quot;【Num】&quot;);</span></span><br><span class="line">                                <span class="keyword">if</span>(HSSFDateUtil.isCellDateFormatted(cell))&#123;</span><br><span class="line">                                    <span class="comment">// 日期</span></span><br><span class="line">                                    Date date = cell.getDateCellValue();</span><br><span class="line">                                    cellValue = <span class="keyword">new</span> DateTime(date).toString(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">                                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                    cell.setCellType(XSSFCell.CELL_TYPE_STRING);</span><br><span class="line">                                    cellValue = cell.getStringCellValue() ;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> XSSFCell.CELL_TYPE_BLANK:</span><br><span class="line"><span class="comment">//                                System.out.println(&quot;【BLANK】&quot;);</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> XSSFCell.CELL_TYPE_ERROR:</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.print(cellValue+<span class="string">&quot;  &quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        in.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/08/04/easyexcel/1596509529664.png" class width="1596509529664">





<p>PIO 这个框架比较原生，用起来比较麻烦，而且在文件很大的时候可能会出现OOM异常，因为它导入是将整个文档全部导入到内存中。</p>
<p>所以， easye小说xcel就出现了，它解决了POI的问题，而且使用起来也非常方便。</p>
<h1 id="easyExcel"><a href="#easyExcel" class="headerlink" title="easyExcel"></a>easyExcel</h1><p>官网：  <a href="https://www.yuque.com/easyexcel/doc/easyexcel">https://www.yuque.com/easyexcel/doc/easyexcel</a> </p>
<p>github：  <a href="https://github.com/alibaba/easyexcel">https://github.com/alibaba/easyexcel</a> </p>
<p>easyexcel是阿里巴巴开源的一个Excel处理框架。以<strong>使用简单，节省内存著称</strong>。</p>
<p>Easy Excel能大大减少占用内存的主要原因是在解析Excel时，没有将文件数据一次性全部加载到内存中。而是在磁盘上一行行读取逐个解析。</p>
<img src="/2020/08/04/easyexcel/1596500707490.png" class width="1596500707490">

<p> easyexcel 是一个 JAVA 解析 Excel 工具。Java 解析、生成 Excel 比较有名的框架有 Apache poi、jxl 。<strong>但他们都存在一个严重的问题就是非常的耗内存</strong>，poi 有一套 SAX 模式的 API 可以一定程度的解决一些内存溢出的问题，但 POI 还是有一些缺陷，比如 07 版 Excel 解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel 重写了 poi 对 07 版 Excel 的解析，能够原本一个 3M 的 excel 用 POI sax 依然需要 100M 左右内存降低到 KB 级别，并且再大的 excel 不会出现内存溢出，03 版依赖 POI 的 sax 模式。在上层做了模型转换的封装，让使用者更加简单方便。 </p>
<h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelIgnore;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-08-04 11:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EquivalenceImportEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;案例描述&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String caseDescription;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;案例名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String caseName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;预期结果&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String expectedResult;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;GIVEN&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String given;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;WHEN&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String when;</span><br><span class="line">    <span class="meta">@ExcelProperty(&quot;THEN&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String then;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 忽略字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件包名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String packageDir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExcelIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String classFileName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">// @ExcelIgnore</span></span><br><span class="line">     <span class="meta">@ExcelProperty(&quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createDateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="写Excel"><a href="#写Excel" class="headerlink" title="写Excel"></a>写Excel</h2><h3 id="通用数据生成"><a href="#通用数据生成" class="headerlink" title="通用数据生成"></a>通用数据生成</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;EquivalenceImportEntity&gt; <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;EquivalenceImportEntity&gt; list = <span class="keyword">new</span> ArrayList&lt;EquivalenceImportEntity&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            EquivalenceImportEntity data = <span class="keyword">new</span> EquivalenceImportEntity();</span><br><span class="line">            data.setCaseDescription(<span class="string">&quot;用于测试easyExcel的案例&quot;</span> + i);</span><br><span class="line">            data.setCaseName(<span class="string">&quot;写excel&quot;</span> + i);</span><br><span class="line">            data.setGiven(<span class="string">&quot;我付款1000RMB预定了一个3周后从成都飞往三亚的航班。&quot;</span> + i);</span><br><span class="line">            data.setWhen(<span class="string">&quot;在航班起飞前一周“我”取消了该行程&quot;</span>);</span><br><span class="line">            data.setThen(<span class="string">&quot;我应该得到预定机票半价的退款（500RMB)&quot;</span>  + i);</span><br><span class="line">            data.setExpectedResult(<span class="string">&quot;返回500元  &quot;</span>  + i);</span><br><span class="line">            data.setCreateDateTime(<span class="keyword">new</span> Date());</span><br><span class="line">            list.add(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 最简单的写</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;1. 创建excel对应的实体对象 参照&#123;<span class="doctag">@link</span> EquivalenceImportEntity&#125;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;2. 直接写即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 写法1</span></span><br><span class="line">       String fileName = Path + System.currentTimeMillis() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">       <span class="comment">// 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭</span></span><br><span class="line">  </span><br><span class="line">       EasyExcel.write(fileName, EquivalenceImportEntity.class).sheet(<span class="string">&quot;User&quot;</span>).doWrite(data());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2020/08/04/easyexcel/1596512628382.png" class width="1596512628382">



<p>也可以排除指定的列去写入，将排除的列存入一个set中，然后write的时候传入set就行了。具体可参照官网 <a href="https://www.yuque.com/easyexcel/doc/write">https://www.yuque.com/easyexcel/doc/write</a> </p>
<h2 id="读取Excel"><a href="#读取Excel" class="headerlink" title="读取Excel"></a>读取Excel</h2><p>还是上面那个对象</p>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-08-04 11:48</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // 有个很重要的点 CaseDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseDataListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">EquivalenceImportEntity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER =  LoggerFactory.getLogger(CaseDataListener.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_COUNT = <span class="number">5</span>;</span><br><span class="line">    List&lt;EquivalenceImportEntity&gt; list = <span class="keyword">new</span> ArrayList&lt;EquivalenceImportEntity&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CaseDataListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个每一条数据解析都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data one row value. Is is same as &#123;<span class="doctag">@link</span> AnalysisContext#readRowHolder()&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 分析上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(EquivalenceImportEntity data, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;解析到一条数据:&#123;&#125;&quot;</span>, JSON.toJSONString(data));</span><br><span class="line">        list.add(data);</span><br><span class="line">        <span class="comment">// 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM</span></span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            saveData();  <span class="comment">// 持久化</span></span><br><span class="line">            <span class="comment">// 存储完成清理 list</span></span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有数据解析完成了 都会来调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里也要保存数据，确保最后遗留的数据也存储到数据库</span></span><br><span class="line">        saveData();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加上存储数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;&#123;&#125;条数据，开始存储数据库！&quot;</span>, list.size());</span><br><span class="line"><span class="comment">//        demoDAO.save(list);</span></span><br><span class="line">        LOGGER.info(<span class="string">&quot;存储数据库成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 最简单的读</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;1. 创建excel对应的实体对象 参照&#123;<span class="doctag">@link</span> EquivalenceImportEntity&#125;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;2. 由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器，参照&#123;<span class="doctag">@link</span> CaseDataListener&#125;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;3. 直接读即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去</span></span><br><span class="line">       <span class="comment">// 写法1：</span></span><br><span class="line">       String fileName = Path+ <span class="string">&quot;1596512468069.xlsx&quot;</span>;</span><br><span class="line">       <span class="comment">// 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭</span></span><br><span class="line">       EasyExcel.read(fileName, EquivalenceImportEntity.class, <span class="keyword">new</span> CaseDataListener()).sheet().doRead();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/08/04/easyexcel/1596513912244.png" class width="1596513912244">



<p>这样就把Excel文件的内容读取到了！！！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>excel</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>fastNote插件开发</title>
    <url>/2020/07/23/idea%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%AC%94%E8%AE%B0%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="开发笔记插件需求分析"><a href="#开发笔记插件需求分析" class="headerlink" title="开发笔记插件需求分析"></a>开发笔记插件需求分析</h1><p>在阅读源码的时候，我们是不是看完后面的就忘记了前面的了。。。所以决定开发一个插件，用于记录我们阅读源码或者开发的过程，最后可以生成一个md格式的笔记，方便我们后面复习查阅。</p>
<p>功能：点击右键之后在菜单中有插件的工具，选中代码片段之后可以生成对应的笔记，而且具有导出md的功能。</p>
<ol>
<li>如何添加一个右键点击之后的子菜单</li>
<li>如何获取编辑器中已经选择的文本</li>
<li>如何弹出对话框，获取用户编辑的笔记内容</li>
<li>如何使用ToolWindow展示笔记列表</li>
<li>如何在ToolWindow中添加表格</li>
<li>如何让用户选择文档生成的目录</li>
<li>如何将笔记列表静态化生成文档</li>
</ol>
<h1 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h1><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>首先创建一个工程，完成plugin.xml</p>
<img src="/2020/07/23/idea%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%AC%94%E8%AE%B0%E6%8F%92%E4%BB%B6/1595412781914.png" class width="1595412781914">



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">idea-plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>cn.hongliang.fastNote.id<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>FastNote<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">vendor</span> <span class="attr">email</span>=<span class="string">&quot;zhl396740445@163.com&quot;</span> <span class="attr">url</span>=<span class="string">&quot;https://hongliangzhu.cn&quot;</span>&gt;</span>Castile<span class="tag">&lt;/<span class="name">vendor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">      This is a notebook for development when you start a project or read source code to record ypur steps, and can generate a md document.&lt;br&gt;</span><br><span class="line">      &lt;em&gt;MarkDown Doc&lt;/em&gt;</span><br><span class="line">    ]]&gt;<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">change-notes</span>&gt;</span>&lt;![CDATA[</span><br><span class="line">       version 1.0: Add a note and main function .&lt;br&gt;</span><br><span class="line">      &lt;em&gt;Only support md doc&lt;/em&gt;</span><br><span class="line">    ]]&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">change-notes</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- please see http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/build_number_ranges.html for description --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">idea-version</span> <span class="attr">since-build</span>=<span class="string">&quot;173.0&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- please see http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/plugin_compatibility.html</span></span><br><span class="line"><span class="comment">       on how to target different products --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- uncomment to enable plugin in all products</span></span><br><span class="line"><span class="comment">  &lt;depends&gt;com.intellij.modules.lang&lt;/depends&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">&quot;com.intellij&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">actions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Add your actions here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">actions</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">idea-plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="创建一个Action"><a href="#创建一个Action" class="headerlink" title="创建一个Action"></a>创建一个Action</h2><p>创建一个Action，用于右键弹出一个子菜单</p>
<img src="/2020/07/23/idea%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%AC%94%E8%AE%B0%E6%8F%92%E4%BB%B6/1595414365001.png" class width="1595414365001">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.fastNote.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hongliang.fastNote.data.DataCenter;</span><br><span class="line"><span class="keyword">import</span> cn.hongliang.fastNote.dialog.AddNoteDialog;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.actionSystem.AnAction;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.actionSystem.AnActionEvent;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.actionSystem.CommonDataKeys;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.editor.Editor;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.editor.SelectionModel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-22 18:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PopUpAction</span> <span class="keyword">extends</span> <span class="title">AnAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(AnActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先获取编辑器对象</span></span><br><span class="line">        Editor editor = e.getRequiredData(CommonDataKeys.EDITOR);</span><br><span class="line">        <span class="comment">// 获取选择的文本</span></span><br><span class="line">        SelectionModel selectionModel = editor.getSelectionModel();</span><br><span class="line">        String selectedText = selectionModel.getSelectedText();</span><br><span class="line">        DataCenter.SELECTED_TEXT = selectedText;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 獲取文件的名稱</span></span><br><span class="line">        String fileName = e.getRequiredData(CommonDataKeys.PSI_FILE).getVirtualFile().getName();</span><br><span class="line">        DataCenter.FILE_NAME = fileName;</span><br><span class="line"></span><br><span class="line">        AddNoteDialog addNoteDialog = <span class="keyword">new</span> AddNoteDialog();</span><br><span class="line">        addNoteDialog.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(selectedText);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建添加笔记的对话框"><a href="#创建添加笔记的对话框" class="headerlink" title="创建添加笔记的对话框"></a>创建添加笔记的对话框</h2><p>创建一个对话框，添加笔记的对话框</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.fastNote.dialog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hongliang.fastNote.data.DataCenter;</span><br><span class="line"><span class="keyword">import</span> cn.hongliang.fastNote.data.NoteData;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.ui.DialogWrapper;</span><br><span class="line"><span class="keyword">import</span> com.intellij.ui.EditorTextField;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-22 18:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddNoteDialog</span> <span class="keyword">extends</span> <span class="title">DialogWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditorTextField noteTitle;</span><br><span class="line">    <span class="keyword">private</span> EditorTextField noteContent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddNoteDialog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">true</span>);</span><br><span class="line">        setTitle(<span class="string">&quot;添加笔记注释&quot;</span>);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JComponent <span class="title">createCenterPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> BorderLayout());</span><br><span class="line">        noteTitle = <span class="keyword">new</span> EditorTextField(<span class="string">&quot;笔记标题&quot;</span>);</span><br><span class="line">        noteContent = <span class="keyword">new</span> EditorTextField(<span class="string">&quot;笔记内容&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置文本框的大小</span></span><br><span class="line">        noteContent.setPreferredSize(<span class="keyword">new</span> Dimension(<span class="number">200</span>, <span class="number">100</span>));</span><br><span class="line">        panel.add(noteTitle, BorderLayout.NORTH);</span><br><span class="line">        panel.add(noteContent, BorderLayout.CENTER);</span><br><span class="line">        <span class="keyword">return</span> panel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JComponent <span class="title">createSouthPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">&quot;添加笔记到列表&quot;</span>);</span><br><span class="line">        <span class="comment">// 按钮事件</span></span><br><span class="line">        button.addActionListener(e -&gt; &#123;</span><br><span class="line">            String noteTitleText = noteTitle.getText();</span><br><span class="line">            String noteContentText = noteContent.getText();</span><br><span class="line">            String fileType = DataCenter.FILE_NAME.substring(DataCenter.FILE_NAME.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">            NoteData noteData = <span class="keyword">new</span> NoteData(noteTitleText, noteContentText, DataCenter.SELECTED_TEXT, DataCenter.FILE_NAME, fileType);</span><br><span class="line">            DataCenter.NOTE_LIST.add(noteData);</span><br><span class="line">            System.out.println(DataCenter.NOTE_LIST);</span><br><span class="line">        &#125;);</span><br><span class="line">        panel.add(button);</span><br><span class="line">        <span class="keyword">return</span> panel;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="NoteData类存储一条笔记的内容"><a href="#NoteData类存储一条笔记的内容" class="headerlink" title="NoteData类存储一条笔记的内容"></a>NoteData类存储一条笔记的内容</h2><p>上面用到了一个<code>NoteData</code>类，里面封装了一个笔记所包含的内容，包括标题、选中的代码，内容，文件名以及文件格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.fastNote.data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-22 19:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String mark;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    <span class="keyword">private</span> String fileType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoteData</span><span class="params">(String title, String mark, String content, String fileName, String fileType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        <span class="keyword">this</span>.fileType = fileType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMark</span><span class="params">(String mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFileName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFileName</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFileType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fileType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFileType</span><span class="params">(String fileType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileType = fileType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;NoteData&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;title=&#x27;&quot;</span> + title + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mark=&#x27;&quot;</span> + mark + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, fileName=&#x27;&quot;</span> + fileName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, fileType=&#x27;&quot;</span> + fileType + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有一个数据中心DataCenter。用于存取笔记。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.fastNote.data;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-22 20:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataCenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String SELECTED_TEXT; <span class="comment">// 选中的代码块</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String FILE_NAME; <span class="comment">// 文件名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;NoteData&gt; NOTE_LIST = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 笔记内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一切准备就绪，运行一下。</p>
<img src="/2020/07/23/idea%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%AC%94%E8%AE%B0%E6%8F%92%E4%BB%B6/1595418378475.png" class>

<h2 id="工具窗口"><a href="#工具窗口" class="headerlink" title="工具窗口"></a>工具窗口</h2><p>创建一个GUI Form</p>
<img src="/2020/07/23/idea%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%AC%94%E8%AE%B0%E6%8F%92%E4%BB%B6/1595429762970.png" class width="1595429762970">

<p>然后添加一些组件，拖动布局。用于我们展示笔记列表。</p>
<img src="/2020/07/23/idea%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%AC%94%E8%AE%B0%E6%8F%92%E4%BB%B6/1595430187106.png" class width="1595430187106">

<p>更改上述控件的filedName后，在目录下会生成一个java文件。这些空间就对象。</p>
<img src="/2020/07/23/idea%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%AC%94%E8%AE%B0%E6%8F%92%E4%BB%B6/1595430263371.png" class width="1595430263371">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.fastNote.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-22 22:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteListWindow</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * main panel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> JPanel contentPanel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文档标题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> JTextField tfTopic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 三个按钮</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> JButton btnCreate;</span><br><span class="line">    <span class="keyword">private</span> JButton btnClear;</span><br><span class="line">    <span class="keyword">private</span> JButton btnClose;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 笔记列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> JScrollPane tabContent;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoteListWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        btnCreate.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        btnClear.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        btnClose.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JPanel <span class="title">getContentPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contentPanel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先把这个工具视窗显示出来，创建一个<code>NoteListWindowFactory</code>实现<code>ToolWindowFactory</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.fastNote.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> b.e.P;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.project.Project;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.wm.ToolWindow;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.wm.ToolWindowFactory;</span><br><span class="line"><span class="keyword">import</span> com.intellij.ui.content.Content;</span><br><span class="line"><span class="keyword">import</span> com.intellij.ui.content.ContentFactory;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *工厂类  工具视窗</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-22 23:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteListWindowFactory</span> <span class="keyword">implements</span> <span class="title">ToolWindowFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createToolWindowContent</span><span class="params">(<span class="meta">@NotNull</span> Project project, <span class="meta">@NotNull</span> ToolWindow toolWindow)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建NoteListWindow对象</span></span><br><span class="line">        NoteListWindow noteListWindow = <span class="keyword">new</span> NoteListWindow(project, toolWindow);</span><br><span class="line">        <span class="comment">// 获取内容工厂的实例</span></span><br><span class="line">        ContentFactory contentFactory = ContentFactory.SERVICE.getInstance();</span><br><span class="line">        <span class="comment">// 获取用于ToolWindow显示的内容</span></span><br><span class="line">        Content content = contentFactory.createContent(noteListWindow.getContentPanel(), <span class="string">&quot;&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//给toolWindow设置内容</span></span><br><span class="line">        toolWindow.getContentManager().addContent(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后需要在plugin.xml中的扩展extension加上我们创建的toolWindow。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">extensions</span> <span class="attr">defaultExtensionNs</span>=<span class="string">&quot;com.intellij&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Add your extensions here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">toolWindow</span> <span class="attr">id</span>=<span class="string">&quot;noteListWindow&quot;</span> <span class="attr">factoryClass</span>=<span class="string">&quot;cn.hongliang.fastNote.window.NoteListWindowFactory&quot;</span> <span class="attr">anchor</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">toolWindow</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2020/07/23/idea%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%AC%94%E8%AE%B0%E6%8F%92%E4%BB%B6/1595433142794.png" class width="1595433142794">

<p>可以看到显示成功，但是缺少表格内容啊，下面完善这部分的功能</p>
<p>设置表头：在<code>DataCenter</code>里面添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataCenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String SELECTED_TEXT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String FILE_NAME;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;NoteData&gt; NOTE_LIST = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] TABLE_HEADER = &#123;<span class="string">&quot;标题&quot;</span>, <span class="string">&quot;备注&quot;</span>, <span class="string">&quot;文件名&quot;</span>, <span class="string">&quot;代码段&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DefaultTableModel TABLEMODEL = <span class="keyword">new</span> DefaultTableModel(<span class="keyword">null</span>, TABLE_HEADER);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化的工具视窗的时候将表格插入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.fastNote.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hongliang.fastNote.data.DataCenter;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.project.Project;</span><br><span class="line"><span class="keyword">import</span> com.intellij.openapi.wm.ToolWindow;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-22 22:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoteListWindow</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * main panel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> JPanel contentPanel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文档标题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> JTextField tfTopic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 三个按钮</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> JButton btnCreate;</span><br><span class="line">    <span class="keyword">private</span> JButton btnClear;</span><br><span class="line">    <span class="keyword">private</span> JButton btnClose;</span><br><span class="line">    <span class="keyword">private</span> JTable tabContent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*******************设置表头*************************</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tabContent.setModel(DataCenter.TABLEMODEL);</span><br><span class="line">        tabContent.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ******************************************</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoteListWindow</span><span class="params">(Project project, ToolWindow toolWindow)</span> </span>&#123;</span><br><span class="line">        init(); <span class="comment">//  初始化表格</span></span><br><span class="line"></span><br><span class="line">        btnCreate.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        btnClear.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        btnClose.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                toolWindow.hide(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JPanel <span class="title">getContentPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contentPanel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后解决创建笔记部分，添加到表格中, 在<code>AddNoteDialog.java</code>类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> JComponent <span class="title">createSouthPanel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line">       JButton button = <span class="keyword">new</span> JButton(<span class="string">&quot;添加笔记到列表&quot;</span>);</span><br><span class="line">       button.addActionListener(e -&gt; &#123;</span><br><span class="line">           String noteTitleText = noteTitle.getText();</span><br><span class="line">           String noteContentText = noteContent.getText();</span><br><span class="line">           String fileType = DataCenter.FILE_NAME.substring(DataCenter.FILE_NAME.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">           NoteData noteData = <span class="keyword">new</span> NoteData(noteTitleText, noteContentText, DataCenter.SELECTED_TEXT, DataCenter.FILE_NAME, fileType);</span><br><span class="line">           DataCenter.NOTE_LIST.add(noteData);</span><br><span class="line">           DataCenter.TABLEMODEL.addRow(DataConvert.convert(noteData));</span><br><span class="line">       &#125;);</span><br><span class="line">       panel.add(button);</span><br><span class="line">       <span class="keyword">return</span> panel;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/23/idea%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%AC%94%E8%AE%B0%E6%8F%92%E4%BB%B6/1595433962156.png" class width="1595433962156">

<h2 id="生成文档"><a href="#生成文档" class="headerlink" title="生成文档"></a>生成文档</h2><p>需求： 点击生成文档，如果用户没有输入文档的标题，将弹出一个对话框提示用户输入。然后选择保存的路径。生成md文档以特定的格式保存。</p>
<p>这里使用的是一个freeMarker的模板引擎。</p>
<p>下面是使用fastNote生成的MD笔记</p>
<p>[TOC]</p>
<h3 id="定义一个接口Processor"><a href="#定义一个接口Processor" class="headerlink" title="定义一个接口Processor"></a>定义一个接口Processor</h3><ul>
<li>此接口用于处理生成文档的功能，传入笔记的数据即可，可以通过其实现类具体生成各种文档</li>
<li>Processor.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(SourceNoteData sourceNoteData)</span> <span class="keyword">throws</span> IOException, TemplateException, Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类继承Processor"><a href="#抽象类继承Processor" class="headerlink" title="抽象类继承Processor"></a>抽象类继承Processor</h3><ul>
<li>这是一个模板，所有文档的生成都需要经过里面的process方法。首先是获取数据，然后获取模板，最后指定写入的位置。</li>
<li>AbstractFreeMarkerProcessor.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用FreeMarker生成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-23 8:54</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 模板设计模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFreeMarkerProcessor</span> <span class="keyword">implements</span> <span class="title">Processor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理流程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">getModel</span><span class="params">(SourceNoteData sourceNoteData)</span></span>; <span class="comment">// 获取数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Template <span class="title">getTemplate</span><span class="params">()</span> <span class="keyword">throws</span> IOException, Exception</span>;  <span class="comment">// 获取模板</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Writer <span class="title">getWriter</span><span class="params">(SourceNoteData sourceNoteData)</span> <span class="keyword">throws</span> FileNotFoundException, Exception</span>; <span class="comment">// 写到哪里</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类实现上面三个方法，按照这个方法的流程进行（模板）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceNoteData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SourceNoteData sourceNoteData)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Template template = getTemplate();</span><br><span class="line">        Object model = getModel(sourceNoteData);</span><br><span class="line">        Writer writer = getWriter(sourceNoteData);</span><br><span class="line">        template.process(model, writer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MDFreeMarkerProcessor生成MD格式"><a href="#MDFreeMarkerProcessor生成MD格式" class="headerlink" title="MDFreeMarkerProcessor生成MD格式"></a>MDFreeMarkerProcessor生成MD格式</h3><ul>
<li>这是抽象类的子类，具体生成md文档</li>
<li>MDFreeMarkerProcessor.java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MDFreeMarkerProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractFreeMarkerProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getModel</span><span class="params">(SourceNoteData sourceNoteData)</span> </span>&#123;</span><br><span class="line">        Map model = <span class="keyword">new</span> HashMap();</span><br><span class="line">        model.put(<span class="string">&quot;topic&quot;</span>, sourceNoteData.getTopic());</span><br><span class="line">        model.put(<span class="string">&quot;noteList&quot;</span>, sourceNoteData.getNoteList());</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Template <span class="title">getTemplate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建模板配置</span></span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration(Configuration.VERSION_2_3_30);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载模板字符串</span></span><br><span class="line">        String templateContent = UrlUtil.loadText(MDFreeMarkerProcessor.class.getResource(<span class="string">&quot;/template/md.ftl&quot;</span>));</span><br><span class="line">        <span class="comment">// 创建字符串模板导入器</span></span><br><span class="line">        StringTemplateLoader stringTemplateLoader = <span class="keyword">new</span> StringTemplateLoader();</span><br><span class="line">        <span class="comment">// 导入字符串模板</span></span><br><span class="line">        stringTemplateLoader.putTemplate(<span class="string">&quot;MDtemplate&quot;</span>, templateContent);</span><br><span class="line">        configuration.setTemplateLoader(stringTemplateLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取模板</span></span><br><span class="line">        <span class="keyword">return</span> configuration.getTemplate(<span class="string">&quot;MDtemplate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Writer <span class="title">getWriter</span><span class="params">(SourceNoteData sourceNoteData)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String fileName = sourceNoteData.getFileName();</span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(fileName)), <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> bufferedWriter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文档模板"><a href="#文档模板" class="headerlink" title="文档模板"></a>文档模板</h3><ul>
<li>这是生成文档的模板，使用freemarker模板引擎填充数据</li>
<li>md.ftl</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">## $&#123;topic&#125;</span></span><br><span class="line">[TOC]</span><br><span class="line">&lt;<span class="comment">#list noteList as note&gt;</span></span><br><span class="line"><span class="comment">### $&#123;note.title&#125;</span></span><br><span class="line">- $&#123;note.mark&#125;</span><br><span class="line">- $&#123;note.fileName&#125;</span><br><span class="line">​```$&#123;note.fileType&#125;</span><br><span class="line">$&#123;note.content&#125;</span><br><span class="line">&lt;/<span class="comment">#list&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2020/07/23/idea%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%AC%94%E8%AE%B0%E6%8F%92%E4%BB%B6/1595474019544.png" class width="1595474019544">



<p>至此，大功告成，希望这个插件可以大大提高我们的学习效率。</p>
]]></content>
      <tags>
        <tag>plugin</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>从网络到IO多路复用</title>
    <url>/2021/07/23/io%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1 id="基于linux操作系统"><a href="#基于linux操作系统" class="headerlink" title="基于linux操作系统"></a>基于linux操作系统</h1><p>tcpdump</p>
<p>strace</p>
<p>man</p>
<p>nc</p>
<p>curl</p>
<p>nginx</p>
<h1 id="开篇-基础知识准备"><a href="#开篇-基础知识准备" class="headerlink" title="开篇-基础知识准备"></a>开篇-基础知识准备</h1><p>tcp、ip协议层 。</p>
<p>TCP： 面向连接的可靠的传输协议， 需要进行3次握手建立连接。</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596339781519.png" class width="1596339781519">

<p>四次挥手断开连接</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596340107335.png" class width="1596340107335">

<p>软件分层结构，每个层有做自己的事情，解耦合。</p>
<p>在linux上执行命令访问<a href="http://www.baidu.com/">www.baidu.com</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span> 6&lt;&gt; /dev/tcp/www.baidu.com/80</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>exec</code>:  将一个程序覆盖当前进程，即将此程序压栈，如果程序执行完是退出，则会让内核触发，将整个进程销毁，断开连接 </p>
<p>6: 文件描述符，可以自己定义</p>
<p>&lt;&gt;: 重定向操作符， 表示输入输出</p>
<p> /dev/tcp/<a href="http://www.baidu.com/80">www.baidu.com/80</a>  ： 虚拟文件系统 </p>
<p> 0  输入流 1  正确输出流 2  报错输出 </p>
</blockquote>
<p> 当前bash里面多了一个6号文件描述符，指向了一个socket， /dev/tcp/<a href="http://www.baidu.com/80%E4%B8%BA%E7%89%B9%E6%AE%8A%E7%9B%AE%E5%BD%95%EF%BC%8C%E8%A7%A6%E5%8F%91%E4%B8%80%E4%B8%AA%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%AE%A9bash%E5%8F%91%E8%B5%B7%E4%BA%86%E5%AF%B9%E7%99%BE%E5%BA%A6socket%E7%9A%84%E8%BF%9E%E6%8E%A5">www.baidu.com/80为特殊目录，触发一个内核机制，让bash发起了对百度socket的连接</a> 。</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596338215863.png" class width="1596338215863">

<p>与百度建立了socket连接后怎么获取百度的主页呢？socket建立表示TCP连接已经建立了，然后应该使用协议来进行交互。是应用层的操作，所以我们需要发送HTTP协议请求头</p>
<p> http协议请求头 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;GET / HTTP/1.0\n&quot;</span>      -e使得bash能识别换行符</span><br><span class="line"><span class="comment"># 将请求头发送到百度服务器</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;GET/HTTP/1.0\n&quot;</span> 1&gt;&amp;8 <span class="comment"># 1 是输出，表示将输出重定向到 6中， 如果重定向后面是一个文件描述符的话，需要加一个 &amp; </span></span><br><span class="line"><span class="comment"># 读取响应信息</span></span><br><span class="line">cat 0&lt;&amp;8</span><br></pre></td></tr></table></figure>





<h1 id="使用工具抓包"><a href="#使用工具抓包" class="headerlink" title="使用工具抓包"></a>使用工具抓包</h1><p>使用tcpdump工具</p>
<p>安装：yum install tcpdump</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596340272940.png" class width="1596340272940">

<p>查看网卡 ifconfig</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596340312930.png" class width="1596340312930">

<p>看一下tcpdump如何使用： tcpdump –help</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596340347063.png" class width="1596340347063">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -nn -i ens33 port 80  <span class="comment"># 监听80端口的时间 在网卡 ens33 上</span></span><br></pre></td></tr></table></figure>

<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596340485781.png" class width="1596340485781">

<p>目前还没有，是一个阻塞状态</p>
<p>然后我们去访问一下百度 curl ， 重开一个ssh</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596340567812.png" class width="1596340567812">

<p>在刚刚的侦听界面上：</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596340618884.png" class width="1596340618884">

<p>分析一下, 先看建立连接，也就是前三行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">11:55:43.617175 IP 192.168.145.130.51914 &gt; 104.193.88.77.80: Flags [S], seq 3681486933, win 29200, options [mss 1460,sackOK,TS val 41257007 ecr 0,nop,wscale 7], length 0</span><br><span class="line"></span><br><span class="line">表示本机给百度发送了一个 seq ，后面的数字表示序列号。 S 表示 sync</span><br><span class="line"></span><br><span class="line">11:55:43.845875 IP 104.193.88.77.80 &gt; 192.168.145.130.51914: Flags [S.], seq 1297381438, ack 3681486934, win 64240, options [mss 1460], length 0</span><br><span class="line"></span><br><span class="line">接着百度给本机发送 了一个 sync+ ack的包。</span><br><span class="line"></span><br><span class="line">11:55:43.845926 IP 192.168.145.130.51914 &gt; 104.193.88.77.80: Flags [.], ack 1, win 29200, length 0</span><br><span class="line"></span><br><span class="line">然后本地给百度回复了一个 ack 确认</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上就是TCP建立连接的三次握手过程，完成建立后，双方开辟资源。</p>
<p>接着看中间几行表示本机与百度进行数据传输的过程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">11:55:43.846291 IP 192.168.145.130.51914 &gt; 104.193.88.77.80: Flags [P.], seq 1:78, ack 1, win 29200, length 77: HTTP: GET / HTTP/1.1</span><br><span class="line"></span><br><span class="line">本机给百度发送了一个数据包 长度为77  协议HTTP/1.1  以GET的方式请求</span><br><span class="line"></span><br><span class="line">11:55:43.846412 IP 104.193.88.77.80 &gt; 192.168.145.130.51914: Flags [.], ack 78, win 64240, length 0</span><br><span class="line"></span><br><span class="line">百度给本就回复一个确认 ack， 因为是可靠传输</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11:55:44.386992 IP 104.193.88.77.80 &gt; 192.168.145.130.51914: Flags [P.], seq 1:2782, ack 78, win 64240, length 2781: HTTP: HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">接着是百度个本机返回单的响应数据  长度为2781  状态码 200 表示成功</span><br><span class="line">上面两个都是百度发出的，最后有一个P表示，数据发送完了，不要存储在缓存中了，请马上告知应用程序去处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11:55:44.387030 IP 192.168.145.130.51914 &gt; 104.193.88.77.80: Flags [.], ack 2782, win 33580, length 0</span><br><span class="line"></span><br><span class="line">本机给百发送ack确认，表示已经收到</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发送完数据之后，接着是断开连接，也就是四次挥手的过程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">11:55:44.387247 IP 192.168.145.130.51914 &gt; 104.193.88.77.80: Flags [F.], seq 78, ack 2782, win 33580, length 0</span><br><span class="line"></span><br><span class="line">本机需要断开连接  fin</span><br><span class="line"></span><br><span class="line">11:55:44.387563 IP 104.193.88.77.80 &gt; 192.168.145.130.51914: Flags [.], ack 79, win 64239, length 0</span><br><span class="line"></span><br><span class="line">百度返回给客户端一个ack，表示知道了你要断开连接。但是这时还没有完全断开，是一个半关闭的转态。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11:55:45.280826 IP 104.193.88.77.80 &gt; 192.168.145.130.51914: Flags [FP.], seq 2782, ack 79, win 64239, length 0</span><br><span class="line"></span><br><span class="line">百度的服务器也要断开连接了，给本机发送了一个fin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11:55:45.280853 IP 192.168.145.130.51914 &gt; 104.193.88.77.80: Flags [.], ack 2783, win 33580, length 0</span><br><span class="line">本机知道了，然后断开</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>通过以上分析，我们以及知道从客户端发起请求建立连接到传输数据再到四次挥手断开连接的全过程。这一整个过程应该是一个完整的粒度，不应该被拆散。</p>
<p>比如，我们做负载均衡的时候，客户端给一个服务器发送了一个建立连接的请求数据包sync， 然后这个服务器返回一个sync+ack给客户端，客户端还需要发送一个ack给服务器，但是由于有多台服务器，负载均衡会选择一个最佳的服务器，可能会出现这样的一种情况，就是客户端的ack发送给了另外一台服务器，而原来的这个服务器一直没有收到客户端的ack，所以这个连接就建立不起来。这就是粒度被拆散了。</p>
<p>这个粒度不能被我们以后所学的技术所拆散的！！！这是一个大前提。</p>
<h1 id="NetCat"><a href="#NetCat" class="headerlink" title="NetCat"></a>NetCat</h1><p> nc是netcat工具的命令，是一个很好用的网络工具。比如，可以用来端口扫描，文件传输等网络功能。 在 网络工具中有“瑞士军刀”美誉的NetCat， 在我们用了N年了至今仍是爱不释手。 </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install nc</span><br></pre></td></tr></table></figure>

<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596342921077.png" class width="1596342921077">

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/Users\ZHLAS\AppData\Roaming\Typora\typora-user-images\1596342893175.png" alt="1596342893175"></p>
<h2 id="监听端口"><a href="#监听端口" class="headerlink" title="监听端口"></a>监听端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -l 8080  <span class="comment"># 开启服务端</span></span><br><span class="line">nc localhost 8080 <span class="comment"># 开启客户端</span></span><br></pre></td></tr></table></figure>

<p>他们之间就建立了连接，可以相互发送数据</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596343177824.png" class width="1596343177824">

<p>查看他们的进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nc</span><br></pre></td></tr></table></figure>

<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596343270786.png" class width="1596343270786">

<p>然后我们用上面的提到的，在 /proc/进程id/fd 目录下面下有进程描述符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> proc/102514/fd</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596343753967.png" class width="1596343753967">

<h1 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h1><blockquote>
<p>yum install strace</p>
</blockquote>
<p>用来跟踪程序的运行以及系统调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir xxoo  <span class="comment"># 创建一个新文件夹，用来存放程序运行的跟踪文件</span></span><br><span class="line"><span class="built_in">cd</span> xxoo</span><br><span class="line">trace -ff -o out nc -l 8080 <span class="comment"># 跟踪这个程序</span></span><br></pre></td></tr></table></figure>

<p>然后在xxoo目录下有一个文件 out-4781 , 后面的id表示nc的进程id</p>
<p>打开这个文件：</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596348250812.png" class width="1596348250812">

<p>查看select的作用： man 2  select</p>
<p>select是一个多路复用器，会阻塞</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596348180958.png" class width="1596348180958">

<p>使用 tail命令去动态查看文件的变化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tail -f out.4781</span><br></pre></td></tr></table></figure>

<p>打开一个客户端 nv localhost 8080</p>
<p>发送一些信息</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596348474672.png" class width="1596348474672">

<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596348629679.png" class width="1596348629679">

<p>write(1, “zhuhongliang\n”, 13)          = 13 表示在 文件描述符1 写入 。1代表标准写</p>
<p>看一下recvfrom 的功能：从一个socket接受数据data，返回数据的字节数</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596348842591.png" class width="1596348842591">





<h1 id="系统调用system-call"><a href="#系统调用system-call" class="headerlink" title="系统调用system call"></a>系统调用system call</h1><p>read、write、 socket、 bind、listen、accept</p>
<p>上述系统方法的实现是在linux kernel里面的实现的。kernel只会对应用程序暴露上述方法的调用，所以程序会对系统内核发起系统调用。</p>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>如果程想使用内核完成网络通信的话，这时候会发生哪些事情呢？</p>
<p>看看下面的过程</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596350428037.png" class width="1596350428037">

<p>首先服务端系统调用kernel，socket获取服务端的文件描述符 5，然后使用bind将文件描述符与端口8080进行绑定，之后监听看有没有连接。</p>
<p>这时候，一个客户端也进行系统调用，经过三次握手之后连接了服务端，服务端系统调用accept， 建立连接 。客户端的文件描述符加入是fd 4 。 然后调用read 读操作，传入客户端的文件描述符4 。但是这个客户端没有发送数据，所以这个read现在被阻塞住了。</p>
<p>此时又有一个客户端来连接</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596350713176.png" class width="1596350713176">

<p>建立完连接后，这时候不会给他分配文件描述符，因为程序已经被阻塞住了，只能运行到accept这个阶段，如果客户端有超时响应的话，会报超时连接错误。</p>
<p>这是整个IO  发展历程中的第一个时期：BIO，即阻塞IO。</p>
<p>那么，我们怎么解决这个问题呢？ 可以开辟一个线程。</p>
<p>一旦出现了一个连接，就分配一个文件描述符，然后开辟一个线程。</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596351333541.png" class width="1596351333541">

<p>如果有线程来<code>read</code>了，就启动线程，否则阻塞。上述就是多线程模型。</p>
<p>这样已经解决服务端无法处理多个客户端连接请求的问题了，但这种多线程模型有什么缺点或者说弊端呢？</p>
<p>思考一下如果有100000个客户端，那么是不是要与100000个线程的开辟？？？</p>
<p>这就开销太大了吧。</p>
<p>我们首先看一下java程序在linux 系统中是如何调用的</p>
<p>写一个简单的java程序</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596352369785.png" class width="1596352369785">

<p>使用是strace 追踪系统调用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -ff -o xxoo java Hello</span><br></pre></td></tr></table></figure>

<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596352460918.png" class width="1596352460918">

<p>可以看到，这样一个简单的java程序并不是只开辟了一个线程。打开113151</p>
<p><img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/Users\ZHLAS\AppData\Roaming\Typora\typora-user-images\1596352589369.png" alt="1596352589369"></p>
<p>发现调用了113152线程， 并且使用的系统调用<code>clone</code></p>
<p>那 我们的主线程是哪个，主线程应该是打印Hello world的那个线程吧</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;Hello world&quot;</span> ./*</span><br></pre></td></tr></table></figure>

<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596352739519.png" class width="1596352739519">

<p>看到了write系统调用了吗。这是在113152线程中。</p>
<p>我们可以得出一个结论，线程的创建是通过调用内核的clone系统调用来实现的，主线程都需要clone，然后如果有成千上万个线程的话，就要进行成千上万次系统调用，这个开销很非常大的。因为调用内核不是直接就调用的，需要发生软中断，而且CPU也要切换状态。</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>在BIO时期这一切万恶之源都是由于系统调用会有阻塞的情况发生，如果一个客户端没有发送数据，就会阻塞。虽然多线程模型可以处理多个客户端的情况，但是由于开销大，系统调用此时多，比较慢。</p>
<p>那么能不能只创建一个线程就可以处理多个客户端呢？</p>
<p>我们看看socket： <code>man 2 socket</code></p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596353886051.png" class width="1596353886051">

<blockquote>
<p>SOCK_NONBLOCK :   Set the O_NONBLOCK file status flag on the new open file description.  Using this flag saves extra calls to fcntl(2) to achieve the same result</p>
</blockquote>
<p>可以使用非阻塞，fcntl来指定非阻塞的文件描述符</p>
<p>==所以，内核需要发生变化==</p>
<p>下面的模型非阻塞的NIO （NON- Block IO）</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596354546614.png" class width="1596354546614">

<p>在客户端只需要写一个死循环，然后有一个客户端的文件描述符解accept，如果没有数据传输，就报错，然后程序可以继续执行。这样的模型也有弊端。</p>
<p>试想一下，如果有10000个客户端，一次循环就进行10000次系统调用，那么如果只有第10000个客户端有数据传输，那这样的开销会很大。</p>
<p>有没有什么解决方法呢？ 如果能把多次系统调用变成一次系统调用那就好啦！！！</p>
<p>怎么做？==内核又需要变化了==</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>上面我们提到了select。看看<code>select</code> ： man 2 select </p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596355176202.png" class width="1596355176202">

<blockquote>
<p>select() and pselect() allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become “ready” for some class of I/O operation (e.g., input possible).  A file descriptor  is considered ready if it is possible to perform the corresponding I/O operation (e.g., read(2)) without blocking.</p>
<p>select()和pselect()允许程序监视多个文件描述符，直到其中一个或多个文件描述符为某些类型的I/O操作(例如，输入)“准备好”。如果文件描述符可以不阻塞地执行相应的I/O操作(如read(2))，则认为它已经准备好了。</p>
</blockquote>
<p>下面是使用了select或者poll的模型</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596355593306.png" class width="1596355593306">

<p>将各个客户端的文件描述符给select，然后select会去主动遍历每一个文件描述符，哪个有数据输出就返回哪个文件描述符，然后通过系统调用read去读取。这样的话就只用以一次系统调用就把需要read的文件描述符选择出来了，比上面的需要非常多的系统调用模型更加优秀。另外，select是系统调用，会主动遍历每一个文件操作符，时间复杂度为O(N)。</p>
<p>这还没有完，这种模型还没有很优美，虽然减少了系统调用，但是select里面的轮询还是O(N)的，这该怎么改进呢？</p>
<p>epoll终于来了！！！</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>讲epoll之前先来看看<code>nginx</code>，看看nginx怎么工作的。</p>
<p>首先需要安装nginx： <a href="https://blog.csdn.net/qq_37345604/article/details/90034424">https://blog.csdn.net/qq_37345604/article/details/90034424</a> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.9.9.tar.gz  </span><br><span class="line">tar -zxvf  nginx-1.9.9.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx目录</span><br><span class="line">./configure</span><br><span class="line"> </span><br><span class="line">make</span><br><span class="line"> </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>运行nginx在 usr/local/nginx/sbin 目录下</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596374161025.png" class width="1596374161025">

<p>我们来看看nginx有多少个线程，不出意外的话，应该是两个，一个是master，一个是worker。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -ff -o out ./nginx</span><br></pre></td></tr></table></figure>

<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596374461886.png" class width="1596374461886">

<p>我们看看对应的out下有多少文件</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596374545591.png" class width="1596374545591">

<p>可以看到有3635、3636、3637三个进程，不应该是两个吗？？？</p>
<p>我们来看看3635这个进程：</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596374748379.png" class width="1596374748379">

<p>这个进程只是启动进程，最后是退出了的，它clone了3636进程， 然后3636进程clone了3637进程，如下图。</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596374641173.png" class width="1596374641173">

<p>所以他们是父子关系。  3635–&gt; 3636 –&gt; 3637。 因为3636是master进程，可以看到他其实没有做什么事情， 就是将3637 worker进程clone出来了。</p>
<p>其实一开始文件描述符是在3635进程，也就是启动线程就去确定了，通过clone将文件描述符带给3636进程， 3636又带去3637进程</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596375190301.png" class width="1596375190301">

<p>再看看3637进程</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596375290597.png" class width="1596375290597">

<p>文件描述符6 放进了8 里面，8 是上面的<code>epoll_create</code>创建出来的。</p>
<p>那么epoll_create 是干嘛的，运行命令 man 2 epoll_create 查看系统调用</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596375526366.png" class width="1596375526366">

<blockquote>
<p>  epoll_create() returns a file descriptor referring to the new epoll instance.  This file descriptor is used for all the subsequent calls to the epoll interface.  When no longer required, the file descriptor returned by epoll_create() should be closed by using close(2).  When all file descriptors referring to an epoll instance have been closed, the kernel  destroys  the  instance  and releases the associated resources for reuse.</p>
<p>epoll_create()返回引用新epoll实例的文件描述符。<strong>此文件描述符用于随后对epoll接口的所有调用。</strong>当不再需要时，应该使用close(2)关闭epoll_create()返回的文件描述符。当引用epoll实例的所有文件描述符都被关闭时，内核会销毁该实例并释放相关的资源以供重用。</p>
</blockquote>
<p>其实系统调用<code>epoll_create()</code> 在内核中开辟一个空间， 使用文件描述符指向这个空间。然后通过epoll_ctl(8, 6) 将文件描述符6放进 8里面。然后epoll_wait(8,  等待， 开始阻塞。</p>
<p><code>epoll_wait</code>会返回有数据输出的文件描述符数量。</p>
<blockquote>
<p>The  epoll_wait()  system  call  waits for events on the epoll(7) instance referred to by the file descriptor epfd.  The memory area pointed to by events will contain the events that will be available for the caller.  Up to maxevents are returned by epoll_wait().  The maxevents argument must be greater than zero.</p>
<p> The timeout argument specifies the minimum number of milliseconds that epoll_wait() will block.  (This interval will be rounded up to the system  clock  granularity,  and  kernel  scheduling delays  mean  that the blocking interval may overrun by a small amount.)  Specifying a timeout of -1 causes epoll_wait() to block indefinitely, while specifying a timeout equal to zero cause  epoll_wait() to return immediately, even if no events are available.</p>
<p>RETURN VALUE( 返回值 )<br>       When successful, epoll_wait() returns the number of file descriptors ready for the requested I/O, or zero if no file descriptor became ready during the requested timeout milliseconds.   When  an error occurs, epoll_wait() returns -1 and errno is set appropriately.</p>
</blockquote>
<blockquote>
<p>epoll_wait()系统调用等待文件描述符epfd引用的epoll(7)实例上的事件。事件指向的内存区域将包含调用者可用的事件。epoll_wait()返回最多maxevents。maxevents参数必须大于零。</p>
<p>超时参数指定epoll_wait()将阻塞的最小毫秒数。(这个时间间隔将被舍入到系统时钟粒度，内核调度延迟意味着阻塞时间间隔可能会超出一小部分。)将超时指定为-1将导致epoll_wait()无限期阻塞，而将超时指定为0将导致epoll_wait()立即返回，即使没有可用的事件。</p>
<p>成功时，epoll_wait()返回为请求的I/O准备好的文件描述符的数量，如果在请求的超时毫秒期间没有文件描述符准备好，则返回0。当发生错误时，epoll_wait()返回-1,errno被适当地设置。</p>
</blockquote>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596376139195.png" class width="1596376139195">

<p>我们来模拟一下访问，目前3637进程是阻塞的，因为没有客户端来连接。</p>
<p>使用tail命令去查看动态的文件变化</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596376468601.png" class width="1596376468601">

<p>使用curl来模拟访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl localhost 80</span><br></pre></td></tr></table></figure>

<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596376962580.png" class width="1596376962580">

<p>out文件的变化</p>
<p><img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/Users\ZHLAS\AppData\Roaming\Typora\typora-user-images\1596376939382.png" alt="1596376939382"></p>
<p>主要看看这几句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">accept4(6, &#123;sa_family=AF_INET, sin_port=htons(34306), sin_addr=inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>)&#125;, [110-&gt;16], SOCK_NONBLOCK) = 3</span><br><span class="line"></span><br><span class="line">一个客户端请求后，首先系统调用accept(6, ...)，6是服务端的文件描述符，客户端的文件描述符是3</span><br><span class="line"></span><br><span class="line">epoll_ctl(8, EPOLL_CTL_ADD, 3, &#123;EPOLLIN|EPOLLRDHUP|EPOLLET, &#123;u32=4200120752, u64=139994364166576&#125;&#125;) = 0</span><br><span class="line"> 紧接着 将3放进8 里面去，这时候还没有客户端的数据流出</span><br><span class="line"></span><br><span class="line">epoll_wait(8, [&#123;EPOLLIN, &#123;u32=4200120752, u64=139994364166576&#125;&#125;], 512, 60000) = 1</span><br><span class="line">epoll_wait 去监听8 里面的文件描述符的 数据到达事件</span><br><span class="line"></span><br><span class="line">recvfrom(3, <span class="string">&quot;GET / HTTP/1.1\r\nUser-Agent: curl&quot;</span>..., 1024, 0, NULL, NULL) = 73</span><br><span class="line"></span><br><span class="line">有事件到达了， 收到的数据是从文件描述3发来的</span><br><span class="line"></span><br><span class="line"><span class="built_in">stat</span>(<span class="string">&quot;/usr/local/nginx/html/index.html&quot;</span>, &#123;st_mode=S_IFREG|0644, st_size=612, ...&#125;) = 0</span><br><span class="line"></span><br><span class="line">判断是请求主页的</span><br><span class="line"></span><br><span class="line">open(<span class="string">&quot;/usr/local/nginx/html/index.html&quot;</span>, O_RDONLY|O_NONBLOCK) = 10</span><br><span class="line">打开主页的文件， 文件描述符是10</span><br><span class="line"></span><br><span class="line">fstat(10, &#123;st_mode=S_IFREG|0644, st_size=612, ...&#125;) = 0</span><br><span class="line">查看文件描述符10 的状态</span><br><span class="line"></span><br><span class="line">writev(3, [&#123;iov_base=<span class="string">&quot;HTTP/1.1 200 OK\r\nServer: nginx/1&quot;</span>..., iov_len=237&#125;], 1) = 237</span><br><span class="line">返回给文件描述符3 的数据，给3写入</span><br><span class="line"></span><br><span class="line">sendfile(3, 10, [0] =&gt; [612], 612)      = 612</span><br><span class="line">发送数据 将10 发送给3 </span><br><span class="line">write(4, <span class="string">&quot;127.0.0.1 - - [02/Aug/2020:22:01&quot;</span>..., 86) = 86</span><br><span class="line">写的时间</span><br><span class="line">close(10)     = 0</span><br><span class="line">关闭文件描述符10</span><br><span class="line">setsockopt(3, SOL_TCP, TCP_NODELAY, [1], 4) = 0</span><br><span class="line">recvfrom(3, <span class="string">&quot;&quot;</span>, 1024, 0, NULL, NULL)    = 0</span><br><span class="line">close(3)  <span class="comment">#  连接断开就会关闭文件描述符3                </span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用nc 来模拟多个客户端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc localhost 80  <span class="comment"># 客户端1</span></span><br><span class="line">nc localhost 80 <span class="comment"># 客户端2</span></span><br></pre></td></tr></table></figure>

<p>这是out文件的变化，可以看到有两个文件描述符加入8 中</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596378280120.png" class width="1596378280120">

<p>所以，所有的连接只需要通过epoll_ctl（8， ）放入8一次，未来就连续调用epoll_wait来监听那个文件描述符有数据到达， 对于文件描述符6来说，等待的是accept事件，对于3、10 等其他的客户端的文件描述符是等待read，一旦监听到了，就将这个文件描述符放入一个集合中。</p>
<img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596378843696.png" class width="1596378843696">

<p>这样的模型不像select会一次将10000个文件描述符拷贝给内核，内核开辟了一个空间，来了一个客户端就通过epoll_ctl将文件描述符放入到指定的区域里面，只要连接不断开，那么可以通过epoll_wait获取到客户端的所有事件。</p>
<p>内核是被动的，中断的事件会让8 里面的文件描述符进入到右边的返回区，然后主程序就是一个epol_wait死循环，一直判断返回区里面有没有事件。</p>
<p>零拷贝： sendFile系统调用</p>
<p>直接内存</p>
<h1 id="附：发展历程图示"><a href="#附：发展历程图示" class="headerlink" title="附：发展历程图示"></a>附：发展历程图示</h1><img src="/2021/07/23/io%E5%A4%8D%E7%94%A8/1596381266279.png" class width="1596381266279">



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket">https://cyc2018.github.io/CS-Notes/#/notes/Socket</a></li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存问题：缓存穿透、缓存击穿、缓存雪崩、分布式锁、一致性hash算法</title>
    <url>/2020/09/06/redis%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透的概念很简单。用户想要查询一个数据。发现redis内存数据库中没有，也就是缓存没有命中。于是向持久层数据库查询，发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库，这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<p>黑客： id=-1，id = -2 … 访问请求。这些id在redis中找不到，在数据库中也找不到。解决办法就是将找不到的id号在<code>redis</code>中存为null值，但是由于大量的id都找不到，而redis有内存淘汰策略，会将有效的数据淘汰掉，<code>redis</code>里面会有大量无效的数据。</p>
<h2 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h2><p> 缓存空对象是指当一个请求过来缓存中和数据库中都不存在该请求的数据，第一次请求就会跳过缓存进行数据库的访问，并且访问数据库后返回为空，此时也将该空对象进行缓存。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     UserDAO userDAO;</span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     RedisCache redisCache;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">          Object object = redisCache.get(Integer.toString(id));</span><br><span class="line">          <span class="comment">// 缓存中存在，直接返回</span></span><br><span class="line">          <span class="keyword">if</span>(object != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 检验该对象是否为缓存空对象，是则直接返回null</span></span><br><span class="line">               <span class="keyword">if</span>(object <span class="keyword">instanceof</span> NullValueResultDO) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> (User)object;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">               <span class="comment">// 缓存中不存在，查询数据库</span></span><br><span class="line">               User user = userDAO.getUser(id);</span><br><span class="line">               <span class="comment">// 存入缓存</span></span><br><span class="line">               <span class="keyword">if</span>(user != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    redisCache.put(Integer.toString(id),user);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将空对象存进缓存</span></span><br><span class="line">                    redisCache.put(Integer.toString(id), <span class="keyword">new</span> NullValueResultDO());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> user;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 若是再次进行访问该空对象的时候，就会直接<strong>击中缓存</strong>，而不是再次<strong>数据库</strong>， 但是缓存空对象会带来比较大的问题，就是缓存中会存在很多空对象，占用<strong>内存的空间</strong>，浪费资源，一个解决的办法就是设置空对象的<strong>较短的过期时间</strong>，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 再缓存的时候，添加多一个该空对象的过期时间60秒</span></span><br><span class="line">redisCache.put(Integer.toString(id), <span class="keyword">new</span> NullValueResultDO(),<span class="number">60</span>);</span><br></pre></td></tr></table></figure>



<p>终极解决方案：在<code>redis</code>与<code>mysql</code>中间加一个过滤器，过滤器中需要保存未来可能查询的字段值。</p>
<p>过滤器不能重量级，当查询的字段多样化的时候，可能会导致内存紧张，导致过滤效率降低。布隆过滤器登场</p>
<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599377570982.png" class width="1599377570982">

<h2 id="布隆算法"><a href="#布隆算法" class="headerlink" title="布隆算法"></a>布隆算法</h2><p>我们希望过滤器不能占用太多的内存，是一个轻量级的过滤器。</p>
<p>布隆过滤器是一种基于<strong>概率</strong>的<strong>数据结构</strong>，主要用来判断某个元素是否在集合内，它具有<strong>运行速度快</strong>（时间效率），<strong>占用内存小</strong>的优点（空间效率），但是有一定的<strong>误识别率</strong>和<strong>删除困难</strong>的问题。它只能告诉你某个元素一定不在集合内或可能在集合内。</p>
<p>布隆过滤器的特点如下：</p>
<ol>
<li>一个非常大<strong>的二进制位数组</strong> （数组里只有0和1）</li>
<li>若干个<strong>哈希函数</strong></li>
<li><strong>空间效率</strong>和<strong>查询效率高</strong></li>
<li>不存在<strong>漏报</strong>（False Negative）：某个元素在某个集合中，肯定能报出来。</li>
<li>可能存在<strong>误报</strong>（False Positive）：某个元素不在某个集合中，可能也被爆出来。</li>
<li>不提供删除方法，代码维护困难。</li>
<li>位数组初始化都为0，它不存元素的具体值，当元素经过哈希函数哈希后的值（也就是数组下标）对应的数组位置值改为1。</li>
</ol>
<p>布隆算法：通过错误率来换取空间的算法。是一个数据标识算法，内部是一个二进制位数组（<code>bitmap</code>）</p>
<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599377591613.png" class width="1599377591613">

<p>布隆过滤器会有一定的错误率，但是这个错误率在实际情况下影响并不大。如果它告诉你存在这个id值，但其实并不在，我们允许他去查询数据库，这点压力mysql还是可以承受得住的，不至于这么脆弱。</p>
<p>但是我们还是希望错误率越低越好，那么，错误率是什么引起的。刚刚说的hash碰撞，与数组的大小、hash函数有关系。</p>
<p>当数组越长，hash碰撞的概率就低。</p>
<p>还与hash函数的个数有关系，hash函数映射不同的hash值。</p>
<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599378161062.png" class width="1599378161062">

<p>只有当三个hash函数的值都相同的时候，才会发生hash碰撞。</p>
<p>并不是hash函数越多越好，很多hash函数的话，可能会导致不管传入的什么值，都会返回“存在”，这样的话错误率是越来越高的。所以要把握度。</p>
<p>如果未来客户端往是数据库中中提交信息，也是通过上面的流程，我们是在插入数据的时候在过滤器中标志数据还是先插入到数据库中，然后返回来标识呢？</p>
<p><strong>我们可以先插入到数据库中，然后通过异步的方式，设置一个时间，将新数据在过滤器上标识。</strong></p>
<p><strong>那么为什么不能删除元素呢？</strong></p>
<p>原因很简单，因为删除元素后，将对应元素的下标设置为零，可能别的元素的下标也引用改下标，这样别的元素的判断就会收到影响，原理图如下：</p>
<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599970639948.png" class width="1599970639948">

<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599970574625.png" class width="1599970574625">

<p>当你删除z元素之后，将对应的下标10和13设置为0，这样导致x和y元素的下标受到影响，导致数据的判断不准确，所以直接不提供删除元素的api。</p>
<h2 id="手写一个布隆过滤器"><a href="#手写一个布隆过滤器" class="headerlink" title="手写一个布隆过滤器"></a>手写一个布隆过滤器</h2><p>以上说的都是布隆过滤器的原理，只有理解了原理，在实际的运用才能如鱼得水，下面就来实操代码，手写一个简单的布隆过滤器。</p>
<p>对于要手写一个布隆过滤器，首先要明确布隆过滤器的核心：</p>
<ul>
<li>若干哈希函数</li>
<li>存值得Api</li>
<li>判断值得Api</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-09-13 12:18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 手写一个简单的布隆过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 布隆过滤器的 的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">2</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 模拟实现不同的hash函数</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">31</span>, <span class="number">47</span>, <span class="number">71</span>&#125;;</span><br><span class="line">    <span class="comment">// 初始化位数组</span></span><br><span class="line">    <span class="keyword">private</span> BitSet bits = <span class="keyword">new</span> BitSet(SIZE);</span><br><span class="line">    <span class="comment">// 用于存储Hash函数</span></span><br><span class="line">    <span class="keyword">private</span> MyHash[] hashFunc = <span class="keyword">new</span> MyHash[num.length];</span><br><span class="line">    <span class="comment">// 初始化hash函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BloomFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)&#123;</span><br><span class="line">            hashFunc[i] = <span class="keyword">new</span> MyHash(SIZE, num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// hash计算</span></span><br><span class="line">        <span class="keyword">for</span>(MyHash func : hashFunc)&#123;</span><br><span class="line">            <span class="comment">// 将为数组对应的哈希下标得位置得值改为1</span></span><br><span class="line">            bits.set(func.hash(value), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  判断是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(MyHash func : hashFunc)&#123;</span><br><span class="line">            res = res &amp;&amp; bits.get(func.hash(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BloomFilter filter = <span class="keyword">new</span> BloomFilter();</span><br><span class="line">        String value = <span class="string">&quot;4243212355312&quot;</span>;</span><br><span class="line">        System.out.println(filter.contains(value));</span><br><span class="line">        filter.add(value);</span><br><span class="line">        System.out.println(filter.contains(value));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">MyHash</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHash</span><span class="params">(<span class="keyword">int</span> cap, <span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = cap;</span><br><span class="line">        <span class="keyword">this</span>.seed = seed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = value.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len; i++)&#123;</span><br><span class="line">            res = seed * res + value.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (cap-<span class="number">1</span>) &amp; res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>false</p>
<p>true</p>
</blockquote>
<p>在实际项目中可以使用别人已经写好的布隆过滤器，比如谷歌的 <code>Google Guava</code>，只需要在项目中引入一下依赖： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>27.0.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> MyBloomFilterSysConfig &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     OrderMapper orderMapper</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 1.创建布隆过滤器  第二个参数为预期数据量10000000，第三个参数为错误率0.00001</span></span><br><span class="line">    BloomFilter&lt;CharSequence&gt; bloomFilter =  BloomFilter.create(Funnels.stringFunnel(Charset.forName(<span class="string">&quot;utf-8&quot;</span>)),<span class="number">10000000</span>, <span class="number">0.00001</span>);</span><br><span class="line">    <span class="comment">// 2.获取所有的订单，并将订单的id放进布隆过滤器里面</span></span><br><span class="line">    List&lt;Order&gt; orderList = orderMapper.findAll()</span><br><span class="line">    <span class="keyword">for</span> (Order order;orderList ) &#123;</span><br><span class="line">        Long id = order.getId();</span><br><span class="line">        bloomFilter.put(<span class="string">&quot;&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在实际项目中会启动一个<strong>系统任务</strong>或者<strong>定时任务</strong>，来初始化布隆过滤器，将热点查询数据的id放进布隆过滤器里面，当用户再次请求的时候，使用布隆过滤器进行判断该订单的id是否在布隆过滤器中存在，不存在直接返回null，具体操作代码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断订单id是否在布隆过滤器中存在</span></span><br><span class="line">bloomFilter.mightContain(<span class="string">&quot;&quot;</span> + id)</span><br></pre></td></tr></table></figure>

<p> 布隆过滤器的缺点就是要维持容器中的数据，因为订单数据肯定是频繁变化的，实时的要更新布隆过滤器中的数据为最新。</p>
<hr>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p> 这个跟<strong>缓存雪崩</strong>有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是<strong>缓存击穿</strong>是指<strong>一个Key</strong>非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。 </p>
<p>缓存击穿这里强调的是<strong>并发</strong>，造成缓存击穿的原因有以下两个：</p>
<ol>
<li>该数据没有人查询过 ，第一次就大并发的访问。（冷门数据）</li>
<li>添加到了缓存，<code>reids</code>有设置数据失效的时间 ，这条数据刚好失效，大并发访问（热点数据）</li>
</ol>
<p> <strong>缓存击穿</strong>的话，设置热点数据永远不过期。或者使用分布式锁解决。</p>
<p>但是是对于一般的场景来说，缓存击穿不需要去解决。因为mysql可以承受。</p>
<p>当用户出现<strong>大并发</strong>访问的时候，在查询缓存的时候和查询数据库的过程加锁，只能第一个进来的请求进行执行，当第一个请求把该数据放进缓存中，接下来的访问就会直接集中缓存，防止了<strong>缓存击穿</strong>。 </p>
<p>业界比价普遍的一种做法，即根据key获取value值为空时，锁上，从数据库中<code>load</code>数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。这里要注意，分布式环境中要使用<strong>分布式锁</strong>，<strong>单机</strong>的话用普通的锁（<code>synchronized</code>、<code>Lock</code>）就够了。 </p>
<p>单机版的锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取库存数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProduceNum</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;   <span class="comment">//加锁</span></span><br><span class="line">            <span class="comment">// 缓存中取数据，并存入缓存中</span></span><br><span class="line">            <span class="keyword">int</span> num= Integer.parseInt(redisTemplate.opsForValue().get(key));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (num&gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没查一次库存-1</span></span><br><span class="line">                redisTemplate.opsForValue().set(key, (num- <span class="number">1</span>) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;剩余的库存为num：&quot;</span> + (num- <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;库存为0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分布式锁可以使用Redisson来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProduceNum</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取分布式锁</span></span><br><span class="line">    RLock lock = redissonClient.getLock(key);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取库存数</span></span><br><span class="line">        <span class="keyword">int</span> num= Integer.parseInt(redisTemplate.opsForValue().get(key));  </span><br><span class="line">        <span class="comment">// 上锁           </span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">if</span> (num&gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//减少库存，并存入缓存中</span></span><br><span class="line">            redisTemplate.opsForValue().set(key, (num - <span class="number">1</span>) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;剩余库存为num：&quot;</span> + (num- <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;库存已经为0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>需要加锁的条件</p>
<ol>
<li>共享资源</li>
<li>共享资源互斥</li>
<li>多任务环境</li>
</ol>
<p>缺一不可。</p>
<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599379606795.png" class width="1599379606795">

<p>但是设置“保安”也可能会发生死锁，因为保安可能会挂。</p>
<p>考虑另一个场景，加入现在JVM1抢到了锁，可以去买票了，但是在买票的过程中，JVM1出现了GC，我们知道，GC的话用户线程会挂起，所以买票会休眠，如果GC时间大于“保安JVM”设置的时间，那么到时会收回锁，这时其他的JVM都可以获取锁，那么就可能出现两个JVM一起来买票。这样的话很可能出现一票多卖的问题。</p>
<p>那么，我们应该给“保安JVM”的超时时间多长合适呢？我们并不知道JVM休眠的时间多少，加入设置超时时间为1小时，那么在买票的第一秒钟宕机了的话，需要等待59分59秒才能获取锁，这样就无法在单位时间内卖出更多的票了。如果超时时间设置的比较短，那么可能会出现上面所说的JVM乱入的现象。所以超时时间的设置是比较重要的。</p>
<p>使用redis分布式锁的原因是redis天生具有有效期这个特性，就不用“保安JVM”了。但是基于redis来做的话还是会出现这个度的问题，超时时间。【后期看看redission框架】</p>
<p>我们一般使用<code>zookeeper</code>来设置分布式锁。</p>
<p>zookeeper是一个分布式的一致性服务。</p>
<p>总结一下分布式锁的解决思路：</p>
<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599380802827.png" class width="1599380802827">

<p>发生缓存击穿的时候，多个请求一起打在mysql，如果需要访问myslq的话，必须先获得分布式锁，先获取分布式锁的那个client先去mysql查询数据，然后缓存在redis中，之后的client就不需要再次抢分布式锁了，直接在redis缓存中去查询即可。这就是分布式锁解决缓存击穿的原理。</p>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p> 同一时间<strong>缓存大面积失效</strong>，那一瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的。</p>
<p><strong>导致缓存雪崩的原因：</strong></p>
<ol>
<li><strong>缓存数据的有效期是一致的， 造成缓存大面积失效</strong></li>
<li><strong>Redis宕机</strong></li>
</ol>
<p>对于缓存雪崩的解决方案有以下两种：</p>
<ol>
<li>搭建<strong>高可用</strong>的集群，防止单机的redis宕机。</li>
<li>设置不同的过期时间，防止同意之间内大量的key失效。</li>
</ol>
<p> 处理缓存雪崩简单，在批量往<strong>Redis</strong>存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效，我相信，Redis这点流量还是顶得住的。</p>
<p>如果Redis挂了，那么可以设置Redis集群。</p>
<p>Redis集群有<strong>切片集群</strong>和<strong>主从复制</strong></p>
<p>切片集群就是将热点数据分散放在各个服务器上</p>
<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599381394478.png" class width="1599381394478">

<p>主从复制的话就是每台服务器存放相同的数据</p>
<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599381436885.png" class width="1599381436885">



<h1 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h1><p>上面说的切片集群，当数据量很大的时候，建议这么做。但是我们不能做到每一台服务器上的数据都是平均的，可能会发生数据倾斜。假如现在新增一台服务器，我们需要从其他的服务器复制一部分数据给新的服务器，这样会发生大量的复制，在复制的过程中，redis服务器是无法提供服务的？？？（不能fork子进程去复制吗），那么就又会发生缓存雪崩的现象。</p>
<p>那么一致性Hash算法就可以解决<strong>集群动态扩展问题。</strong>内部是通过<strong>哈希环</strong>来实现的。</p>
<p>在实现分布式缓存的时候，我们怎么讲数据平均地去分配到redis服务器中？</p>
<p>加入现在redis集群中只有两台数据库。如下所示分配原理。</p>
<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599381984577.png" class width="1599381984577">

<p>假如新增一台服务器，hash函数应该%3 ，这时候需要将原来的数据的重新分配。这样会导致大量的数据迁移。原来能找的数据现在找不到了，导致大量的缓存失效，出现缓存雪崩的现象。那么可以使用一致性hash算法来解决。内部是通过<strong>哈希环</strong>来实现的。</p>
<h2 id="hash环"><a href="#hash环" class="headerlink" title="hash环"></a>hash环</h2><img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599382730796.png" class width="1599382730796">

<p>将数据和redis都映射到一个hash环上面，数据顺时针去寻找要存储的redis。</p>
<p>这样可以避免大量数据的迁移。但是还是可能会发生数据倾斜。</p>
<p>解决方法就是设置<strong>虚拟节点</strong>。</p>
<p>我们理想的环境是，让数据均匀地覆盖到每一台服务器上，但是使用一致性hash算法映射到hash环中很有可能是倾斜的。</p>
<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599383207694.png" class width="1599383207694">

<p>这样会导致大量的数据都缓存在redis1中，导致分局分布极度不均匀，机器没有平均地被使用。要想数据均匀分布到服务器上，很直观的想法就是让服务器的数量尽量多，且均匀地出现在hash环上面。</p>
<p>我们可以给每一个服务器设置许多虚拟节点。</p>
<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599383426423.png" class width="1599383426423">

<p>虚拟节点越多，就更有概率使其均匀分布在hash环上面。</p>
<p>具体缓存读写的时候先找到虚拟节点，然后在从虚拟节点找到真实redis服务器实现读写。这样就解决了数据倾斜的问题。</p>
<img src="/2020/09/06/redis%E6%B7%B1%E5%85%A5/1599383545962.png" class width="1599383545962">



<p>最后，解决几个问题。</p>
<h2 id="一致性hash的性质"><a href="#一致性hash的性质" class="headerlink" title="一致性hash的性质"></a>一致性hash的性质</h2><h3 id="平衡性"><a href="#平衡性" class="headerlink" title="平衡性"></a>平衡性</h3><p>也就是hash的结果应该尽可能分散，避免出现过多的hash碰撞。</p>
<h3 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h3><p>所谓单调性也就是指，当有新的节点增加的时候，旧数据的寻找方式应该一致，即按照原来的方式找到数据所对应的服务器，而新数据可以按照新的散列算法找到服务器。</p>
<p>如果不单调的话，当新的节点 增加的时候，导致所有的数据都需要重新计算，这样会有大量的数据迁移，开销很大。</p>
<h3 id="分散性"><a href="#分散性" class="headerlink" title="分散性"></a>分散性</h3><p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </p>
<h3 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h3><p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。 </p>
<h3 id="平滑性-Smoothness"><a href="#平滑性-Smoothness" class="headerlink" title="平滑性(Smoothness)"></a>平滑性(Smoothness)</h3><p>平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</p>
<h2 id="hash环上是怎么定位所在的服务器的"><a href="#hash环上是怎么定位所在的服务器的" class="headerlink" title="hash环上是怎么定位所在的服务器的"></a>hash环上是怎么定位所在的服务器的</h2><p>定位数据存储在哪台服务器的方法为：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器</p>
<p><strong>可以为这些服务器维护一条二分查找树，定位服务器的过程就是在二分查找树中找刚好比其大的节点。</strong> </p>
<p>如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。</p>
<p>在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。 </p>
<p>综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的<strong>容错性和可扩展性。</strong> </p>
<h2 id="假如出现数据倾斜怎么办"><a href="#假如出现数据倾斜怎么办" class="headerlink" title="假如出现数据倾斜怎么办"></a>假如出现数据倾斜怎么办</h2><p>当服务节点太少的话，很容易因为节点分布不均匀而造成数据倾斜问题。</p>
<p>一致性hash算法引入了虚拟节点机制。 即对每一个服务节点计算多个哈希（可以用原节点key+”##xxxk”作为每个虚拟节点的key，然后求hashcode）， 每个计算结果位置都放置一个此服务节点，称为虚拟节点。</p>
<p>具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点。</p>
<p>数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。 </p>
<p> 一致性hash算法在分布式环境中应用的很广，只要是涉及到分布式存储的负载均衡问题，一致性hash都是很好的解决的方案。 </p>
<h2 id="Hash环是一个什么数据结构"><a href="#Hash环是一个什么数据结构" class="headerlink" title="Hash环是一个什么数据结构"></a>Hash环是一个什么数据结构</h2><p>我们知道，一致性hash算法是基于hash环来实现的，怎么构造一个$ 2^{32}$ 的整数环？然后根据节点名称的hash值将服务器节点放置在这个hash环中。应该选用什么样的数据结构，才能使得时间复杂度最低？</p>
<p>最直观的考虑，是使用一个list，而且是有序的。每次按照顺序去找数据所对应的服务节点。时间复杂度为O(N)。</p>
<p>如果采用二叉查找树，查找的时间复杂度可以为O(logN）。但是不能简单使用一般的二叉树，因为在最坏的情况下，可能会链化。时间复杂度退化为O(N)。</p>
<p>我们可以使用AVL树或者红黑树。</p>
<p>使用红黑树的原因如下：</p>
<ol>
<li><p>因为红黑树本身主要的作用就是存储有序的数据，这其实和第一种方案想一块去了，但是效率比使用list效率快多了。</p>
</li>
<li><p>JDK中提供了红黑树的数据结构代码实现 TreeMap和TreeSet。</p>
<p>以TreeMap为例，TreeMap本身提供了一个<code>tailMap</code>(K fromKey)方法，支持从红黑树中查找比fromKey大的值的集合，但并不需要遍历整个数据结构，然后再从集合中取第一个即可，更方便的TreeMap提供了<code>higherKey</code>(k key)，可以直接获取第一个比参数key大的对象，这里要注意的是，如果tailMap.isEmpty()==true或higherkey返回null，代表数据在环的末端，这时应该取tailMap中最小的元素作为存储服务器，即tailMap.firstKey()。 </p>
</li>
</ol>
<h2 id="虚拟节点是怎么和物理节点对应的"><a href="#虚拟节点是怎么和物理节点对应的" class="headerlink" title="虚拟节点是怎么和物理节点对应的"></a>虚拟节点是怎么和物理节点对应的</h2><p>加入节点A的key为keyA，我们可以循环生成若干个虚拟节点，key分别为keyA##VN0、keyA##VN1、keyA##VN2…..keyA##VNn。然后采用上面的hash算法分别求这些虚拟节点的hashcode，然后放入hash环中（即TreeMap中），定位数据所属的服务器节点时，假设返回keyA##VNk，则通过截取可以获取物理节点keyA。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247492908&idx=2&sn=c267f0a64a0351c04ec90aee67adea53&chksm=9bf75599ac80dc8f4dd0c0c7e26d02687d9b2d09c65e31cbbe93e7538141a31717ddb092d3d0&mpshare=1&scene=24&srcid=0910zUE11c03LEUNb2MMQlcQ&sharer_sharetime=1599710287928&sharer_shareid=aeb401628295afea2c86016b3d2e688a&key=c3402f98b9ff36461430d990546f29bfee944ed635248dc88054dbf8009b06d8618ec57a50704ad9bb8a909c006789d1e5b3746ef9e424bc694da2f72645940c7643236ec0f2c6161f1529cd0b7766464850db79ab9570fb2ad0b0a7f3e3dcb4648db6b2d653b7497ff50dc767275e4a8c36f99b2e92233b4fca409ac156c633&ascene=14&uin=MjY3ODQ2NDEwMA==&devicetype=Windows+10+x64&version=62090538&lang=zh_CN&exportkey=AdPC4RHJGpcux7aZXd97k0Y=&pass_ticket=i7dXOrdw4RePybTZOo6ZJhWekdu7HluH0I8XZTjYjDnJGqh1XgpinBI8xO777jWR&wx_header=0">一不小心肝出了4W字的Redis面试教程</a></li>
<li><a href="https://blog.csdn.net/wudiyong22/article/details/78687246">https://blog.csdn.net/wudiyong22/article/details/78687246</a></li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的Value类型及其应用场景</title>
    <url>/2020/09/13/redis%E7%9A%84Value%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>字符串类型，也可以进行数值计算，bitmap也属于String。</p>
<img src="/2020/09/13/redis%E7%9A%84Value%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/1599395860254.png" class width="1599395860254">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> a hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>String类型的数据结构存储方式有三种<code>int、raw、embstr</code>。那么这三种存储方式有什么区别 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 345</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding k1</span><br><span class="line"><span class="string">&quot;int&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 3.2000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding k2</span><br><span class="line"><span class="string">&quot;embstr&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>Redis中规定假如存储的是<strong>整数型值</strong>，比如<code>set num 123</code>这样的类型，就会使用 int的存储方式进行存储，在redisObject的<strong>ptr属性</strong>中就会保存该值。 </p>
<p>假如存储的<strong>字符串是一个字符串值并且长度大于32个字节</strong>就会使用<code>SDS（simple dynamic string）</code>方式进行存储，并且encoding设置为raw；若是<strong>字符串长度小于等于32个字节</strong>就会将encoding改为embstr来保存字符串.</p>
<p> SDS称为<strong>简单动态字符串</strong>，对于SDS中的定义在Redis的源码中有的三个属性<code>int len、int free、char buf[]</code>。  len保存了字符串的长度，free表示buf数组中未使用的字节数量，buf数组则是保存字符串的每一个字符元素。 </p>
<img src="/2020/09/13/redis%E7%9A%84Value%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/1599892180794.png" class width="1599892180794">

<p>SDS与C语言字符串有什么区别呢？</p>
<p>Redis没有使用C语言的字符串，而是自己定义和设计了自己的字符串类型，具有很多优势、</p>
<ol>
<li><p>C语言的字符串类型没有len属性，如果要获得字符串的长度只能遍历一遍去统计，时间复杂度为O(n)。而Redis中的SDS有len这个属性，直接返回len值就行，时复为O(1)。</p>
</li>
<li><p>C语言两个字符串拼接如果没有分配足够长度的空间的话，会出现缓冲区溢出的情况。而redis会先根据 len的属性判断空间是否满足要求，空间不够时会相应扩展，不会缓冲区溢出。</p>
<p> 具体的空间预分配原则是：<strong>当修改字符串后的长度len小于1MB，就会预分配和len一样长度的空间，即len=free；若是len大于1MB，free分配的空间大小就为1MB</strong>。 </p>
</li>
<li><p>SDS有空间预分配和惰性空间释放两种策略。在为字符串分配空间的时候，分配的空间比实际要多。能<strong>减少连续的执行字符串增长带来内存重新分配的次数</strong> 。</p>
</li>
<li><p> 当字符串被<strong>缩短</strong>的时候，SDS也不会立即回收不适用的空间，而是通过<code>free</code>属性将不使用的空间记录下来，等后面使用的时候再释放。 </p>
</li>
<li><p>SDS是二进制安全的，除了可以储存字符串以外还可以储存二进制文件（如图片、音频，视频等文件的二进制数据）；而c语言中的字符串是以空字符串作为结束符，一些图片中含有结束符，因此不是二进制安全的。 </p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">c语言字符串</th>
<th align="left">SDS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取长度的时间复杂度为O(n)</td>
<td align="left">获取长度的时间复杂度为O(1)</td>
</tr>
<tr>
<td align="left">不是二进制安全的</td>
<td align="left">是二进制安全的</td>
</tr>
<tr>
<td align="left">只能保存字符串</td>
<td align="left">还可以保存二进制数据</td>
</tr>
<tr>
<td align="left">n次增长字符串必然会带来n次的内存分配</td>
<td align="left">n次增长字符串内存分配的次数&lt;=n</td>
</tr>
</tbody></table>
<h2 id="VFS-虚拟文件系统"><a href="#VFS-虚拟文件系统" class="headerlink" title="VFS 虚拟文件系统"></a>VFS 虚拟文件系统</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> /root/user/video a.ma4</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get /root/user/video</span><br><span class="line"><span class="string">&quot;a.ma4&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 4</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECR k1</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBY k1 5</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;8&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="strlen-计算的是字节数"><a href="#strlen-计算的是字节数" class="headerlink" title="strlen 计算的是字节数"></a>strlen 计算的是字节数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 a</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; STRLEN a</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; APPEND k1 xxoo</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; APPEND k1 朱</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;axxoo\xe6\x9c\xb1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; strlen k1</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><p>是一个二进制位</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT k1 1 1 <span class="comment"># 0 1 0 0 0 0 0 0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;@&quot;</span> <span class="comment"># 表示是ASCII码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT k1 7 1   <span class="comment"># 0 1 0 0 0 0 0 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;A&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SETBIT k2 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT k2 6 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;B&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="与或操作"><a href="#与或操作" class="headerlink" title="与或操作"></a>与或操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BITOP and andkey k1 k2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get andkey</span><br><span class="line"><span class="string">&quot;@&quot;</span></span><br><span class="line"><span class="comment"># 0 1 0 0 0 0 0 1</span></span><br><span class="line"> <span class="comment"># 0 1 0 0 0 0 1 0</span></span><br><span class="line"> <span class="comment"># --&gt; 0 1 0 0 0 0 0 0   @</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 127.0.0.1:6379&gt; BITOP or  orkey k1 k2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get orkey</span><br><span class="line"><span class="string">&quot;C&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果设置的位数很大，会自动进行字节拓宽</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SETBIT k1 9999 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; STRLEN k1</span><br><span class="line">(<span class="built_in">integer</span>) 1250</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h2 id="bitcount统计1的个数"><a href="#bitcount统计1的个数" class="headerlink" title="bitcount统计1的个数"></a>bitcount统计1的个数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BITCOUNT k1 0 0</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT k1 0 -1</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<h2 id="bitmap的应用场景"><a href="#bitmap的应用场景" class="headerlink" title="bitmap的应用场景"></a>bitmap的应用场景</h2><h3 id="用户统计"><a href="#用户统计" class="headerlink" title="用户统计"></a>用户统计</h3><p>需求： 统计任意时间窗 统计用户的登录天数</p>
<p>使用bitmap来做。</p>
<p>比如统计一年内用户的登录天数，可以创建一个365位的bitmap，用户在哪一天登陆了，就将对应的位置为1，然后使用bitcount来统计1的个数，即为用户的登录总天数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT hongliang 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT hongliang 364  1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT hongliang 0 -1</span><br><span class="line">(<span class="built_in">integer</span>) 2  <span class="comment"># 两天</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; STRLEN hongliang</span><br><span class="line">(<span class="built_in">integer</span>) 46  <span class="comment"># 只消耗了46个字节就能存储一年的时间</span></span><br></pre></td></tr></table></figure>

<h3 id="京东618只要用户登录就送一个礼物"><a href="#京东618只要用户登录就送一个礼物" class="headerlink" title="京东618只要用户登录就送一个礼物"></a>京东618只要用户登录就送一个礼物</h3><p>假设京东有2个亿个用户，那么我们需要准备多少份礼物。</p>
<p>用户分为活跃用户和僵尸用户，我们应该为活跃用户准备礼物。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT 20200101 2 1  <span class="comment"># 2020年1月1日，用户3登陆了</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT 20200101 6 1 <span class="comment"># 2020年1月1日，用户7登陆了</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; SETBIT 20200102 6 1 <span class="comment"># 2020年1月2日，用户7登陆了</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>这样设计，我们可以看出， 1月1日和1月2日两天只有两个用户登陆了，我们可以使用或运算来得出2.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BITOP or res 20200101  20200102</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT res 0 -1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>

<h3 id="12306"><a href="#12306" class="headerlink" title="12306"></a>12306</h3><p>12306买票问题</p>
<img src="/2020/09/13/redis%E7%9A%84Value%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/1599398206186.png" class width="1599398206186">

<p>将座位的情况缓存到redis中，每一个站的座位情况使用bitmap来处理。</p>
<p>假如客户P买了从A-B的车票，客户Q想买A-D的车票，那么只需要将ABCD四个站的bitmap进行或运算即可，为0的那个座位才能买。</p>
<h3 id="linux权限管理"><a href="#linux权限管理" class="headerlink" title="linux权限管理"></a>linux权限管理</h3><p>chmod 777  </p>
<p>rwx rwx rwx 持有者  持有组  其他人 任何人都有权限</p>
<p>三个位分别表示421</p>
<p>000 = 0</p>
<p>111=  7</p>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p> Redis中的列表在3.2之前的版本是使用<code>ziplist</code>和<code>linkedlist</code>进行实现的。在3.2之后的版本就是引入了<code>quicklist</code>。 </p>
<p>linkedlist是一个双向链表。quicklist底层也是采用链表实现的。</p>
<p><strong>Redis中链表的特性：</strong></p>
<ol>
<li>每一个节点都有指向前一个节点和后一个节点的指针。</li>
<li>头节点和尾节点的prev和next指针指向为null，所以链表是无环的。</li>
<li>链表有自己长度的信息，获取长度的时间复杂度为O(1)。</li>
</ol>
<h2 id="数据结构使用"><a href="#数据结构使用" class="headerlink" title="数据结构使用"></a>数据结构使用</h2><p>lpush  队列</p>
<p>rpop 栈</p>
<p>LinkedList 双向链表</p>
<p>lindex 数组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH k1 a b c d e</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; LRANGE k1 0 -1</span><br><span class="line">1) <span class="string">&quot;e&quot;</span></span><br><span class="line">2) <span class="string">&quot;d&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">4) <span class="string">&quot;b&quot;</span></span><br><span class="line">5) <span class="string">&quot;a&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX k1 2</span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpush k1 x y z</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; LRANGE k1 0 -1</span><br><span class="line">1) <span class="string">&quot;e&quot;</span></span><br><span class="line">2) <span class="string">&quot;d&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">4) <span class="string">&quot;b&quot;</span></span><br><span class="line">5) <span class="string">&quot;a&quot;</span></span><br><span class="line">6) <span class="string">&quot;x&quot;</span></span><br><span class="line">7) <span class="string">&quot;y&quot;</span></span><br><span class="line">8) <span class="string">&quot;z&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpop k1</span><br><span class="line"><span class="string">&quot;z&quot;</span></span><br></pre></td></tr></table></figure>

<p>ltrim 保留数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE k1 0 -1</span><br><span class="line">1) <span class="string">&quot;e&quot;</span></span><br><span class="line">2) <span class="string">&quot;d&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">4) <span class="string">&quot;b&quot;</span></span><br><span class="line">5) <span class="string">&quot;a&quot;</span></span><br><span class="line">6) <span class="string">&quot;x&quot;</span></span><br><span class="line">7) <span class="string">&quot;y&quot;</span></span><br><span class="line">8) <span class="string">&quot;z&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpop k1</span><br><span class="line"><span class="string">&quot;z&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LTRIM k1 0 3 <span class="comment"># 保留0-3的数据，其他的都删除</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE k1 0 -1</span><br><span class="line">1) <span class="string">&quot;e&quot;</span></span><br><span class="line">2) <span class="string">&quot;d&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">4) <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p> 结合lpush和brpop命令就可以实现。生产者使用lupsh从列表的左侧插入元素，消费者使用brpop命令从队列的右侧获取元素进行消费。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.redismessage.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisStandaloneConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-09-12 15:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.pool.max-active&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxActive;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.pool.max-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.pool.min-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.pool.max-wait&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxWait;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.database&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> database;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisPoolConfig <span class="title">getRedisConfiguration</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(maxActive);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(maxIdle);</span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(maxWait);</span><br><span class="line">        <span class="keyword">return</span> jedisPoolConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">getRedisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisStandaloneConfiguration redisStandaloneConfiguration = <span class="keyword">new</span> RedisStandaloneConfiguration();</span><br><span class="line">        redisStandaloneConfiguration.setHostName(host);</span><br><span class="line">        redisStandaloneConfiguration.setPort(port);</span><br><span class="line">        redisStandaloneConfiguration.setDatabase(database);</span><br><span class="line">        JedisPoolConfig jedisPoolConfig= getRedisConfiguration();</span><br><span class="line"><span class="comment">//        redisStandaloneConfiguration.setPoolConfig(jedisPoolConfig);</span></span><br><span class="line"></span><br><span class="line">        JedisConnectionFactory factory = <span class="keyword">new</span> JedisConnectionFactory(redisStandaloneConfiguration);</span><br><span class="line">        factory.setPoolConfig(jedisPoolConfig);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;?, ?&gt; getRedisTemplate() &#123;</span><br><span class="line">        JedisConnectionFactory factory = getRedisConnectionFactory();</span><br><span class="line">        RedisTemplate&lt;?, ?&gt; redisTemplate = <span class="keyword">new</span> StringRedisTemplate(factory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-09-12 15:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存消息到消息队列中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lPushMessage</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().leftPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从消息队列中弹出消息 - &lt;rpop：非阻塞式&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">rPopMessage</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().rightPop(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getMessage</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>Hash对象的实现方式有两种，分别是ziplist、hashtable；</p>
<h2 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h2><p>压缩列表<code>（ziplist）</code>是一组连续内存块组成的顺序的数据结构，压缩列表能够节省空间，压缩列表中使用多个节点来存储数据。</p>
<p>压缩列表是列表键和哈希键底层实现的原理之一，<strong>压缩列表并不是以某种压缩算法进行压缩存储数据，而是它表示一组连续的内存空间的使用，节省空间</strong>，压缩列表的内存结构图如下：</p>
<img src="/2020/09/13/redis%E7%9A%84Value%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/1599895721527.png" class width="1599895721527">

<p>压缩列表中每一个节点表示的含义如下所示：</p>
<ol>
<li><code>zlbytes</code>：4个字节的大小，记录压缩列表占用内存的字节数。</li>
<li><code>zltail</code>：4个字节大小，记录表尾节点距离起始地址的偏移量，用于快速定位到尾节点的地址。</li>
<li><code>zllen</code>：2个字节的大小，记录压缩列表中的节点数。</li>
<li><code>entry</code>：表示列表中的每一个节点。</li>
<li><code>zlend</code>：表示压缩列表的特殊结束符号<code>&#39;0xFF&#39;</code>。</li>
</ol>
<p>再压缩列表中每一个entry节点又有三部分组成，包括<code>previous_entry_ength、encoding、content</code>。</p>
<ol>
<li><code>previous_entry_ength</code>表示前一个节点entry的长度，可用于计算前一个节点的其实地址，因为他们的地址是连续的。</li>
<li>encoding：这里保存的是content的内容类型和长度。</li>
<li>content：content保存的是每一个节点的内容。</li>
</ol>
<h2 id="用法类似HashMap"><a href="#用法类似HashMap" class="headerlink" title="用法类似HashMap"></a>用法类似HashMap</h2><p>类似HashMap， 用法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> @<span class="built_in">hash</span></span><br><span class="line"></span><br><span class="line">  HDEL key field [field ...]</span><br><span class="line">  summary: Delete one or more <span class="built_in">hash</span> fields</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HEXISTS key field</span><br><span class="line">  summary: Determine <span class="keyword">if</span> a <span class="built_in">hash</span> field exists</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HGET key field</span><br><span class="line">  summary: Get the value of a <span class="built_in">hash</span> field</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HGETALL key</span><br><span class="line">  summary: Get all the fields and values <span class="keyword">in</span> a <span class="built_in">hash</span></span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HINCRBY key field increment</span><br><span class="line">  summary: Increment the <span class="built_in">integer</span> value of a <span class="built_in">hash</span> field by the given number</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HINCRBYFLOAT key field increment</span><br><span class="line">  summary: Increment the <span class="built_in">float</span> value of a <span class="built_in">hash</span> field by the given amount</span><br><span class="line">  since: 2.6.0</span><br><span class="line"></span><br><span class="line">  HKEYS key</span><br><span class="line">  summary: Get all the fields <span class="keyword">in</span> a <span class="built_in">hash</span></span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HLEN key</span><br><span class="line">  summary: Get the number of fields <span class="keyword">in</span> a <span class="built_in">hash</span></span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HMGET key field [field ...]</span><br><span class="line">  summary: Get the values of all the given <span class="built_in">hash</span> fields</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HMSET key field value [field value ...]</span><br><span class="line">  summary: Set multiple <span class="built_in">hash</span> fields to multiple values</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">  summary: Incrementally iterate <span class="built_in">hash</span> fields and associated values</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  HSET key field value</span><br><span class="line">  summary: Set the string value of a <span class="built_in">hash</span> field</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HSETNX key field value</span><br><span class="line">  summary: Set the value of a <span class="built_in">hash</span> field, only <span class="keyword">if</span> the field does not exist</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  HSTRLEN key field</span><br><span class="line">  summary: Get the length of the value of a <span class="built_in">hash</span> field</span><br><span class="line">  since: 3.2.0</span><br><span class="line"></span><br><span class="line">  HVALS key</span><br><span class="line">  summary: Get all the values <span class="keyword">in</span> a <span class="built_in">hash</span></span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置和获取数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset k1 name tom</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET k1 age 12</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HVALS k1  <span class="comment"># 获取value</span></span><br><span class="line">1) <span class="string">&quot;tom&quot;</span></span><br><span class="line">2) <span class="string">&quot;12&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HKEYS k1 <span class="comment"># 获取key</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HGET k1 name <span class="comment"># 获取指定key的value值</span></span><br><span class="line"><span class="string">&quot;tom&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HGET k1 age</span><br><span class="line"><span class="string">&quot;12&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; HINCRBY k1 age 3 <span class="comment"># 数值计算</span></span><br><span class="line">(<span class="built_in">integer</span>) 15</span><br><span class="line">127.0.0.1:6379&gt; HVALS k1</span><br><span class="line">1) <span class="string">&quot;tom&quot;</span></span><br><span class="line">2) <span class="string">&quot;15&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>商品详情页</li>
<li>聚合场景</li>
<li>用户数据管理</li>
<li>存储用户的信息： 用户id作为key，其他信息作为value</li>
<li>hash也可以用作高并发场景下使用Redis生成唯一的id。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// offset表示的是id的递增梯度值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">(String key,String hashKey,Long offset)</span> <span class="keyword">throws</span> BusinessException</span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == offset) &#123;</span><br><span class="line">              offset=<span class="number">1L</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 生成唯一id</span></span><br><span class="line">          <span class="keyword">return</span> redisUtil.increment(key, hashKey, offset);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">//若是出现异常就是用uuid来生成唯一的id值</span></span><br><span class="line">          <span class="keyword">int</span> randNo=UUID.randomUUID().toString().hashCode();</span><br><span class="line">          <span class="keyword">if</span> (randNo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              randNo=-randNo;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Long.valueOf(String.format(<span class="string">&quot;%16d&quot;</span>, randNo));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>是一个无序的集合，不允许添加重复元素。 Set的底层实现是<strong>ht和intset</strong>，ht（哈希表）前面已经详细了解过，下面我们来看看intset类型的存储结构。 </p>
<p>intset也叫做整数集合，用于保存整数值的数据结构类型，它可以保存<code>int16_t</code>、<code>int32_t</code> 或者<code>int64_t</code> 的整数值。</p>
<p>在整数集合中，有三个属性值<code>encoding、length、contents[]</code>，分别表示编码方式、整数集合的长度、以及元素内容，length就是记录contents里面的大小。</p>
<p>在整数集合新增元素的时候，若是超出了原集合的长度大小，就会对集合进行升级，具体的升级过程如下：</p>
<ol>
<li>首先扩展底层数组的大小，并且数组的类型为新元素的类型。</li>
<li>然后将原来的数组中的元素转为新元素的类型，并放到扩展后数组对应的位置。</li>
<li>整数集合升级后就不会再降级，编码会一直保持升级后的状态。</li>
</ol>
<h2 id="无序去重"><a href="#无序去重" class="headerlink" title="无序去重"></a>无序去重</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd k1 a b c d a c</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS k1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;d&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h2 id="SRANDMEMBER随机返回元素"><a href="#SRANDMEMBER随机返回元素" class="headerlink" title="SRANDMEMBER随机返回元素"></a>SRANDMEMBER随机返回元素</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SRANDMEMBER k1 2</span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER k1 4</span><br><span class="line">1) <span class="string">&quot;d&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure>

<p>返回的是一个集合，如果是正数，则返回的是一个不重复的集合，如果是负数，则可能会返回重复的集合。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SRANDMEMBER k1 -3</span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER k1 -3</span><br><span class="line">1) <span class="string">&quot;d&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;d&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER k1 -3</span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;a&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER k1 -3</span><br><span class="line">1) <span class="string">&quot;d&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER k1 -8  <span class="comment"># 负数的话会有重复数据</span></span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;d&quot;</span></span><br><span class="line">5) <span class="string">&quot;b&quot;</span></span><br><span class="line">6) <span class="string">&quot;d&quot;</span></span><br><span class="line">7) <span class="string">&quot;a&quot;</span></span><br><span class="line">8) <span class="string">&quot;d&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li><p>抽奖</p>
</li>
<li><p>随机事件</p>
</li>
<li><p>并查集（共同好友）</p>
</li>
<li><p>推荐系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SADD k1 a b c d e</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; SADD k2 b f c d r</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; SUNION k1 k2  <span class="comment"># 并集</span></span><br><span class="line">1) <span class="string">&quot;r&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;d&quot;</span></span><br><span class="line">5) <span class="string">&quot;f&quot;</span></span><br><span class="line">6) <span class="string">&quot;a&quot;</span></span><br><span class="line">7) <span class="string">&quot;e&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER k1 k2 <span class="comment"># 交集 （共同好友）</span></span><br><span class="line">1) <span class="string">&quot;d&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SDIFF k1 k2  <span class="comment"># k1-k2 (减去k2中之后的)</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;e&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SDIFF k2 k1 <span class="comment"># k2-k1</span></span><br><span class="line">1) <span class="string">&quot;f&quot;</span></span><br><span class="line">2) <span class="string">&quot;r&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h1><p>有序集合，通过score来排序。 ZSet的底层实现是<code>ziplist</code>和<code>skiplist</code> </p>
<p> <code>skiplist</code>也叫做<strong>跳跃表</strong>，跳跃表是一种有序的数据结构，它通过每一个节点维持多个指向其它节点的指针，从而达到快速访问的目的。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BZPOPMAX key [key ...] timeout</span><br><span class="line">  summary: Remove and <span class="built_in">return</span> the member with the highest score from one or more sorted sets, or block until one is available</span><br><span class="line">  since: 5.0.0</span><br><span class="line"></span><br><span class="line">  BZPOPMIN key [key ...] timeout</span><br><span class="line">  summary: Remove and <span class="built_in">return</span> the member with the lowest score from one or more sorted sets, or block until one is available</span><br><span class="line">  since: 5.0.0</span><br><span class="line"></span><br><span class="line">  ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</span><br><span class="line">  summary: Add one or more members to a sorted <span class="built_in">set</span>, or update its score <span class="keyword">if</span> it already exists</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZCARD key</span><br><span class="line">  summary: Get the number of members <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZCOUNT key min max</span><br><span class="line">  summary: Count the members <span class="keyword">in</span> a sorted <span class="built_in">set</span> with scores within the given values</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZINCRBY key increment member</span><br><span class="line">  summary: Increment the score of a member <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Intersect multiple sorted sets and store the resulting sorted <span class="built_in">set</span> <span class="keyword">in</span> a new key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZLEXCOUNT key min max</span><br><span class="line">  summary: Count the number of members <span class="keyword">in</span> a sorted <span class="built_in">set</span> between a given lexicographical range</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZPOPMAX key [count]</span><br><span class="line">  summary: Remove and <span class="built_in">return</span> members with the highest scores <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">  since: 5.0.0</span><br><span class="line"></span><br><span class="line">  ZPOPMIN key [count]</span><br><span class="line">  summary: Remove and <span class="built_in">return</span> members with the lowest scores <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">  since: 5.0.0</span><br><span class="line"></span><br><span class="line">  ZRANGE key start stop [WITHSCORES]</span><br><span class="line">  summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by index</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by lexicographical range</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by score</span><br><span class="line">  since: 1.0.5</span><br><span class="line"></span><br><span class="line">  ZRANK key member</span><br><span class="line">  summary: Determine the index of a member <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZREM key member [member ...]</span><br><span class="line">  summary: Remove one or more members from a sorted <span class="built_in">set</span></span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYLEX key min max</span><br><span class="line">  summary: Remove all members <span class="keyword">in</span> a sorted <span class="built_in">set</span> between the given lexicographical range</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYRANK key start stop</span><br><span class="line">  summary: Remove all members <span class="keyword">in</span> a sorted <span class="built_in">set</span> within the given indexes</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZREMRANGEBYSCORE key min max</span><br><span class="line">  summary: Remove all members <span class="keyword">in</span> a sorted <span class="built_in">set</span> within the given scores</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line">  summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by index, with scores ordered from high to low</span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by lexicographical range, ordered from higher to lower strings.</span><br><span class="line">  since: 2.8.9</span><br><span class="line"></span><br><span class="line">  ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span><br><span class="line">  summary: Return a range of members <span class="keyword">in</span> a sorted <span class="built_in">set</span>, by score, with scores ordered from high to low</span><br><span class="line">  since: 2.2.0</span><br><span class="line"></span><br><span class="line">  ZREVRANK key member</span><br><span class="line">  summary: Determine the index of a member <span class="keyword">in</span> a sorted <span class="built_in">set</span>, with scores ordered from high to low</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br><span class="line">  ZSCAN key cursor [MATCH pattern] [COUNT count]</span><br><span class="line">  summary: Incrementally iterate sorted sets elements and associated scores</span><br><span class="line">  since: 2.8.0</span><br><span class="line"></span><br><span class="line">  ZSCORE key member</span><br><span class="line">  summary: Get the score associated with the given member <span class="keyword">in</span> a sorted <span class="built_in">set</span></span><br><span class="line">  since: 1.2.0</span><br><span class="line"></span><br><span class="line">  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</span><br><span class="line">  summary: Add multiple sorted sets and store the resulting sorted <span class="built_in">set</span> <span class="keyword">in</span> a new key</span><br><span class="line">  since: 2.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD k1 4 apple 3.2 banana 1.6 orange</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;orange&quot;</span></span><br><span class="line">2) <span class="string">&quot;1.6000000000000001&quot;</span></span><br><span class="line">3) <span class="string">&quot;banana&quot;</span></span><br><span class="line">4) <span class="string">&quot;3.2000000000000002&quot;</span></span><br><span class="line">5) <span class="string">&quot;apple&quot;</span></span><br><span class="line">6) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE k1 0 -1</span><br><span class="line">1) <span class="string">&quot;orange&quot;</span></span><br><span class="line">2) <span class="string">&quot;banana&quot;</span></span><br><span class="line">3) <span class="string">&quot;apple&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREVRANGE k1 0 -1 withscores  <span class="comment"># 反转排序</span></span><br><span class="line">1) <span class="string">&quot;apple&quot;</span></span><br><span class="line">2) <span class="string">&quot;4&quot;</span></span><br><span class="line">3) <span class="string">&quot;banana&quot;</span></span><br><span class="line">4) <span class="string">&quot;3.2000000000000002&quot;</span></span><br><span class="line">5) <span class="string">&quot;orange&quot;</span></span><br><span class="line">6) <span class="string">&quot;1.600000000000000</span></span><br></pre></td></tr></table></figure>

<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><p>动态的排行榜。</p>
<h3 id="有序事件"><a href="#有序事件" class="headerlink" title="有序事件"></a>有序事件</h3><h3 id="评论-分页"><a href="#评论-分页" class="headerlink" title="评论+分页"></a>评论+分页</h3><h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><p>跳跃表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> k1</span><br><span class="line">zset</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding k1</span><br><span class="line"><span class="string">&quot;ziplist&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到并不是我们所说的跳表，而是一个list，这是因为我们的元素比较少。</p>
<p>如果我们的元素数量很多或者某个元素的值很大的话，则会使用跳表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZADD k1 99 saddddddddkakjfhkashfkaskfhkahsfkjahkjfawoiffahkfnakshfakkshfffffffffffffffffffffffffffffffaoifafskaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; OBJECT encoding k1</span><br><span class="line"><span class="string">&quot;skiplist&quot;</span>  <span class="comment"># 跳表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247492908&idx=2&sn=c267f0a64a0351c04ec90aee67adea53&chksm=9bf75599ac80dc8f4dd0c0c7e26d02687d9b2d09c65e31cbbe93e7538141a31717ddb092d3d0&mpshare=1&scene=24&srcid=0910zUE11c03LEUNb2MMQlcQ&sharer_sharetime=1599710287928&sharer_shareid=aeb401628295afea2c86016b3d2e688a&key=ef51a5b0b69d9d306c00f4abee9eddaa00e68d39087cfe78143ce430aa51865e29531fc0369a864483b4023425c1a9b85f74b539312eb29777b1e08deaf2ea3b704c0d7a80f70fb15d926645afee7be6241ba170b4f95a4ed259f0b4434990df5bd726cde37d04eae3183132432a0fb84f501dca309f42345a14df02ba595982&ascene=14&uin=MjY3ODQ2NDEwMA==&devicetype=Windows+10+x64&version=62090538&lang=zh_CN&exportkey=AUCwPrWXBVeQJVbPfd1FKjk=&pass_ticket=Kicr60fAH6+pfbmVo4a6oA/jHmaq6ZwlT93eWQKZrwNyGN/Oj6siyPl6l0ivyzOl&wx_header=0">一不小心肝出了4W字的Redis面试教程</a></li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP面向切面编程？你懂了吗？</title>
    <url>/2020/06/26/spring02-aop/</url>
    <content><![CDATA[<h1 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h1><p>什么是<code>aop</code>(Aspect Oriented Programming ),  翻译过来就是“面向切面编程”， 你们估计听过OOP 面向对象编程，对这个已经很熟悉了，那么他们俩有什么关系呢？？？答案是： 没有啥关系。。。，非要说有啥关系，或许能说AOP是OOP的一种延伸吧，AOP可以做到OOP办不到的事情。</p>
<p>那，OOP不能做到的事情是什么呢？</p>
<p>在面向对象编程思想中，我们认为世间万物一切皆对象，面向对象编程的思想就是我要做一件事情，我不需要自己去做，交给专业的人去做，让各个对象组合去帮我们做成一件事情。</p>
<p>在OOP中，我们是纵向编程， 纵向继承机制 。</p>
<p>AOP中是横向抽取机制。</p>
<p>我们一般写程序都是从上到下，需要什么就要创建什么，如果有多个相同的业务，每一业务都要做一些公共的验证或者处理，那么在每个业务中都需要写同样的代码，这样代码很多重复，繁琐。而AOP的作用就是将一些公共的代码或者功能抽取出来，生成一个切面（后面会说到），然后哪个地方需要验证，处理就在程序执行的过程中动态地去插入这些代码。这些代码可能在程序的执行前，方法执行后等等。。。，这就是AOP里面的连接点和通知了。这些稍后再讲。</p>
<p>AOP编程操作的主要对象是切面(<code>aspect</code>)，而切面用于<strong>模块化横切关注点（公共功能）</strong>。</p>
<p><strong>简单来说aop的作用就是在程序运行期间，不修改源码对已有方法进行增强。</strong> </p>
<h1 id="AOP-优点"><a href="#AOP-优点" class="headerlink" title="AOP 优点"></a>AOP 优点</h1><p>减少重复代码     提高开发效率     维护方便</p>
<h1 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h1><h2 id="横切关注点"><a href="#横切关注点" class="headerlink" title="横切关注点"></a>横切关注点</h2><p>从每个方法中抽取出来的同一类非核心业务。就是公共的功能代码</p>
<h2 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a>切面（Aspect）</h2><p>封装横切关注点信息的类，每个关注点体现为一个通知方法。</p>
<p>也就是把这些公共的代码或者功能抽取成为一个类，这个类，就是我们所说的切面。</p>
<h2 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h2><p>在切面中的横切关注点用在目标对象中的方法就是通知，通知包含：用在啥地方（执行前？执行后？），使用的是啥功能（验证？ 打印日志？）。</p>
<p>说白了就是切面必须要完成的各个<strong>具体工作</strong>。</p>
<blockquote>
<p>通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。 </p>
</blockquote>
<h2 id="目标（Target）"><a href="#目标（Target）" class="headerlink" title="目标（Target）"></a>目标（Target）</h2><p>目标对象，很简单，就是你要增强的对象。</p>
<h2 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h2><p>向目标对象应用通知之后创建的代理对象。一个类被 AOP 织入增强后，就产生一个结果代理类。</p>
<p> AOP中会通过代理的方式，对目标对象生成一个代理对象，代理对象中会加入需要增强功能，通过代理对象来间接的方式目标对象，起到增强目标对象的效果。 </p>
<h2 id="连接点（Join-Point）"><a href="#连接点（Join-Point）" class="headerlink" title="连接点（Join Point）"></a>连接点（Join Point）</h2><p>横切关注点在程序代码中的具体体现，对应程序执行的某个特定位置。例如：类某个方法调用前、调用后、方法捕获到异常后等。</p>
<p>也就是说，所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。</p>
<p>在应用程序中可以使用横纵两个坐标来定位一个具体的连接点：  </p>
<img src="/2020/06/26/spring02-aop/1592979868739.png" class width="1592979868739">

<h2 id="切入点-pointcut"><a href="#切入点-pointcut" class="headerlink" title="切入点(pointcut)"></a>切入点(pointcut)</h2><p>所谓切入点是指我们要对哪些 <code>Joinpoint</code> 进行拦截的定义。</p>
<p>切入点就是定位连接点的<strong>方式</strong>。每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物。如果把连接点看作数据库中的记录，那么切入点就是查询条件——<strong>AOP可以通过切入点定位到特定的连接点</strong>。切点通过org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p>
<p>也就是说是用来指定需要将通知使用到哪些地方，比如需要用在哪些类的哪些方法上，切入点就是做这个配置的。 是要通过切入点表达式来 配置和指定。</p>
<h1 id="AOP的实现"><a href="#AOP的实现" class="headerlink" title="AOP的实现"></a>AOP的实现</h1><p>AOP是通过动态代理的方式实现的。</p>
<p>动态代理的特点： 字节码随用随创建，随用随加载。  它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。  装饰者模式就是静态代理的一种体现。</p>
<p>动态代理技术有两种，一种是基于接口的动态代理，另一种是基于子类的动态代理。</p>
<h2 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h2><p>由JDK 官方的 Proxy 类实现。  要求：被代理类最少实现一个接口。 </p>
<p>在很久以前，演员和剧组都是直接见面联系的。没有中间人环节。  而随着时间的推移，产生了一个新兴职业：经纪人（中间人），这个时候剧组再想找演员就需要通过经纪 人来找了。下面我们就用代码演示出来。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 一个经纪公司的要求:  </span></span><br><span class="line"><span class="comment"> *   能做基本的表演和危险的表演 </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IActor</span> </span>&#123;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">  	* 基本演出   </span></span><br><span class="line"><span class="comment">  	* <span class="doctag">@param</span> money   </span></span><br><span class="line"><span class="comment">  	*/</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicAct</span><span class="params">(<span class="keyword">float</span> money)</span></span>;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">  	* 危险演出   </span></span><br><span class="line"><span class="comment">  	* <span class="doctag">@param</span> money   </span></span><br><span class="line"><span class="comment">  	*/</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dangerAct</span><span class="params">(<span class="keyword">float</span> money)</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 一个演员  </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="comment">//实现了接口，就表示具有接口中的方法实现。即：符合经纪公司的要求 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Actor</span> <span class="keyword">implements</span> <span class="title">IActor</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicAct</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123; </span><br><span class="line">  		System.out.println(<span class="string">&quot;拿到钱，开始基本的表演：&quot;</span>+money);  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dangerAct</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;   </span><br><span class="line">        System.out.println(<span class="string">&quot;拿到钱，开始危险的表演：&quot;</span>+money);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用代理来间接获取对象。要求被代理类至少实现一个接口。</p>
<p>创建的方式： <code>Proxy.newProxyInstance</code>(三个参数)</p>
<p>参数的含义：</p>
<blockquote>
<p>ClassLoader：和被代理对象使用相同的类加载器。</p>
<p>Interfaces：和被代理对象具有相同的行为。实现相同的接口。  </p>
<p>InvocationHandler：如何代理。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IActor proxyActor = (IActor) Proxy.newProxyInstance(</span><br><span class="line">    actor.getClass().getClassLoader(),            actor.getClass().getInterfaces(), </span><br><span class="line">	<span class="keyword">new</span> InvocationHandler()&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">     	* 执行被代理对象的任何方法，都会经过该方法。      </span></span><br><span class="line"><span class="comment">     	* 此方法有拦截的功能。      </span></span><br><span class="line"><span class="comment">     	*  </span></span><br><span class="line"><span class="comment">     	* 参数：      </span></span><br><span class="line"><span class="comment">     	*  proxy：代理对象的引用。不一定每次都用得到      </span></span><br><span class="line"><span class="comment">     	*  method：当前执行的方法对象      </span></span><br><span class="line"><span class="comment">     	*  args：执行方法所需的参数      </span></span><br><span class="line"><span class="comment">     	* 返回值：      </span></span><br><span class="line"><span class="comment">     	*  当前执行方法的返回值      </span></span><br><span class="line"><span class="comment">     	*/</span>   </span><br><span class="line">        <span class="meta">@Override</span>     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">            ...</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<h2 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h2><p>使用<code>CGLib</code>的<code>Enhancer</code>类创建代理对象。</p>
<p>要求被代理的对象不能是最终类。</p>
<p>方法参数：Enhancer.create(Class, Callback)</p>
<blockquote>
<p>Class: 被代理对象的字节码</p>
<p>Callback：如何代理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Actor cglibActor = (Actor) Enhancer.create(actor.getClass(),        </span><br><span class="line">               <span class="keyword">new</span> MethodInterceptor()&#123; </span><br><span class="line">                   <span class="comment">/** </span></span><br><span class="line"><span class="comment">                   * 执行被代理对象的任何方法，都会经过该方法。在此方法内部就可以对被代理对象的任何 方法进行增强。     </span></span><br><span class="line"><span class="comment">                   * 参数：     </span></span><br><span class="line"><span class="comment">                   *  前三个和基于接口的动态代理是一样的。     </span></span><br><span class="line"><span class="comment">                   *  MethodProxy：当前执行方法的代理对象。     </span></span><br><span class="line"><span class="comment">                   * 返回值：     </span></span><br><span class="line"><span class="comment">                   *  当前执行方法的返回值     </span></span><br><span class="line"><span class="comment">                   */</span> </span><br><span class="line">                   <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line">                   </span><br><span class="line">                   </span><br><span class="line">                       。。。代理</span><br><span class="line">                       </span><br><span class="line">                   &#125;</span><br><span class="line">                   </span><br><span class="line">                   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="关于代理的选择"><a href="#关于代理的选择" class="headerlink" title="关于代理的选择"></a>关于代理的选择</h2><p>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 </p>
<h1 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h1><p>AspectJ：Java社区里最完整最流行的AOP框架。</p>
<p>在Spring2.0以上版本中，可以使用基于<code>AspectJ</code>注解或基于XML配置的AOP。</p>
<h2 id="在Spring中启用AspectJ注解支持"><a href="#在Spring中启用AspectJ注解支持" class="headerlink" title="在Spring中启用AspectJ注解支持"></a>在Spring中启用AspectJ注解支持</h2><h3 id="1-导包"><a href="#1-导包" class="headerlink" title="1. 导包"></a>1. 导包</h3><p>导入对应的jar包</p>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><p>在bean.xml中配置aop.</p>
<p>当Spring IOC容器侦测到bean配置文件中的<a href="aop:aspectj-autoproxy">aop:aspectj-autoproxy</a>元素时，会自动为 与AspectJ切面匹配的bean创建代理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop/spring-aop-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hongliang.aop&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    开启aspectJ的自动代理功能 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-编码"><a href="#3-编码" class="headerlink" title="3. 编码"></a>3. 编码</h3><p>举例： math的加减乘除，然后在执行过程中记录执行的方法，方法的参数，使用一个Logger类来作为切面。</p>
<p>MathI.java 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang.aop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-06-21 14:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MathI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MathImpl.java 实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-06-21 14:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathImpl</span> <span class="keyword">implements</span> <span class="title">MathI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = i + j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = i - j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = i * j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = i / j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-用AspectJ注解声明切面"><a href="#4-用AspectJ注解声明切面" class="headerlink" title="4. 用AspectJ注解声明切面"></a>4. 用AspectJ注解声明切面</h3><ol>
<li><p>   要在Spring中声明AspectJ切面，只需要在IOC容器中将切面声明为<code>bean</code>实例。</p>
</li>
<li><p>   当在Spring IOC容器中初始化AspectJ切面之后，Spring IOC容器就会为那些与 AspectJ切面相匹配的bean创建代理。</p>
</li>
<li><p>   在AspectJ注解中，切面只是一个带有<code>@Aspect</code>注解的Java类，它往往要包含很多通知。</p>
</li>
<li><p>   通知是标注有某种注解的简单的Java方法。</p>
</li>
<li><p>   AspectJ支持5种类型的通知注解：</p>
</li>
</ol>
<p>① @Before：前置通知，在方法执行之前执行</p>
<p>② @After：后置通知，在方法执行之后执行</p>
<p>③ @AfterRunning：返回通知，在方法返回结果之后执行</p>
<p>④ @AfterThrowing：异常通知，在方法抛出异常之后执行</p>
<p>⑥ @Around：环绕通知，围绕着方法执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang.aop;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // 切面： 用来存储横切关注点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-06-21 14:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//标注当前类是切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoggerAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 将方法指定为前置通知  value 为切入点表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.hongliang.aop.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Method:&quot;</span> + methodName+<span class="string">&quot;\t arguments: &quot;</span>+ Arrays.toString(args));</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行之前&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * finally</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.hongliang.aop.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.hongliang.aop.*.*(..))&quot; , returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returning</span><span class="params">(JoinPoint joinPoint, Object result)</span></span>&#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName()+<span class="string">&quot;\t&quot;</span>+result);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(* com.hongliang.aop.*.*(..))&quot; , throwing = &quot;ex&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Exception ex)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出了异常啊:&quot;</span> +ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(* com.hongliang.aop.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="AOP细节"><a href="#AOP细节" class="headerlink" title="AOP细节"></a>AOP细节</h1><h2 id="1-切入点表达式"><a href="#1-切入点表达式" class="headerlink" title="1. 切入点表达式"></a>1. 切入点表达式</h2><p>作用： 通过<strong>表达式的方式</strong>定位<strong>一个或多个</strong>具体的连接点。  </p>
<p>切入点表达式的写法:</p>
<p>关键字：execution(表达式)</p>
<p>表达式：<br>                    访问修饰符  返回值  包名.包名.包名…类名.方法名(参数列表)</p>
<p> 标准的表达式写法：<br>                    public void com.hongliangng.service.impl.AccountServiceImpl.saveAccount()</p>
<p>访问修饰符可以省略<br>                    void com.hongliangng.service.impl.AccountServiceImpl.saveAccount()</p>
<p>返回值可以使用通配符，表示任意返回值  </p>
<p>​            * com.hongliangng.service.impl.AccountServiceImpl.saveAccount()</p>
<p>包名可以使用通配符，表示任意包。但是有几级包，就需要写几个</p>
<p>​            *.* *.*.*.*.AccountServiceImpl.saveAccount())</p>
<p>包名可以使用..表示当前包及其子包<br>                    * *..AccountServiceImpl.saveAccount()</p>
<p>类名和方法名都可以使用*来实现通配</p>
<p>​            * *..*.*()</p>
<p>全通配写法：<br>                    * *..*.*(..)</p>
<p>实际开发中切入点表达式的通常写法：<br>                    切到业务层实现类下的所有方法<br>                        * com.hongliangng.service.impl.*.*(..)</p>
<h2 id="2-当前连接点细节"><a href="#2-当前连接点细节" class="headerlink" title="2. 当前连接点细节"></a>2. 当前连接点细节</h2><p>切入点表达式通常都会是从宏观上定位一组方法，和具体某个通知的注解结合起来就能够确定对应的连接点。那么就一个具体的连接点而言，我们可能会关心这个连接点的一些具体信息，例如：当前连接点所在方法的方法名、当前传入的参数值等等。这些信息都封装在<code>JoinPoint</code>接口的实例对象中。</p>
<h3 id="JoinPoint"><a href="#JoinPoint" class="headerlink" title="JoinPoint"></a>JoinPoint</h3><img src="/2020/06/26/spring02-aop/1593161851836.png" class width="1593161851836">

<h2 id="3-通知"><a href="#3-通知" class="headerlink" title="3. 通知"></a>3. 通知</h2><ol>
<li><p>   在具体的连接点上要执行的操作。</p>
</li>
<li><p>   一个切面可以包括一个或者多个通知。</p>
</li>
<li><p>   通知所使用的注解的值往往是<strong>切入点表达式</strong>。</p>
</li>
</ol>
<h3 id="前置通知"><a href="#前置通知" class="headerlink" title="前置通知"></a>前置通知</h3><p>前置通知：在方法执行之前执行的通知</p>
<p>使用<code>@Before</code>注解</p>
<h3 id="后置通知"><a href="#后置通知" class="headerlink" title="后置通知"></a>后置通知</h3><p>后置通知：后置通知是在连接点完成之后执行的，即连接点返回结果或者抛出异常的时候</p>
<p>使用<code>@After</code>注解</p>
<p><strong>无论连接点是正常返回还是抛出异常，后置通知都会执行</strong>  （<code>finally</code>）</p>
<h3 id="返回通知"><a href="#返回通知" class="headerlink" title="返回通知"></a>返回通知</h3><ol>
<li><p>   返回通知：无论连接点是正常返回还是抛出异常，后置通知都会执行。如果只想在连接点返回的时候记录日志，应使用返回通知代替后置通知。</p>
</li>
<li><p>   使用<code>@AfterReturning</code>注解，在返回通知中访问连接点的返回值</p>
</li>
</ol>
<p>​     ①在返回通知中，只要将returning属性添加到@AfterReturning注解中，就可以访问连接点的返回值。该属性的值即为用来传入返回值的参数名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(* com.hongliang.aop.*.*(..))&quot; , returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returning</span><span class="params">(JoinPoint joinPoint, Object result)</span></span>&#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName()+<span class="string">&quot;\t&quot;</span>+result);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回通知&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>​     ②必须在通知方法的签名中添加一个同名参数。在运行时Spring AOP会通过这个参数传递返回值</p>
<p>​     ③原始的切点表达式需要出现在<code>pointcut</code>属性中</p>
<h3 id="异常通知"><a href="#异常通知" class="headerlink" title="异常通知"></a>异常通知</h3><ol>
<li><p>   异常通知：只在连接点抛出异常时才执行异常通知</p>
</li>
<li><p>   将<code>throwing</code>属性添加到<code>@AfterThrowin</code>g注解中，也可以访问连接点抛出的异常。<code>Throwable</code>是所有错误和异常类的顶级父类，所以在异常通知方法可以捕获到任何错误和异常。</p>
</li>
<li><p>   如果只对某种特殊的异常类型感兴趣，可以将参数声明为其他异常的参数类型。然后通知就只在抛出这个类型及其子类的异常时才被执行</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(* com.hongliang.aop.*.*(..))&quot; , throwing = &quot;ex&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Exception ex)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;出了异常啊:&quot;</span> +ex.getMessage());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><ol>
<li><p>   环绕通知是所有通知类型中功能最为强大的，能够全面地控制连接点，甚至可以控制是否执行连接点。</p>
</li>
<li><p>   对于环绕通知来说，连接点的参数类型必须是<code>ProceedingJoinPoint</code>。它是 <code>JoinPoint</code>的子接口，允许控制何时执行，是否执行连接点。</p>
</li>
<li><p>   在环绕通知中需要明确调用<code>ProceedingJoinPoint</code>的<code>proceed()</code>方法来执行被代理的方法。如果忘记这样做就会导致通知被执行了，但目标方法没有被执行。</p>
</li>
<li><p>   注意：环绕通知的方法需要返回目标方法执行之后的结果，即调用 <code>joinPoint.proceed();</code>的返回值，否则会出现空指针异常。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;pt1()&quot;)</span>  <span class="comment">// 切入点表达式引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundPrintLog</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span></span>&#123;</span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] args = proceedingJoinPoint.getArgs();</span><br><span class="line">            System.out.println(<span class="string">&quot;前置： Logger类中的printLog方法开始记录日志了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            rtValue = proceedingJoinPoint.proceed(args); <span class="comment">//</span></span><br><span class="line">            System.out.println(<span class="string">&quot;后置： Logger类中的printLog方法开始记录日志了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> rtValue;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;异常： Logger类中的printLog方法开始记录日志了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(throwable);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;最终：Logger类中的printLog方法开始记录日志了...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return rtValue;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-重用切入点定义"><a href="#4-重用切入点定义" class="headerlink" title="4. 重用切入点定义"></a>4. 重用切入点定义</h2><ol>
<li><p>   在编写<code>AspectJ</code>切面时，可以直接在通知注解中书写切入点表达式。但同一个切点表达式可能会在多个通知中重复出现。</p>
</li>
<li><p>   在<code>AspectJ</code>切面中，可以通过<code>@Pointcut</code>注解将一个切入点声明成简单的方法。切入点的方法体通常是空的，因为将切入点定义与应用程序逻辑混在一起是不合理的。</p>
</li>
<li><p>   切入点方法的访问控制符同时也控制着这个切入点的可见性。如果切入点要在多个切面中共用，最好将它们集中在一个公共的类中。在这种情况下，它们必须被声明为public。在引入这个切入点时，必须将类名也包括在内。如果类没有与这个切面放在同一个包中，还必须包含包名。</p>
</li>
<li><p>   其他通知可以通过方法名称引入该切入点</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.hongliang.service.impl.*.*(..))&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-指定切面的优先级"><a href="#5-指定切面的优先级" class="headerlink" title="5. 指定切面的优先级"></a>5. 指定切面的优先级</h2><ol>
<li><p>   在同一个连接点上应用不止一个切面时，除非明确指定，否则它们的优先级是<strong>不确定</strong>的。</p>
</li>
<li><p>   切面的优先级可以通过实现<code>Ordered</code>接口或利用<code>@Order</code>注解指定。</p>
</li>
<li><p>   实现<code>Ordered</code>接口，<code>getOrder()</code>方法的返回值越小，优先级越高。</p>
</li>
<li><p>   若使用<code>@Order</code>注解，序号出现在注解中。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//标注当前类是切面</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoggerAspect</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span>  <span class="comment">//标注当前类是切面</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoggerAspect01</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="基于XML的AOP配置"><a href="#基于XML的AOP配置" class="headerlink" title="基于XML的AOP配置"></a>基于XML的AOP配置</h1><ol>
<li><p>把通知Bean也交给spring来管理</p>
</li>
<li><p>使用aop:config标签表名开始AOP配置</p>
</li>
<li><p>使用aop:aspect标签表明配置切面     </p>
<p>id属性：是给切面提供一个唯一标识     ref属性：是指定通知类bean的Id。</p>
</li>
<li><p>在aop:aspect标签的内部使用对应的标签来配置通知的类型</p>
</li>
</ol>
<h2 id="第一步：把通知类用-bean-标签配置起来"><a href="#第一步：把通知类用-bean-标签配置起来" class="headerlink" title="第一步：把通知类用 bean 标签配置起来"></a>第一步：把通知类用 bean 标签配置起来</h2><p>通知类也就是切面</p>
<p>如果有注解的话，需要引入扫描包的标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hongliang.aop&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="第二步：使用-aop-config-声明-aop-配置"><a href="#第二步：使用-aop-config-声明-aop-配置" class="headerlink" title="第二步：使用 aop:config 声明 aop 配置"></a>第二步：使用 aop:config 声明 aop 配置</h2><h2 id="第三步：使用-aop-aspect-配置切面"><a href="#第三步：使用-aop-aspect-配置切面" class="headerlink" title="第三步：使用 aop:aspect 配置切面"></a>第三步：使用 aop:aspect 配置切面</h2><img src="/2020/06/26/spring02-aop/1593164326190.png" class width="1593164326190">

<h2 id="第四步：使用-aop-pointcut-配置切入点表达式"><a href="#第四步：使用-aop-pointcut-配置切入点表达式" class="headerlink" title="第四步：使用 aop:pointcut 配置切入点表达式"></a>第四步：使用 aop:pointcut 配置切入点表达式</h2><h2 id="第五步：使用-aop-xxx-配置对应的通知类型"><a href="#第五步：使用-aop-xxx-配置对应的通知类型" class="headerlink" title="第五步：使用 aop:xxx 配置对应的通知类型"></a>第五步：使用 aop:xxx 配置对应的通知类型</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myLoggerAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforeMethod&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.hongliang.aop.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--            配置切入点表达式 : 所有切面可用 （但是必须放在配置切面之前 ）--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.hongliang.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="不使用-XML的配置方式"><a href="#不使用-XML的配置方式" class="headerlink" title="不使用 XML的配置方式"></a>不使用 XML的配置方式</h1><p>在spring的配置类中引入 以下注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@ComponentScan(basePackages=&quot;com.hongliang&quot;)</span> <span class="meta">@EnableAspectJAutoProxy</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123; &#125; </span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例设计模式</title>
    <url>/2021/07/23/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h1 id="涉及到的知识点"><a href="#涉及到的知识点" class="headerlink" title="涉及到的知识点"></a>涉及到的知识点</h1><ol>
<li>类加载机制</li>
<li>字节码知识</li>
<li>jvm指令重排序</li>
<li>java序列化机制</li>
</ol>
<h1 id="定义及应用场景"><a href="#定义及应用场景" class="headerlink" title="定义及应用场景"></a>定义及应用场景</h1><p>保证一个类只有一个实例，并且提供一个全局访问点</p>
<p>场景： 线程池、数据库连接池</p>
<h1 id="单例设计模式八种方式"><a href="#单例设计模式八种方式" class="headerlink" title="单例设计模式八种方式"></a>单例设计模式八种方式</h1><ol>
<li>饿汉式**(<strong>静态常量</strong>)**</li>
<li>饿汉式（静态代码块）</li>
<li>懒汉式(线程不安全)</li>
<li> 懒汉式(线程安全，同步方法)</li>
<li>懒汉式(线程安全，同步代码块)</li>
<li> 双重检查</li>
<li>静态内部类</li>
<li>枚举</li>
</ol>
<h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><p>使用的时候才开始初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>; <span class="comment">// 单例对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 私有化构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.要想让一个类只能构建一个对象，自然不能让它随便去做new操作，因此Signleton的构造方法是私有的。</p>
<p>2.instance是Singleton类的静态成员，也是我们的单例对象。它的初始值可以写成Null，也可以写成new Singleton()。至于其中的区别后来会做解释。</p>
<p>3.getInstance是获取单例对象的方法。</p>
<p>如果单例初始值是null，还未构建，则构建单例对象并返回。这个写法属于单例模式当中的<strong>懒汉模式。</strong></p>
<p>如果单例对象一开始就被new Singleton()主动构建，则不再需要判空操作，这种写法属于<strong>饿汉模式</strong>。</p>
<p>这两个名字很形象：饿汉主动找食物吃，懒汉躺在地上等着人喂</p>
</blockquote>
<p>但是上面的代码并不安全，为啥？在多线程的环境下去创建会导致返回多个不同的实例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 模拟两个线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123; LazySingleton l1 = getInstance();</span><br><span class="line">            System.out.println(l1);&#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123; LazySingleton l1 = getInstance();</span><br><span class="line">            System.out.println(l1);&#125;).start();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>; <span class="comment">// 单例对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 私有化构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);  <span class="comment">// 休眠2秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>cn.hongliang.singleton.LazySingleton@6afa9656<br>cn.hongliang.singleton.LazySingleton@2b3351f2</p>
</blockquote>
<p>可以看到创建了两个不同的实例对象，单例失效了！</p>
<p>假设Singleton类刚刚被初始化，instance对象还是空，这时候两个线程同时访问getInstance方法：  因为Instance是空，所以两个线程同时通过了条件判断，开始执行new操作： </p>
<img src="/2021/07/23/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1596726027608.png" class width="1596726027608">

<p>这样的话两个线程分别创建一个实例。</p>
<p>对于线程不安全的问题，我们很直观的就想到加锁，使用synchronized关键字，改写代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>; <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class)&#123; <span class="comment">//  注意，这里要锁类</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123; <span class="comment">// 双重检测机制</span></span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节问题：</p>
<ol>
<li><p> 为了防止new Singleton被执行多次，因此在<strong>new操作之前</strong>加上<code>Synchronized</code> 同步锁，锁住整个类（注意，这里不能使用对象锁）。 因为锁实例是锁不到的，每个线程还是可以进来。</p>
</li>
<li><p>在拿到锁之后，进入到 Synchronized 临界区以后，还要再做一次判空。 因为如果一个线程已经创建了一个实例，下一个进程进来的时候也会执行一次new Singleton操作，这样又创建了两个对象，所以这里要加上双重检测机制。</p>
</li>
</ol>
</blockquote>
<p>但是上面的代码还是有漏洞， 这就涉及到了JVM 的指令重排序问题了。</p>
<p>指令重排序：JVM会根据cpu的执行情况，改变程序指令的执行顺序。我们创建一个对象的时候经历了很多步操作，1. 加载： 加载对应的二进制字节码文件，并且在方法区创建对应的数据结构，2. 连接： a. 验证 b.解析 c.初始化， 3. 初始化： 给静态属性赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  Last modified 2020-8-8; size 435 bytes</span><br><span class="line">  MD5 checksum 3b5f34a0e7b4eb8045214ecd6c8a007d</span><br><span class="line">  Compiled from <span class="string">&quot;User.java&quot;</span></span><br><span class="line">public class cn.hongliang.singleton.User</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   <span class="comment">#1 = Methodref          #4.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#2 = Class              #20            // cn/hongliang/singleton/User</span></span><br><span class="line">   <span class="comment">#3 = Methodref          #2.#19         // cn/hongliang/singleton/User.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#4 = Class              #21            // java/lang/Object</span></span><br><span class="line">   <span class="comment">#5 = Utf8               &lt;init&gt;</span></span><br><span class="line">   <span class="comment">#6 = Utf8               ()V</span></span><br><span class="line">   <span class="comment">#7 = Utf8               Code</span></span><br><span class="line">   <span class="comment">#8 = Utf8               LineNumberTable</span></span><br><span class="line">   <span class="comment">#9 = Utf8               LocalVariableTable</span></span><br><span class="line">  <span class="comment">#10 = Utf8               this</span></span><br><span class="line">  <span class="comment">#11 = Utf8               Lcn/hongliang/singleton/User;</span></span><br><span class="line">  <span class="comment">#12 = Utf8               main</span></span><br><span class="line">  <span class="comment">#13 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#14 = Utf8               args</span></span><br><span class="line">  <span class="comment">#15 = Utf8               [Ljava/lang/String;</span></span><br><span class="line">  <span class="comment">#16 = Utf8               user</span></span><br><span class="line">  <span class="comment">#17 = Utf8               SourceFile</span></span><br><span class="line">  <span class="comment">#18 = Utf8               User.java</span></span><br><span class="line">  <span class="comment">#19 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  <span class="comment">#20 = Utf8               cn/hongliang/singleton/User</span></span><br><span class="line">  <span class="comment">#21 = Utf8               java/lang/Object</span></span><br><span class="line">&#123;</span><br><span class="line">  public cn.hongliang.singleton.User();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcn/hongliang/singleton/User;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           <span class="comment">#2                  // class cn/hongliang/singleton/User</span></span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial <span class="comment">#3                  // Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         7: astore_1</span><br><span class="line">         8: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 10: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">            8       1     1  user   Lcn/hongliang/singleton/User;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;User.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指向简单的一个new对象操作，会执行以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">memory =allocate();    //1：分配对象的内存空间 </span><br><span class="line"></span><br><span class="line">ctorInstance(memory);  //2：初始化对象 </span><br><span class="line"></span><br><span class="line">instance =memory;     //3：设置instance指向刚分配的内存地址 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是这几条指令不是一成不变的，有可能会经过JVM和CPU的优化，指令重排成下面的顺序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">memory =allocate();  //1：分配对象的内存空间 </span><br><span class="line"></span><br><span class="line">instance =memory;   //3：设置instance指向刚分配的内存地址 </span><br><span class="line"></span><br><span class="line">ctorInstance(memory); //2：初始化对象 </span><br></pre></td></tr></table></figure>

<p>当执行到第二条的时候，对象已经创建了，但是对象没有完成初始化，是一个不完整的对象。而此时线程T2 抢占到了cpu，在第一个if判断语句，得到的结果是不为空，然后直接返回此对象。这样得到的是一个未经过初始化的一个对象，之后很可能会出现空指针异常。</p>
<img src="/2021/07/23/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1596870204355.png" class width="1596870204355">

<p>解决方法是使用volatile关键字，次关键字可以禁止指令重排序。所以改进后的单例设计模式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>; <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class)&#123; <span class="comment">//  注意，这里要锁类</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123; <span class="comment">// 双重检测机制</span></span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如此在线程T2看来，instance对象的引用要么指向null，要么指向一个初始化完毕的Instance，而不会出现某个中间态，保证了安全。 </p>
<h1 id="synchronized改为reentranlock如何写"><a href="#synchronized改为reentranlock如何写" class="headerlink" title="synchronized改为reentranlock如何写"></a>synchronized改为reentranlock如何写</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LockSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">LockSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LockSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">           lock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   instance  = <span class="keyword">new</span> LockSingleton();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           instance = getInstance();</span><br><span class="line">           System.out.println(instance);</span><br><span class="line">       &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            instance = getInstance();</span><br><span class="line">            System.out.println(instance);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h1><p>在类加载阶段就完成了实例化。通过类加载机制来保证线程安全</p>
<p>类加载有是三个步骤<br>加载： 加载对应的二进制字节码文件，并且在方法区创建对应的数据结构</p>
<p>连接： a. 验证 b.解析 c.初始化</p>
<p>初始化： 给静态属性赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungarySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungarySingleton instance = <span class="keyword">new</span> HungarySingleton();</span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungarySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有的方法返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungarySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>   优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p>
</li>
<li><p>   缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p>
</li>
</ol>
<h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li> 从外部无法访问静态内部类<code>InstanceHolder</code>，只有当调用<code>Singleton.getInstance</code>方法的时候，才能得到单例对象<code>INSTANCE</code>。 </li>
<li> <code>INSTANCE</code>对象初始化的时机并不是在单例类<code>Singleton</code>被加载的时候，而是在调用<code>getInstance</code>方法，使得静态内部类<code>InstanceHolder</code>被加载的时候。因此这种实现方式是利用<strong>classloader的加载机制</strong>来实现<strong>懒加载</strong>，并保证构建单例的线程安全。 </li>
</ol>
<p>可以看到，使用静态内部类的方法创建单例对象是很巧妙的，但是，和以上方法一样，都不能阻止使用反射机制来创建，也就是说，反射机制会打破上述单例模式。</p>
<p>来看看是怎么实现的。</p>
<h1 id="反射打破单例"><a href="#反射打破单例" class="headerlink" title="反射打破单例"></a>反射打破单例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefectSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 首先获得构造器</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.hongliang.singleton.Singleton&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; declaredConstructor = clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// 因为构造方法是private的， 所以设置暴力反射</span></span><br><span class="line">        declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Singleton s1= (Singleton) declaredConstructor.newInstance();</span><br><span class="line">        Singleton s2= (Singleton) declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.hashCode() == s2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>false<br>false</p>
</blockquote>
<p>可以看到创建的两个实例对象，所以破坏了单例。</p>
<p>接下来介绍一下使用枚举类的方法来创建单例对象，枚举的方式可以阻止反射。</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span>  <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</li>
<li>缺点就是并不是使用懒加载的方式实现的。</li>
<li>这种方式是 <strong>Effective Java</strong> 作者 <strong>Josh Bloch</strong> 提倡的方式.</li>
</ol>
<p>如果使用反射来创建实例，会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefectSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        SingletonEnum singletonEnum1 = SingletonEnum.class.getDeclaredConstructor().newInstance();</span><br><span class="line">        SingletonEnum singletonEnum2 = SingletonEnum.class.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(singletonEnum1 == singletonEnum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Exception in thread “main” java.lang.NoSuchMethodException: cn.hongliang.singleton.SingletonEnum.&lt;init&gt;()<br>at java.lang.Class.getConstructor0(Class.java:3082)<br>at java.lang.Class.getDeclaredConstructor(Class.java:2178)<br>at cn.hongliang.singleton.RefectSingleton.main(RefectSingleton.java:24)</p>
</blockquote>
<p>刚刚说了枚举既可以防止反射创建单例也能够防止反序列化创建新的对象，我们继续看看什么是序列化。</p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h2><p>序列化就是将java对象编码成二进制文件，课保存在磁盘中。</p>
<p>反序列化就是从文件中解码成一个对象。</p>
<h2 id="怎么实现序列化"><a href="#怎么实现序列化" class="headerlink" title="怎么实现序列化"></a>怎么实现序列化</h2><p>java对象实现<code>Serializable</code>接口，通过<code>ObjectOutputStream</code>， <code>ObjectInputputStream</code>实现序列化和反序列化。</p>
<h2 id="什么样的数据会序列化到文件中"><a href="#什么样的数据会序列化到文件中" class="headerlink" title="什么样的数据会序列化到文件中"></a>什么样的数据会序列化到文件中</h2><p>对象的默认序列化机制写入的内容是：对象的类，类签名，以及<strong>非瞬态</strong>（<code>transit</code>）和<strong>非静态</strong>字段的值，因为静态static的东西在方法区。</p>
<p>所以序列化的数据是在堆中的，将堆中数据的生命周期延长，持久化到文件，保存到磁盘中，文件扩展名是.object， 当我们以后想要使用这个类的时候就不需要new了，直接从文件中读取就行。</p>
<h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p> <code>SerializableUID</code>号是根据类的特征和类的签名算出来的 ，主要用于判断是否为同一个版本的对象。如果没有加上<code>serialVersionUID</code> ，在反序列化之前更改了类的签名或者增加了一些字段，在反序列化的时候就报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeralizVersionIDTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line"><span class="comment">//        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;user&quot;));</span></span><br><span class="line"><span class="comment">//        oos.writeObject(user);</span></span><br><span class="line"><span class="comment">//         反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        User user1 = (User) ois.readObject();</span><br><span class="line">        System.out.println(user1.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        oos.close();</span></span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在反序列化之前，增加了一个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反序列化之后报错</p>
<img src="/2021/07/23/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1596876224494.png" class width="1596876224494">

<p>所以我们需要手动指定一个<code>serialVersionUID</code> ，就可以正常反序列化了。</p>
<h2 id="静态变量的序列化"><a href="#静态变量的序列化" class="headerlink" title="静态变量的序列化"></a>静态变量的序列化</h2><p>我们在User类中加上一个静态变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>然后在序列化之后，将变量i修改成99， 通过反序列化之后i的值应该是多少呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeralizVersionIDTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        User.i = <span class="number">99</span>; <span class="comment">// 序列化之后改变值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        User user1 = (User) ois.readObject();</span><br><span class="line">        System.out.println(user1.i);</span><br><span class="line">        oos.close();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>99</p>
</blockquote>
<p>这说明了序列化不对静态变量序列化。我们总说是对象序列化，但是i数据属于类变量，所以不会序列化静态变量。</p>
<h2 id="不想要序列化？transit"><a href="#不想要序列化？transit" class="headerlink" title="不想要序列化？transit"></a>不想要序列化？transit</h2><p>那么对于非静态变量就可以序列化，但是可不可以选择不序列化呢？</p>
<p>当然，那就是<code>transit</code>关键字</p>
<blockquote>
<p><code>Transient</code> 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，<code>transient</code> 变量的值被设为初始值，如 <code>int</code> 型的是 0，对象型的是 <code>null</code>。 </p>
</blockquote>
<h2 id="父类的序列化"><a href="#父类的序列化" class="headerlink" title="父类的序列化"></a>父类的序列化</h2><p>考虑这种情况，子类实现了<code>Serializable</code>接口，父类没有实现<code>Serializable</code>接口。看看序列化与反序列化的时候会出现什么情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 默认的构造函数， 不加报错</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeralizVersionIDTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;son&quot;</span>));</span><br><span class="line">        oos.writeObject(son);</span><br><span class="line"><span class="comment">//         反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;son&quot;</span>));</span><br><span class="line">        Son s = (Son) ois.readObject();</span><br><span class="line">        System.out.println(s.money); <span class="comment">// 父亲那里继承下来的钱</span></span><br><span class="line">        oos.close();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>0</p>
</blockquote>
<p>反序列化子类需要创建父类，调用父类默认的无参构造方法。</p>
<p>所以除了可以用tansit关键字修饰不想被序列化的属性之外，还可以将不想序列化的属性放入父类中，子类实现<code>Serializable</code>接口， 父类不实现。</p>
<h1 id="单例解决序列化的问题"><a href="#单例解决序列化的问题" class="headerlink" title="单例解决序列化的问题"></a>单例解决序列化的问题</h1><p>言归正传！！！！！！！！！！！！回到单例设计模式</p>
<p>下面以饿汉模式举例， 实现<code>Serializable</code>接口，看看序列化的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungarySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungarySingleton instance = <span class="keyword">new</span> HungarySingleton();</span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungarySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有的方法返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungarySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HungarySingleton instance = HungarySingleton.getInstance();</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;instance&quot;</span>));</span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;instance&quot;</span>));</span><br><span class="line">        HungarySingleton instance1 = (HungarySingleton) ois.readObject();</span><br><span class="line">        System.out.println(instance1 == instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>false</p>
</blockquote>
<p>可以发现返回的是两个对象，也就是说，序列化破坏了我们的单例模式！</p>
<p>那怎么解决呢？</p>
<p>使用 <strong>readResolve</strong>()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungarySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersioUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungarySingleton instance = <span class="keyword">new</span> HungarySingleton();</span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungarySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有的方法返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungarySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>似乎是加了<code>readResolve()</code>方法后反序列化做的是浅拷贝,也就是拷贝的是之前对象的指针,指的还是原先的对象，  而不加默认是深拷贝?直接开辟新空间, 地址自然就不一样了.</p>
<p>如果使用枚举的话，可以解决序列化的问题。 使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被<strong>反序列化</strong>的时候，保证反序列的返回结果是同一对象。 </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>语义分割算法之DeepLabV3+</title>
    <url>/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/</url>
    <content><![CDATA[<h1 id="语义分割算法之DeepLabV3"><a href="#语义分割算法之DeepLabV3" class="headerlink" title="语义分割算法之DeepLabV3+"></a>语义分割算法之DeepLabV3+</h1><p>论文标题：  Encoder-Decoder with Atrous Separable Convolution for Semantic Image<br>Segmentation  </p>
<p>DeepLab series has come along for versions from <a href="https://towardsdatascience.com/review-deeplabv1-deeplabv2-atrous-convolution-semantic-segmentation-b51c5fbde92d">DeepLabv1</a> (2015 ICLR), <a href="https://towardsdatascience.com/review-deeplabv1-deeplabv2-atrous-convolution-semantic-segmentation-b51c5fbde92d">DeepLabv2</a> (2018 TPAMI), and <a href="https://towardsdatascience.com/review-deeplabv3-atrous-convolution-semantic-segmentation-6d818bfd1d74?source=post_page---------------------------">DeepLabv3</a> (arXiv).</p>
<p>论文地址： <a href="https://arxiv.org/pdf/1802.02611.pdf">https://arxiv.org/pdf/1802.02611.pdf</a> </p>
<p>github： <a href="https://github.com/jfzhang95/pytorch-deeplab-xception">https://github.com/jfzhang95/pytorch-deeplab-xception</a> </p>
<p>语义分割主要面临两个问题，第一是物体的多尺度问题，第二是DCNN的多次下采样会造成特征图分辨率变小，导致预测精度降低，边界信息丢失。DeepLab V3设计的ASPP模块较好的解决了第一个问题，而这里要介绍的DeepLabv3+则主要是为了解决第2个问题的。 我们知道从DeepLabV1系列引入空洞卷积开始，我们就一直在解决第2个问题呀，为什么现在还有问题呢？见以前的博客：<a href="https://www.hongliangzhu.cn/2020/04/09/deeplabv1%E5%92%8Cdeeplabv2/">deeplabv1和deeplabv2</a>和<a href="https://www.hongliangzhu.cn/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/">deeplabv3-空洞卷积(语义分割)</a>。对于DeepLabV3，如果Backbone为ResNet101，Stride=16将造成后面9层的特征图变大，后面9层的计算量变为原来的4倍大。而如果采用Stride=8，则后面78层的计算量都会变得很大。这就造成了DeepLabV3如果应用在大分辨率图像时非常耗时。所以为了改善这个缺点，DeepLabV3+来了。 </p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><img src="/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/1586857503568.png" class width="1586857503568">

<ul>
<li><p>(a):  With <strong>Atrous Spatial Pyramid Pooling (ASPP)</strong>, able to encode multi-scale contextual information.  ASPP 模块，可以编码多尺度特征， 其中的8x是直接双线性插值操作，不用参与训练 。</p>
</li>
<li><p>(b)： With <strong>Encoder-Decoder Architecture, the location/spatial information is recovered.</strong> Encoder-Decoder Architecture has been proved to be useful in literature such as <a href="https://towardsdatascience.com/review-fpn-feature-pyramid-network-object-detection-262fc7482610">FPN</a>, <a href="https://towardsdatascience.com/review-dssd-deconvolutional-single-shot-detector-object-detection-d4821a2bbeb5">DSSD</a>, <a href="https://medium.com/datadriveninvestor/review-tdm-top-down-modulation-object-detection-3f0efe9e0151">TDM</a>, <a href="https://towardsdatascience.com/review-sharpmask-instance-segmentation-6509f7401a61">SharpMask</a>, <a href="https://medium.com/datadriveninvestor/review-red-net-residual-encoder-decoder-network-denoising-super-resolution-cb6364ae161e">RED-Net</a>, and <a href="https://towardsdatascience.com/review-u-net-biomedical-image-segmentation-d02bf06ca760">U-Net</a> for different kinds of purposes.  编解码器结构， 可以恢复位置/空间信息。 事实证明，编码器/解码器体系结构在FPN，DSSD，TDM，SharpMask，RED-Net和U-Net等文献中可用于多种用途。 融合了低层和高层的信息。</p>
</li>
<li><p>(c):  DeepLabv3+ makes use of (a) and (b).  本文使用的DeeplabV3+结构。采用了(a)和(b)。</p>
</li>
<li><p> Further, with the use of <strong>Modified Aligned Xception</strong>, and <strong>Atrous Separable Convolution</strong>, a faster and stronger network is developed.   此外，通过使用修正的对齐Xception和Atrous可分离卷积，可以开发出更快，更强大的网络。 </p>
</li>
<li><p>最后，DeepLabv3 +的性能优于PSPNet（在2016年ILSVRC场景解析挑战赛中排名第一）和之前的DeepLabv3。 </p>
</li>
</ul>
<h2 id="OutLine"><a href="#OutLine" class="headerlink" title="OutLine"></a>OutLine</h2><ol>
<li><strong>Atrous Separable Convolution</strong></li>
<li><strong>Encoder-Decoder Architecture</strong></li>
<li><strong>Modified Aligned Xception</strong></li>
<li><strong>Ablation Study</strong></li>
<li><strong>Comparison with State-of-the-art Approaches</strong></li>
</ol>
<h1 id="Atrous-Separable-Convolution"><a href="#Atrous-Separable-Convolution" class="headerlink" title="Atrous Separable Convolution"></a><strong>Atrous Separable Convolution</strong></h1><h2 id="Atrous-Convolution"><a href="#Atrous-Convolution" class="headerlink" title="Atrous Convolution"></a>Atrous Convolution</h2> <img src="/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/1.png" class title="img"> 

<ul>
<li>对于输出y上的每个位置i和一个滤波器w, atrous卷积应用于输入特征映射x，其中atrous rate对应于我们采样输入信号时的步幅。</li>
<li>空洞卷积详见： <a href="https://hongliangzhu.cn/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/#%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF">https://hongliangzhu.cn/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/#%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF</a> </li>
</ul>
<h2 id="Atrous-Separable-Convolution-1"><a href="#Atrous-Separable-Convolution-1" class="headerlink" title="Atrous Separable Convolution"></a><strong>Atrous Separable Convolution</strong></h2> <img src="/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/2.png" class title="img">

<ul>
<li> （a）和（b），深度可分卷积：将标准卷积分解为深度卷积，然后再进行点向卷积（即1×1卷积），大大降低了计算复杂度。</li>
<li>（c）: 它在保持相似（或更好）性能的同时，大大降低了所提出模型的计算复杂度。 </li>
<li> Combining with point-wise convolution, it is <strong>Atrous Separable Convolution.</strong></li>
</ul>
<h1 id="Encoder-Decoder-Architecture"><a href="#Encoder-Decoder-Architecture" class="headerlink" title="Encoder-Decoder Architecture"></a>Encoder-Decoder Architecture</h1><p>为了解决上面提到的DeepLabV3在分辨率图像的耗时过多的问题，DeepLabV3+在DeepLabV3的基础上加入了编码器。这是Deeplabv3+的一个主要的创新点。</p>
<img src="/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/1586914885075.png" class width="1586914885075">

<h2 id="DeepLabv3-as-Encoder"><a href="#DeepLabv3-as-Encoder" class="headerlink" title="DeepLabv3 as Encoder"></a><a href="%5Bhttps://hongliangzhu.cn/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/%5D(https://hongliangzhu.cn/2020/04/09/deeplabv3-%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/)">DeepLabv3</a> as Encoder</h2><p>编码器就是一个DeeplabV3结构。 首先选一个低层级的feature用1 * 1的卷积进行通道压缩（原本为256通道，或者512通道），目的是减少低层级的比重。论文认为编码器得到的feature具有更丰富的信息，所以编码器的feature应该有更高的比重。 这样做有利于训练。 </p>
<ul>
<li>对于图像分类的任务来说， 最终特征图的空间分辨率通常比输入图像分辨率小32倍，因此输出步幅= 32。 （output stride = 32）</li>
<li>对于语义分割来说，缩小32倍太小了。</li>
<li>通过移除最后一个（或者两个）块中的步幅并相应的应用空洞卷积，采用out stride=16（或者8）进行更加密集的特征提取。</li>
<li>同时，Deeplabv3增强了ASPP模块， 该模块通过以不同rate应用具有图像级别特征的atrous卷积来探测多尺度的卷积特征。 </li>
</ul>
<h2 id="Proposed-Decoder"><a href="#Proposed-Decoder" class="headerlink" title="Proposed Decoder"></a>Proposed Decoder</h2><p>对于解码器部分，直接将编码器的输出上采样4倍，使其分辨率和低层级的feature一致。举个例子，如果采用resnet <code>conv2</code> 输出的feature，则这里要x4上采样。将两种feature连接后，再进行一次3x3的卷积（细化作用），然后再次上采样就得到了像素级的预测。 </p>
<p>实验结果表明，这种结构在Stride=16时有很高的精度速度又很快。stride=8相对来说只获得了一点点精度的提升，但增加了很多的计算量。 </p>
<h1 id="Modified-Aligned-Xception"><a href="#Modified-Aligned-Xception" class="headerlink" title="Modified Aligned Xception"></a>Modified Aligned Xception</h1><h2 id="Aligned-Xception"><a href="#Aligned-Xception" class="headerlink" title="Aligned Xception"></a>Aligned Xception</h2><p>可参考：<a href="https://towardsdatascience.com/review-dcn-deformable-convolutional-networks-2nd-runner-up-in-2017-coco-detection-object-14e488efce44">https://towardsdatascience.com/review-dcn-deformable-convolutional-networks-2nd-runner-up-in-2017-coco-detection-object-14e488efce44</a></p>
 <img src="/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/J.png" class title="img">

<ul>
<li> <a href="https://towardsdatascience.com/review-xception-with-depthwise-separable-convolution-better-than-inception-v3-image-dc967dd42568">Xception</a> 是用于图像分类任务的</li>
<li> Aligned Xception 是来自可变形卷积，用于目标检测。</li>
</ul>
<h2 id="Modified-Aligned-Xception-1"><a href="#Modified-Aligned-Xception-1" class="headerlink" title="Modified Aligned Xception"></a>Modified Aligned Xception</h2><p>论文受到近期MSRA组在Xception上改进工作可变形卷积(<a href="https://arxiv.org/pdf/1703.06211.pdf">Deformable-ConvNets</a>)启发，Deformable-ConvNets对Xception做了改进，能够进一步提升模型学习能力，新的结构如下： </p>
<img src="/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/1586915880278.png" class width="1586915880278">

<ul>
<li>更深的Xception结构，不同的地方在于不修改entry flow network的结构，为了快速计算和有效的使用内存</li>
<li>所有的max pooling结构被stride=2的深度可分离卷积代替</li>
<li>每个3x3的depthwise convolution都跟BN和Relu</li>
</ul>
<p>最后将改进后的Xception作为encodet主干网络，替换原本DeepLabv3的ResNet101。 </p>
<hr>
<h1 id="Ablation-Study"><a href="#Ablation-Study" class="headerlink" title="Ablation Study"></a>Ablation Study</h1><h2 id="Decoder-Design"><a href="#Decoder-Design" class="headerlink" title="Decoder Design"></a>Decoder Design</h2><p>论文使用modified aligned Xception改进后的ResNet-101，在ImageNet-1K上做预训练，通过扩张卷积做密集的特征提取。采用DeepLabv3的训练方式(poly学习策略，crop 513x513)。注意在decoder模块同样包含BN层。 </p>
<p>为了评估在低级特征使用1*1卷积降维到固定维度的性能，做了如下对比实验： </p>
<img src="/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/1586916640683.png" class width="1586916640683">

<p> 实验中取了<code>conv2</code>尺度为[3x3, 256]的输出，降维后的通道数在32和48之间最佳，最终选择了48。 </p>
<p>编解码特征图融合后经过了3x3卷积，论文探索了这个卷积的不同结构对结果的影响 </p>
<img src="/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/1586916764594.png" class width="1586916764594">

<p>And it is most effective to use the Conv2 (before striding) feature map and two extra [3×3 conv; 256 channels] operations.</p>
<p>最终，选择了使用两组3x3卷积。这个表格的最后一项代表实验了如果使用<code>Conv2</code>和<code>Conv3</code>同时预测，上采样2倍后与<code>Conv3</code>结合，再上采样2倍的结果对比，这并没有提升显著的提升性能，考虑到计算资源的限制，论文最终采样简单的decoder方案，即我们看到的DeepLabV3+的网络结构图。 </p>
<h2 id="Model-Variants-with-ResNet-as-Backbone"><a href="#Model-Variants-with-ResNet-as-Backbone" class="headerlink" title="Model Variants with ResNet as Backbone"></a>Model Variants with ResNet as Backbone</h2><img src="/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/1586917023137.png" class width="1586917023137">

<ul>
<li> <strong>Baseline</strong> (First row block): 77.21% to 79.77% mIOU </li>
<li><strong>With Decoder</strong> (Second row block): The performance is improved from 77.21% to 78.85% or 78.51% to 79.35%.</li>
<li> The performance is further improved to 80.57% when using multi-scale and left-right flipped inputs. </li>
<li> <strong>Coarser feature maps</strong> (Third row block): i.e. stride = 32, the performance is not good. </li>
</ul>
<h2 id="Modified-Aligned-Xception-as-Backbone"><a href="#Modified-Aligned-Xception-as-Backbone" class="headerlink" title="Modified Aligned Xception as Backbone"></a>Modified Aligned Xception as Backbone</h2><img src="/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/1586918209264.png" class width="1586918209264">

<ul>
<li><strong>Baseline</strong> (First row block): 79.17% to 81.34% mIOU.</li>
<li><strong>With Decoder</strong> (Second row block): 79.93% to 81.63% mIOU.</li>
<li><strong>Using Depthwise Separable Convolution</strong> (Third row block): Multiply-Adds is significantly reduced by 33% to 41%, while similar mIOU performance is obtained.</li>
<li><strong>Pretraining on COCO</strong> (Fourth row block): Extra 2% improvement.</li>
<li><strong>Pretraining on JFT</strong> (Fifth row block): Extra 0.8% to 1% improvement.</li>
</ul>
<p> 这里可以看到使用深度分离卷积可以显著降低计算消耗。 </p>
<h2 id="Visualization"><a href="#Visualization" class="headerlink" title="Visualization"></a>Visualization</h2><img src="/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/1586918257606.png" class width="1586918257606">

<hr>
<h1 id="Comparison-with-State-of-the-art-Approaches"><a href="#Comparison-with-State-of-the-art-Approaches" class="headerlink" title="Comparison with State-of-the-art Approaches"></a><strong>Comparison with State-of-the-art Approaches</strong></h1><img src="/2020/04/14/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BDeepLabV3/1586918772788.png" class width="1586918772788">

<p> DeepLabv3+ outperforms many SOTA approaches .</p>
<p>论文提出的DeepLabv3+是encoder-decoder架构，其中encoder架构采用Deeplabv3，decoder采用一个简单却有效的模块用于恢复目标边界细节。并可使用空洞卷积在指定计算资源下控制feature的分辨率。论文探索了Xception和深度分离卷积在模型上的使用，进一步提高模型的速度和性能。模型在VOC2012上获得了SOAT。Google出品，必出精品，这网络真的牛。 </p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>github：<a href="https://github.com/jfzhang95/pytorch-deeplab-xception.git">https://github.com/jfzhang95/pytorch-deeplab-xception.git</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 	Dilated ResNet with multi-grid + improved ASPP + decoder</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepLab</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, backbone=<span class="string">&#x27;resnet&#x27;</span>, output_stride=<span class="number">16</span>, num_classes=<span class="number">21</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 sync_bn=<span class="literal">True</span>, freeze_bn=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DeepLab, self).__init__()</span><br><span class="line">        <span class="keyword">if</span> backbone == <span class="string">&#x27;drn&#x27;</span>:</span><br><span class="line">            output_stride = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sync_bn == <span class="literal">True</span>:</span><br><span class="line">            BatchNorm = SynchronizedBatchNorm2d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            BatchNorm = nn.BatchNorm2d</span><br><span class="line">		<span class="comment"># 基网络</span></span><br><span class="line">        self.backbone = build_backbone(backbone, output_stride, BatchNorm)</span><br><span class="line">        <span class="comment"># ASPP模块</span></span><br><span class="line">        self.aspp = build_aspp(backbone, output_stride, BatchNorm)</span><br><span class="line">        <span class="comment"># 编解码器</span></span><br><span class="line">        self.decoder = build_decoder(num_classes, backbone, BatchNorm)</span><br><span class="line"></span><br><span class="line">        self.freeze_bn = freeze_bn</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        <span class="comment"># backbone 输出低级特征和编码特征</span></span><br><span class="line">        x, low_level_feat = self.backbone(<span class="built_in">input</span>)</span><br><span class="line">        x = self.aspp(x)</span><br><span class="line">        x = self.decoder(x, low_level_feat)</span><br><span class="line">        <span class="comment"># 上采样</span></span><br><span class="line">        x = F.interpolate(x, size=<span class="built_in">input</span>.size()[<span class="number">2</span>:], mode=<span class="string">&#x27;bilinear&#x27;</span>, align_corners=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 构建backbone</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> modeling.backbone <span class="keyword">import</span> resnet, xception, drn, mobilenet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_backbone</span>(<span class="params">backbone, output_stride, BatchNorm</span>):</span></span><br><span class="line">    <span class="keyword">if</span> backbone == <span class="string">&#x27;resnet&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> resnet.ResNet101(output_stride, BatchNorm)</span><br><span class="line">    <span class="keyword">elif</span> backbone == <span class="string">&#x27;xception&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> xception.AlignedXception(output_stride, BatchNorm)</span><br><span class="line">    <span class="keyword">elif</span> backbone == <span class="string">&#x27;drn&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> drn.drn_d_54(BatchNorm)</span><br><span class="line">    <span class="keyword">elif</span> backbone == <span class="string">&#x27;mobilenet&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> mobilenet.MobileNetV2(output_stride, BatchNorm)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ASPP：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> modeling.sync_batchnorm.batchnorm <span class="keyword">import</span> SynchronizedBatchNorm2d</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ASPPModule</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inplanes, planes, kernel_size, padding, dilation, BatchNorm</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(_ASPPModule, self).__init__()</span><br><span class="line">        self.atrous_conv = nn.Conv2d(inplanes, planes, kernel_size=kernel_size,  stride=<span class="number">1</span>, padding=padding, dilation=dilation, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn = BatchNorm(planes)</span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self._init_weight()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.atrous_conv(x) <span class="comment"># 空洞卷积</span></span><br><span class="line">        x = self.bn(x) <span class="comment"># 加入bn层</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.relu(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_weight</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                torch.nn.init.kaiming_normal_(m.weight)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, SynchronizedBatchNorm2d):</span><br><span class="line">                m.weight.data.fill_(<span class="number">1</span>)</span><br><span class="line">                m.bias.data.zero_()</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">                m.weight.data.fill_(<span class="number">1</span>)</span><br><span class="line">                m.bias.data.zero_()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASPP</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, backbone, output_stride, BatchNorm</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ASPP, self).__init__()</span><br><span class="line">        <span class="keyword">if</span> backbone == <span class="string">&#x27;drn&#x27;</span>:</span><br><span class="line">            inplanes = <span class="number">512</span></span><br><span class="line">        <span class="keyword">elif</span> backbone == <span class="string">&#x27;mobilenet&#x27;</span>:</span><br><span class="line">            inplanes = <span class="number">320</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            inplanes = <span class="number">2048</span></span><br><span class="line">        <span class="keyword">if</span> output_stride == <span class="number">16</span>:</span><br><span class="line">            dilations = [<span class="number">1</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">18</span>]</span><br><span class="line">        <span class="keyword">elif</span> output_stride == <span class="number">8</span>:</span><br><span class="line">            dilations = [<span class="number">1</span>, <span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">        self.aspp1 = _ASPPModule(inplanes, <span class="number">256</span>, <span class="number">1</span>, padding=<span class="number">0</span>, dilation=dilations[<span class="number">0</span>], BatchNorm=BatchNorm)</span><br><span class="line">        self.aspp2 = _ASPPModule(inplanes, <span class="number">256</span>, <span class="number">3</span>, padding=dilations[<span class="number">1</span>], dilation=dilations[<span class="number">1</span>], BatchNorm=BatchNorm)</span><br><span class="line">        self.aspp3 = _ASPPModule(inplanes, <span class="number">256</span>, <span class="number">3</span>, padding=dilations[<span class="number">2</span>], dilation=dilations[<span class="number">2</span>], BatchNorm=BatchNorm)</span><br><span class="line">        self.aspp4 = _ASPPModule(inplanes, <span class="number">256</span>, <span class="number">3</span>, padding=dilations[<span class="number">3</span>], dilation=dilations[<span class="number">3</span>], BatchNorm=BatchNorm)</span><br><span class="line">		</span><br><span class="line">        self.global_avg_pool = nn.Sequential(nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">                                             nn.Conv2d(inplanes, <span class="number">256</span>, <span class="number">1</span>, stride=<span class="number">1</span>, bias=<span class="literal">False</span>),  BatchNorm(<span class="number">256</span>),  nn.ReLU())</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1280</span>, <span class="number">256</span>, <span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = BatchNorm(<span class="number">256</span>)</span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line">        self.dropout = nn.Dropout(<span class="number">0.5</span>)</span><br><span class="line">        self._init_weight()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x1 = self.aspp1(x)</span><br><span class="line">        x2 = self.aspp2(x)</span><br><span class="line">        x3 = self.aspp3(x)</span><br><span class="line">        x4 = self.aspp4(x)</span><br><span class="line">        x5 = self.global_avg_pool(x)</span><br><span class="line">        x5 = F.interpolate(x5, size=x4.size()[<span class="number">2</span>:], mode=<span class="string">&#x27;bilinear&#x27;</span>, align_corners=<span class="literal">True</span>)</span><br><span class="line">        x = torch.cat((x1, x2, x3, x4, x5), dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.bn1(x)</span><br><span class="line">        x = self.relu(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.dropout(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_weight</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                <span class="comment"># n = m.kernel_size[0] * m.kernel_size[1] * m.out_channels</span></span><br><span class="line">                <span class="comment"># m.weight.data.normal_(0, math.sqrt(2. / n))</span></span><br><span class="line">                torch.nn.init.kaiming_normal_(m.weight)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, SynchronizedBatchNorm2d):</span><br><span class="line">                m.weight.data.fill_(<span class="number">1</span>)</span><br><span class="line">                m.bias.data.zero_()</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">                m.weight.data.fill_(<span class="number">1</span>)</span><br><span class="line">                m.bias.data.zero_()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_aspp</span>(<span class="params">backbone, output_stride, BatchNorm</span>):</span></span><br><span class="line">    <span class="keyword">return</span> ASPP(backbone, output_stride, BatchNorm)</span><br></pre></td></tr></table></figure>

<p>Decoder：编解码器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> modeling.sync_batchnorm.batchnorm <span class="keyword">import</span> SynchronizedBatchNorm2d</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoder</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_classes, backbone, BatchNorm</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Decoder, self).__init__()</span><br><span class="line">        <span class="keyword">if</span> backbone == <span class="string">&#x27;resnet&#x27;</span> <span class="keyword">or</span> backbone == <span class="string">&#x27;drn&#x27;</span>:</span><br><span class="line">            low_level_inplanes = <span class="number">256</span></span><br><span class="line">        <span class="keyword">elif</span> backbone == <span class="string">&#x27;xception&#x27;</span>:</span><br><span class="line">            low_level_inplanes = <span class="number">128</span></span><br><span class="line">        <span class="keyword">elif</span> backbone == <span class="string">&#x27;mobilenet&#x27;</span>:</span><br><span class="line">            low_level_inplanes = <span class="number">24</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">		<span class="comment"># 低级特征融合  降维到48  1x1卷积</span></span><br><span class="line">        self.conv1 = nn.Conv2d(low_level_inplanes, <span class="number">48</span>, <span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = BatchNorm(<span class="number">48</span>)</span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line">        self.last_conv = nn.Sequential(nn.Conv2d(<span class="number">304</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                                       BatchNorm(<span class="number">256</span>),</span><br><span class="line">                                       nn.ReLU(),</span><br><span class="line">                                       nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">                                       nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">                                       BatchNorm(<span class="number">256</span>),</span><br><span class="line">                                       nn.ReLU(),</span><br><span class="line">                                       nn.Dropout(<span class="number">0.1</span>),</span><br><span class="line">                                       nn.Conv2d(<span class="number">256</span>, num_classes, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>))</span><br><span class="line">        self._init_weight()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, low_level_feat</span>):</span></span><br><span class="line">        low_level_feat = self.conv1(low_level_feat)</span><br><span class="line">        low_level_feat = self.bn1(low_level_feat)</span><br><span class="line">        low_level_feat = self.relu(low_level_feat)</span><br><span class="line"></span><br><span class="line">        x = F.interpolate(x, size=low_level_feat.size()[<span class="number">2</span>:], mode=<span class="string">&#x27;bilinear&#x27;</span>, align_corners=<span class="literal">True</span>)</span><br><span class="line">        x = torch.cat((x, low_level_feat), dim=<span class="number">1</span>)</span><br><span class="line">        x = self.last_conv(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_weight</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                torch.nn.init.kaiming_normal_(m.weight)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, SynchronizedBatchNorm2d):</span><br><span class="line">                m.weight.data.fill_(<span class="number">1</span>)</span><br><span class="line">                m.bias.data.zero_()</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">                m.weight.data.fill_(<span class="number">1</span>)</span><br><span class="line">                m.bias.data.zero_()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_decoder</span>(<span class="params">num_classes, backbone, BatchNorm</span>):</span></span><br><span class="line">    <span class="keyword">return</span> Decoder(num_classes, backbone, BatchNorm)</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://medium.com/@sh.tsang/review-deeplabv3-atrous-separable-convolution-semantic-segmentation-a625f6e83b90">Review: DeepLabv3+ — Atrous Separable Convolution (Semantic Segmentation)</a></li>
<li><a href="https://mp.weixin.qq.com/s/0dS0Isj2oCo_CF7p4riSCA">项目实战 DeepLabV1,V2,V3 Google三大语义分割算法源码解析</a></li>
<li><a href="https://www.yanxishe.com/blogDetail/15772">语义分割算法之DeepLabV3+论文解读及代码分析</a></li>
</ol>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>papers</tag>
      </tags>
  </entry>
  <entry>
    <title>Java专题之Socket编程</title>
    <url>/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h1><p>Java 中的网络支持：</p>
<ul>
<li><code>InetAddress</code>：用于表示网络上的硬件资源，即 IP 地址；</li>
<li><code>URL</code>：统一资源定位符；</li>
<li><code>Sockets</code>：使用 TCP 协议实现网络通信；</li>
<li><code>Datagram</code>：使用 UDP 协议实现网络通信。</li>
</ul>
<hr>
<h1 id="二、-InetAddress"><a href="#二、-InetAddress" class="headerlink" title="二、 InetAddress"></a>二、 InetAddress</h1><p> 没有公有的构造函数，只能通过静态方法来创建实例。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IP  InetAddress</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-19 21:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        InetAddress address = InetAddress.getLocalHost(); <span class="comment">// 192.168.145.1</span></span><br><span class="line">        System.out.println(address.getHostAddress());</span><br><span class="line">        System.out.println(address.getHostName()); <span class="comment">// zhuhongliang</span></span><br><span class="line">        <span class="comment">// 根据域名得到InetAddress</span></span><br><span class="line">        <span class="comment">//根据域名得到InetAddress对象</span></span><br><span class="line">        address = InetAddress.getByName(<span class="string">&quot;www.163.com&quot;</span>);</span><br><span class="line">        System.out.println(address.getHostAddress());<span class="comment">//返回 163服务器的ip:183.216.182.9</span></span><br><span class="line">        System.out.println(address.getHostName());  <span class="comment">//输出：www.163.com</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据ip得到InetAddress对象</span></span><br><span class="line">        address = InetAddress.getByName(<span class="string">&quot;183.216.182.7&quot;</span>);</span><br><span class="line">        System.out.println(address.getHostAddress());  <span class="comment">//返回 163服务器的ip:61.135.253.15</span></span><br><span class="line">        System.out.println(address.getHostName());<span class="comment">//输出ip而不是域名。如果这个IP地 址不存在或DNS 服务器不允许进行IP地址和域名的映射，getHostName方法就直接返回这个IP地址。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>ip地址用来标识一台计算机，端口用来区分不同的程序。</p>
<blockquote>
<p>常用的命令：</p>
<p>查看所有端口： netstat -ano</p>
<p>查看指定端口： netstat -ano | findstr “5023”</p>
<p>查看指定进程： tasklist | findstr “5032”</p>
<p>查看具体程序： 使用任务管理器查看pid</p>
</blockquote>
<img src="/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582167681824.png" alt="1582167681824" style="zoom:100%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包含端口</span></span><br><span class="line">InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>); <span class="comment">//指定了端口</span></span><br><span class="line">InetSocketAddress socketAddress2 = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">9000</span>);</span><br><span class="line">System.out.println(socketAddress.getHostName()); <span class="comment">// 127.0.0.1</span></span><br><span class="line">System.out.println(socketAddress2.getAddress()); <span class="comment">//  localhost/127.0.0.1</span></span><br><span class="line">System.out.println(socketAddress.getPort()); <span class="comment">// 8080</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="三、-URL"><a href="#三、-URL" class="headerlink" title="三、 URL"></a>三、 URL</h1><p>URL（Uniform Resource Locator）：  统一资源定位符 ， 由4部分组成：协议 、存放资源的主机域名、端口号和资源文件名。 如： <a href="http://www.www.baidu.com:9090/index.html">http://www.www.baidu.com:9090/index.html</a></p>
<p>URL是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引 擎的查询。</p>
<blockquote>
<p>互联网的三大基石： html， http， url</p>
</blockquote>
<p>URI（Universal Resource Identifier）： 统一资源标志符，用来标识抽象或者物理资源的一个紧凑字符串。</p>
<p>URN（Universal Resource Name）：统一资源名称， 通过特定命名空间中的唯一名称或ID来标识资源。</p>
<img src="/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582123666801.png" alt="1582167681824" style="zoom:100%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * URL: 统一资源定位符  区分资源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-19 22:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com:9090/index.html?uname=zhu&amp;age=18#a&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取四个值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;协议：&quot;</span>+ url.getProtocol());</span><br><span class="line">        System.out.println(<span class="string">&quot;域名|ip： &quot;</span>+ url.getHost());</span><br><span class="line">        System.out.println(<span class="string">&quot;请求的资源1：&quot;</span>+ url.getFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;请求的资源2： &quot;</span>+ url.getPath());</span><br><span class="line">        <span class="comment">//参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;参数：&quot;</span>+ url.getQuery());</span><br><span class="line">        <span class="comment">// 锚点</span></span><br><span class="line">        System.out.println(<span class="string">&quot;锚点： &quot;</span>+ url.getRef());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>协议：http<br>域名|ip： <a href="http://www.baidu.com/">www.baidu.com</a><br>请求的资源1：/index.html?uname=zhu&amp;age=18<br>请求的资源2： /index.html<br>参数：uname=zhu&amp;age=18<br>锚点： a</p>
</blockquote>
<h2 id="爬虫原理"><a href="#爬虫原理" class="headerlink" title="爬虫原理"></a>爬虫原理</h2><p>使用url来下载资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * URL下载资源  爬虫原理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-20 10:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpyderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://www.jd.com&quot;</span>);</span><br><span class="line"><span class="comment">//        URL url = new URL(&quot;https://www.dianping.com&quot;); //不是所有的网站都可以爬</span></span><br><span class="line">        InputStream is  = url.openStream(); <span class="comment">//</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is, <span class="string">&quot;utf8&quot;</span>));</span><br><span class="line">        String msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != (msg=br.readLine()))&#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于不能直接通过URL来获取资源的，可以通过浏览器请求方式来获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *爬虫原理  : 模拟浏览器访问</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-20 10:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpyderTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://www.dianping.com&quot;</span>);</span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection)url.openConnection();</span><br><span class="line">        conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        conn.setRequestProperty(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36&quot;</span>);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream(), <span class="string">&quot;utf8&quot;</span>));</span><br><span class="line">        String msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != (msg = br.readLine()))&#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="四、-传输协议TCP-amp-UDP"><a href="#四、-传输协议TCP-amp-UDP" class="headerlink" title="四、 传输协议TCP&amp;UDP"></a>四、 传输协议TCP&amp;UDP</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 </p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 </p>
<h2 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h2><p>​        我们开发的网络应用程序位于<strong>应用层</strong>，TCP和UDP属于传输层协议，在应用层如何使用传输层 的服务呢？在应用层和传输层之间，则是使用套接字来进行分离。 </p>
<p>​        套接字就像是传输层为应用层开的一个小口，应用程序通过这个小口向远程发送数据，或者 接收远程发来的数据；而这个小口以内，也就是数据进入这个口之后，或者数据从这个口出来之前，是不知道也不需要知道的，也不会关心它如何传输，这属于网络其它层次的工作。</p>
<img src="/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582169809295.png" alt="1582169809295" style="zoom:100%;">

<p>​        Socket实际是网络传输层供给应用层的编程接口。传输层则在网络层的基础上提供进 程到进程问的逻辑通道，而应用层的进程则利用传输层向另一台主机的某一进程通 信。Socket就是应用层与传输层之间的桥梁 。</p>
<p>​        使用Socket编程可以开发客户机和服务器应用程序，可以在本地网络上进行通信，也 可通过Internet在全球范围内通信。</p>
<blockquote>
<p>生活案例1：</p>
<p>​        如果你想写封邮件发给远方的朋友，如何写信、将信 打包，属于应用层。信怎么写，怎么打包完全由我们做主；<br>​        而当我们将信投入邮筒时，邮筒的那个口就是套接字， 在进入套接字之后，就是传输层、网络层等（邮局、公路交管或者航线等）其它层次的工作了。我们从来不会去关心信是如何从西安发往北京的，我们只知道 写好了投入邮筒就OK了。</p>
</blockquote>
<img src="/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582170182414.png" alt="1582170182414" style="zoom:80%;">

<blockquote>
<p>生活案例2:</p>
<p>如果你想发货给国外，你只要把 货物放入集装箱，然后交给码头就可以了。发送什么货物，货物如何打包, 完全有你做主。 码头就是套接字，剩下的事情就 交给港口和货运公司处理就行了，具体细节我们无需了解。</p>
</blockquote>
<p>​                                     <img src="/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/socket.jpg" alt="img" style="zoom:60%;"> </p>
<hr>
<h1 id="五、-UDP编程"><a href="#五、-UDP编程" class="headerlink" title="五、 UDP编程"></a>五、 UDP编程</h1><h2 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h2><ul>
<li>DatagramSocket：通信类 :  用于发送或者接受数据包的套接字</li>
<li>DatagramPacket：数据包类</li>
</ul>
<p>使用基于UDP协议的Socket网络编程实现 ：</p>
<p>​        不需要利用IO流实现数据的传输。 每个数据发送单元被统一封装成数据包的方式，发送方将数据包发送到网络中，数据包在网络中去寻找他的目的地。</p>
<p>UDP编程 ： 一切转换成字节数组</p>
<p>接收端：</p>
<blockquote>
<p>1.使用DatagramSocket 指定端口 创建接收端</p>
<p>2.指定容器， 封装DatagramPacket包</p>
<p>3.阻塞式接受包裹receive（DatagramPacket p）</p>
<p>4.分析数据  byte[]    getData()     getLength()</p>
<p>5.释放资源</p>
</blockquote>
<p>发送端</p>
<blockquote>
<p>1.使用DatagramSocket 指定端口 创建发送端</p>
<p>2.准备数据  ==》  一定要转成字节数组</p>
<p>3.封装 DatagramPacket包，需要指定目的地 + 端口</p>
<p>4.发送包裹  send( DatagramPacket p）</p>
<p>5.释放资源</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受端：</span></span><br><span class="line"><span class="comment"> * 1. 使用DatagramSocket 指定端口 创建接收端</span></span><br><span class="line"><span class="comment"> * 2. 指定容器， 封装DatagramPacket包</span></span><br><span class="line"><span class="comment"> * 3. 阻塞式接受包裹receive（DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 4. 分析数据</span></span><br><span class="line"><span class="comment"> *  byte[] getData()</span></span><br><span class="line"><span class="comment"> *          getLength()</span></span><br><span class="line"><span class="comment"> *  5.  释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020-02-20 11:51</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收端启动中...&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 使用DatagramSocket 指定端口 创建接收端</span></span><br><span class="line">        DatagramSocket server = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2. 指定容器， 封装DatagramPacket包</span></span><br><span class="line">        <span class="keyword">byte</span>[] contiainer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">60</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(contiainer, <span class="number">0</span>, contiainer.length);</span><br><span class="line">        <span class="comment">// 3. 阻塞式接受包裹receive（DatagramPacket p）</span></span><br><span class="line">        server.receive(packet);</span><br><span class="line">        <span class="comment">// 4. 分析数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] datas = packet.getData();</span><br><span class="line">        <span class="keyword">int</span> len = packet.getLength();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(datas, <span class="number">0</span>, len));</span><br><span class="line">        <span class="comment">// 5.  释放资源</span></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送端：</span></span><br><span class="line"><span class="comment"> * 1. 使用DatagramSocket 指定端口 创建发送端</span></span><br><span class="line"><span class="comment"> * 2. 准备数据 一定转成字节数组</span></span><br><span class="line"><span class="comment"> * 3. 封装DatagramPacket包，需要指定目的地</span></span><br><span class="line"><span class="comment"> * 4. 发送包裹send( DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 5.  释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-20 17:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UPDCilent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送方启动中...&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 使用DatagramSocket 指定端口 创建发送端</span></span><br><span class="line">        DatagramSocket client = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2. 准备数据 一定转成字节数组</span></span><br><span class="line">        String data = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] datas = data.getBytes();</span><br><span class="line">        <span class="comment">//3. 封装DatagramPacket包，需要指定目的地</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length,</span><br><span class="line">                <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        <span class="comment">// 4. 发送包裹send( DatagramPacket p）</span></span><br><span class="line">        client.send(packet);</span><br><span class="line">        <span class="comment">// 5.  释放资源</span></span><br><span class="line">        client.close();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="UDP编程：-传输基本数据类型和引用"><a href="#UDP编程：-传输基本数据类型和引用" class="headerlink" title="UDP编程： 传输基本数据类型和引用"></a>UDP编程： 传输基本数据类型和引用</h2><p>服务端（接收端）： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受端： 基本数据类型和引用  </span></span><br><span class="line"><span class="comment"> * 1. 使用DatagramSocket 指定端口 创建接收端</span></span><br><span class="line"><span class="comment"> * 2. 指定容器， 封装DatagramPacket包</span></span><br><span class="line"><span class="comment"> * 3. 阻塞式接受包裹receive（DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 4. 分析数据</span></span><br><span class="line"><span class="comment"> *  5.  释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-20 19:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPTypeServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传输基本数据类型==&gt;接收端启动中。。。。&quot;</span>);</span><br><span class="line">        DatagramSocket server = <span class="keyword">new</span> DatagramSocket(<span class="number">9898</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] datas = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">90</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length);</span><br><span class="line">        server.receive(packet);</span><br><span class="line">        <span class="keyword">byte</span>[] data = packet.getData();</span><br><span class="line">        <span class="keyword">int</span> len = packet.getLength();</span><br><span class="line">        ObjectInputStream dis = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> ByteArrayInputStream(data)));</span><br><span class="line">        <span class="comment">// 按照顺序读取</span></span><br><span class="line">        String msg = dis.readUTF(); <span class="comment">//  读取</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = dis.readBoolean();</span><br><span class="line">        <span class="keyword">int</span> a = dis.readInt();</span><br><span class="line">        Object o = dis.readObject();</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        System.out.println(a+<span class="string">&quot;=&gt;&quot;</span>+msg+<span class="string">&quot;--&gt;&quot;</span>+flag);</span><br><span class="line"><span class="comment">//        o.toString();</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Employee)&#123;</span><br><span class="line">            Employee e = (Employee)o;</span><br><span class="line">            e.toString();</span><br><span class="line">            System.out.println(<span class="string">&quot;的确是马云&quot;</span>);</span><br><span class="line">            System.out.println(e.getName() +<span class="string">&quot;:&quot;</span>+  e.getMoney());</span><br><span class="line">        &#125;</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端（发送端）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送端： 基本数据类型和引用</span></span><br><span class="line"><span class="comment"> * 1. 使用DatagramSocket 指定端口 创建发送端</span></span><br><span class="line"><span class="comment"> * 2. 准备数据 一定转成字节数组</span></span><br><span class="line"><span class="comment"> * 3. 封装DatagramPacket包，需要指定目的地</span></span><br><span class="line"><span class="comment"> * 4. 发送包裹send( DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 5.  释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-20 17:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UPDTypeCilent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传输基本数据类型==&gt;发送方启动中...&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 使用DatagramSocket 指定端口 创建发送端</span></span><br><span class="line">        DatagramSocket client = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2. 准备数据 一定转成字节数组</span></span><br><span class="line">        ByteArrayOutputStream  bao = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream dos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> BufferedOutputStream(bao));</span><br><span class="line">        dos.writeUTF(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">        dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">        dos.writeInt(<span class="number">99</span>);</span><br><span class="line">        <span class="comment">// 对象</span></span><br><span class="line">        Employee e = <span class="keyword">new</span> Employee(<span class="string">&quot;马云&quot;</span>, <span class="number">900000</span>);</span><br><span class="line">        dos.writeObject(e);</span><br><span class="line">        dos.flush();</span><br><span class="line">        <span class="keyword">byte</span>[] datas = bao.toByteArray();</span><br><span class="line">        <span class="comment">//3. 封装DatagramPacket包，需要指定目的地</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length,</span><br><span class="line">                <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">9898</span>));</span><br><span class="line">        <span class="comment">// 4. 发送包裹send( DatagramPacket p）</span></span><br><span class="line">        client.send(packet);</span><br><span class="line">        <span class="comment">// 5.  释放资源</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>传输基本数据类型==&gt;发送方启动中…</p>
<p>66<br>99=&gt;Hello world!–&gt;true<br>的确是马云<br>null:900000.0</p>
</blockquote>
<h2 id="UDP编程：-传输文件"><a href="#UDP编程：-传输文件" class="headerlink" title="UDP编程： 传输文件"></a>UDP编程： 传输文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送端： 发送文件</span></span><br><span class="line"><span class="comment"> * 1. 使用DatagramSocket 指定端口 创建发送端</span></span><br><span class="line"><span class="comment"> * 2. 准备数据 一定转成字节数组</span></span><br><span class="line"><span class="comment"> * 3. 封装DatagramPacket包，需要指定目的地</span></span><br><span class="line"><span class="comment"> * 4. 发送包裹send( DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 5.  释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-20 17:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UPDFileCilent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件 ==&gt; 发送方启动中...&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 使用DatagramSocket 指定端口 创建发送端</span></span><br><span class="line">        DatagramSocket client = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2. 准备数据 一定转成字节数组</span></span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;./socket/socket.png&quot;</span>);  <span class="comment">// 注意图片不能太大，否则会报异常</span></span><br><span class="line">        BufferedInputStream bi = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">        ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] data  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">60</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ( -<span class="number">1</span> !=  (len = is.read(data,<span class="number">0</span>, data.length)))&#123;</span><br><span class="line">            os.write(data, <span class="number">0</span>, len);</span><br><span class="line">            os.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] datas = os.toByteArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 封装DatagramPacket包，需要指定目的地</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length,</span><br><span class="line">                <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        <span class="comment">// 4. 发送包裹send( DatagramPacket p）</span></span><br><span class="line">        client.send(packet);</span><br><span class="line">        <span class="comment">// 5.  释放资源</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受端：</span></span><br><span class="line"><span class="comment"> * 1. 使用DatagramSocket 指定端口 创建接收端</span></span><br><span class="line"><span class="comment"> * 2. 指定容器， 封装DatagramPacket包</span></span><br><span class="line"><span class="comment"> * 3. 阻塞式接受包裹receive（DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 4. 分析数据</span></span><br><span class="line"><span class="comment"> *  byte[] getData()</span></span><br><span class="line"><span class="comment"> *          getLength()</span></span><br><span class="line"><span class="comment"> *  5.  释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020-02-20 11:51</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPFileServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收端启动中...&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 使用DatagramSocket 指定端口 创建接收端</span></span><br><span class="line">        DatagramSocket server = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2. 指定容器， 封装DatagramPacket包</span></span><br><span class="line">        <span class="keyword">byte</span>[] contiainer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">60</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(contiainer, <span class="number">0</span>, contiainer.length);</span><br><span class="line">        <span class="comment">// 3. 阻塞式接受包裹receive（DatagramPacket p）</span></span><br><span class="line">        server.receive(packet);</span><br><span class="line">        <span class="comment">// 4. 分析数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] datas = packet.getData();</span><br><span class="line">        <span class="keyword">int</span> len = packet.getLength();</span><br><span class="line"><span class="comment">//        System.out.println(new String(datas, 0, len));</span></span><br><span class="line">        BufferedOutputStream os =<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./socket/copy.png&quot;</span>)); <span class="comment">//接受数据</span></span><br><span class="line">        os.write(datas, <span class="number">0</span>, datas.length);</span><br><span class="line">        os.flush();</span><br><span class="line">        <span class="comment">// 5.  释放资源</span></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="UDP案例：-多线程实现在线咨询"><a href="#UDP案例：-多线程实现在线咨询" class="headerlink" title="UDP案例： 多线程实现在线咨询"></a>UDP案例： 多线程实现在线咨询</h2><h3 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送端： 使用面向对象封装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 10:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">talkSend</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket client ; <span class="comment">// 发送端套接字</span></span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader; <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">private</span> String toIP; <span class="comment">// 发送到服务端的IP</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> toPort; <span class="comment">// 服务端的端口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">talkSend</span><span class="params">(<span class="keyword">int</span> port, String toIP, <span class="keyword">int</span> toPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.toIP = toIP;</span><br><span class="line">        <span class="keyword">this</span>.toPort = toPort;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.client = <span class="keyword">new</span> DatagramSocket(port);</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            String msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg = reader.readLine();</span><br><span class="line">                <span class="keyword">byte</span>[] datas = msg.getBytes();</span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length, <span class="keyword">new</span> InetSocketAddress(<span class="keyword">this</span>.toIP, <span class="keyword">this</span>.toPort));</span><br><span class="line">                client.send(packet); <span class="comment">// 发送</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equals(msg))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 11:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">talkRecieve</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket server;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">talkRecieve</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.server = <span class="keyword">new</span> DatagramSocket(port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">60</span>];</span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(data,<span class="number">0</span>, data.length);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                server.receive(packet);</span><br><span class="line">                <span class="keyword">byte</span>[] datas = packet.getData();</span><br><span class="line">                String msg = <span class="keyword">new</span> String(datas);</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;bye&quot;</span>.equals(msg))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建学生端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生端： 加入多线程，实现在线交流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 11:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkStudent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> talkSend(<span class="number">8989</span>, <span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> talkRecieve(<span class="number">10024</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建教师端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 教室端： 加入多线程，实现在线交流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 11:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkTeacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> talkRecieve(<span class="number">9999</span>)).start(); <span class="comment">// 接受信息</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> talkSend(<span class="number">10025</span>, <span class="string">&quot;localhost&quot;</span>, <span class="number">10024</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582258221891.png" class width="1582258221891">

<hr>
<h1 id="六、-TCP-编程"><a href="#六、-TCP-编程" class="headerlink" title="六、 TCP 编程"></a>六、 TCP 编程</h1><p>TCP协议基于请求-响应模式，  在网络通讯中，第一次主动发起通讯的程序被称作客户端(Client)程序，第一次通讯中等待连接的程序被称作服务器端 (Server)程序。利用IO流实现数据的传输。</p>
<img src="/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582261736199.png" alt="1582261736199" style="zoom:100%;">

<h2 id="TCP通信原理"><a href="#TCP通信原理" class="headerlink" title="TCP通信原理"></a>TCP通信原理</h2><p> 服务器创建<code>ServerSocket</code>，在指定端口监听并并处理请求。</p>
<p>客户端创建<code>Socket</code>，向服务器发送请求。</p>
<img src="/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582262725020.png" alt="1582262725020" style="zoom:100%;">

<h2 id="完成网络登录功能"><a href="#完成网络登录功能" class="headerlink" title="完成网络登录功能"></a>完成网络登录功能</h2><p>使用基于TCP协议的Socket网络编程实现。</p>
<blockquote>
<p>单向：客户端向服务器端发送字符串，服务器获取字符串并输出<br>双向：服务器端给出客户端反馈，客户端得到反馈并输出<br>对象：客户端向服务器端发送User对象，服务器端获取对象并输出<br>多线程：服务器接收多个客户端的请求，并给出反馈每个客户请求开启一个线程</p>
</blockquote>
<p>服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">/**</span><br><span class="line"> * TCP单向： 服务端</span><br><span class="line"> * @author Hongliang Zhu</span><br><span class="line"> * @create 2020-02-21 13:28</span><br><span class="line"> */</span><br><span class="line">public class TCPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;-----------服务端--------------&quot;);</span><br><span class="line">        ServerSocket server = new ServerSocket(9696);</span><br><span class="line">        Socket cilent = server.accept(); //  监听连接请求， 返回对应的客户端</span><br><span class="line">        System.out.println(&quot;建立了一个连接&quot;);</span><br><span class="line">        InputStream is = cilent.getInputStream();</span><br><span class="line">        DataInputStream dis = new DataInputStream(is);</span><br><span class="line">        // 读取</span><br><span class="line">        String uname = null;</span><br><span class="line">        String upwd = null;</span><br><span class="line">        String msg = dis.readUTF();</span><br><span class="line">        String []datas = msg.split(&quot;&amp;&quot;);</span><br><span class="line">        for(String s: datas)&#123;</span><br><span class="line">            String[] info = s.split(&quot;=&quot;);</span><br><span class="line">            if(&quot;uname&quot;.equals(info[0]))&#123;</span><br><span class="line">                System.out.println(&quot;您的用户名为：&quot;+ info[1]);</span><br><span class="line">                uname = info[1];</span><br><span class="line">            &#125;</span><br><span class="line">            if(&quot;upwd&quot;.equals(info[0]))&#123;</span><br><span class="line">                System.out.println(&quot;您的密码为：&quot;+ info[1]);</span><br><span class="line">                upwd = info[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断：返回给客户端的信息</span><br><span class="line">        String back = null;</span><br><span class="line">        DataOutputStream dos = new DataOutputStream(cilent.getOutputStream());</span><br><span class="line">        if(&quot;zhuhongliang&quot;.equals(uname) &amp;&amp; &quot;123456&quot;.equals(upwd))&#123;</span><br><span class="line">            back = &quot;登录成功， 欢迎回来&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            back = &quot;用户名或者密码错误！&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        dos.writeUTF(back);</span><br><span class="line">        dos.flush();</span><br><span class="line"></span><br><span class="line">        // 关闭资源</span><br><span class="line">        dos.close();</span><br><span class="line">        dis.close();</span><br><span class="line">        cilent.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCp 客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 13:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------客户端---------------&quot;</span>);</span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">9696</span>); <span class="comment">//服务器的ip和端口</span></span><br><span class="line">        <span class="comment">// 操作： 输入输出流</span></span><br><span class="line">        String uname;</span><br><span class="line">        String upwd;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">        uname = br.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        upwd = br.readLine();</span><br><span class="line">        String msg = <span class="string">&quot;uname=&quot;</span>+ uname +<span class="string">&quot;&amp;&quot;</span>+<span class="string">&quot;upwd=&quot;</span>+upwd;</span><br><span class="line">        <span class="comment">// 写出</span></span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">        dos.writeUTF(msg);</span><br><span class="line">        dos.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收服务端返回的结果</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">        String res = dis.readUTF();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        dos.close();</span><br><span class="line">        br.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582267524749.png" alt="1582267524749" style="zoom:100%;">

<img src="/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582267597408.png" alt="1582267597408" style="zoom:100%;">

<img src="/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582267550778.png" alt="1582267550778" style="zoom:100%;">

<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCp 客户端  文件上传</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 13:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------客户端---------------&quot;</span>);</span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">9696</span>); <span class="comment">//服务器的ip和端口</span></span><br><span class="line">        <span class="comment">// 操作： 输入输出流</span></span><br><span class="line">        <span class="comment">// 文件拷贝</span></span><br><span class="line">        InputStream is = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;./io/io.png&quot;</span>));</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> BufferedOutputStream(client.getOutputStream());</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (-<span class="number">1</span> != (len = is.read(buff)))&#123;</span><br><span class="line">            os.write(buff,<span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        os.flush();</span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP:服务端  保存文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 13:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------服务端--------------&quot;</span>);</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9696</span>);</span><br><span class="line">        Socket cilent = server.accept(); <span class="comment">//  监听连接请求， 返回对应的客户端</span></span><br><span class="line">        System.out.println(<span class="string">&quot;建立了一个连接&quot;</span>);</span><br><span class="line">        <span class="comment">// 接受数据</span></span><br><span class="line">        InputStream is = <span class="keyword">new</span> BufferedInputStream(cilent.getInputStream());</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;./socket/tcp.png&quot;</span>)));</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (-<span class="number">1</span> != (len = is.read(buff)))&#123;</span><br><span class="line">            os.write(buff,<span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        os.flush();</span><br><span class="line">        is.close();</span><br><span class="line">        os.close();</span><br><span class="line">        cilent.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多用户登录"><a href="#多用户登录" class="headerlink" title="多用户登录"></a>多用户登录</h2><p>服务端： 使用了<strong>多线程</strong>实现多个用户同时处理，将对接管道封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP多用户登录： 服务端  多线程处理  面向对象高度封装！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 13:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPMutiServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// main方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------服务端--------------&quot;</span>);</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9696</span>);</span><br><span class="line">        <span class="keyword">boolean</span> isRuning = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (isRuning)&#123;</span><br><span class="line">            Socket cilent = server.accept(); <span class="comment">//  监听连接请求， 返回对应的客户端</span></span><br><span class="line">            System.out.println(<span class="string">&quot;建立了一个连接&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Channel(cilent)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 封装管道 里面有输入流和输出流 ，使用多线程可以服务多个客户端</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket client; <span class="comment">// 客户端</span></span><br><span class="line">        <span class="keyword">private</span> DataInputStream dis; <span class="comment">// 输入流  ==&gt; 用于客户端请求服务端的信息</span></span><br><span class="line">        <span class="keyword">private</span> DataOutputStream dos; <span class="comment">//  输出流 ==&gt; 服务端给客户端的响应信息</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Channel</span><span class="params">(Socket client)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = client;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">this</span>.client.getInputStream()); <span class="comment">// 获取客户端输入</span></span><br><span class="line">                dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">this</span>.client.getOutputStream()); <span class="comment">// 给客户端的响应</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">recieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">            String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg = dis.readUTF();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送给客户端数据</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dos.writeUTF(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != dos)</span><br><span class="line">                    dos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != dis)</span><br><span class="line">                    dis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != client)</span><br><span class="line">                    client.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 读取读取</span></span><br><span class="line">            String msg = recieve();</span><br><span class="line">            String uname = <span class="keyword">null</span>;</span><br><span class="line">            String upwd = <span class="keyword">null</span>;</span><br><span class="line">            String []datas = msg.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(String s: datas)&#123;</span><br><span class="line">                String[] info = s.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;uname&quot;</span>.equals(info[<span class="number">0</span>]))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的用户名为：&quot;</span>+ info[<span class="number">1</span>]);</span><br><span class="line">                    uname = info[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;upwd&quot;</span>.equals(info[<span class="number">0</span>]))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的密码为：&quot;</span>+ info[<span class="number">1</span>]);</span><br><span class="line">                    upwd = info[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断：返回给客户端的信息</span></span><br><span class="line">            String back = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;zhuhongliang&quot;</span>.equals(uname) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(upwd))&#123;</span><br><span class="line">                back = <span class="string">&quot;登录成功， 欢迎回来&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                back = <span class="string">&quot;用户名或者密码错误！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            send(back); <span class="comment">// 发送给客户端</span></span><br><span class="line">            release(); <span class="comment">// 释放资源</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端： 对发送和接受高度封装：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多用户登录： 面向对象思维高度封装！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020年2月21日23:57:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPMultiClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------客户端---------------&quot;</span>);</span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">9696</span>); <span class="comment">//服务器的ip和端口</span></span><br><span class="line">        <span class="comment">// 操作： 输入输出流</span></span><br><span class="line">        <span class="keyword">new</span> Send(client).send();</span><br><span class="line">        <span class="comment">//接收</span></span><br><span class="line">        <span class="keyword">new</span> Recieve(client).recieve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送给服务器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket client;</span><br><span class="line">        <span class="keyword">private</span> BufferedReader br;</span><br><span class="line">        <span class="keyword">private</span> DataOutputStream dos;</span><br><span class="line">        String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Send</span><span class="params">(Socket client)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = client;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">                dos = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">                msg = init();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">            String uname = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            String upwd = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">                uname = br.readLine();</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">                upwd = br.readLine();</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;uname=&quot;</span>+ uname +<span class="string">&quot;&amp;&quot;</span>+<span class="string">&quot;upwd=&quot;</span>+upwd;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// 写出</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dos.writeUTF(msg);</span><br><span class="line">                dos.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收服务器的返回消息</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Recieve</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket client;</span><br><span class="line">        <span class="keyword">private</span> DataInputStream dis;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Recieve</span><span class="params">(Socket client)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = client;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String res = dis.readUTF();</span><br><span class="line">                System.out.println(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="七、-实例：-手写在线聊天室"><a href="#七、-实例：-手写在线聊天室" class="headerlink" title="七、 实例： 手写在线聊天室"></a>七、 实例： 手写在线聊天室</h1><h2 id="1-服务器"><a href="#1-服务器" class="headerlink" title="1.  服务器"></a>1.  服务器</h2><p>功能：相当于消息的中转站（转发器）</p>
<blockquote>
<p>1.可以同时处理多个客户端的请求。</p>
<p>2.当一个用户进入群聊的时候，会给群聊中所有的用户群发一条系统消息，提示所有用户有人进来了群聊当中。</p>
<p>3.当一个用户成功进入群聊的时候， 服务器会发送一条问候语给当前客户。</p>
<p>4.当一个用户离开群聊的时候，会给群聊中所有的用户群发一条系统消息，提示所有用户xxx离开了群聊。</p>
<p>5.一个用户发送的消息可以给群聊中的所有用户发送。</p>
<p>6.可以对指定的用户私聊，消息只对指定的用户看见。格式： @xxx：message</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chatVersion;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.relation.Relation;</span><br><span class="line"><span class="keyword">import</span> javax.print.attribute.standard.MediaSize.Other;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在线聊天室： 群聊版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZHLAS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chat</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> CopyOnWriteArrayList&lt;Channel&gt; all = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;-------------服务器启动中------------------&quot;</span>);</span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">		<span class="comment">// 等待连接</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			Socket client = server.accept();</span><br><span class="line">			System.out.println(<span class="string">&quot;建立一个连接&quot;</span>);</span><br><span class="line">			Channel c = <span class="keyword">new</span> Channel(client);</span><br><span class="line">			all.add(c); <span class="comment">// 加入一个客户端</span></span><br><span class="line">			<span class="keyword">new</span> Thread(c).start();	<span class="comment">// 开始服务		</span></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//一个Channel代表一个客户端</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Socket client;</span><br><span class="line">		<span class="keyword">private</span> DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">private</span> DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">boolean</span> isRuning = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">private</span> String name; <span class="comment">//当前客户端的名字</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Channel</span><span class="params">(Socket client)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.client = client;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">				dos= <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">				<span class="comment">//欢迎您的到来</span></span><br><span class="line">				<span class="keyword">this</span>.name = recieve(); <span class="comment">///接收到客户端的名字		</span></span><br><span class="line">				<span class="keyword">this</span>.send(<span class="string">&quot;欢迎您来到聊天室！&quot;</span>); <span class="comment">// 发送给对应客户端的欢迎词</span></span><br><span class="line">				sendOthers(<span class="keyword">this</span>.name+ <span class="string">&quot;加入了群聊...&quot;</span>, <span class="keyword">true</span>); <span class="comment">//告诉大家谁加入了群聊</span></span><br><span class="line">			&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">				relese();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 服务器接收到客户端发送的数据</span></span><br><span class="line">		<span class="function"><span class="keyword">private</span> String <span class="title">recieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				msg = dis.readUTF();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				relese();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> msg;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 服务器给客户点发送数据</span></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				dos.writeUTF(msg);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				relese();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 群发 ： 获取自己的消息， 发送给别人</span></span><br><span class="line"><span class="comment">		 * 私聊： 约定数据格式 ： <span class="doctag">@xxx</span>:msg</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendOthers</span><span class="params">(String msg, <span class="keyword">boolean</span> isSys)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">boolean</span> isPrivate = msg.startsWith(<span class="string">&quot;@&quot;</span>); <span class="comment">//私聊</span></span><br><span class="line">			<span class="keyword">if</span>(isPrivate)&#123; <span class="comment">//私聊</span></span><br><span class="line">				<span class="keyword">int</span> idx = msg.indexOf(<span class="string">&quot;:&quot;</span>); <span class="comment">//冒号的位置</span></span><br><span class="line">				<span class="comment">// 获取目标和数据</span></span><br><span class="line">				String targetName = msg.substring(<span class="number">1</span>, idx);</span><br><span class="line">				msg = msg.substring(idx+<span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 遍历客户，找到指定目标</span></span><br><span class="line">				<span class="keyword">for</span>(Channel target : all)&#123;</span><br><span class="line">					<span class="keyword">if</span>(target.name.equals(targetName))&#123;</span><br><span class="line">						target.send(<span class="keyword">this</span>.name +<span class="string">&quot;悄悄地对你说： &quot;</span>+msg);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">// 遍历容器</span></span><br><span class="line">				<span class="keyword">for</span>(Channel c: all)&#123;</span><br><span class="line">					<span class="keyword">if</span>(<span class="keyword">this</span> == c)&#123; <span class="comment">//自己</span></span><br><span class="line">						<span class="keyword">continue</span>; </span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="keyword">if</span>(!isSys)</span><br><span class="line">							c.send(<span class="keyword">this</span>.name+<span class="string">&quot;对所有人说： &quot;</span>+msg);</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">							c.send(msg);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//释放资源</span></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relese</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.isRuning = <span class="keyword">false</span>;</span><br><span class="line">			Release.reslese(dos, dis, client);</span><br><span class="line">			<span class="comment">// 移除容器的客户端</span></span><br><span class="line">			all.remove(<span class="keyword">this</span>);</span><br><span class="line">			sendOthers(<span class="keyword">this</span>.name+<span class="string">&quot;离开了群聊...&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			String msg =<span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="keyword">while</span>(isRuning)&#123;</span><br><span class="line">				<span class="comment">// 接收数据</span></span><br><span class="line">				msg  = recieve();</span><br><span class="line">				<span class="comment">// 发送数据</span></span><br><span class="line">				<span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(msg))&#123;</span><br><span class="line"><span class="comment">//					send(msg);</span></span><br><span class="line">					sendOthers(msg, <span class="keyword">false</span>); <span class="comment">// 群聊</span></span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h2><p>功能：</p>
<blockquote>
<p>1.发送消息给服务器</p>
<p>2.从服务器那边接收消息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chatVersion;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.nio.Buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.CosNaming.NamingContextExtPackage.StringNameHelper;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在线聊天室：客户端  </span></span><br><span class="line"><span class="comment"> * 目标：群聊 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZHLAS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;-------------客户端--------------&quot;</span>);</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的姓名：&quot;</span>);</span><br><span class="line">		String name = br.readLine();</span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>); <span class="comment">// 建立连接</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Send(client, name)).start();  <span class="comment">//  发送</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Recieve(client)).start();	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chatVersion;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 发送端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZHLAS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Socket client;</span><br><span class="line">	<span class="comment">// 准备数据</span></span><br><span class="line">	<span class="keyword">private</span> BufferedReader br; </span><br><span class="line">	<span class="keyword">private</span> DataOutputStream dos;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isRuning = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">private</span> String name; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Send</span><span class="params">(Socket client, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.client = client;</span><br><span class="line">		br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			dos = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">			send(name); <span class="comment">// 把客户端的名称发送给服务器</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">this</span>.isRuning = <span class="keyword">false</span>;</span><br><span class="line">			Release.reslese(dos, br, client);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 写出</span></span><br><span class="line">			dos.writeUTF(msg);	</span><br><span class="line">			dos.flush();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">this</span>.isRuning = <span class="keyword">false</span>;</span><br><span class="line">			Release.reslese(dos, br);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(isRuning)&#123;	</span><br><span class="line">			String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				msg = br.readLine();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="keyword">this</span>.isRuning = <span class="keyword">false</span>;</span><br><span class="line">				Release.reslese(br);</span><br><span class="line">			&#125;</span><br><span class="line">			send(msg);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chatVersion;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZHLAS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recieve</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Socket client;</span><br><span class="line">	<span class="keyword">private</span> DataInputStream dis;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isRuning = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Recieve</span><span class="params">(Socket client)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.client = client;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">this</span>.isRuning = <span class="keyword">false</span>;</span><br><span class="line">			Release.reslese(dis, client);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">recieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String msg =<span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			msg = dis.readUTF();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			Release.reslese(dis);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> msg;	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(isRuning)&#123;</span><br><span class="line">			String msg = recieve();</span><br><span class="line">			<span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(msg))</span><br><span class="line">				System.out.println(msg);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-释放资源"><a href="#3-释放资源" class="headerlink" title="3. 释放资源"></a>3. 释放资源</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> chatVersion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Release</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reslese</span><span class="params">(Closeable... targets)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Closeable target: targets)&#123;</span><br><span class="line">			<span class="keyword">if</span>(target != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					target.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-运行效果"><a href="#4-运行效果" class="headerlink" title="4. 运行效果"></a>4. 运行效果</h2><img src="/2021/07/23/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582388285811.png" alt="1582388285811" style="zoom:150%;">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之反射机制Reflection</title>
    <url>/2020/03/02/Java%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6Reflect/</url>
    <content><![CDATA[<h1 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h1><p>程序运行时，可以改变程序结构或变量类型。典型的语言：Python、ruby、js等。</p>
<p> C,  C++,  JAVA不是动态语言，JAVA可以称之为“准动态语言”。但是JAVA有一定的动态性，我们可以利用反射机制、 字节码操作获得类似动态语言的特性。JAVA的动态性让编程的时候更加灵活！</p>
<hr>
<h1 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h1><p><code>Reflection</code>（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>
<p>程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个 已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。</p>
<p>加载完类之后，在堆内存中，就产生了一个 <code>Class</code> 类型的对象（一个类只有一个 <code>Class</code> 对象），这个对象就包含了完整的类的结构信息。 我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：<strong>反射</strong>。 </p>
<hr>
<h1 id="Java反射机制提供的功能"><a href="#Java反射机制提供的功能" class="headerlink" title="Java反射机制提供的功能"></a>Java反射机制提供的功能</h1><blockquote>
<p>在运行时判断任意一个对象所属的类</p>
<p>在运行时构造任意一个类的对象</p>
<p>在运行时判断任意一个类所具有的成员变量和方法</p>
<p>在运行时调用任意一个对象的成员变量和方法</p>
<p>生成动态代理</p>
</blockquote>
<hr>
<h1 id="反射初体验"><a href="#反射初体验" class="headerlink" title="反射初体验"></a>反射初体验</h1><p>一个Peason类，里面包含了：</p>
<blockquote>
<ol>
<li>无参数构造方法</li>
<li>有参数构造方法（包括private和public的）</li>
<li>public的属性name、private的属性age</li>
<li>get和set方法</li>
<li>自定义方法（包括private和public的）</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-02 11:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Peason</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;  <span class="comment">// 私有</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Peason</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Peason</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Peason</span><span class="params">(String name)</span> </span>&#123; <span class="comment">// 私有</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Peason&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">show</span><span class="params">(String nation)</span></span>&#123; <span class="comment">// 私有</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;国籍为：&quot;</span> + nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个人&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反射示例，通过反射创建对象，调用对象的属性和方法以及修改私有的属性和调用使用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Class clazz = Peason.class;</span><br><span class="line">       <span class="comment">// 通过反射，创建对象</span></span><br><span class="line">       Constructor constructor = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">       Object tom = constructor.newInstance(<span class="string">&quot;tom&quot;</span>, <span class="number">15</span>);</span><br><span class="line">       System.out.println(tom.toString()); <span class="comment">// Peason&#123;name=&#x27;tom&#x27;, age=15&#125;</span></span><br><span class="line"></span><br><span class="line">       System.out.println((tom <span class="keyword">instanceof</span> Peason));</span><br><span class="line">       <span class="comment">// 通过反射， 调用对象指定的属性和方法</span></span><br><span class="line">       Field age = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">       age.set(tom, <span class="string">&quot;zhu&quot;</span>);</span><br><span class="line">       System.out.println(tom.toString());</span><br><span class="line">       Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">       System.out.println(Arrays.toString(declaredFields));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 方法</span></span><br><span class="line">       Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">       show.invoke(tom);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;**********************************************&quot;</span>);</span><br><span class="line">       <span class="comment">//调用私有方法和属性</span></span><br><span class="line">       Constructor cons1 = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">       cons1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Object jack = cons1.newInstance(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">       System.out.println(jack.toString());</span><br><span class="line">       Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">       name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       name.set(jack, <span class="string">&quot;lihang&quot;</span>);</span><br><span class="line">       System.out.println(jack.toString());</span><br><span class="line">       <span class="comment">// 调用私有的方法</span></span><br><span class="line">       Method showNation = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">       showNation.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       Object china = showNation.invoke(jack, <span class="string">&quot;China&quot;</span>);<span class="comment">//  国籍为：China</span></span><br><span class="line">       System.out.println(china <span class="keyword">instanceof</span> String);</span><br><span class="line">       System.out.println(china);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>既然使用反射也可以创建对象，那么在开发中是使用new还是使用反射来创建对象呢？ 答案是通过new关键字来创建对象。如果在编译之前不知道需要创建哪个对象，则需要通过反射来创建对象，体现了反射的动态性。</p>
<p>封装性的目的就是为了不让外面的对象来调用私有的方法，然而反射却可以调用私有的属性和方法，那么反射机制与面向对象的封装性是不是矛盾的呢？其实不矛盾，因为封装的目的中带有提示的成分，建议程序员不要去调用私有的方法，因为以及提供了public的方法，没有必要去调用的私有的方法，这是封装的一种提示。而反射是可不可以的问题。</p>
<hr>
<h1 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h1><p><code>java.lang.Class</code>类十分特殊，用来表示<code>java</code>中的类型。</p>
<p><code>class / interface / enum / annotation / [] / primitive type / void</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1 = Object.class;</span><br><span class="line">System.out.println(c1); <span class="comment">// class java.lang.Object</span></span><br><span class="line">Class c2 = <span class="keyword">int</span>[][].class;</span><br><span class="line">System.out.println(c2); <span class="comment">// class [[I</span></span><br><span class="line">Class c3 = <span class="keyword">int</span>[].class;</span><br><span class="line">System.out.println(c3); <span class="comment">// class [I</span></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">Class c4 = a.getClass();</span><br><span class="line">Class c5 = b.getClass();</span><br><span class="line">System.out.println(c4 == c5); <span class="comment">// true 只要是同一维度，就是相同的Class对象</span></span><br></pre></td></tr></table></figure>

<p>对象照镜子后可以得到的信息：<strong>某个类的属性</strong>、<strong>方法和构造器</strong>、<strong>某个类到底实现了哪些接口</strong>。对于每个类而言，<code>JRE</code> 都为其保留一个不变的 <code>Class</code> 类型的对象。一个 <code>Class</code> 对象包含了特定某个类的有关信息。<code>Class</code>类是<code>Reflection</code>的根源。针对任何您想动态加载、运行的类，唯有先获得相应的<code>Class</code> 对象。</p>
<blockquote>
<p><code>Class</code>本身也是一个类</p>
<p><code>Class</code>对象只能由系统建立对象</p>
<p>一个类在<code>JVM</code> 中只会有一个Class实例 （重要： 不管你用哪种方式获取的Class实例，都是同一个）</p>
<p>一个<code>Class</code>对象对应的是一个加载到<code>JVM</code>中的一个<code>.class</code>文件</p>
<p>每个类的实例都会记得自己是由哪个<code>Class</code>实例所生成</p>
<p>通过<code>Class</code>可以完整地得到一个类中的完整结构</p>
</blockquote>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>程序进过<code>javac.exe</code> 命令以后，会生成过程一个或者多个字节码文件(.class结尾)，接着我们使用<code>java.exe</code> 命令对某个字节码文件进行解释执行。相当于字节码文件加载到内存中。此过程就称为类的加载，我们就称为<strong>运行时类</strong>，此运行时类就作为一个<code>Class</code>的一个实例。</p>
<p>加载到内存中的运行时类，会缓存一段时间。在此时间之内，我们可以通过不同的方式来获取次运行时类。</p>
<h2 id="Class对象的获取"><a href="#Class对象的获取" class="headerlink" title="Class对象的获取"></a>Class对象的获取</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>若已知具体的类，通过类的<code>class</code>属性获取，该方法最为安全可靠，程序性能最高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;PersonC&gt; clazz = PersonC.class;</span><br><span class="line">System.out.println(clazz); <span class="comment">// class PersonC</span></span><br></pre></td></tr></table></figure>

<h3 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h3><p>已知某个类的实例，调用该实例的<code>getClass()</code>方法获取<code>Class</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PersonC p = <span class="keyword">new</span> PersonC();</span><br><span class="line">Class clazz1 = p.getClass();</span><br><span class="line">System.out.println(clazz1); <span class="comment">// class PersonC</span></span><br></pre></td></tr></table></figure>

<h3 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h3><p>已知一个类的全类名，且该类在类路径下，可通过<code>Class</code>类的静态方法<code>forName()</code>获取，可能抛出<code>ClassNotFoundException</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class clazz2 = Class.forName(<span class="string">&quot;PersonC&quot;</span>);</span><br><span class="line">        System.out.println(clazz2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(clazz == clazz1);  <span class="comment">//true</span></span><br><span class="line">System.out.println(clazz == clazz2);<span class="comment">//true</span></span><br><span class="line">System.out.println(clazz1 == clazz2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="第四种方式：类加载器"><a href="#第四种方式：类加载器" class="headerlink" title="第四种方式：类加载器"></a>第四种方式：类加载器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader loader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">Class clazz4 = loader.loadClass(<span class="string">&quot;PersonC&quot;</span>);</span><br><span class="line">System.out.println(clazz4); <span class="comment">// class PersonC</span></span><br></pre></td></tr></table></figure>

<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</p>
<img src="/2020/03/02/Java%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6Reflect/1583138012647.png" alt="1583138012647" style="zoom:100%;">

<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>将 <code>class</code>文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 <code>java.lang.Class</code>对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个<code>Class</code>对象。这个加载的过程需要类加载器参与。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>将<code>Java</code>类的二进制代码合并到 <code>JVM</code> 的运行状态之中的过程。</p>
<p><strong>验证</strong>：确保加载的类信息符合<code>JVM</code>规范，例如：以cafe开头，没有安全方面的问题</p>
<p><strong>准备</strong>：正式为类变量（ <code>static</code>）分配内存并设置类变量<strong>默认初始值</strong>的阶段，这些内存都将在方法区中进行分配。比如 <code>static int n;</code>  在这个环节n会被赋值为 0 。</p>
<p><strong>解析</strong>：虛拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行类构造器<code>&lt;cini&gt;()</code>方法的过程。<strong>类构造器<code>&lt; clinit&gt;()</code>方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的</strong>。（类构造器是构造类信息的，不是构造该类对象的构造器）。static int n = 2;  //初始化阶段赋值</p>
<p>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</p>
<p>虛拟机会保证一个类的<code>&lt; clinit&gt;()</code>方法在多线程环境中被正确加锁和同步。</p>
<h3 id="举例说明类加载"><a href="#举例说明类加载" class="headerlink" title="举例说明类加载"></a>举例说明类加载</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;  <span class="comment">// 静态代码块</span></span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>; <span class="comment">// 静态变量</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoadingClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(A.m); <span class="comment">// </span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>根据类加载机制，首先第一步类加载，将A加载到内存当中，已经有一个class实例了； </p>
<p>第二步是类的链接，进行类变量的默认初始值， 将m 赋值为0， 即链接结束后 m = 0; </p>
<p>第三步是初始化， 由于静态代码块在静态变量定义之前，所以，m 先赋值为300， 然后赋值为100。 m的值由<code>&lt; clinit&gt;()</code>方法执行决定的。 这个A的类构造器<code>&lt; clinit&gt;()</code>方法由类变量的赋值和静态的代码块中的语句按照顺序合并产生，类似于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt; clinit&gt;()&#123;</span><br><span class="line">	m = <span class="number">300</span>;</span><br><span class="line">    m = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故，最终输出的值为100。</p>
<h3 id="类的主动引用"><a href="#类的主动引用" class="headerlink" title="类的主动引用"></a>类的主动引用</h3><p>此过程一定会发生类的初始化</p>
<blockquote>
<ol>
<li>new一个类的对象</li>
<li>调用类的静态成员(除了final常量)和静态方法</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用</li>
<li>当虚拟机启动，java  Hello，则一定会初始化Hello类。说白了就是先启动main方法所在的类</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * l类加载全过程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-06 10:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">classLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader 类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader 中 main方法...&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	类的主动引用</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 调用类的静态成员（除finall）</span></span><br><span class="line"><span class="comment">//        System.out.println(A.k);</span></span><br><span class="line">        System.out.println(A.b); <span class="comment">//finall 常量不会初始化类A ： 属于被动引用</span></span><br><span class="line">        <span class="comment">// new 对象</span></span><br><span class="line"></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">// 反射</span></span><br><span class="line"><span class="comment">//        Class a = Class.forName(&quot;A&quot;);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态初始化类A&quot;</span>);</span><br><span class="line">        k = <span class="number">600</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;类A的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类Father的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类Father的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码执行情况：</p>
<blockquote>
<p>classLoader 类的静态代码块<br>        classLoader 中 main方法…<br>        100<br>        <strong>父类Father的静态代码块</strong><br>        <strong>静态初始化类A</strong><br>        父类Father的构造函数<br>        类A的构造函数</p>
</blockquote>
<h3 id="类的被动引用"><a href="#类的被动引用" class="headerlink" title="类的被动引用"></a>类的被动引用</h3><p>不会发生类的初始化</p>
<blockquote>
<ol>
<li><p>当访问一个静态域时，只有真正声明这个域的类才会被初始化</p>
<p>通过子类引用父类的静态变量，不会导致子类初始化</p>
</li>
<li><p>通过数组定义类引用，不会触发此类的初始化</p>
</li>
<li><p>引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）final</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> father = <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类Father的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类Father的构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader 中 main方法...&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 被动引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//        System.out.println(A.b); //finall 常量不会初始化类A</span></span><br><span class="line">        A[] arr = <span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line">        System.out.println(A.father);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>classLoader 类的静态代码块<br>        classLoader 中 main方法…<br>        父类Father的静态代码块<br>        666</p>
</blockquote>
<h2 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h2><img src="/2020/03/02/Java%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6Reflect/1583138659002.png" alt="1583138659002" style="zoom:100%;">

<p>类加载器作用：</p>
<blockquote>
<p>类加载的作用：将<code>class</code>文件字节码内容加载到内存中，并将这些静态数据<strong>转换成方法区的运行时数据结构</strong>，然后在堆中生成一个代表这个类的 <code>java.lang.class</code>对象，作为方法区中类数据的访问入口。</p>
<p>类缓存：标准的 <code>JavaSE</code> 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过<code>JVM</code>垃圾回收机制可以回收这些<code>Class</code>对象。</p>
</blockquote>
<p>类加载器是用来把类(<code>class</code>)装载进内存的。<code>JVM</code> 规范定义了两种类型的类加载器：<strong>启动类加载器</strong>(<code>bootstrap</code>)和<strong>用户自定义加载器</strong>(<code>user-defined class loader</code>)。 <code>JVM</code>在运行时会产生3个类加载器组成的初始化加载器层次结构 ，如下图所示：</p>
<img src="/2020/03/02/Java%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6Reflect/1583139662384.png" alt="1583139662384" style="zoom:100%;">

<p><strong>引导类加载器</strong>：用C++编写的，是<code>JVM</code>自带的类装载器，负责Java平台<strong>核心库</strong>，用来装载核心类库。该加载器无法直接获取。</p>
<p><strong>扩展类加载器</strong>：负责<code>jre/lib/ext</code>目录下的<code>jar</code>包或 <code>–D java.ext.dirs</code> 指定目录下的<code>jar</code>包装入工作库。</p>
<p><strong>系统类加载器</strong>：负责<code>java –classpath</code> 或 <code>–D java.class.path</code>所指的目录下的类与<code>jar</code>包装入工作 ，是最常用的加载器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-02 17:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ClassLoader classLoader = TestClassLoader.class.getClassLoader();</span><br><span class="line">        <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        System.out.println(classLoader); </span><br><span class="line">        <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2  系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line">        </span><br><span class="line">        ClassLoader parent = classLoader.getParent();</span><br><span class="line">        System.out.println(parent); <span class="comment">// sun.misc.Launcher$ExtClassLoader@a09ee92</span></span><br><span class="line">        ClassLoader parent1 = parent.getParent();</span><br><span class="line">        System.out.println(parent1); <span class="comment">// null</span></span><br><span class="line">        </span><br><span class="line">        ClassLoader classloader = Class.forNme(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classloader); <span class="comment">//null  说明是由引导类加载器加载的</span></span><br><span class="line">              </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于自定义类， 使用的是系统类加载器进行加载。调用系统类加载器的<code>getParent()</code>方法，获取扩展类系统加载器，调用扩展类系统加载器<code>getParent()</code> 无法获取引导类加载器，引导类加载器主要负责加载<code>java</code>的核心类库，无法加载自定义类。</p>
<h3 id="类加载器的代理模式"><a href="#类加载器的代理模式" class="headerlink" title="类加载器的代理模式"></a>类加载器的代理模式</h3><p>代理模式 – 交给其他加载器来加载指定的类。</p>
<p><strong>双亲委托机制</strong> ： 就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高的爷爷辈的，如果父类加载器 可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载 任务时，才自己去加载。</p>
<blockquote>
<p>双亲委托机制是为了保证 Java 核心库的类型安全 </p>
<p>这种机制就保证不会出现用户自己能定义java.lang.Object/String类的情况。 </p>
</blockquote>
<p>类加载器除了用于加载类，也是安全的最基本的屏障。</p>
<p>双亲委托机制是代理模式的一种。并不是所有的类加载器都采用双亲委托机制。<code>tomcat</code>服务器类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。 这与一般类加载器的顺序是相反的。</p>
<h3 id="ClassLoader的作用举例：读取配置文件"><a href="#ClassLoader的作用举例：读取配置文件" class="headerlink" title="ClassLoader的作用举例：读取配置文件"></a><code>ClassLoader</code>的作用举例：读取配置文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> 		    FileInputStream(<span class="string">&quot;./reflect/jdbc.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">       properties.load(fis);</span><br><span class="line">       String user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;user = &quot;</span>+user + <span class="string">&quot;, passeord = &quot;</span>+ password);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>继承 <code>java.lang.ClassLoader</code></p>
<p> 1、首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经装载，直接返回；否则转入步骤2。</p>
<p>2、委派类加载请求给父类加载器（更准确的说应该是双亲类加载器，真个虚拟机中各种类加载器最终会呈现树状结构），如果父类加载器能够完成，则返回父类加载器加载的Class实例；否则转入步骤3。</p>
<p>3、调用本类加载器的findClass（…）方法，试图获取对应的字节码，如果获取的到，则调用defineClass（…）导入类型到方法区；如 果获取不到对应的字节码或者其他原因失败，返回异常给loadClass（…）， loadClass（…）转抛异常，终止加载过程（注意：这里的 异常种类不止一种）。 </p>
<h4 id="文件系统类加载器"><a href="#文件系统类加载器" class="headerlink" title="文件系统类加载器"></a>文件系统类加载器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义文件系统加载器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-06 14:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">fileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; loadedClass = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果有已经加载的类，则返回</span></span><br><span class="line">        <span class="keyword">if</span>( loadedClass != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> loadedClass;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ClassLoader parent = <span class="keyword">this</span>.getParent();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                loadedClass = parent.loadClass(name); <span class="comment">// 委托给父类去加载</span></span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(loadedClass != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> loadedClass;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 父类无法加载</span></span><br><span class="line">                <span class="comment">// 本类加载， 读取文件，转换成字节数组</span></span><br><span class="line">                <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">                <span class="keyword">if</span>(classData == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    loadedClass = defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadedClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//com.test.java  将直接骂文件转换成字节数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String name)  &#123;</span><br><span class="line">        String path = rootDir + <span class="string">&quot;/&quot;</span>+ name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>)+<span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(data, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(baos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-06 15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileSystemClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        fileSystemClassLoader loader = <span class="keyword">new</span> fileSystemClassLoader(<span class="string">&quot;F:/java&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = loader.loadClass(<span class="string">&quot;com.test.java.hello&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; aClass1 = loader.loadClass(<span class="string">&quot;com.test.java.hello&quot;</span>);</span><br><span class="line">        fileSystemClassLoader loader1 = <span class="keyword">new</span> fileSystemClassLoader(<span class="string">&quot;F:/java&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; cc = loader1.loadClass(<span class="string">&quot;com.test.java.hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c1 = loader.loadClass(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(aClass.hashCode());</span><br><span class="line">        System.out.println(aClass1.hashCode());</span><br><span class="line">        System.out.println(cc.hashCode()); <span class="comment">// 不同的类加载器</span></span><br><span class="line">        System.out.println(cc.getClassLoader()); <span class="comment">// fileSystemClassLoader@677327b6</span></span><br><span class="line">        System.out.println(c1.getClassLoader());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2133927002<br>        2133927002<br>        1836019240<br>        fileSystemClassLoader@677327b6<br>        null</p>
</blockquote>
<p><strong>注意：被两个类加载器加载的同一个类，JVM不认为是相同的类。</strong></p>
<hr>
<h1 id="通过反射创建运行时对象"><a href="#通过反射创建运行时对象" class="headerlink" title="通过反射创建运行时对象"></a>通过反射创建运行时对象</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = PersonC.class;</span><br><span class="line">       <span class="comment">// 通过反射，创建对象</span></span><br><span class="line">       Constructor constructor = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">       Object tom = constructor.newInstance(<span class="string">&quot;tom&quot;</span>, <span class="number">15</span>);</span><br><span class="line">       System.out.println(tom.toString()); <span class="comment">// PersonC&#123;name=&#x27;tom&#x27;, age=15&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="获取类的属性和内部结构"><a href="#获取类的属性和内部结构" class="headerlink" title="获取类的属性和内部结构"></a>获取类的属性和内部结构</h1><p>首先创建一个结构丰富的类，包含继承、实现接口，有参构造和无参构造、以及权限不同的属性和方法、带返回值的和不带返回值的，还有注解信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"><span class="keyword">import</span> annotation.MyAnnotation;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个结构非常丰富的类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-02 21:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Myannotation(value = &quot;hi&quot;)</span> <span class="comment">// 注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Creature</span>&lt;<span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">Myinterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 私有权限</span></span><br><span class="line">    <span class="keyword">int</span> age; <span class="comment">//  默认权限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id; <span class="comment">//  公共权限</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    Person(String name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">show</span><span class="params">(String nation)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的国籍为：&quot;</span>+ nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">(String insterests)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insterests;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个人...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-02 21:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creature</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生物在吃东西...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生物在呼吸...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Myinterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Myannotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取属性结构Field【了解】"><a href="#获取属性结构Field【了解】" class="headerlink" title="获取属性结构Field【了解】"></a>获取属性结构Field【了解】</h2><h3 id="getFields"><a href="#getFields" class="headerlink" title="getFields()"></a>getFields()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"><span class="keyword">for</span>(Field f: fields)&#123;</span><br><span class="line">	System.out.println(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>public int com.Person.id<br>        public double com.Creature.weight</p>
</blockquote>
<p><code>getFields()</code>: 获取当前运行时类及其父类中所有声明为<code>public</code>访问权限的属性。</p>
<h3 id="getDeclaredFields"><a href="#getDeclaredFields" class="headerlink" title="getDeclaredFields()"></a>getDeclaredFields()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field f: declaredFields)&#123;</span><br><span class="line">    System.out.println(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>private java.lang.String com.Person.name<br>        int com.Person.age<br>        public int com.Person.id</p>
</blockquote>
<p><code>getDeclaredFields()</code>: 获取当前运行时类当中声明的所有属性。</p>
<h3 id="获取属性的权限、数据类型和变量名"><a href="#获取属性的权限、数据类型和变量名" class="headerlink" title="获取属性的权限、数据类型和变量名"></a>获取属性的权限、数据类型和变量名</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        System.out.println(<span class="string">&quot;1.权限修饰符:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Field f: declaredFields)&#123;</span><br><span class="line">            <span class="keyword">int</span> modifiers = f.getModifiers();</span><br><span class="line">            System.out.println(Modifier.toString(modifiers));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;2. 数据类型&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Field f: declaredFields)&#123;</span><br><span class="line">            Class type = f.getType();</span><br><span class="line">            System.out.println(type.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;3. 变量名&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Field f: declaredFields)&#123;</span><br><span class="line">            String name = f.getName();</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.权限修饰符:<br>            private</p>
<p>​    public</p>
<p>2.数据类型<br>        java.lang.String<br>        int<br>        int</p>
<p>3.变量名<br>        name<br>        age<br>        id</p>
</blockquote>
<p><code>getModifiers()</code>： 获取属性的权限修饰符。</p>
<p><code>getType()</code>：  获取属性的数据类型。</p>
<p><code>getName()</code>： 获取属性的名称。</p>
<h2 id="获取运行类的方法结构"><a href="#获取运行类的方法结构" class="headerlink" title="获取运行类的方法结构"></a>获取运行类的方法结构</h2><h3 id="getMethods"><a href="#getMethods" class="headerlink" title="getMethods()"></a>getMethods()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m: methods)&#123;    </span><br><span class="line">    System.out.println(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>public int com.Person.compareTo(java.lang.String)<br>public int com.Person.compareTo(java.lang.Object)<br>public void com.Person.info()<br>public java.lang.String com.Person.display(java.lang.String)<br>public void com.Creature.breath()<br>public void com.Creature.eat()<br>public final void java.lang.Object.wait() throws java.lang.InterruptedException<br>public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException<br>public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException<br>public boolean java.lang.Object.equals(java.lang.Object)<br>public java.lang.String java.lang.Object.toString()<br>public native int java.lang.Object.hashCode()<br>public final native java.lang.Class java.lang.Object.getClass()<br>public final native void java.lang.Object.notify()<br>public final native void java.lang.Object.notifyAll()</p>
</blockquote>
<p><code>getMethods()</code>: 获取当前运行时类及其父类中所有声明为<code>public</code>访问权限的方法。</p>
<h3 id="getDeclaredMethods"><a href="#getDeclaredMethods" class="headerlink" title="getDeclaredMethods()"></a>getDeclaredMethods()</h3><p>同属性结构：<code>getDeclaredMethods()</code> ：获取当前运行时类当中声明的所有属性。（不包含父类中的）</p>
<blockquote>
<p>public int com.Person.compareTo(java.lang.String)<br>public int com.Person.compareTo(java.lang.Object)<br>public void com.Person.info()<br>private java.lang.String com.Person.show(java.lang.String)<br>public java.lang.String com.Person.display(java.lang.String)</p>
</blockquote>
<p>方法也能获取一些自身的结构： 权限修饰符、返回值类型、方法名、形参列表、异常信息、返回值。里面都有对应的方法，可以去查询API。</p>
<blockquote>
<p>public Class&lt;?&gt; getReturnType()取得全部的返回值</p>
<p>public Class&lt;?&gt;[] getParameterTypes()取得全部的参数</p>
<p>public int getModifiers()取得修饰符</p>
<p>public Class&lt;?&gt;[] getExceptionTypes()取得异常信息</p>
</blockquote>
<hr>
<h2 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h2><p><code>public Constructor&lt;T&gt;[] getConstructors()</code>： 返回此 Class 对象所表示的类的所有public构造方法。</p>
<p><code>public Constructor&lt;T&gt;[] getDeclaredConstructors()</code>：     返回此 Class 对象表示的类声明的所有构造方法 。</p>
<p>​     Constructor类中 ：</p>
<blockquote>
<ol>
<li><p>取得修饰符: <code>public int getModifiers();</code></p>
</li>
<li><p>取得方法名称: <code>public String getName();</code></p>
</li>
<li><p>取得参数的类型：<code>public Class&lt;?&gt;[] getParameterTypes();</code></p>
</li>
</ol>
</blockquote>
<h2 id="获取运行时类的父类"><a href="#获取运行时类的父类" class="headerlink" title="获取运行时类的父类"></a>获取运行时类的父类</h2><p><code>public Class&lt;? Super T&gt; getSuperclass()</code>： 返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的 Class。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br><span class="line">Class superclass = clazz.getSuperclass();</span><br><span class="line">System.out.println(superclass); <span class="comment">// class com.Creature</span></span><br><span class="line"></span><br><span class="line">Type genericSuperclass = clazz.getGenericSuperclass(); <span class="comment">// 带泛型的父类</span></span><br><span class="line">System.out.println(genericSuperclass); <span class="comment">// com.Creature&lt;java.lang.String&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="获取运行时带泛型类的父类的泛型"><a href="#获取运行时带泛型类的父类的泛型" class="headerlink" title="获取运行时带泛型类的父类的泛型"></a>获取运行时带泛型类的父类的泛型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br><span class="line">Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;</span><br><span class="line"><span class="comment">// 获取泛型类型</span></span><br><span class="line">Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">System.out.println(actualTypeArguments[<span class="number">0</span>].getTypeName()); <span class="comment">// java.lang.String</span></span><br></pre></td></tr></table></figure>

<p>在JDBC中需要使用到。DAO操作。</p>
<p>获取父类泛型类型：<strong>Type getGenericSuperclass()</strong></p>
<p>泛型类型：<strong>ParameterizedType</strong></p>
<p>获取实际的泛型类型参数数组：<strong>getActualTypeArguments()</strong></p>
<h2 id="获取运行时类实现的接口"><a href="#获取运行时类实现的接口" class="headerlink" title="获取运行时类实现的接口"></a>获取运行时类实现的接口</h2><p><code>public Class&lt;?&gt;[] getInterfaces() ；</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class i: interfaces)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>interface java.lang.Comparable<br>        interface com.Myinterface</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class i: interfaces1)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>interface java.io.Serializable</p>
</blockquote>
<h2 id="获取运行时类所在的包"><a href="#获取运行时类所在的包" class="headerlink" title="获取运行时类所在的包"></a>获取运行时类所在的包</h2><p><code>Package getPackage()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Package aPackage = clazz.getPackage();</span><br><span class="line">System.out.println(aPackage);  <span class="comment">// package com</span></span><br></pre></td></tr></table></figure>

<h2 id="获取注解"><a href="#获取注解" class="headerlink" title="获取注解"></a>获取注解</h2><p>详见《Java注解Annotation》文章反射注解部分。</p>
<hr>
<h1 id="使用反射生成并操作对象"><a href="#使用反射生成并操作对象" class="headerlink" title="使用反射生成并操作对象"></a>使用反射生成并操作对象</h1><h2 id="使用反射获取指定的属性"><a href="#使用反射获取指定的属性" class="headerlink" title="使用反射获取指定的属性"></a>使用反射获取指定的属性</h2><p>在反射机制中，可以直接通过<code>Field</code>类操作类中的属性，通过<code>Field</code>类提供的<code>set()</code>和<code>get()</code>方法就可以完成设置和取得属性内容的操作 。</p>
<blockquote>
<p><code>public Field getField(String name)</code> 返回此Class对象表示的类或接口的指定的<code>public</code>的Field。</p>
<p><code>public Field getDeclaredField(String name)</code>返回此Class对象表示的类或接口的指定的Field。（所有声明的，也包括私有属性）</p>
</blockquote>
<p>在Field中：</p>
<blockquote>
<p><code>public Object get(Object obj)</code> 取得指定对象<code>obj</code>上此<code>Field</code>的属性内容</p>
<p><code>public void set(Object obj,Object value)</code> 设置指定对象<code>obj</code>上此<code>Field</code>的属性内容</p>
</blockquote>
<p>注：在类中属性都设置为**非<code>public</code>**的前提下，在使用<code>set()</code>和<code>get()</code>方法时，首先要使用Field类中的<code>setAccessible(true)</code>方法将需要操作的属性设置为可以被外部访问。</p>
<blockquote>
<p><code>public void setAccessible(true)</code>访问私有属性时，让这个属性可见。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// 创建实例对象</span></span><br><span class="line">    Person p = (Person) clazz.getConstructor().newInstance();</span><br><span class="line">    <span class="comment">// 获取指定的属性</span></span><br><span class="line">    Field f = clazz.getField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取指定的属性值</span></span><br><span class="line">    String name = f.getName();</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="comment">//设置当前的属性值</span></span><br><span class="line">    f.set(p, <span class="number">100</span>);</span><br><span class="line">    System.out.println(p.toString());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取指定的s属性;私有</span></span><br><span class="line">   Field name1 = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">   name1.setAccessible(<span class="keyword">true</span>);<span class="comment">//设定可访问</span></span><br><span class="line">   name1.set(p,  <span class="string">&quot;zhuhongliang&quot;</span>);</span><br><span class="line">   System.out.println(p.toString());</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用反射获取指定的方法"><a href="#使用反射获取指定的方法" class="headerlink" title="使用反射获取指定的方法"></a>使用反射获取指定的方法</h2><p>通过反射，调用类中的方法，通过<code>Method</code>类完成。步骤：</p>
<p>1.通过Class类的<code>getMethod(String name, Class … parameterTypes)</code>方法取得一个<code>Method</code>对象，并设置此方法操作时所需要的参数类型。</p>
<p>2.之后使用<code>Object invoke(Object obj,  Object[] args)</code>进行调用，并向方法中传递要设置的obj对象的参数信息。</p>
<img src="/2020/03/02/Java%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6Reflect/1583203783541.png" alt="1583203783541" style="zoom:100%;">

<p><code>Object invoke(Object obj,  Object[] args)</code>:</p>
<blockquote>
<p>1.<code>Object</code> 对应原方法的返回值，若原方法无返回值，此时返回<code>null</code></p>
<p>2.若原方法若为静态方法，此时形参<code>Object obj</code>可为<code>null</code> 或者 对于的calss对象。</p>
<p>3.若原方法形参列表为空，则<code>Object[] args</code>为<code>null</code></p>
<p>4.若原方法声明为<code>private</code>,则需要在调用此<code>invoke()</code>方法前，显式调用方法对象的<code>setAccessible(true)</code>方法，将可访问<code>private</code>的方法。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在Person类增加入菜静态方法：</span><br><span class="line">// 静态方法</span><br><span class="line"> private static String showdesc(String name)&#123;</span><br><span class="line">     System.out.println(&quot;英俊潇洒 &quot;);</span><br><span class="line">     return name;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     Class clazz = Person.class;</span><br><span class="line">     <span class="comment">// 创建实例对象</span></span><br><span class="line">     Person p = (Person) clazz.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">    Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">    show.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    show.invoke(p, <span class="string">&quot;加拿大&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------调用静态方法--------&quot;</span>);</span><br><span class="line">    Method showdesc = clazz.getDeclaredMethod(<span class="string">&quot;showdesc&quot;</span>, String.class);</span><br><span class="line">    showdesc.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Object invoke = showdesc.invoke(<span class="keyword">null</span>,<span class="string">&quot;应似飞鸿踏雪泥&quot;</span>); <span class="comment">// 具有返回值</span></span><br><span class="line">    System.out.println(invoke);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我的国籍为：加拿大<br>        ————-调用静态方法——–<br>        英俊潇洒<br>        应似飞鸿踏雪泥</p>
</blockquote>
<h2 id="调用指定的构造器"><a href="#调用指定的构造器" class="headerlink" title="调用指定的构造器"></a>调用指定的构造器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void test6() throws Exception &#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Constructor cons = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    cons.setAccessible(true);</span><br><span class="line">    Person zhu = (Person) cons.newInstance(&quot;zhu&quot;);</span><br><span class="line">    System.out.println(zhu.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="setAccessible"><a href="#setAccessible" class="headerlink" title="setAccessible"></a>setAccessible</h1><p>启用和禁用访问安全检查的开关，值为 <code>true</code> 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 <code>false</code> 则指示反射的对象应该实施 Java 语言访问检查。并不是为<code>true</code> 就能访问为<code>false</code>就不能访问。</p>
<p> <strong>禁止安全检查，可以提高反射的运行速度。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射性能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-03 14:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAccessiable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        Person p = (Person) clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        Method test = clazz.getDeclaredMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; <span class="number">1000000000L</span>; i++)&#123;</span><br><span class="line">            p1.test();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通方法调用10亿次，耗时：&quot;</span>+ (end - start));</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; <span class="number">1000000000L</span>; i++)&#123;</span><br><span class="line">            test.invoke(p);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;反射方法动态调用调用10亿次，耗时：&quot;</span>+ (end - start));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        test.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; <span class="number">1000000000L</span>; i++)&#123;</span><br><span class="line">            test.invoke(p);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;反射方法动态调用调用10亿次，跳过安全检查，耗时：&quot;</span>+ (end - start));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>普通方法调用10亿次，耗时：396<br>        反射方法动态调用调用10亿次，耗时：1886<br>        反射方法动态调用调用10亿次，跳过安全检查，耗时：1545</p>
</blockquote>
<h1 id="反射的应用–动态代理"><a href="#反射的应用–动态代理" class="headerlink" title="反射的应用–动态代理"></a>反射的应用–动态代理</h1><p>代理设计模式：</p>
<p>使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理，代理对象决定是否以及何时将方法调用转到原始对象上。</p>
<p><strong>静态代理</strong>特征是代理类和目标对象的类都是在<strong>编译期间</strong>确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能。</p>
<p><strong>动态代理</strong>是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhu.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-03 13:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClothFactory factory;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyClothFactory</span><span class="params">(ClothFactory factory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理类做一些准备工作...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        factory.produceCloth();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;代理类做一些收尾工作...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nike</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nike公司生产运动服...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建被代理类对象</span></span><br><span class="line">        Nike nike = <span class="keyword">new</span> Nike();</span><br><span class="line">        <span class="comment">// 创建代理类对象</span></span><br><span class="line">        ProxyClothFactory proxyClothFactory = <span class="keyword">new</span> ProxyClothFactory(nike);</span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>代理类做一些准备工作…<br>        Nike公司生产运动服…<br>        代理类做一些收尾工作…</p>
</blockquote>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><strong>Proxy</strong>  : 专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。  提供用于创建动态代理类和动态代理对象的静态方法:</p>
<blockquote>
<p>static Object newProxyInstance( ClassLoader  loader, Class[] interfaces,         InvocationHandler h)直接创建一个动态代理对象。</p>
<p>static Class getProxyClass( ClassLoader loader, Class… interfaces)  创建一个动态代理类所对应的Class对象。</p>
</blockquote>
<p>创建一个代理对象，将被代理对象的类加载器，Class对象，实现的接口一句执行函数的句柄作为参数传入到代理类对象中。通过调用代理类对象的同名方法就会通过invoke()动态调用代理类中的同名方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhu.proxy;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-03-03 13:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getBelief</span><span class="params">()</span></span>; <span class="comment">// 信仰</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBelief</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span>+ food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理：</span></span><br><span class="line"><span class="comment"> *  1.  如何根据加载到内存中的被代理类， 动态的创建一个代理类及其对象？</span></span><br><span class="line"><span class="comment"> *  2. 当通过代理类的对象调用方法时， 如何动态地去调用被代理类中的同名方法？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用此方法， 返回一个代理类的对象  Object obj是一个被代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler();</span><br><span class="line">        handler.bind(obj);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj; <span class="comment">// 需要使用被代理类的对象进行赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象调用方法a中， 就会自动调用如下的方法：invoke</span></span><br><span class="line">    <span class="comment">// 将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// method: 即为代理类对象调用的方法，此方法也就作为了被代理类的方法</span></span><br><span class="line">        Object returnValue = method.invoke(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个代理类对象</span></span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(<span class="keyword">new</span> SuperMan());</span><br><span class="line">        String belief = proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;胖哥俩&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">        ClothFactory proxyInstance1 = (ClothFactory) ProxyFactory.getProxyInstance(<span class="keyword">new</span> Nike());</span><br><span class="line">        proxyInstance1.produceCloth();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>I believe I can fly!</p>
<p>我喜欢吃胖哥俩</p>
<p>Nike公司生产运动服…</p>
</blockquote>
<h2 id="总结-动态代理步骤"><a href="#总结-动态代理步骤" class="headerlink" title="总结 动态代理步骤"></a>总结 <strong>动态代理步骤</strong></h2><ol>
<li>创建一个实现接口<strong>InvocationHandler</strong>的类，它必须实现<code>invoke</code>方法，以完成代理的具体操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object theProxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">         Object retval = method.invoke(targetObj, params);</span><br><span class="line">         <span class="comment">// Print out the result</span></span><br><span class="line">           System.out.println(retval);</span><br><span class="line">            <span class="keyword">return</span> retval;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception exc)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Object theProxy： 被代理的对象</p>
<p>Method method：  要调用的方法</p>
<p>Object[] params： 方法调用时所需要的参数</p>
</blockquote>
<ol start="2">
<li>创建被代理的类以及接口</li>
<li> 通过Proxy的静态方法创建一个代理对象。</li>
<li>通过代理对象调用被代理对象的方法。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>开源数据集</title>
    <url>/2020/02/13/%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<h1 id="开源数据集"><a href="#开源数据集" class="headerlink" title="开源数据集"></a>开源数据集</h1><p>[toc]</p>
<h1 id="Images-Analysis"><a href="#Images-Analysis" class="headerlink" title="Images Analysis"></a>Images Analysis</h1><table>
<thead>
<tr>
<th align="center">数据集</th>
<th align="center">介绍</th>
<th align="center">备注</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Flickr30k</td>
<td align="center">图片描述</td>
<td align="center">31,783 images，每张图片5个语句标注</td>
<td><a href="http://web.engr.illinois.edu/~bplumme2/Flickr30kEntities/">链接</a></td>
</tr>
<tr>
<td align="center">Microsoft COCO</td>
<td align="center">图片描述</td>
<td align="center">330,000 images,每张图片至少5个语句标注</td>
<td><a href="http://cocodataset.org/#download">链接</a></td>
</tr>
<tr>
<td align="center">ESP Game</td>
<td align="center">多标签定义图像</td>
<td align="center">20,770 images，268 tags，诸如bed, light man,music</td>
<td><a href="https://www.kaggle.com/c/challenges-in-representation-learning-multi-modal-learning/data">链接</a></td>
</tr>
<tr>
<td align="center">IAPRTC-12</td>
<td align="center">多标签定义图像</td>
<td align="center">19,452 images,291 tags</td>
<td><a href="http://www.imageclef.org/photodata">链接</a></td>
</tr>
<tr>
<td align="center">NUS-WIDE</td>
<td align="center">多标签定义图像</td>
<td align="center">269,648 images,several tags (2-5 on average) per image</td>
<td><a href="http://lms.comp.nus.edu.sg/research/NUS-WIDE.htm">链接</a></td>
</tr>
<tr>
<td align="center">CUHK-PEDES</td>
<td align="center">以文搜图</td>
<td align="center">34,054 images，每张图片2条描述</td>
<td><a href="http://cuhk-pedes.shuanglee.me/">链接</a></td>
</tr>
<tr>
<td align="center">VRD</td>
<td align="center">视觉关系检测</td>
<td align="center">5,000 images, 100目录，37,993对关系</td>
<td><a href="https://cs.stanford.edu/people/ranjaykrishna/vrd/">链接</a></td>
</tr>
<tr>
<td align="center">sVG</td>
<td align="center">视觉关系检测</td>
<td align="center">108,000 images, 998,000对关系</td>
<td><a href="https://drive.google.com/file/d/0B5RJWjAhdT04SXRfVHBKZ0dOTzQ/view">链接</a></td>
</tr>
<tr>
<td align="center">Visual Genome Dataset</td>
<td align="center">图像属性检测</td>
<td align="center">108,077 images, 5.4 M 区域块，2.8 M 属性，2.3 M 关系</td>
<td><a href="https://visualgenome.org/">链接</a></td>
</tr>
<tr>
<td align="center">VQA</td>
<td align="center">问答系统</td>
<td align="center">1,105,904问题，11,059,040 回答</td>
<td><a href="http://www.visualqa.org/">链接</a></td>
</tr>
<tr>
<td align="center">Visual7W</td>
<td align="center">问答系统</td>
<td align="center">327,939 问答对</td>
<td><a href="http://web.stanford.edu/~yukez/visual7w/">链接</a></td>
</tr>
<tr>
<td align="center">TID2013</td>
<td align="center">图像质量评价</td>
<td align="center">25张参考图像，24个失真类型</td>
<td><a href="http://www.ponomarenko.info/tid2013.htm">链接</a></td>
</tr>
<tr>
<td align="center">CSIQ</td>
<td align="center">图像质量评价</td>
<td align="center">30张参考图像，6个失真类型</td>
<td><a href="http://vision.eng.shizuoka.ac.jp/mod/page/view.php?id=23">链接</a></td>
</tr>
<tr>
<td align="center">LIVE</td>
<td align="center">图像质量评价</td>
<td align="center">29张参考图像，5个失真类型</td>
<td><a href="http://live.ece.utexas.edu/research/quality/subjective.htm">链接</a></td>
</tr>
<tr>
<td align="center">WATERLOO</td>
<td align="center">图像质量评价</td>
<td align="center">4744张参考图像，20个失真类型</td>
<td><a href="https://ece.uwaterloo.ca/~k29ma/exploration/">链接</a></td>
</tr>
<tr>
<td align="center">photo.net</td>
<td align="center">图像美观评价</td>
<td align="center">20,278张图像，打分[0,10]</td>
<td><a href="http://ritendra.weebly.com/aesthetics-datasets.html">链接</a></td>
</tr>
<tr>
<td align="center">DPChallenge.com</td>
<td align="center">图像美观评价</td>
<td align="center">16,509张图像，打分[0,10]</td>
<td><a href="http://ritendra.weebly.com/aesthetics-datasets.html">链接</a></td>
</tr>
<tr>
<td align="center">CUHK</td>
<td align="center">图像美观评价</td>
<td align="center">28,410张图像，只分高质量和低质量</td>
<td><a href="http://mmlab.ie.cuhk.edu.hk/archive/CUHKPQ/Dataset.htm">链接</a></td>
</tr>
<tr>
<td align="center">AVA</td>
<td align="center">图像美观评价</td>
<td align="center">255,500张图像，打分[0,10]</td>
<td><a href="https://github.com/mtobeiyf/ava_downloader">链接</a></td>
</tr>
</tbody></table>
<p><a href="#%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86">top</a></p>
<h1 id="Image-Motion-amp-Tracking"><a href="#Image-Motion-amp-Tracking" class="headerlink" title="Image Motion &amp; Tracking"></a>Image Motion &amp; Tracking</h1><table>
<thead>
<tr>
<th>数据集</th>
<th>介绍</th>
<th>备注</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td>CUHK03</td>
<td>Person re-identification(人重识别)</td>
<td>image num:13164 person num:1360 camera num:10( 5 pairs)</td>
<td><a href="http://www.ee.cuhk.edu.hk/~xgwang/CUHK_identification.html">链接</a></td>
</tr>
<tr>
<td>CUHK02</td>
<td>Person re-identification(人重识别)</td>
<td>image num:7264 person num:1816 camera num:10( 5 pairs)</td>
<td><a href="http://www.ee.cuhk.edu.hk/~xgwang/CUHK_identification.html">链接</a></td>
</tr>
<tr>
<td>CUHK01</td>
<td>Person re-identification(人重识别)</td>
<td>image num:3884 person num:971 camera num: 2</td>
<td><a href="http://www.ee.cuhk.edu.hk/~xgwang/CUHK_identification.html">链接</a></td>
</tr>
<tr>
<td>VIPeR</td>
<td>Person re-identification(人重识别)</td>
<td>image num:1264 person num:632 camera num:2</td>
<td><a href="https://vision.soe.ucsc.edu/node/178">链接</a></td>
</tr>
<tr>
<td>ETH1,2,3</td>
<td>Person re-identification(人重识别)</td>
<td>image num:8580 person num:83,35,28 camera num:1</td>
<td><a href="http://homepages.dcc.ufmg.br/~william/datasets.html">链接</a></td>
</tr>
<tr>
<td>PRID2011</td>
<td>Person re-identification(人重识别)</td>
<td>image num:24541 person num:934 camera num:2</td>
<td><a href="https://www.tugraz.at/institute/icg/research/team-bischof/lrs/downloads/PRID11/">链接</a></td>
</tr>
<tr>
<td>MARS</td>
<td>Person re-identification(人重识别)</td>
<td>image num:11910031 person num:1261 camera num:6</td>
<td><a href="http://www.liangzheng.com.cn/Project/project_mars.html">链接</a></td>
</tr>
<tr>
<td>Market1501</td>
<td>Person re-identification(人重识别)</td>
<td>image num:32217 person num:1501 camera num:6</td>
<td><a href="http://www.liangzheng.org/Project/project_reid.html">链接</a></td>
</tr>
<tr>
<td>Epic Fail (EF) dataset</td>
<td>Risk Assessment(风险评估)</td>
<td>video num:3000</td>
<td><a href="https://vision.soe.ucsc.edu/?q=node/178">链接</a></td>
</tr>
<tr>
<td>Street Accident (SA) dataset</td>
<td>Risk Assessment(风险评估)</td>
<td>video num:1733</td>
<td><a href="https://vision.soe.ucsc.edu/?q=node/178">链接</a></td>
</tr>
<tr>
<td>OTB-50</td>
<td>visual tracking(跟踪)</td>
<td>video num:50</td>
<td><a href="http://www.visual-tracking.net/">链接</a></td>
</tr>
<tr>
<td>OTB-100</td>
<td>visual tracking(跟踪)</td>
<td>video num:100</td>
<td><a href="http://www.visual-tracking.net/">链接</a></td>
</tr>
<tr>
<td>VOT2015</td>
<td>visual tracking(跟踪)</td>
<td>video num:60</td>
<td><a href="http://www.votchallenge.net/vot2015/">链接</a></td>
</tr>
<tr>
<td>ALOV300</td>
<td>visual tracking(跟踪)</td>
<td>video num:314</td>
<td><a href="http://alov300pp.joomlafree.it/">链接</a></td>
</tr>
<tr>
<td>MOT</td>
<td>visual tracking(跟踪)</td>
<td>video num:train:11 test:11</td>
<td><a href="https://motchallenge.net/">链接</a></td>
</tr>
<tr>
<td>THUMOS</td>
<td>Temporal action localization(动作定位)</td>
<td>video num:<del>3K activities class:20 instances:</del>3K</td>
<td><a href="http://crcv.ucf.edu/THUMOS14/">链接</a></td>
</tr>
<tr>
<td>ActivityNet</td>
<td>Temporal action localization(动作定位)</td>
<td>video num:20k activities class:200 instances:7.6K</td>
<td><a href="http://activity-net.org/challenges/2016/">链接</a></td>
</tr>
<tr>
<td>Mexaction2</td>
<td>Temporal action localization(动作定位)</td>
<td>activities class:2 instances:1975</td>
<td><a href="http://mexculture.cnam.fr/xwiki/bin/view/Datasets/Mex+action+dataset">链接</a></td>
</tr>
<tr>
<td>FlyingChairs dataset</td>
<td>optical flow(光流)</td>
<td>image pairs：22k</td>
<td><a href="https://lmb.informatik.uni-freiburg.de/resources/datasets/FlyingChairs.en.html">链接</a></td>
</tr>
<tr>
<td>FlyingThings3D</td>
<td>optical flow(光流)</td>
<td>image pairs：22k</td>
<td><a href="https://lmb.informatik.uni-freiburg.de/resources/datasets/SceneFlowDatasets.en.html">链接</a></td>
</tr>
<tr>
<td>KITTI benchmark suite</td>
<td>optical flow(光流)</td>
<td>image pairs：1600</td>
<td><a href="http://www.cvlibs.net/datasets/kitti/">链接</a></td>
</tr>
<tr>
<td>MPI Sintel</td>
<td>optical flow(光流)</td>
<td>image pairs：1064</td>
<td><a href="http://sintel.is.tue.mpg.de/">链接</a></td>
</tr>
</tbody></table>
<h1 id="Video-Analysis-amp-Scene-Understanding"><a href="#Video-Analysis-amp-Scene-Understanding" class="headerlink" title="Video Analysis &amp; Scene Understanding"></a>Video Analysis &amp; Scene Understanding</h1><table>
<thead>
<tr>
<th>数据集</th>
<th>介绍</th>
<th>备注</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td>UCF101</td>
<td>动作行为识别</td>
<td>13320 video,101类动作，主要是五大类：1)人-物交互；2)肢体运动；3)人-人交互；4)弹奏乐器；5)运动</td>
<td><a href="http://crcv.ucf.edu/data/UCF101.php">链接</a></td>
</tr>
<tr>
<td>HMDB51</td>
<td>动作行为识别</td>
<td>7000 videos,51类，包括人脸表情动作，身体动作，人与人交互等</td>
<td><a href="http://serre-lab.clps.brown.edu/resource/hmdb-a-large-human-motion-database/#Downloads">链接</a></td>
</tr>
<tr>
<td>Moments-in-Time</td>
<td>动作行为识别</td>
<td>1,000,000 videos,339类</td>
<td><a href="http://moments.csail.mit.edu/">链接</a></td>
</tr>
<tr>
<td>ActivityNet 1.3</td>
<td>动作行为识别</td>
<td>20,000 videos,200类</td>
<td><a href="http://activity-net.org/challenges/2016/guidelines.html">链接</a></td>
</tr>
<tr>
<td>Kinetics</td>
<td>动作行为识别</td>
<td>300,000 videos，400类</td>
<td><a href="https://deepmind.com/research/open-source/open-source-datasets/kinetics/">链接</a></td>
</tr>
<tr>
<td>AVA</td>
<td>动作行为识别</td>
<td>57,600 videos，80类</td>
<td><a href="https://research.google.com/ava/">链接</a></td>
</tr>
<tr>
<td>Collective Activity Dataset</td>
<td>群体活动行为识别</td>
<td>44 videos,穿叉、行走、等待、交谈和排队 五类</td>
<td><a href="http://vhosts.eecs.umich.edu/vision//activity-dataset.html">链接</a></td>
</tr>
<tr>
<td>Choi’s New Dataset</td>
<td>群体活动行为识别</td>
<td>32 videos，聚会，谈话，分开，一起走，追逐和排队 六类</td>
<td>None</td>
</tr>
<tr>
<td>ActivityNet 1.3</td>
<td>检测动作事件的起始时间和终止时间</td>
<td>20,000 videos,200类动作的起始时间和终止时间</td>
<td><a href="http://activity-net.org/challenges/2016/guidelines.html">链接</a></td>
</tr>
<tr>
<td>THUMOS</td>
<td>检测动作事件的起始时间和终止时间</td>
<td>15,000 videos，101类动作的起始时间和终止时间</td>
<td><a href="http://www.thumos.info/download.html">链接</a></td>
</tr>
<tr>
<td>MED</td>
<td>事件检测</td>
<td>32,744 videos,20个事件</td>
<td><a href="http://www-nlpir.nist.gov/projects/tv2017/data/">链接</a></td>
</tr>
<tr>
<td>EventNet</td>
<td>事件检测</td>
<td>90,000 videos，500个事件</td>
<td><a href="http://eventnet.ee.columbia.edu/">链接</a></td>
</tr>
<tr>
<td>Columbia Consumer Video</td>
<td>事件检测</td>
<td>9,317 videos，20个事件</td>
<td><a href="http://www.ee.columbia.edu/ln/dvmm/CCV/">链接</a></td>
</tr>
<tr>
<td>ADE20K</td>
<td>事件检测</td>
<td>20,210 videos，900个事件</td>
<td><a href="http://sceneparsing.csail.mit.edu/">链接</a></td>
</tr>
<tr>
<td>DAVIS</td>
<td>视频主物体分割</td>
<td>50 videos，分割标注</td>
<td><a href="http://davischallenge.org/">链接</a></td>
</tr>
<tr>
<td>FBMS</td>
<td>视频主物体分割</td>
<td>59 videos，分割标注</td>
<td><a href="https://lmb.informatik.uni-freiburg.de/resources/datasets/moseg.en.html">链接</a></td>
</tr>
<tr>
<td>IJB-C</td>
<td>视频人脸识别</td>
<td>11,000 videos，</td>
<td><a href="https://www.nist.gov/programs-projects/face-challenges">链接</a></td>
</tr>
<tr>
<td>YouTube Faces</td>
<td>视频人脸识别</td>
<td>3,425 videos，1595 人</td>
<td><a href="https://www.cs.tau.ac.il/~wolf/ytfaces/">链接</a></td>
</tr>
<tr>
<td>MS-Celeb-1M</td>
<td>视频人脸识别</td>
<td>1,000,000 images，21,000人</td>
<td><a href="http://www.msceleb.org/download/sampleset">链接</a></td>
</tr>
<tr>
<td>MSVD</td>
<td>视频描述</td>
<td>1,970 videos</td>
<td><a href="http://www.cs.utexas.edu/users/ml/clamp/videoDescription/YouTubeClips.tar">链接</a></td>
</tr>
<tr>
<td>MSR-VTT-10K</td>
<td>视频描述</td>
<td>10，000 videos</td>
<td><a href="http://ms-multimedia-challenge.com/2017/dataset">链接</a></td>
</tr>
<tr>
<td>MSR-VTT-10K</td>
<td>视频描述</td>
<td>无</td>
<td><a href="https://sites.google.com/site/describingmovies/lsmdc-2016/download">链接</a></td>
</tr>
</tbody></table>
<p><a href="#%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86">top</a></p>
<h1 id="3D-Computer-Vision"><a href="#3D-Computer-Vision" class="headerlink" title="3D Computer Vision"></a>3D Computer Vision</h1><table>
<thead>
<tr>
<th>数据集</th>
<th>介绍</th>
<th>备注</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td>photoface database</td>
<td>基于光度立体视觉的二维和三维人脸识别数据库</td>
<td>总共7356张图像，包含1839个session和261个subjects</td>
<td>None</td>
</tr>
<tr>
<td>NYU Depth V2 dataset</td>
<td>关于RGBD 图像场景理解的数据库</td>
<td>提供1449张深度图片和他们的密集2d点类标注</td>
<td><a href="https://cs.nyu.edu/~silberman/datasets/nyu_depth_v2.html">链接</a></td>
</tr>
<tr>
<td>SUN RGBD dataset</td>
<td>是上面的NYU Depth V2 dataset的超集，多了3D bounding boxes和room layouts的标注。</td>
<td>有10,000张RGB-D图片，有58,657个3D包围框和146,617 个2d包围框。</td>
<td><a href="http://rgbd.cs.princeton.edu/">链接</a></td>
</tr>
<tr>
<td>PASCAL3D+</td>
<td>新的三维物体检测和姿态估计数据集，从PASCAL VOC 演化而来，包含图像，注解，和3D CAD模型</td>
<td>总共12个类，平均每个类别有3000多个实例</td>
<td><a href="http://cvgl.stanford.edu/projects/pascal3d.html">链接</a></td>
</tr>
<tr>
<td>IKEA</td>
<td>包含典型室内场景的三维模型的数据库，例如桌子椅子等</td>
<td>包含大约759张图片和219个3D模型</td>
<td><a href="http://ikea.csail.mit.edu/">链接</a></td>
</tr>
<tr>
<td>New Tsukuba Dataset</td>
<td>包含了很多立体物体对的数据库，用于立体物体匹配</td>
<td>总共1800个立体物体对，以及每立体对的立体视差图、遮挡图和不连续图</td>
<td><a href="https://cvlab-home.blogspot.jp/2012/05/h2fecha-2581457116665894170-displaynone.html">链接</a></td>
</tr>
<tr>
<td>Oxford RobotCar Dataset</td>
<td>关于户外自动驾驶的数据集。</td>
<td>包含在驾驶汽车过程从6个摄像头收集的2000w张图片，和当时的激光雷达，GPS和地面实况标注。</td>
<td><a href="http://robotcar-dataset.robots.ox.ac.uk/">链接</a></td>
</tr>
<tr>
<td>Middlebury V3</td>
<td>包含高分辨率物体立体视差标注的数据库</td>
<td>包含33个类，没有明说每类有多少数据</td>
<td><a href="http://vision.middlebury.edu/stereo/eval3/">链接</a></td>
</tr>
<tr>
<td>ShapeNet</td>
<td>包含3D模型，和3d模型的类别标注的数据集，覆盖了常用的3D数据集PASCAL 3D+。</td>
<td>它涵盖55个常见的对象类别，有大约51,300个3D模型</td>
<td><a href="https://www.shapenet.org/">链接</a></td>
</tr>
<tr>
<td>MICC dataset</td>
<td>包含了3D人脸扫描和在不同分辨率，条件和缩放级别下的几个视频序列的数据库。</td>
<td>有53个人的立体人脸数据</td>
<td><a href="https://www.micc.unifi.it/resources/datasets/florence-3d-faces/">链接</a></td>
</tr>
<tr>
<td>CMU MoCap Dataset</td>
<td>包含了3D人体关键点标注和骨架移动标注的数据集。</td>
<td>有6个类别和23个子类别，总共2605个数据。</td>
<td><a href="http://mocap.cs.cmu.edu/">链接</a></td>
</tr>
<tr>
<td>DTU dataset</td>
<td>关于3D场景的数据集。</td>
<td>有124个场景，每场景有49/64个位置的RGB图像和结构光标注。</td>
<td><a href="http://roboimagedata.compute.dtu.dk/?page_id=36">链接</a></td>
</tr>
</tbody></table>
<p><a href="#%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86">top</a></p>
<h1 id="Analyzing-Humans-in-Images"><a href="#Analyzing-Humans-in-Images" class="headerlink" title="Analyzing Humans in Images"></a>Analyzing Humans in Images</h1><table>
<thead>
<tr>
<th>数据集</th>
<th>介绍</th>
<th>备注</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td>MSR-Action3D</td>
<td>包含深度的动作识别数据集，</td>
<td>有20个动作，总共557个序列。</td>
<td><a href="http://users.eecs.northwestern.edu/~jwa368/my_data.html">链接</a></td>
</tr>
<tr>
<td>Florence-3D</td>
<td>包含深度的动作识别数据集，</td>
<td>有9个动作，总共215个动作序列。</td>
<td><a href="https://www.micc.unifi.it/resources/datasets/florence-3d-actions-dataset/">链接</a></td>
</tr>
<tr>
<td>Berkeley MHAD</td>
<td>包含深度的动作识别数据集，</td>
<td>有11个动作，产生660个动作序列。</td>
<td><a href="http://tele-immersion.citris-uc.org/berkeley_mhad">链接</a></td>
</tr>
<tr>
<td>Online Action Detection</td>
<td>包含深度的动作识别数据集，</td>
<td>数据集包含59个长序列，包含10种不同的日常生活行为。</td>
<td><a href="http://homes.esat.kuleuven.be/~rdegeest/OnlineActionDetection.html">链接</a></td>
</tr>
<tr>
<td>ChaLearn LAP IsoGD Dataset</td>
<td>RGB-D图像的手势识别的数据集。</td>
<td>包括47933个RGB-D手势视频，有249个手势标签。Training有35878视频，Validation有5784个，test有6271个</td>
<td><a href="http://gesture.chalearn.org/2016-looking-at-people-cvpr-challenge/isogd-and-congd-datasets">链接</a></td>
</tr>
<tr>
<td>MAFA dataset</td>
<td>关于面部遮挡问题的数据集</td>
<td>有30, 811张人脸和35806张有遮挡的脸组成。</td>
<td><a href="http://www.escience.cn/people/geshiming/mafa.html">链接</a></td>
</tr>
<tr>
<td>MSRC-12 Kinect Gesture Dataset</td>
<td>手势识别数据集</td>
<td>有4900张图片，包含12个不同手势，</td>
<td><a href="https://www.microsoft.com/en-us/download/details.aspx?id=52283">链接</a></td>
</tr>
<tr>
<td>2013 Chalearn Gesture Challenge dataset</td>
<td>手势识别数据集</td>
<td>有11000张图片，包含20个不同手势，</td>
<td><a href="http://gesture.chalearn.org/2013-multi-modal-challenge">链接</a></td>
</tr>
<tr>
<td>WIDER FACE</td>
<td>人脸检测数据集</td>
<td>有 32,203 张图片，标注了393703个人脸。</td>
<td><a href="http://mmlab.ie.cuhk.edu.hk/projects/WIDERFace/">链接</a></td>
</tr>
<tr>
<td>FDDB</td>
<td>人脸检测数据集</td>
<td>2845张图片，标注了5171张人脸。</td>
<td><a href="http://vis-www.cs.umass.edu/fddb/">链接</a></td>
</tr>
<tr>
<td>300-VW dataset</td>
<td>面部表情数据集</td>
<td>包含114个视频和总计218,595帧。</td>
<td><a href="https://ibug.doc.ic.ac.uk/resources/300-VW/">链接</a></td>
</tr>
<tr>
<td>HMDB51</td>
<td>人类行为识别的数据集</td>
<td>包含51个动作，总共有6766个视频剪辑</td>
<td><a href="http://serre-lab.clps.brown.edu/resource/hmdb-a-large-human-motion-database/">链接</a></td>
</tr>
<tr>
<td>MPII Cooking Activities Dataset</td>
<td>人类行为识别的数据集</td>
<td>包含65个动作，有5609个视频</td>
<td><a href="https://www.mpi-inf.mpg.de/departments/computer-vision-and-multimodal-computing/research/human-activity-recognition/mpii-cooking-activities-dataset/">链接</a></td>
</tr>
<tr>
<td>UCF101</td>
<td>人类行为识别的数据集</td>
<td>包含101个动作，有13320个视频</td>
<td><a href="http://crcv.ucf.edu/data/UCF101.php">链接</a></td>
</tr>
<tr>
<td>IJB-A dataset</td>
<td>包含视频和图片人脸识别的数据集</td>
<td>包含5712个图像和2085个视频</td>
<td><a href="https://www.nist.gov/programs-projects/face-challenges">链接</a></td>
</tr>
<tr>
<td>YouTube celebrities</td>
<td>视频人脸识别的数据集</td>
<td>包含47位名人的1910个视频</td>
<td><a href="https://www.cs.tau.ac.il/~wolf/ytfaces/">链接</a></td>
</tr>
<tr>
<td>COX</td>
<td>视频人脸识别的数据集</td>
<td>包含1000个主题的4000个视频</td>
<td><a href="http://vipl.ict.ac.cn/view_database.php?id=3">链接</a></td>
</tr>
<tr>
<td>Human3.6M</td>
<td>人体姿态估计的数据集</td>
<td>360万张3D照片，11名受试者在4个视点下执行15个了不同的动作</td>
<td><a href="http://vision.imar.ro/human3.6m/description.php">链接</a></td>
</tr>
<tr>
<td>iLIDS</td>
<td>行人重识别的数据集</td>
<td>476 张图像，包含119个人</td>
<td><a href="http://www.eecs.qmul.ac.uk/~xiatian/downloads_qmul_iLIDS-VID_ReID_dataset.html">链接</a></td>
</tr>
<tr>
<td>VIPeR</td>
<td>行人重识别的数据集</td>
<td>632个行人图片对（由两个相机拍摄）</td>
<td><a href="https://iiw.kuleuven.be/onderzoek/eavise/viper/dataset">链接</a></td>
</tr>
<tr>
<td>CUHK01</td>
<td>行人重识别的数据集</td>
<td>包含971行人, 3884张图片</td>
<td><a href="http://www.ee.cuhk.edu.hk/~xgwang/CUHK_identification.html">链接</a></td>
</tr>
<tr>
<td>CUHK03</td>
<td>行人重识别的数据集</td>
<td>包含1360行人, 13164张图片</td>
<td><a href="http://www.ee.cuhk.edu.hk/~xgwang/CUHK_identification.html">链接</a></td>
</tr>
<tr>
<td>RWTH-PHOENIX-Weather multi-signer 2014</td>
<td>手语识别的数据集</td>
<td>包含了5672个德语手语的句子，有65,227个手语姿势和799,006帧</td>
<td><a href="https://www-i6.informatik.rwth-aachen.de/~forster/database-rwth-phoenix.php">链接</a></td>
</tr>
<tr>
<td>AFLW</td>
<td>人类面部关键点的数据集</td>
<td>总共约有25k张脸，每幅图像标注了大约21个位置。</td>
<td><a href="https://www.tugraz.at/institute/icg/research/team-bischof/lrs/downloads/aflw">链接</a></td>
</tr>
<tr>
<td>CMU mocap database</td>
<td>动作识别的数据集</td>
<td>2235个数据，包含144个不同的动作。</td>
<td><a href="http://mocap.cs.cmu.edu/">链接</a></td>
</tr>
<tr>
<td>Georgia Tech (GT) database</td>
<td>人脸识别数据库</td>
<td>50个人每人15张人脸。</td>
<td><a href="http://www.anefian.com/research/face_reco.htm">链接</a></td>
</tr>
<tr>
<td>ORL</td>
<td>人脸识别数据库</td>
<td>40个人每个人10张图。</td>
<td><a href="https://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html">链接</a></td>
</tr>
</tbody></table>
<p><a href="#%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86">top</a></p>
<h1 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h1><table>
<thead>
<tr>
<th>数据集</th>
<th>介绍</th>
<th>备注</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td>DogCentric Activity Dataset</td>
<td>第一视角的狗和人之间的相互行为的数据集（视频）</td>
<td>总共有10类，具体数据量没有明说，y是动作类别</td>
<td><a href="http://robotics.ait.kyushu-u.ac.jp/yumi/db/first_dog.html">链接</a></td>
</tr>
<tr>
<td>JPL First-Person Interaction Dataset</td>
<td>第一视角观察动作的数据集</td>
<td>57个视频，8个大类，y是动作类别</td>
<td><a href="http://michaelryoo.com/jpl-interaction.html">链接</a></td>
</tr>
<tr>
<td>NUS-WIDE</td>
<td>关于图像文本匹配的数据集</td>
<td>269,648个图像和对应的标签</td>
<td><a href="http://lms.comp.nus.edu.sg/research/NUS-WIDE.htm">链接</a></td>
</tr>
<tr>
<td>LabelMe Dataset</td>
<td>关于图像文本匹配的数据集</td>
<td>3825个图像和对应标签</td>
<td><a href="http://labelme.csail.mit.edu/Release3.0/browserTools/php/dataset.php">链接</a></td>
</tr>
<tr>
<td>Pascal Dataset</td>
<td>关于图像文本匹配的数据集</td>
<td>5011张训练图像和4952张测试图像</td>
<td>)</td>
</tr>
<tr>
<td>ICDAR 2015</td>
<td>关于文本检测的数据集</td>
<td>1500张训练，1000张测试，y为四边形的四个顶点。</td>
<td><a href="http://rrc.cvc.uab.es/">链接</a></td>
</tr>
<tr>
<td>COCO-Text</td>
<td>关于文本检测的数据集</td>
<td>63686张图片，其中43686张被选为训练集，剩下的2万用于测试。</td>
<td><a href="https://vision.cornell.edu/se3/coco-text-2/">链接</a></td>
</tr>
<tr>
<td>MSRA-TD500</td>
<td>关于文本检测的数据集</td>
<td>300个训练，200个测试图像</td>
<td><a href="http://www.iapr-tc11.org/mediawiki/index.php/MSRA_Text_Detection_500_Database_(MSRA-TD500)">链接</a></td>
</tr>
<tr>
<td>Microsoft 7-Scenes Dataset</td>
<td>室内人体运动的数据集</td>
<td>有7种不同室内环境，每包含500-1000张图像视频序列。</td>
<td><a href="https://www.microsoft.com/en-us/research/project/rgb-d-dataset-7-scenes/">链接</a></td>
</tr>
<tr>
<td>Oxford RobotCar</td>
<td>户外自动驾驶数据集</td>
<td>包含图像，激光扫描结果和GPS数据。</td>
<td><a href="http://robotcar-dataset.robots.ox.ac.uk/">链接</a></td>
</tr>
</tbody></table>
<p><a href="#%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86">top</a></p>
<h1 id="Low-amp-Mid-Level-Vision"><a href="#Low-amp-Mid-Level-Vision" class="headerlink" title="Low- &amp; Mid-Level Vision"></a>Low- &amp; Mid-Level Vision</h1><table>
<thead>
<tr>
<th>数据集</th>
<th>介绍</th>
<th>备注</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td>Deep Video Deblurring for Hand-held Cameras</td>
<td>video/image deblurring(图像去模糊)</td>
<td>video num:71 video time: 3-5s blurry and sharp pair image num:6708</td>
<td><a href="https://www.cs.ubc.ca/labs/imager/tr/2017/DeepVideoDeblurring/#dataset">链接</a></td>
</tr>
<tr>
<td>GOPRO dataset</td>
<td>video/image deblurring(图像去模糊)</td>
<td>blurry and sharp pair image num:3214 train num:2103 test num:1111</td>
<td><a href="https://github.com/SeungjunNah/DeepDeblur_release">链接</a></td>
</tr>
<tr>
<td>BSD68</td>
<td>image restoration(图像修复)/高斯降噪</td>
<td>image num:68</td>
<td><a href="https://www.robots.ox.ac.uk/~vgg/data/dtd/">链接</a></td>
</tr>
<tr>
<td>BSD100</td>
<td>“image restoration(图像修复)super resolution超分辨率重建”</td>
<td>image num:100</td>
<td><a href="https://github.com/jbhuang0604/SelfExSR/tree/master/data">链接</a></td>
</tr>
<tr>
<td>Set5</td>
<td>“image restoration(图像修复)super resolution超分辨率重建”</td>
<td>image num:5</td>
<td><a href="https://github.com/jbhuang0604/SelfExSR/tree/master/data">链接</a></td>
</tr>
<tr>
<td>Set14</td>
<td>“image restoration(图像修复)super resolution超分辨率重建”</td>
<td>image num:14</td>
<td><a href="https://github.com/jbhuang0604/SelfExSR/tree/master/data">链接</a></td>
</tr>
<tr>
<td>Urban100</td>
<td>“image restoration(图像修复)super resolution超分辨率重建”</td>
<td>image num:100</td>
<td><a href="https://github.com/jbhuang0604/SelfExSR/tree/master/data">链接</a></td>
</tr>
<tr>
<td>NYU v2 dataset</td>
<td>“image restoration(图像修复)depth super resolution深度超分辨率重建”</td>
<td>image num:1449</td>
<td><a href="https://cs.nyu.edu/~silberman/datasets/nyu_depth_v2.html">链接</a></td>
</tr>
<tr>
<td>Middlebury dataset</td>
<td>“image restoration(图像修复)depth super resolution深度超分辨率重建”</td>
<td>image pair num: 33</td>
<td><a href="http://vision.middlebury.edu/stereo/data/">链接</a></td>
</tr>
<tr>
<td>alpha matting benchmark</td>
<td>Natural image matting(抠图)</td>
<td>“train num:27,test num:8”</td>
<td><a href="http://www.alphamatting.com/">链接</a></td>
</tr>
<tr>
<td>real image benchmark</td>
<td>Natural image matting(抠图)</td>
<td>“train num:49300,test num:1000”</td>
<td><a href="https://sites.google.com/view/deepimagematting">链接</a></td>
</tr>
<tr>
<td>MSRA10K/MSRA-B</td>
<td>Image saliency detection(显著性区域检测)</td>
<td>image num(MSRA10K):10000 image num(MSRA-B):5000</td>
<td><a href="https://mmcheng.net/zh/msra10k/">链接</a></td>
</tr>
<tr>
<td>ECSSD</td>
<td>Image saliency detection(显著性区域检测)</td>
<td>image num:1000</td>
<td><a href="http://www.cse.cuhk.edu.hk/leojia/projects/hsaliency/dataset.html">链接</a></td>
</tr>
<tr>
<td>DUT-OMRON</td>
<td>Image saliency detection(显著性区域检测)</td>
<td>image num:5168</td>
<td><a href="http://saliencydetection.net/dut-omron/">链接</a></td>
</tr>
<tr>
<td>PASCAL-S</td>
<td>Image saliency detection(显著性区域检测)</td>
<td>image num:850</td>
<td><a href="http://cbi.gatech.edu/salobj/">链接</a></td>
</tr>
<tr>
<td>HKU-IS</td>
<td>Image saliency detection(显著性区域检测)</td>
<td>image num:4447</td>
<td><a href="http://i.cs.hku.hk/~gbli/deep_saliency.html">链接</a></td>
</tr>
<tr>
<td>SOD</td>
<td>Image saliency detection(显著性区域检测)</td>
<td>image num:300</td>
<td><a href="http://i.cs.hku.hk/~gbli/deep_saliency.html">链接</a></td>
</tr>
<tr>
<td>Describable Textures Dataset</td>
<td>texture synthesis(纹理合成)</td>
<td>image num:5640 category num:47 split train:val:test = 1:1:1</td>
<td><a href="https://www.robots.ox.ac.uk/~vgg/data/dtd/">链接</a></td>
</tr>
<tr>
<td>CVPPP leaf segmentation</td>
<td>Instance segmentation(样例分割)</td>
<td>image num: 161 train num: 128 test num: 33</td>
<td><a href="https://www.plant-phenotyping.org/CVPPP2014-dataset">链接</a></td>
</tr>
<tr>
<td>KITTI car segmentation</td>
<td>Instance segmentation(样例分割)</td>
<td>image num: 3976 train num: 3712 test num: 144 val:120</td>
<td><a href="http://www.cvlibs.net/datasets/kitti/eval_semantics.php">链接</a></td>
</tr>
<tr>
<td>Cityscapes</td>
<td>Instance segmentation(样例分割)</td>
<td>image num: 5000 train num: 2975 test num: 1525 val:500</td>
<td><a href="https://www.cityscapes-dataset.com/">链接</a></td>
</tr>
<tr>
<td>SYMMAX</td>
<td>Symmetry Detection(对称性检测)</td>
<td>image num: train:200 test:100</td>
<td><a href="https://github.com/KevinKecc/SRN">链接</a></td>
</tr>
<tr>
<td>WHSYMMAX</td>
<td>Symmetry Detection(对称性检测)</td>
<td>image num: train:228 test:100 object num: 1</td>
<td><a href="https://github.com/KevinKecc/SRN">链接</a></td>
</tr>
<tr>
<td>SK506</td>
<td>Symmetry Detection(对称性检测)</td>
<td>image num: train:300 test:206 object num: 16</td>
<td><a href="https://github.com/KevinKecc/SRN">链接</a></td>
</tr>
<tr>
<td>Sym-PASCAL</td>
<td>Symmetry Detection(对称性检测)</td>
<td>image num: train:648 test:787 object num: 14</td>
<td><a href="https://github.com/KevinKecc/SRN">链接</a></td>
</tr>
<tr>
<td>Color Checker Dataset</td>
<td>Color constancy(颜色恒定)</td>
<td>image num: 568</td>
<td><a href="http://www.eecs.harvard.edu/~ayanc/oldcc/dbs.html">链接</a></td>
</tr>
<tr>
<td>NUS 8-Camera Dataset</td>
<td>Color constancy(颜色恒定)</td>
<td>image num: 1736</td>
<td><a href="http://www.comp.nus.edu.sg/~whitebal/illuminant/illuminant.html">链接</a></td>
</tr>
</tbody></table>
<p><a href="#%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86">top</a></p>
<h1 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h1><table>
<thead>
<tr>
<th>数据集</th>
<th>介绍</th>
<th>备注</th>
<th>网址</th>
</tr>
</thead>
<tbody><tr>
<td>Stanford Sentiment Treebank</td>
<td>文本情感分析</td>
<td>11855个句子划分为239231个短语，每个短语有个概率值，越小越负面，越大越正面</td>
<td><a href="https://nlp.stanford.edu/sentiment/">链接</a></td>
</tr>
<tr>
<td>IMDB</td>
<td>文本情感分析</td>
<td>100,000句子，正面负面两类</td>
<td><a href="http://ai.stanford.edu/~amaas/data/sentiment/">链接</a></td>
</tr>
<tr>
<td>Yelp</td>
<td>文本情感分析</td>
<td>无</td>
<td><a href="https://www.yelp.com/dataset/challenge">链接</a></td>
</tr>
<tr>
<td>Multi-Domain Sentiment Dataset(Amazon product)</td>
<td>文本情感分析</td>
<td>100,000+句子，正面负面2类或强正面、弱正面、中立、弱负面、强负面5类</td>
<td><a href="http://www.cs.jhu.edu/~mdredze/datasets/sentiment/">链接</a></td>
</tr>
<tr>
<td>SemEval</td>
<td>文本情感分析</td>
<td>20,632句子，三类（正面、负面、中立）</td>
<td><a href="http://alt.qcri.org/semeval2017/task4/index.php?id=data-and-tools">链接</a></td>
</tr>
<tr>
<td>Sentiment140(STS)</td>
<td>文本情感分析</td>
<td>1,600,000句子,三类（正面、负面、中立）</td>
<td><a href="https://drive.google.com/uc?id=0B04GJPshIjmPRnZManQwWEdTZjg&export=download">链接</a></td>
</tr>
</tbody></table>
<p><a href="#%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86">top</a></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之并发专题</title>
    <url>/2020/02/16/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="一、-进程与线程"><a href="#一、-进程与线程" class="headerlink" title="一、 进程与线程"></a>一、 进程与线程</h1><h2 id="1-程序、进程、线程"><a href="#1-程序、进程、线程" class="headerlink" title="1.程序、进程、线程"></a>1.程序、进程、线程</h2><ul>
<li><p>程序： 程序是一段静态的代码，它是应用程序执行的蓝本</p>
</li>
<li><p>进程：进程是指一种正在运行的程序，有自己的地址空间 </p>
<p>​            特点 ：动态性、并发性、独立性</p>
</li>
<li><p>线程： 进程内部的一个执行单元，它是程序中一个单一的顺序控制流程。 **如果在一个进程中同时运行了多个线程，用来完成不同的工作，则称之为多线程 **。 线程又被称为轻量级进程(lightweight process)</p>
</li>
</ul>
<blockquote>
<p> 并发和并行的区别 ：</p>
<p>并行： 多个CPU同时执行多个任务</p>
<p>并发： 一个CPU（采用时间片）同时执行多个任务</p>
</blockquote>
<h2 id="2-进程和线程的区别"><a href="#2-进程和线程的区别" class="headerlink" title="2.进程和线程的区别"></a>2.进程和线程的区别</h2><img src="/2020/02/16/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/1581842407976.png" alt="1581842407976" style="zoom:80%;">

<hr>
<h1 id="二、-使用线程"><a href="#二、-使用线程" class="headerlink" title="二、 使用线程"></a>二、 使用线程</h1><p>有三种使用线程的方法：</p>
<ul>
<li><p>实现 <code>Runnable</code> 接口；</p>
</li>
<li><p>实现 <code>Callable</code> 接口；</p>
</li>
<li><p>继承 <code>Thread</code> 类。</p>
<p>​            实现 <code>Runnable</code> 和 <code>Callable</code> 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 <code>Thread</code> 来调用。可以理解为任务是通过线程驱动从而执行的。</p>
</li>
</ul>
<h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-13 17:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Demo2 d2 = <span class="keyword">new</span> Demo2();</span><br><span class="line">        Thread th = <span class="keyword">new</span> Thread(d2);</span><br><span class="line"></span><br><span class="line">        th.start(); <span class="comment">// 启动线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;听歌&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><p>同样也是需要实现 <code>run()</code> 方法，因为 Thread 类也实现了 Runable 接口。当调用 <code>start()</code> 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 <code>run()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h2><p> 与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; <span class="comment">// 这里要通过泛型指定返回值Integer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123; <span class="comment">// 注意返回值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>与实现Runnable相比， Callable功能更强大些 </li>
<li>可以有返回值，支持泛型的返回值 </li>
<li>可以抛出异常 </li>
<li>需要借助FutureTask，比如获取返回结果</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>背景： 经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</p>
<p>思路： 提前创建好多个线程， 放入线程池当中，使用时直接获取， 用完后放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p>
<p>优势：</p>
<ul>
<li>提高反应速度（减少了创建新线程的时间）</li>
<li>降低资源的消耗（重复利用线程池中的线程，必须要每次都创建）</li>
<li>便于线程的管理。<ul>
<li><code>corePoolSize</code> : 核心池的大小</li>
<li><code>maximumPoolSize</code>: 最大线程数</li>
<li><code>keepAliveTime</code>: 线程没有任务时最多保持多长时间后会终止。</li>
<li>…</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java线程池的完整构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> maximumPoolSize, // 线程数的上限</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">long</span> keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，</span></span></span><br><span class="line"><span class="params"><span class="function">                                     // 超过这个时间，多余的线程会被回收。</span></span></span><br><span class="line"><span class="params"><span class="function">  BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列</span></span></span><br><span class="line"><span class="params"><span class="function">  ThreadFactory threadFactory, // 新线程的产生方式</span></span></span><br><span class="line"><span class="params"><span class="function">  RejectedExecutionHandler handler)</span> <span class="comment">// 拒绝策略</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">System.out.println(service.getClass()); <span class="comment">//  class 					            java.util.concurrent.ThreadPoolExecutor</span></span><br><span class="line">ThreadPoolExecutor service1 = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">service1.setCorePoolSize(<span class="number">15</span>);</span><br><span class="line"><span class="comment">// service1.setKeepAliveTime();</span></span><br></pre></td></tr></table></figure>

<p>详见[基础线程机制](#三、 基础线程机制)</p>
<p>参考：  <a href="https://www.cnblogs.com/CarpenterLee/p/9558026.html">https://www.cnblogs.com/CarpenterLee/p/9558026.html</a> </p>
<h2 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h2><p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<blockquote>
<p>实现Runnable接口方式的多线程 </p>
<p>优势：可以继承其它类，多线程可共享同一个Runnable对象</p>
<p>劣势：编程方式稍微复杂，如果需要访问当前线程，需要调用<code>Thread.currentThread()</code>方 法</p>
</blockquote>
<h2 id="Thread类常用方法"><a href="#Thread类常用方法" class="headerlink" title="Thread类常用方法"></a>Thread类常用方法</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static Thread currentThread()</td>
<td align="center">得到当前线程</td>
</tr>
<tr>
<td align="center">getName( )</td>
<td align="center">返回线程的名称</td>
</tr>
<tr>
<td align="center">setName (String name)</td>
<td align="center">将线程的名称设置为由name指定的名称</td>
</tr>
<tr>
<td align="center">int getPriority()</td>
<td align="center">获得线程的优先级数值</td>
</tr>
<tr>
<td align="center">void setPriority()</td>
<td align="center">设置线程的优先级数值</td>
</tr>
<tr>
<td align="center">void start( )</td>
<td align="center">调用run( )方法启动线程，开始线程的执行</td>
</tr>
<tr>
<td align="center">void run( )</td>
<td align="center">存放线程体代码</td>
</tr>
<tr>
<td align="center">isAlive()</td>
<td align="center">判断线程是否还“活”着，即线程是未终止</td>
</tr>
</tbody></table>
<hr>
<h2 id="一些多线程的例子"><a href="#一些多线程的例子" class="headerlink" title="一些多线程的例子"></a>一些多线程的例子</h2><h3 id="1-模拟龟兔赛跑"><a href="#1-模拟龟兔赛跑" class="headerlink" title="1. 模拟龟兔赛跑"></a>1. 模拟龟兔赛跑</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟龟兔赛跑</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-13 17:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Racer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String Winner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= <span class="number">100</span>; step++)&#123;</span><br><span class="line">            <span class="comment">// 模拟兔子每10步休息一次</span></span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;兔子&quot;</span>) &amp;&amp; step % <span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;乌龟&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;----&gt;&quot;</span>+ step);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(isGameOver(step))&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断比赛是否结束</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isGameOver</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Winner != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;Winner is &quot;+ Winner);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(step == <span class="number">100</span>)&#123;</span><br><span class="line">            Winner = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;Winner is &quot;</span>+ Winner);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Racer racer = <span class="keyword">new</span> Racer();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()); <span class="comment">// 主线程</span></span><br><span class="line">        <span class="comment">// 创建两个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(racer, <span class="string">&quot;兔子&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(racer, <span class="string">&quot;乌龟&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用Callable接口来创建线程的方式，模拟龟兔赛跑例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的第三种方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-13 17:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Racer_Call</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    String Winner;  <span class="comment">// 胜利者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= <span class="number">100</span>; step++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;pool-1-thread-1&quot;</span>) &amp;&amp; step % <span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot;====&gt;&quot;</span>+step);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(isGameOver(step))&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isGameOver</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Winner != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;Winner is &quot;+ Winner);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(step == <span class="number">100</span>)&#123;</span><br><span class="line"></span><br><span class="line">            Winner = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;Winner is &quot;</span>+ Winner);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Racer_Call rc = <span class="keyword">new</span> Racer_Call();</span><br><span class="line">        <span class="comment">//创建执行服务</span></span><br><span class="line">        ExecutorService ex = Executors.newFixedThreadPool(<span class="number">2</span>); <span class="comment">//  线程池中两个线程</span></span><br><span class="line">        <span class="comment">// 提交执行</span></span><br><span class="line">        Future&lt;Integer&gt; ribbits = ex.submit(rc);</span><br><span class="line">        Future&lt;Integer&gt; turtle = ex.submit(rc);</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">int</span> riSteps = ribbits.get();</span><br><span class="line">        <span class="keyword">int</span> tu = turtle.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;兔子的步数：&quot;</span> + riSteps);</span><br><span class="line">        System.out.println(<span class="string">&quot;乌龟的步数：&quot;</span> + tu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ex.shutdownNow();<span class="comment">// 关闭服务</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-Web12306"><a href="#2-Web12306" class="headerlink" title="2. Web12306"></a>2. Web12306</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-13 17:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Web12306</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span> tickets = <span class="number">10</span>; <span class="comment">// 共享资源</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tickets &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; ----&gt;&quot;</span> + tickets--);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Web12306 w1 = <span class="keyword">new</span> Web12306();</span><br><span class="line">        Web12306 w2 = <span class="keyword">new</span> Web12306();</span><br><span class="line"></span><br><span class="line">        Web12306 w3 = <span class="keyword">new</span> Web12306();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(w1, <span class="string">&quot;张三&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(w2, <span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(w3, <span class="string">&quot;王五&quot;</span>).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="三、-基础线程机制"><a href="#三、-基础线程机制" class="headerlink" title="三、 基础线程机制"></a>三、 基础线程机制</h1><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。 </p>
<blockquote>
<p>主要有三种 Executor：</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-16 17:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool(); <span class="comment">// 个任务创建一个线程；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown(); <span class="comment">// 关闭服务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+ <span class="string">&quot;:  executor test 。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>pool-1-thread-1:  executor test 。。。<br>pool-1-thread-5:  executor test 。。。<br>pool-1-thread-4:  executor test 。。。<br>pool-1-thread-3:  executor test 。。。<br>pool-1-thread-2:  executor test 。。。</p>
</blockquote>
<h2 id="Daemon-守护进程"><a href="#Daemon-守护进程" class="headerlink" title="Daemon 守护进程"></a>Daemon 守护进程</h2><p>​        守护线程是程序运行时在<strong>后台提供服务的线程</strong>，不属于程序中不可或缺的部分。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。<code>main()</code> 属于非守护线程。非守护进程也说普通进程或者用户进程。</p>
<p>​        在线程启动之前使用 <code>setDaemon()</code> 方法可以将一个线程设置为守护线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java中的线程分为两类：一种是<strong>守护线程</strong>，一种是<strong>用户线程</strong>。</p>
<p>它们在几乎每个方面都是相同的，<strong>唯一的区别是判断JVM何时离开。</strong></p>
<ul>
<li><p>守护线程是用来服务用户线程的，通过在start()方法前调用<code>thread.setDaemon(true)</code>可以把一个用户线程变成一个守护线程。</p>
</li>
<li><p>Java垃圾回收就是一个典型的守护线程。</p>
</li>
<li><p>若JVM中都是守护线程，当前JVM将退出。</p>
</li>
</ul>
<h2 id="Threa-Sleep"><a href="#Threa-Sleep" class="headerlink" title="Threa.Sleep()"></a>Threa.Sleep()</h2><p><code>Thread.sleep(millisec)</code> 方法会休眠当前正在执行的线程，<code>millisec</code> 单位为毫秒。</p>
<p><code>sleep()</code> 可能会抛出 <code>InterruptedException</code>，因为异常不能跨线程传播回 <code>main()</code> 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="yield-礼让线程"><a href="#yield-礼让线程" class="headerlink" title="yield() 礼让线程"></a>yield() 礼让线程</h2><p>对静态方法 <code>Thread.yield()</code> 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。 </p>
<p>yield让当前正在执行线程暂停，不是阻塞线程，而是将线程转入<strong>就绪状态</strong> </p>
<p>如果调用了yield方法之后，没有其他等待执行的线程，这个时候当前线程就会马上恢复执行！ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * yield 礼让线程 --&gt; 高风亮节，主动让出CPU，重新回到就绪状态 直接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-13 20:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">yieldDemo1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// lambda表达式  一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;lambda&quot;</span>+ i);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                Thread.yield(); <span class="comment">//  main 线程礼让</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;main:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="四、-中断"><a href="#四、-中断" class="headerlink" title="四、 中断"></a>四、 中断</h1><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。 </p>
<h2 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h2><p>​        通过调用一个线程的 <code>interrupt()</code> 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 <code>InterruptedException</code>，从而提前结束该线程。但是不能中断 I/O 阻塞和 <code>synchronized</code> 锁阻塞。</p>
<p>​        对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 <code>Thread.sleep()</code> 方法，因此会抛出一个 <code>InterruptedException</code>，从而提前结束线程，不执行之后的语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-16 17:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread1 myThread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        myThread1.start();</span><br><span class="line">        myThread1.interrupt(); <span class="comment">//  线程中断</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;lalla&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2020/02/16/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/1581844882895.png" class width="1581844882895">

<h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>​        如果一个线程的 <code>run()</code> 方法执行一个无限循环，并且没有执行 <code>sleep()</code> 等会抛出 <code>InterruptedException</code> 的操作，那么调用线程的 <code>interrupt()</code> 方法就无法使线程提前结束。</p>
<p>​        但是调用 <code>interrupt()</code> 方法会设置线程的中断标记，此时调用 <code>interrupted()</code> 方法会返回 true。因此可以在循环体中使用 <code>interrupted()</code> 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-16 17:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">interruptedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;  <span class="comment">// interrupted()方法会设置线程的中断标记 返回true</span></span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h2><p>调用 <code>Executor</code> 的 <code>shutdown()</code> 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 <code>shutdownNow()</code> 方法，则相当于调用每个线程的 <code>interrupt()</code> 方法。 </p>
<p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Main run</p>
<p>java.lang.InterruptedException: sleep interrupted<br>    at java.lang.Thread.sleep(Native Method)<br>    at MyRunnable.run(ExecutorTest.java:25)<br>    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)<br>    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)<br>    at java.lang.Thread.run(Thread.java:748) </p>
</blockquote>
<p>如果只想中断 Executor 中的一个线程，可以通过使用 <code>submit()</code> 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 <code>cancel(true)</code> 方法就可以中断线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="五、-互斥同步"><a href="#五、-互斥同步" class="headerlink" title="五、 互斥同步"></a>五、 互斥同步</h1><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 <code>synchronized</code>，而另一个是 JDK 实现的 <code>ReentrantLock</code>(可重入锁)。 </p>
<blockquote>
<p>死锁 ： 当两个线程相互等待对方释放“锁”时就会发生死锁 </p>
<p> 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</p>
<p>  多线程编程时应该注意避免死锁的发生</p>
</blockquote>
<p>线程同步问题的应用场景： 多个用户同时操作一个银行账户。每次取款100元，取款前先检查余额是否足够。如果不够， 放弃取款。</p>
<blockquote>
<p>当多个线程访问同一个数据时，容易出现线程安全问题。需要让线程同步，保证数据安全</p>
</blockquote>
<p>当两个或两个以上线程访问同一资源时，需要某种方式来确保资源在某一时刻只被一个线程 使用</p>
<p>看一个线程不安全的例子： 去银行取钱 会出现负数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程不安全： 取钱  出现负数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-14 11:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnSafeTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="number">100</span>, <span class="string">&quot;结婚礼金&quot;</span>);</span><br><span class="line">        DrawMoney d1 = <span class="keyword">new</span> DrawMoney(account, <span class="number">70</span>, <span class="string">&quot;我&quot;</span>);</span><br><span class="line">        DrawMoney d2 = <span class="keyword">new</span> DrawMoney(account, <span class="number">80</span>, <span class="string">&quot;老婆&quot;</span>);</span><br><span class="line">        d1.start();</span><br><span class="line">        d2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money; <span class="comment">// 金额</span></span><br><span class="line">    String name; <span class="comment">// 名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawMoney</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account; <span class="comment">// 操作的账户</span></span><br><span class="line">    String name; <span class="comment">// 谁取钱</span></span><br><span class="line">    <span class="keyword">int</span> drawingmoney; <span class="comment">//取多少钱</span></span><br><span class="line">    <span class="keyword">int</span> packet; <span class="comment">// 已经取得的钱数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawMoney</span><span class="params">(Account account,<span class="keyword">int</span> m, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawingmoney = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account.money - drawingmoney &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        account.money -= drawingmoney;</span><br><span class="line">        packet += drawingmoney;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;口袋里有&quot;</span>+packet+<span class="string">&quot;, 账户余额为：&quot;</span>+account.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>我口袋里有70, 账户余额为：-50<br>老婆口袋里有80, 账户余额为：-50</p>
</blockquote>
<p>同理， 在Web12306例子中，会出现重复票的问题，以及当只剩下一张票的时候，即临界资源时，会出现负数。</p>
<p>线程同步的实现方案 ：</p>
<ol>
<li>同步方法</li>
<li>同步代码块</li>
</ol>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ol>
<li><p>同步一个代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>对于以下代码，使用 <code>ExecutorService</code> 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两个不同的对象</span></span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>同步一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-16 19:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">        <span class="comment">//SynchronizedExample e2 = new SynchronizedExample();</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; e1.func2());</span><br><span class="line">        executorService.execute(() -&gt; e1.func2());</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>0 1 2 3 4 5 6 7 8 9<br>0 1 2 3 4 5 6 7 8 9 </p>
</blockquote>
<ol start="4">
<li><p>同步一个静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-16 19:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line"><span class="comment">//        SynchronizedExample e2 = new SynchronizedExample();</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; e1.func2());</span><br><span class="line">        executorService.execute(() -&gt; e1.func2());</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>作用于整个类</p>
<blockquote>
<p>0 1 2 3 4 5 6 7 8 9<br>0 1 2 3 4 5 6 7 8 9 </p>
</blockquote>
</li>
</ol>
<h2 id="ReentrantLock-可重入锁"><a href="#ReentrantLock-可重入锁" class="headerlink" title="ReentrantLock 可重入锁"></a>ReentrantLock 可重入锁</h2><p><code>ReentrantLock</code> 是 <code>java.util.concurrent（J.U.C）</code>包中的锁。 </p>
<p>​        锁作为并发共享数据保证一致性的工具，大多数内置锁都是可重入的，也就是说如果某个线程试图获取一个已经由他自己持有的锁，那么，这个请求会立刻成功，并且将这个锁的计数器值加1。而当线程退出同步代码块时，计数器将会递减。当计数值等于零的时候，锁就会释放。如果没有可重入锁的支持，在第二次企图获得锁时将会进入死锁状态，可重入锁随处可见。</p>
<p>​    <code>synchronized</code>的就是一个可重入锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> other;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可重入锁：锁可以延续使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-16 20:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 第一次获得锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">// 第二次获得同样的锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;可重入锁！！！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> LockTest().test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可重入锁 ！！！ .</p>
<p>…</p>
</blockquote>
<p>下面举个例子：使用不可重入锁会导致死锁的情况，下面的代码会造成死循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> other;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不可重入锁： 锁不可以延续使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-16 20:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest2</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获得锁</span></span><br><span class="line">        doSomething();</span><br><span class="line">        lock.unlock(); <span class="comment">// 锁释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可重入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LockTest2 test = <span class="keyword">new</span> LockTest2();</span><br><span class="line">        test.a();</span><br><span class="line">        test.doSomething();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line">    <span class="comment">//是否占用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 使用锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isLocked)&#123; <span class="comment">// 锁被占用了之后，一直要等待锁释放之后</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait(); <span class="comment">// 等待线程释放锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用锁，占有锁</span></span><br><span class="line">        isLocked = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isLocked = <span class="keyword">false</span>; <span class="comment">//  释放</span></span><br><span class="line">        notify(); <span class="comment">// 唤醒其他线程使用锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改写成可重入锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> other;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 自己实现可重入锁： 锁可以延续使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-16 20:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest2</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 获得锁</span></span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">        doSomething();</span><br><span class="line">        lock.unlock(); <span class="comment">// 锁释放</span></span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可重入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LockTest2 test = <span class="keyword">new</span> LockTest2();</span><br><span class="line">        test.a();</span><br><span class="line"><span class="comment">//        test.doSomething();</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最终后的锁计数器的值为&quot;</span>);</span><br><span class="line">        System.out.println(test.lock.getHoldCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line">    <span class="comment">//是否占用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果是自己的持有锁，则可以立刻获得锁</span></span><br><span class="line">    <span class="keyword">private</span> Thread lockedBy = <span class="keyword">null</span>; <span class="comment">// 存储线程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holdCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁的计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> holdCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread(); <span class="comment">//  当前线程</span></span><br><span class="line">        <span class="comment">// 如果被锁了，并且持有锁的线程不等于当前线程</span></span><br><span class="line">       <span class="keyword">while</span> (isLocked &amp;&amp; lockedBy != t)&#123;</span><br><span class="line">            wait();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 可以使用锁了</span></span><br><span class="line">       isLocked = <span class="keyword">true</span>;</span><br><span class="line">       lockedBy = t;</span><br><span class="line">       holdCount++; <span class="comment">// 计数器加1；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread() == lockedBy)&#123; <span class="comment">//当前线程等于lockedBy的时候才会释放</span></span><br><span class="line">            holdCount--; <span class="comment">// 计数器减一</span></span><br><span class="line">            <span class="keyword">if</span>(holdCount == <span class="number">0</span>)&#123;</span><br><span class="line">                isLocked = <span class="keyword">false</span>; <span class="comment">//  释放</span></span><br><span class="line">                lockedBy = <span class="keyword">null</span>;</span><br><span class="line">                notify(); <span class="comment">// 唤醒其他线程使用锁</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1<br>2<br>hello world<br>1<br>0<br>最终后的锁计数器的值为<br>0</p>
</blockquote>
<p>直接用<code>java.util.concurrent（J.U.C）</code>包里面的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>

<p>将上面的代码中的 <code>Lock lock = new Lock();</code>改成上述代码就行了，方法都是一样的。可以运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果同步代码有异常，要将unlock()写入finally语句块 </p>
<blockquote>
<p>Lock和synchronized的区别</p>
<p>1.Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁</p>
<p>2.Lock只有代码块锁，synchronized有代码块锁和方法锁</p>
<p>3.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</p>
<p>优先使用顺序：  Lock—-同步代码块（已经进入了方法体，分配了相应资源）—-同步方法（在方法体之外）</p>
</blockquote>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="1-锁的实现"><a href="#1-锁的实现" class="headerlink" title="1. 锁的实现"></a>1. 锁的实现</h3><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p>
<h3 id="2-性能"><a href="#2-性能" class="headerlink" title="2. 性能"></a>2. 性能</h3><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 </p>
<h3 id="3-等待可中断"><a href="#3-等待可中断" class="headerlink" title="3. 等待可中断"></a>3. 等待可中断</h3><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 </p>
<h3 id="4-公平锁"><a href="#4-公平锁" class="headerlink" title="4. 公平锁"></a>4. 公平锁</h3><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p>
<p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
<h3 id="5-锁绑定多个条件"><a href="#5-锁绑定多个条件" class="headerlink" title="5. 锁绑定多个条件"></a>5. 锁绑定多个条件</h3><p>一个 ReentrantLock 可以同时绑定多个 <code>Condition</code> 对象 。</p>
<h2 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h2><p>除非需要使用 <code>ReentrantLock</code> 的高级功能，否则优先使用 <code>synchronized</code>。这是因为 <code>synchronized</code> 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 <code>ReentrantLock</code> 不是所有的 JDK 版本都支持。并且使用 <code>synchronized</code> 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。 </p>
<h2 id="同步小实例"><a href="#同步小实例" class="headerlink" title="同步小实例"></a>同步小实例</h2><h3 id="1-快乐电影院"><a href="#1-快乐电影院" class="headerlink" title="1. 快乐电影院"></a>1. 快乐电影院</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快乐影院： 实现多线程买电影票</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-14 17:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappyCinema</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cinema cinema = <span class="keyword">new</span> Cinema(<span class="string">&quot;旺达&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Custom(cinema, <span class="number">2</span>), <span class="string">&quot;张三&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Custom(cinema, <span class="number">1</span>), <span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Custom</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Cinema cinema; <span class="comment">// 去哪个影院看电影</span></span><br><span class="line">    <span class="keyword">int</span> seats; <span class="comment">//  要买多少张票</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Custom</span><span class="params">(Cinema cinema, <span class="keyword">int</span> seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cinema = cinema;</span><br><span class="line">        <span class="keyword">this</span>.seats = seats;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cinema)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cinema.bookTickets(seats))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;购票成功，&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;的位置为：==&gt;&quot;</span>+seats );</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;票不够， 购票失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cinema</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> totalSeats; <span class="comment">// 有多少座位</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cinema</span><span class="params">(String name, <span class="keyword">int</span> totalSeats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.totalSeats = totalSeats;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bookTickets</span><span class="params">(<span class="keyword">int</span> nums)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前电影院有&quot;</span>+totalSeats+<span class="string">&quot;张票.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums &gt;  totalSeats)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            totalSeats-=nums;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当前电影院有2张票.<br>购票成功，张三的位置为：==&gt;2<br>当前电影院有0张票.<br>票不够， 购票失败</p>
</blockquote>
<h3 id="2-高级功能：快乐电影院-支持在线选座"><a href="#2-高级功能：快乐电影院-支持在线选座" class="headerlink" title="2.高级功能：快乐电影院-支持在线选座"></a>2.高级功能：快乐电影院-支持在线选座</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快乐影院： 实现多线程买电影票 支持选座</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-14 17:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappyMovie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; NumsSeats = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        NumsSeats.add(<span class="number">1</span>);</span><br><span class="line">        NumsSeats.add(<span class="number">2</span>);</span><br><span class="line">        NumsSeats.add(<span class="number">3</span>);</span><br><span class="line">        NumsSeats.add(<span class="number">4</span>);</span><br><span class="line">        NumsSeats.add(<span class="number">5</span>);</span><br><span class="line">        NumsSeats.add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; seat1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        seat1.add(<span class="number">1</span>);</span><br><span class="line">        seat1.add(<span class="number">4</span>);</span><br><span class="line">        seat1.add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; seat2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        seat2.add(<span class="number">3</span>);</span><br><span class="line">        seat2.add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ZZCinema cinema = <span class="keyword">new</span> ZZCinema(<span class="string">&quot;旺达&quot;</span>, NumsSeats);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HappyCustom(cinema, seat1), <span class="string">&quot;张三&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HappyCustom(cinema, seat2), <span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HappyCustom</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    ZZCinema cinema; <span class="comment">// 去哪个影院看电影</span></span><br><span class="line">    List&lt;Integer&gt; seats; <span class="comment">//  要买多少张票</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HappyCustom</span><span class="params">(ZZCinema cinema, List&lt;Integer&gt; seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cinema = cinema;</span><br><span class="line">        <span class="keyword">this</span>.seats = seats;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cinema)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cinema.bookTickets(seats))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;购票成功，&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;的位置为：==&gt;&quot;</span>+seats );</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;票不够，&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; 购票失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZZCinema</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    List&lt;Integer&gt; totalSeats; <span class="comment">// 有多少座位</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZZCinema</span><span class="params">(String name, List&lt;Integer&gt; totalSeats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.totalSeats = totalSeats;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bookTickets</span><span class="params">(List&lt;Integer&gt; seats)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎光临&quot;</span>+ <span class="keyword">this</span>.name +<span class="string">&quot;当前电影院有&quot;</span>+totalSeats+<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(seats.size() &gt; totalSeats.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; copy =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        copy.addAll(totalSeats);</span><br><span class="line">        copy.removeAll(seats);</span><br><span class="line">        <span class="keyword">if</span>(totalSeats.size() - copy.size() != seats.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 出票失败</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        totalSeats = copy;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>欢迎光临旺达当前电影院有[1, 2, 3, 4, 5, 6].<br>购票成功，张三的位置为：==&gt;[1, 4, 6]<br>欢迎光临旺达当前电影院有[2, 3, 5].<br>票不够，李四 购票失败</p>
</blockquote>
<h3 id="3-快乐12306"><a href="#3-快乐12306" class="headerlink" title="3. 快乐12306"></a>3. 快乐12306</h3><p>注意和快乐电影院的实现方法，有所不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 快乐火车票</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-14 18:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Happy12306</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; NumsSeats = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        NumsSeats.add(<span class="number">1</span>);</span><br><span class="line">        NumsSeats.add(<span class="number">2</span>);</span><br><span class="line">        NumsSeats.add(<span class="number">3</span>);</span><br><span class="line">        NumsSeats.add(<span class="number">4</span>);</span><br><span class="line">        NumsSeats.add(<span class="number">5</span>);</span><br><span class="line">        NumsSeats.add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; seat1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        seat1.add(<span class="number">1</span>);</span><br><span class="line">        seat1.add(<span class="number">4</span>);</span><br><span class="line">        seat1.add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; seat2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        seat2.add(<span class="number">3</span>);</span><br><span class="line">        seat2.add(<span class="number">5</span>);</span><br><span class="line">        Web12306 w = <span class="keyword">new</span> Web12306(NumsSeats, <span class="string">&quot;12306赣州站&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Passenger(w,seat1, <span class="string">&quot;张三&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Passenger(w, seat2, <span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Passenger</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; seats; <span class="comment">//  要买多少张票</span></span><br><span class="line">    String name; <span class="comment">//  名字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Passenger</span><span class="params">(Runnable target, List&lt;Integer&gt; seats, String name)</span> </span>&#123; <span class="comment">// 传入target</span></span><br><span class="line">        <span class="keyword">super</span>(target, name);</span><br><span class="line">        <span class="keyword">this</span>.seats = seats;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web12306</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; tickets;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Web12306</span><span class="params">(List&lt;Integer&gt; tickets, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tickets = tickets;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Passenger p =  (Passenger)Thread.currentThread();  <span class="comment">//  当前乘客</span></span><br><span class="line">        <span class="keyword">if</span>(bookTickets(p.seats))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;购票成功，&quot;</span>+ Thread.currentThread().getName()+<span class="string">&quot;的位置为：==&gt;&quot;</span>+p.seats );</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;票不够，&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; 购票失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">bookTickets</span><span class="params">(List&lt;Integer&gt; seats)</span></span>&#123; <span class="comment">// 同步方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎光临&quot;</span>+ <span class="keyword">this</span>.name +<span class="string">&quot;当前有&quot;</span>+tickets+<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(seats.size() &gt; tickets.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; copy =  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        copy.addAll(tickets);</span><br><span class="line">        copy.removeAll(seats);</span><br><span class="line">        <span class="keyword">if</span>(tickets.size() - copy.size() != seats.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 出票失败</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        tickets = copy;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>欢迎光临12306赣州站当前有[1, 2, 3, 4, 5, 6].<br>购票成功，张三的位置为：== &gt;[1, 4, 6]<br>欢迎光临12306赣州站当前有[2, 3, 5].<br>购票成功，李四的位置为：== &gt;[3, 5]</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>释放锁的操作：</p>
<blockquote>
<ol>
<li><p>当前线程的同步方法、同步代码块执行结束</p>
</li>
<li><p>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。</p>
</li>
<li><p>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</p>
</li>
<li><p>当前线程在同步代码块、同步方法中执行了锁对象的**wait()**方法，当前线程暂停，并释放锁。</p>
</li>
</ol>
</blockquote>
<p>不会释放锁的操作：</p>
<blockquote>
<ol>
<li><p>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行</p>
</li>
<li><p>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。</p>
<p>​            ==&gt; 应尽量避免使用suspend()和resume()来控制线程(这两个方法以及过时了!  )</p>
</li>
</ol>
</blockquote>
<hr>
<h1 id="七、-线程状态"><a href="#七、-线程状态" class="headerlink" title="七、 线程状态"></a>七、 线程状态</h1><p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态 。</p>
<h2 id="新建（NEW）"><a href="#新建（NEW）" class="headerlink" title="新建（NEW）"></a>新建（NEW）</h2><p>创建后尚未启动。</p>
<h2 id="可运行（RUNABLE）"><a href="#可运行（RUNABLE）" class="headerlink" title="可运行（RUNABLE）"></a>可运行（RUNABLE）</h2><p>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。 </p>
<h2 id="阻塞（BLOCKED）"><a href="#阻塞（BLOCKED）" class="headerlink" title="阻塞（BLOCKED）"></a>阻塞（BLOCKED）</h2><p>请求获取 <code>monitor lock</code> （监视器）从而进入 <code>synchronized</code> 函数或者代码块，但是其它线程已经占用了该 <code>monitor lock</code>，所以处于阻塞状态。要结束该状态进入从而 <code>RUNABLE</code> 需要其他线程释放 <code>monitor lock</code>。 </p>
<h2 id="无限期等待（WAITING）"><a href="#无限期等待（WAITING）" class="headerlink" title="无限期等待（WAITING）"></a>无限期等待（WAITING）</h2><p>等待其它线程显式地唤醒。 </p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 <code>monitor lock</code>。而等待是主动的，通过调用 <code>Object.wait()</code> 等方法进入。 </p>
<table>
<thead>
<tr>
<th align="center">进入方法</th>
<th align="center">退出方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">没有设置 Timeout 参数的 Object.wait() 方法</td>
<td align="center">Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td align="center">没有设置 Timeout 参数的 Thread.join() 方法</td>
<td align="center">被调用的线程执行完毕</td>
</tr>
<tr>
<td align="center">LockSupport.park() 方法</td>
<td align="center">LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h2 id="限期等待（TIME-WAITING"><a href="#限期等待（TIME-WAITING" class="headerlink" title="限期等待（TIME_WAITING)"></a>限期等待（TIME_WAITING)</h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。 </p>
<table>
<thead>
<tr>
<th align="center">进入方法</th>
<th align="center">退出方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Thread.sleep() 方法</td>
<td align="center">时间结束</td>
</tr>
<tr>
<td align="center">设置了 Timeout 参数的 Object.wait() 方法</td>
<td align="center">时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td align="center">设置了 Timeout 参数的 Thread.join() 方法</td>
<td align="center">时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td align="center">LockSupport.parkNanos() 方法</td>
<td align="center">LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td align="center">LockSupport.parkUntil() 方法</td>
<td align="center">LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<p>调用 <code>Thread.sleep()</code> 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 <code>Object.wait()</code> 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。 </p>
<h2 id="死亡（TERMINATED）"><a href="#死亡（TERMINATED）" class="headerlink" title="死亡（TERMINATED）"></a>死亡（TERMINATED）</h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。 </p>
<p><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html">Java SE 9 Enum Thread.State</a> </p>
<hr>
<h1 id="八、线程的生命周期"><a href="#八、线程的生命周期" class="headerlink" title="八、线程的生命周期"></a>八、线程的生命周期</h1><img src="/2020/02/16/Java%E4%B9%8B%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/1581860001074.png" class width="1581860001074">

<hr>
<h1 id="九、线程之间的协作-通信"><a href="#九、线程之间的协作-通信" class="headerlink" title="九、线程之间的协作/通信"></a>九、线程之间的协作/通信</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。 </p>
<h2 id="Join-插队"><a href="#Join-插队" class="headerlink" title="Join-插队"></a>Join-插队</h2><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ThreadStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * join: 合并线程， 插队线程，注意谁被阻塞了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-13 20:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockedJoin t = <span class="keyword">new</span> BlockedJoin();</span><br><span class="line">        Thread th = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        th.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>;  i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(  i == <span class="number">40</span>)&#123;</span><br><span class="line">                th.join();  <span class="comment">// 必须当th线程执行完之后，main线程才会执行  main被阻塞！</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;main:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="wait-与-notify-和-notifyAll"><a href="#wait-与-notify-和-notifyAll" class="headerlink" title="wait() 与 notify() 和 notifyAll()"></a>wait() 与 notify() <strong>和</strong> notifyAll()</h2><p>它们都属于 <code>Object</code> 的一部分，而不属于 <code>Thread</code>。</p>
<p><code>Java.lang.Object</code>提供的这三个方法只有在<code>synchronized</code>方法或<code>synchronized</code>代码块中才能使用，否则会报<code>java.lang.IllegalMonitorStateException</code>异常。 </p>
<h3 id="1-wait-方法"><a href="#1-wait-方法" class="headerlink" title="1. wait() 方法"></a>1. wait() 方法</h3><p>​        wait()令当前线程挂起并放弃CPU、同步资源，使别的线程可访问并修改共享资源，而当前线程排队等候再次对资源的访问。调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 <code>notify()</code> 或者 <code>notifyAll()</code> 来唤醒挂起的线程。 </p>
<p>​        <strong>使用 wait() 挂起期间，线程会释放锁</strong>。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 <code>notify()</code> 或者 <code>notifyAll()</code> 来唤醒挂起的线程，造成死锁。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>

<p><strong>wait() 和 sleep() 的区别</strong></p>
<ul>
<li><code>wait()</code> 是 <code>Object</code> 的方法，而 <code>sleep()</code> 是 <code>Thread</code> 的静态方法；</li>
<li><code>wait()</code> 会释放锁，<code>sleep()</code> 不会。</li>
</ul>
<h3 id="2-notify-方法"><a href="#2-notify-方法" class="headerlink" title="2. notify()方法"></a>2. notify()方法</h3><p>​        唤醒正在排队等待同步资源的线程中优先级最高者结束等待。</p>
<h3 id="3-notifyAll-方法"><a href="#3-notifyAll-方法" class="headerlink" title="3. notifyAll() 方法"></a>3. notifyAll() 方法</h3><p>​        唤醒正在排队等待资源的所有线程结束等待 。 </p>
<h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h2><p>​        <code>java.util.concurrent</code> 类库中提供了 <code>Condition</code> 类来实现线程之间的协调，可以在 <code>Condition</code> 上调用 <code>await()</code> 方法使线程等待，其它线程调用 <code>signal()</code> 或 <code>signalAll()</code> 方法唤醒等待的线程。 </p>
<p>​        相比于 <code>wait()</code> 这种等待方式，<code>await()</code> 可以指定等待的条件，因此更加灵活。</p>
<p>​        使用 <code>Lock</code> 来获取一个 <code>Condition</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cooperation;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-16 21:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">        executorService.execute(() -&gt; example.after());</span><br><span class="line">        executorService.execute(() -&gt; example.before());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></figure>



<h2 id="线程通信：生产者消费者模式"><a href="#线程通信：生产者消费者模式" class="headerlink" title="线程通信：生产者消费者模式"></a>线程通信：生产者消费者模式</h2><p>​        生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</p>
<p>这里可能出现两个问题：</p>
<blockquote>
<p>生产者比消费者快时，消费者会漏掉一些数据没有取到。</p>
<p>消费者比生产者快时，消费者会取相同的数据。</p>
</blockquote>
<p>以一个例子来理解：生产馒头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cooperation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 生产者和消费者问题： 管程法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-15 12:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Buffer b = <span class="keyword">new</span> Buffer();  <span class="comment">// 缓存区</span></span><br><span class="line">        Product p = <span class="keyword">new</span> Product(b);</span><br><span class="line">        Consumer c = <span class="keyword">new</span> Consumer(b);</span><br><span class="line">        p.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    Buffer buffer;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span> ; i++)&#123;</span><br><span class="line">            buffer.push(<span class="keyword">new</span> ManTou(i));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者生产了&quot;</span>+i+<span class="string">&quot;号馒头， 当前共有馒头&quot;</span>+ buffer.getNum() +<span class="string">&quot; 个&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> max_szie = <span class="number">10</span>; <span class="comment">// 大小</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>  num;</span><br><span class="line">    <span class="keyword">private</span> ManTou[] man = <span class="keyword">new</span> ManTou[max_szie];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">( ManTou manTou)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= max_szie)&#123; <span class="comment">// 不用生产了</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();  <span class="comment">// 缓存区满了， 生产者等待消费者消费，当消费者唤醒生产者时继续生产</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            man[num] = manTou;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll(); <span class="comment">// 唤醒消费者来消费了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取走馒头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ManTou <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>)&#123; <span class="comment">// 没有馒头</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll(); <span class="comment">// 唤醒生产者该生产了</span></span><br><span class="line">        <span class="keyword">return</span> man[num];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Buffer buffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buffer.getNum() == <span class="number">0</span>)    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            ManTou m = buffer.pop();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者消费了一个&quot;</span>+m.getId()+<span class="string">&quot;馒头， 当前共有馒头&quot;</span>+ buffer.getNum() +<span class="string">&quot; 个&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 馒头</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ManTou</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id; <span class="comment">// 馒头的编号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ManTou</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>生产者生产了0号馒头， 当前共有馒头1 个<br>生产者生产了1号馒头， 当前共有馒头2 个<br>生产者生产了2号馒头， 当前共有馒头3 个<br>消费者消费了一个2馒头， 当前共有馒头2 个<br>生产者生产了3号馒头， 当前共有馒头3 个<br>生产者生产了4号馒头， 当前共有馒头4 个<br>消费者消费了一个4馒头， 当前共有馒头3 个<br>生产者生产了5号馒头， 当前共有馒头4 个<br>生产者生产了6号馒头， 当前共有馒头5 个<br>生产者生产了7号馒头， 当前共有馒头6 个<br>消费者消费了一个7馒头， 当前共有馒头5 个<br>生产者生产了8号馒头， 当前共有馒头6 个<br>生产者生产了9号馒头， 当前共有馒头7 个<br>消费者消费了一个9馒头， 当前共有馒头6 个<br>生产者生产了10号馒头， 当前共有馒头7 个<br>生产者生产了11号馒头， 当前共有馒头8 个<br>生产者生产了12号馒头， 当前共有馒头9 个</p>
<p>…</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li> <a href="https://cyc2018.github.io/CS-Notes">https://cyc2018.github.io/CS-Notes</a> </li>
<li> BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007. </li>
<li> 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011. </li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之IO流</title>
    <url>/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/</url>
    <content><![CDATA[<h1 id="一、-概览"><a href="#一、-概览" class="headerlink" title="一、 概览"></a>一、 概览</h1> <img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/io.png" alt="img" style="zoom:150%;">

 

<p>Java 的 I/O 大概可以分成以下几类：</p>
<ul>
<li>磁盘操作：<code>File</code></li>
<li>字节操作：<code>InputStream</code> 和 <code>OutputStream</code></li>
<li>字符操作：<code>Reader</code> 和 <code>Writer</code></li>
<li>对象操作：<code>Serializable</code></li>
<li>网络操作：<code>Socket</code></li>
<li>新的输入/输出：<code>NIO</code></li>
</ul>
<h2 id="流分类"><a href="#流分类" class="headerlink" title="流分类"></a>流分类</h2><p>按照方向：<strong>一切以程序为中心</strong></p>
<ul>
<li><p>输入流： 数据源到程序（InputStream、Reader 读进来）</p>
</li>
<li><p>输出流：  程序到目的地（OutputStream、 Writer 写出去）</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581908492985.png" class width="1581908492985"></li>
</ul>
<p>按照功能划分：</p>
<ul>
<li><strong>节点流</strong>： 可以直接从数据源或者目的地读写数据===&gt; 直接操作数据源</li>
</ul>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581908122130.png" alt="1581908122130" style="zoom:80%;">

<ul>
<li><p>处理流(包装流)： 不是直接连接到数据源火目的地，是其他流进行封装。目的主要是简化操作和提高性能。</p>
<p>装饰者设计模式。</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581908288856.png" class width="1581908288856"></li>
</ul>
<p><strong>关系</strong>：节点流是在IO的第一线，所有操作必须同节点流。处理流是对节点流的性能进行提升。</p>
<p>通常很少使用单个流对象，而是将一系列的流以包装的形式链接起来处理数据。</p>
<p>包装可以在不改变被包装流的前提下，获得更强的流处理功能 。</p>
<p>按照数据分类：</p>
<ul>
<li><p>字节流： 按照字节读取数据（<code>InputStream</code> 、 <code>OutputStream</code>)</p>
</li>
<li><p>字符流： 按照字符读取数据（<code>Reader</code>、 <code>Writer</code>）</p>
<p>编码的不同，从而有了对字符进行高效操作的字符流对象。</p>
<p>原理： 底层还是基于字节流，自动搜索了指定的码表（UTF-8、GBK、Unicode等）</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581909883561.png" class width="1581909883561">

<p>典型的字符输入流/输出流的链接如下：</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581910065259.png" class width="1581910065259">

<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581910081342.png" class width="1581910081342">

<hr>
</li>
</ul>
<h1 id="二、-磁盘操作File"><a href="#二、-磁盘操作File" class="headerlink" title="二、 磁盘操作File"></a>二、 磁盘操作File</h1><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。 File代表的是一个抽象的表示形式，用于连接java程序与磁盘的桥梁，java只能跟OS交流。</p>
<h2 id="File类的构造方法"><a href="#File类的构造方法" class="headerlink" title="File类的构造方法"></a>File类的构造方法</h2><ul>
<li><ul>
<li><table>
<thead>
<tr>
<th><code>File(File parent, String child)</code>  从父抽象路径名和子路径名字符串创建新的 <code>File</code>实例。</th>
</tr>
</thead>
<tbody><tr>
<td><code>File(String pathname)</code>  通过将给定的路径名字符串转换为抽象路径名来创建新的 <code>File</code>实例。</td>
</tr>
<tr>
<td><code>File(String parent,  String child)</code>  从父路径名字符串和子路径名字符串创建新的 <code>File</code>实例。</td>
</tr>
<tr>
<td><code>File(URI uri)</code>  通过将给定的 <code>file:</code> URI转换为抽象路径名来创建新的 <code>File</code>实例。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 11:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">&quot;F:/java/base/io/io.png&quot;</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        System.out.println(file.length());</span><br><span class="line"></span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">&quot;F:/java/base/io&quot;</span>, <span class="string">&quot;io.png&quot;</span>);</span><br><span class="line">        System.out.println(file1.length());</span><br><span class="line"></span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="keyword">new</span> File(<span class="string">&quot;F:/java/base&quot;</span>), <span class="string">&quot;/io/io.png&quot;</span>);</span><br><span class="line">        System.out.println(file1.length());</span><br><span class="line"></span><br><span class="line">        System.out.println(file.getAbsoluteFile()); <span class="comment">// 绝对路径</span></span><br><span class="line">        <span class="comment">// 相对路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;user.dir&quot;</span>));  <span class="comment">// F:\java\base</span></span><br><span class="line">        <span class="comment">// 构建不存在的文件</span></span><br><span class="line">        File src = <span class="keyword">new</span> File(<span class="string">&quot;kkk/ooo.png&quot;</span>);</span><br><span class="line">        System.out.println(src); <span class="comment">// kkk\ooo.png</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>416160<br>416160<br>416160<br>F:\java\base\io\io.png<br>F:\java\base<br>kkk\ooo.png</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>从 Java7 开始，可以使用 Paths 和 Files 代替 File。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path p = Paths.get(<span class="string">&quot;F:/java/base&quot;</span>,<span class="string">&quot;io/io.png&quot;</span>);</span><br><span class="line">System.out.println(p); <span class="comment">// F:\java\base\io\io.png</span></span><br></pre></td></tr></table></figure>

<h2 id="查看文件的基本信息"><a href="#查看文件的基本信息" class="headerlink" title="查看文件的基本信息"></a>查看文件的基本信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 12:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String path = <span class="string">&quot;F:/java/base/io/io.png&quot;</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        System.out.println(<span class="string">&quot;名称：&quot;</span> + file.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;路径: &quot;</span>+ file.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;绝对路径: &quot;</span>+ file.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;父路径：&quot;</span> + file.getParent());</span><br><span class="line">        System.out.println(file.getParentFile().getName()); <span class="comment">// 父对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>名称：io.png<br>路径: F:\java\base\io\io.png<br>绝对路径: F:\java\base\io\io.png<br>父路径：F:\java\base\io<br>io</p>
</blockquote>
<h2 id="查看文件的状态"><a href="#查看文件的状态" class="headerlink" title="查看文件的状态"></a>查看文件的状态</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件的状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 12:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File src  = <span class="keyword">new</span> File(<span class="string">&quot;io/io.png&quot;</span>);</span><br><span class="line">        System.out.println(src.length()); <span class="comment">// 字节数 文件的长度</span></span><br><span class="line">        System.out.println(src.getPath());</span><br><span class="line">        System.out.println(src.getAbsoluteFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在： &quot;</span>+ src.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否是文件： &quot;</span>+ src.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否是文件夹： &quot;</span>+ src.isDirectory());</span><br><span class="line">        <span class="comment">// 文件状态</span></span><br><span class="line">        src = <span class="keyword">new</span> File(<span class="string">&quot;kkk.jpg&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!src.exists())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(src.isFile())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件操作&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件夹操作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>416160<br>io\io.png<br>F:\java\base\io\io.png<br>是否存在： true<br>是否是文件： true<br>是否是文件夹： false<br>文件不存在</p>
</blockquote>
<h2 id="操作文件夹"><a href="#操作文件夹" class="headerlink" title="操作文件夹"></a>操作文件夹</h2><ul>
<li><ul>
<li><table>
<thead>
<tr>
<th><code>boolean</code></th>
<th><code>mkdir()</code>  创建由此抽象路径名命名的目录。</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>mkdirs()</code>  创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件夹</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 12:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建目录 mkdir() : 确保上级目录存在，不然创建失败</span></span><br><span class="line">        File file =  <span class="keyword">new</span> File(<span class="string">&quot;./io/dir/test&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> flag = file.mkdir();</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">        flag = file.mkdirs();  <span class="comment">// 推荐</span></span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>false<br>true</p>
</blockquote>
<p>list文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件夹</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 12:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;./io&quot;</span>);</span><br><span class="line">        <span class="comment">// 下级名称</span></span><br><span class="line">        String[] subNames = dir.list(); <span class="comment">// 下面一层的文件名</span></span><br><span class="line">        <span class="keyword">for</span>(String name: subNames)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 下级对象</span></span><br><span class="line">        File[] subFiles = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File s: subFiles)&#123;</span><br><span class="line">            System.out.println(s.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  所有盘符：</span></span><br><span class="line">        File[] roots = dir.listRoots();</span><br><span class="line">        <span class="keyword">for</span>(File f : roots)&#123;</span><br><span class="line">            System.out.println(f.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>dir<br>io.iml<br>io.png</p>
<p>src</p>
<p>dir<br>io.iml<br>io.png</p>
<p>src</p>
<p>C:<br>D:<br>F:<br>H:\</p>
</blockquote>
<p>递归列出一个目录下的所有文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAllFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="keyword">null</span> || !dir.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dir.isFile()) &#123;</span><br><span class="line">        System.out.println(dir.getName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">        listAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算文件夹的大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 计算一个文件夹的大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 13:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">countFiles</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;./io&quot;</span>);</span><br><span class="line">        count(file);</span><br><span class="line">        System.out.println(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(File src)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(src == <span class="keyword">null</span> || !src.exists())&#123; <span class="comment">//文件不存在</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(src.isFile())&#123;</span><br><span class="line">            <span class="comment">// 是一个文件，计算大小</span></span><br><span class="line">            length += src.length();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不是文件</span></span><br><span class="line">            <span class="keyword">for</span>(File f : src.listFiles())&#123;</span><br><span class="line">                count(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>421864</p>
</blockquote>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581916190639.png" class width="1581916190639">

<p>进阶一下：使用面向对象的思维对文件夹进行统计大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用面向对象的思维对文件夹进行统计大小。  封装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 13:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> length; <span class="comment">// 文件的长度</span></span><br><span class="line">    <span class="comment">// 源文件</span></span><br><span class="line">    <span class="keyword">private</span> File src;</span><br><span class="line">    <span class="keyword">private</span> String path; <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirCount</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        src = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">this</span>.count(src);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(File src)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(src == <span class="keyword">null</span> || !src.exists())&#123; <span class="comment">//文件不存在</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(src.isFile())&#123;</span><br><span class="line">            <span class="comment">// 是一个文件，计算大小</span></span><br><span class="line">            length += src.length();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不是文件</span></span><br><span class="line">            <span class="keyword">for</span>(File f : src.listFiles())&#123;</span><br><span class="line">                count(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DirCount dir = <span class="keyword">new</span> DirCount(<span class="string">&quot;./io&quot;</span>);</span><br><span class="line">        System.out.println(dir.getLength());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>422905</p>
</blockquote>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581916719181.png" class width="1581916719181">

<hr>
<h1 id="三、-字符编码"><a href="#三、-字符编码" class="headerlink" title="三、 字符编码"></a>三、 字符编码</h1><blockquote>
<p>计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。</p>
</blockquote>
<p><strong>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</strong> </p>
<p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。 </p>
<ul>
<li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li>
<li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li>
<li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li>
</ul>
<p>UTF-16be 中的 be 指的是 <code>Big Endian</code>，也就是大端。相应地也有 UTF-16le，le 指的是 <code>Little Endian</code>，也就是小端。</p>
<p>Java 的内存编码使用双字节编码 <code>UTF-16be</code>，这不是指 Java 只支持这一种编码方式，而是说 <code>char</code> 这种类型使用 <code>UTF-16be</code> 进行编码。<code>char</code> 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 <code>char</code> 来存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编码： 字符串 ---&gt; 字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 15:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentEncode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;性命生命使命&quot;</span>;  <span class="comment">// 这里使用的是UTF-8编码，中文占3个字节</span></span><br><span class="line">        <span class="comment">// 编码： 字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] datas = msg.getBytes(); <span class="comment">// 使用工程默认的字符集</span></span><br><span class="line">        System.out.println(datas.length); <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         编码其他字符集</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datas = msg.getBytes(<span class="string">&quot;UTF-16LE&quot;</span>); <span class="comment">// 每个用2个字节</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(datas.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解码</span></span><br><span class="line">        msg = <span class="keyword">new</span> String(datas, <span class="number">0</span>, datas.length, <span class="string">&quot;UTF-16LE&quot;</span>);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 乱码问题</span></span><br><span class="line">        <span class="comment">// 1. 字节数不够</span></span><br><span class="line">        msg = <span class="keyword">new</span> String(datas,<span class="number">0</span>, datas.length - <span class="number">1</span>, <span class="string">&quot;UTF-16LE&quot;</span>);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 字符集不统一</span></span><br><span class="line">        msg = <span class="keyword">new</span> String(datas,<span class="number">0</span>, datas.length , <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>18<br>12<br>性命生命使命<br>性命生命使�<br>‘`}Tu}TO}T</p>
</blockquote>
<hr>
<h2 id="String的编码方式"><a href="#String的编码方式" class="headerlink" title="String的编码方式"></a>String的编码方式</h2><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;中文&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在调用无参数 <code>getBytes()</code> 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 <code>char</code> 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。<code>getBytes()</code> 的默认编码方式与平台有关，一般为 UTF-8。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes();</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="四、-四大抽象类"><a href="#四、-四大抽象类" class="headerlink" title="四、 四大抽象类"></a>四、 四大抽象类</h1><table>
<thead>
<tr>
<th>抽象基类</th>
<th><strong>字节流</strong></th>
<th><strong>字符流</strong></th>
<th>常用方法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>输入流</strong></td>
<td><strong>InputStream</strong>   字节输入流</td>
<td><strong>Reader</strong>  字符输入流</td>
<td>int read()、void close()</td>
</tr>
<tr>
<td><strong>输出流</strong></td>
<td><strong>OutputStream</strong>   字节输出流</td>
<td><strong>Writer</strong>  字符输出流</td>
<td>void write(int)、void flush()、 void close（）</td>
</tr>
</tbody></table>
<ol>
<li><p>Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。</p>
</li>
<li><p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</p>
</li>
</ol>
<h2 id="标准步骤"><a href="#标准步骤" class="headerlink" title="标准步骤"></a>标准步骤</h2><p>想象成搬家的程序：</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581926173859.png" class width="1581926173859">

<p>①. 创建源    ②. 选择流    ③. 操作(读、写)    ④. 释放资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *标准步骤：</span></span><br><span class="line"><span class="comment"> * ①. 创建源</span></span><br><span class="line"><span class="comment"> * ②. 选择流</span></span><br><span class="line"><span class="comment"> * ③. 操作(读、写)</span></span><br><span class="line"><span class="comment"> * ④. 释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 16:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         <span class="comment">//①. 创建源</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;F:\\java\\base\\io\\a.txt&quot;</span>);</span><br><span class="line">         <span class="comment">//②. 选择流</span></span><br><span class="line">        InputStream in = <span class="keyword">null</span>; <span class="comment">// 作用域提前</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">//③. 操作(读、写)</span></span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="keyword">while</span> ((temp = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 文件末尾返回-1</span></span><br><span class="line">            <span class="comment">// ④. 释放资源</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != in)  <span class="comment">// 避免空指针异常，需要加上判断</span></span><br><span class="line">                    in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>H<br>e<br>l<br>l<br>o</p>
<p>W<br>o<br>r<br>l<br>d<br>!</p>
</blockquote>
<h2 id="文件字节输入流FileInputStream"><a href="#文件字节输入流FileInputStream" class="headerlink" title="文件字节输入流FileInputStream"></a>文件字节输入流FileInputStream</h2><p>选择流就相当于选择搬家公司，read()方法就是一个字节一个字节地读取，就相当于一件物品的去搬， 而read(bytr[] a) 相当于用卡车来搬！更加快速。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *标准步骤：</span></span><br><span class="line"><span class="comment"> * ①. 创建源</span></span><br><span class="line"><span class="comment"> * ②. 选择流</span></span><br><span class="line"><span class="comment"> * ③. 操作(读、写)</span></span><br><span class="line"><span class="comment"> * ④. 释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 16:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         <span class="comment">//①. 创建源</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;F:\\java\\base\\io\\a.txt&quot;</span>);</span><br><span class="line">         <span class="comment">//②. 选择流</span></span><br><span class="line">        InputStream in = <span class="keyword">null</span>; <span class="comment">// 作用域提前</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">//③. 操作(读、写)</span></span><br><span class="line">            <span class="keyword">byte</span>[] flush = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; <span class="comment">// 缓冲容器</span></span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>; <span class="comment">// 接受长度</span></span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(flush)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//字节数组 --&gt; 字符串 （解码）</span></span><br><span class="line">                String str = <span class="keyword">new</span> String(car, <span class="number">0</span>, len);</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 文件末尾返回-1</span></span><br><span class="line">            <span class="comment">// ④. 释放资源</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != in)  <span class="comment">// 避免空指针异常，需要加上判断</span></span><br><span class="line">                    in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Hello World! zhu hong liang</p>
</blockquote>
<h2 id="文件字节流输出流FileOutputStream"><a href="#文件字节流输出流FileOutputStream" class="headerlink" title="文件字节流输出流FileOutputStream"></a>文件字节流输出流FileOutputStream</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 文件字节输出流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 16:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTes02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create resource</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;./io/dext.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//choose Stream</span></span><br><span class="line">        FileOutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            os = <span class="keyword">new</span> FileOutputStream(file, <span class="keyword">true</span>); <span class="comment">// 追加标志</span></span><br><span class="line">            String msg = <span class="string">&quot;Hello , welcome to BeiJing !&quot;</span>;</span><br><span class="line">            <span class="comment">// buffer array</span></span><br><span class="line">            <span class="keyword">byte</span>[] buff = msg.getBytes();</span><br><span class="line">            <span class="comment">// write</span></span><br><span class="line">            os.write(buff,<span class="number">0</span>, buff.length);</span><br><span class="line">            <span class="comment">// flush</span></span><br><span class="line">            os.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581929276665.png" class width="1581929276665">

<h2 id="实现文件拷贝"><a href="#实现文件拷贝" class="headerlink" title="实现文件拷贝"></a>实现文件拷贝</h2><img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581929414683.png" class width="1581929414683">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现文件拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 16:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File src = <span class="keyword">new</span> File(<span class="string">&quot;./io/io.png&quot;</span>);</span><br><span class="line">        FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">            os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./io/io_cpoy.png&quot;</span>); <span class="comment">// 写出的文件</span></span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> cnt;</span><br><span class="line">            <span class="keyword">while</span> ((cnt = in.read(buff, <span class="number">0</span>, buff.length)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buff, <span class="number">0</span>, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123; <span class="comment">// 关闭资源  先打开的后关闭</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(os != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(in != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="思考：进阶–-gt-实现文件夹的拷贝"><a href="#思考：进阶–-gt-实现文件夹的拷贝" class="headerlink" title="思考：进阶–&gt; 实现文件夹的拷贝"></a>思考：进阶–&gt; 实现文件夹的拷贝</h2><h2 id="Reader-与-Writer"><a href="#Reader-与-Writer" class="headerlink" title="Reader 与 Writer"></a>Reader 与 Writer</h2><p>不管是磁盘还是网络传输，最小的存储单元都是<strong>字节</strong>，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p>
<ul>
<li>InputStreamReader 实现从字节流解码成字符流；</li>
<li>OutputStreamWriter 实现字符流编码成为字节流。</li>
</ul>
<p>实现逐行输出文本文件的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFileContent</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    FileReader fileReader = <span class="keyword">new</span> FileReader(filePath);</span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span></span><br><span class="line">    <span class="comment">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法</span></span><br><span class="line">    <span class="comment">// 因此只要一个 close() 调用即可</span></span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ByteArrayInputStream-amp-ByteArrayOuputStream"><a href="#ByteArrayInputStream-amp-ByteArrayOuputStream" class="headerlink" title="ByteArrayInputStream &amp;  ByteArrayOuputStream"></a>ByteArrayInputStream &amp;  ByteArrayOuputStream</h2><p>上面的FileInputStream中源都是一个文件，文件是存储在磁盘中的，Java程序无法直接访问到，需要通过OS来连接，这里的字节数组流ByteArrayInputStream 的源是内存中的一个字节数组，JVM是可以直接访问的，与操作系统无关了，并且字节数组流不需要close资源，因为JVM有GC来管理，会由JVM来释放，不需要自己手动关闭。</p>
<p>字符串、一切数据，所有的都可以转换成字节数组，方便网络的传输，在底层使用的较多。</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581937779174.png" class width="1581937779174">

<p>ByteArrayInputStream中的构造函数:</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581937843825.png" class width="1581937843825">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节数组输入流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020年2月17日19:12:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         <span class="comment">//①. 创建源</span></span><br><span class="line">        <span class="keyword">byte</span>[] src = <span class="string">&quot;talk is cheap show me the code&quot;</span>.getBytes();</span><br><span class="line">         <span class="comment">//②. 选择流</span></span><br><span class="line">        InputStream in = <span class="keyword">null</span>; <span class="comment">// 作用域提前</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> ByteArrayInputStream(src);</span><br><span class="line">            <span class="comment">//③. 操作(读、写)</span></span><br><span class="line">            <span class="keyword">byte</span>[] flush = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>]; <span class="comment">// 缓冲容器 每三个字符读一次</span></span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>; <span class="comment">// 接受长度</span></span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(flush)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//字节数组 --&gt; 字符串 （解码）</span></span><br><span class="line">                String str = <span class="keyword">new</span> String(flush, <span class="number">0</span>, len);</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 文件末尾返回-1</span></span><br><span class="line">            <span class="comment">// ④. 释放资源</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != in)  <span class="comment">// 可以不用关闭</span></span><br><span class="line">                    in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ByteArrayOutputStream</code>该类实现了将数据写入字节数组的输出流。当数据写入缓冲区时，缓冲区会自动增长。数据可以使用<code>toByteArray()</code>和<code>toString()</code> 。不需要在构造方法中传入目的数组。</p>
<p>关闭<code>ByteArrayOutputStream</code>没有任何效果。  该流中的方法可以在流关闭后调用，而不生成<code>IOException</code> 。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 字节数组输出流`ByteArrayOutputStream`</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 16:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTes04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create resource</span></span><br><span class="line">        <span class="keyword">byte</span>[] dest = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//choose Stream 要使用新增方法，不能使用多态</span></span><br><span class="line">        ByteArrayOutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            os = <span class="keyword">new</span> ByteArrayOutputStream(); <span class="comment">// 不需要传入目的地</span></span><br><span class="line">            String msg = <span class="string">&quot;Hello , welcome to BeiJing !&quot;</span>;</span><br><span class="line">            <span class="comment">// buffer array</span></span><br><span class="line">            <span class="keyword">byte</span>[] buff = msg.getBytes();</span><br><span class="line">            <span class="comment">// write</span></span><br><span class="line">            os.write(buff,<span class="number">0</span>, buff.length);</span><br><span class="line">            <span class="comment">// flush</span></span><br><span class="line">            os.flush();</span><br><span class="line">            dest = os.toByteArray(); <span class="comment">// 获取数据</span></span><br><span class="line">            System.out.println(dest.length+<span class="string">&quot;===&gt;&quot;</span>+<span class="keyword">new</span> String(dest,<span class="number">0</span>, os.size()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="综合-对接流"><a href="#综合-对接流" class="headerlink" title="综合-对接流"></a>综合-对接流</h2><p>例：将一张图片读取到一个字节数组中，先使用文件输入流，通过程序做一个中转，程序再写出到字节数组中。然后字节数组通过字节数组输入流到程序中，再使用文件输出流将字节数组写回到文件中（图片）。</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581941301174.png" class width="1581941301174">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 字节数组输出流`ByteArrayOutputStream`</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 16:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">picTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 图片转换成字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] datas = FileToByteArray(<span class="string">&quot;./io/io.png&quot;</span>);</span><br><span class="line">        System.out.println(datas.length);</span><br><span class="line">        ByteArrayToFile(datas, <span class="string">&quot;./io/ppp_img.png&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  图片到字节数组中</span></span><br><span class="line"><span class="comment">     *  1. 图片到程序： FileInputStream</span></span><br><span class="line"><span class="comment">     *  2. 程序到数组： ByteArrayOutputStream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] FileToByteArray(String filepath)&#123;</span><br><span class="line">        <span class="comment">//①. 创建源  目的地</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(filepath);</span><br><span class="line">        <span class="keyword">byte</span>[] dext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//②. 选择流</span></span><br><span class="line">        InputStream in = <span class="keyword">null</span>; <span class="comment">// 作用域提前</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">//③. 操作</span></span><br><span class="line">            <span class="keyword">byte</span>[] flush = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; <span class="comment">// 缓冲容器</span></span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>; <span class="comment">// 接受长度</span></span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(flush)) != -<span class="number">1</span>)&#123;</span><br><span class="line">              bos.write(flush, <span class="number">0</span>, len); <span class="comment">//写出到字节数组</span></span><br><span class="line">            &#125;</span><br><span class="line">            bos.flush();</span><br><span class="line">            <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> != in)  <span class="comment">// 避免空指针异常，需要加上判断</span></span><br><span class="line">                    in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *字节数组写出到图片</span></span><br><span class="line"><span class="comment">     * 1. 字节数组读取到程序中 : ByteArrayOutputStream</span></span><br><span class="line"><span class="comment">     * 2. 程序写出到文件: FileOutputStream</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ByteArrayToFile</span><span class="params">(<span class="keyword">byte</span>[] datas, String filePath)</span></span>&#123;</span><br><span class="line">        <span class="comment">//①. 创建源</span></span><br><span class="line">        File dest = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="comment">//②. 选择流(增加方法) 不能使用多态</span></span><br><span class="line">        InputStream in = <span class="keyword">null</span>; <span class="comment">// 作用域提前</span></span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> ByteArrayInputStream(datas);</span><br><span class="line">            os = <span class="keyword">new</span> FileOutputStream(dest);</span><br><span class="line">            <span class="comment">//③. 操作(读、写)</span></span><br><span class="line">            <span class="keyword">byte</span>[] flush = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">10</span>]; <span class="comment">// 缓冲容器</span></span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>; <span class="comment">// 接受长度</span></span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(flush)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//字节数组 --&gt; 文件</span></span><br><span class="line">                os.write(flush, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            os.flush(); <span class="comment">//刷新</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != os)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="封装成工具类"><a href="#封装成工具类" class="headerlink" title="封装成工具类"></a>封装成工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 21:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 文件 到文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;./io/a.txt&quot;</span>);</span><br><span class="line">            OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./io/a_copy.txt&quot;</span>);</span><br><span class="line">            copy(is, os);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件到字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] datas = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;./io/io.png&quot;</span>);</span><br><span class="line">            ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            copy(is, os);</span><br><span class="line">            datas = os.toByteArray();</span><br><span class="line">            System.out.println(datas.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字节数组到文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream is = <span class="keyword">new</span> ByteArrayInputStream(datas);</span><br><span class="line">            OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./io/io_copyppppp.png&quot;</span>);</span><br><span class="line">            copy(is, os);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 对接输入输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> os 输出流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(InputStream in, OutputStream os)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">int</span> cnt;</span><br><span class="line">            <span class="keyword">while</span> ((cnt = in.read(buff, <span class="number">0</span>, buff.length)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buff, <span class="number">0</span>, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ios</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Closeable... ios)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Closeable io: ios)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(io != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    io.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="装饰者设计模式"><a href="#装饰者设计模式" class="headerlink" title="装饰者设计模式"></a>装饰者设计模式</h2><p>Java I/O 使用了装饰者模式来实现。以 <code>InputStream</code> 为例，</p>
<ul>
<li>InputStream 是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li>
</ul>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581949697054.png" class width="1581949697054">

<p>实例化一个具有缓存功能的字节流对象时，只需要在 <code>FileInputStream</code> 对象上再套一层 <code>BufferedInputStream</code> 对象即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br></pre></td></tr></table></figure>

<p><code>DataInputStream</code> 装饰者提供了对更多数据类型进行输入的操作，比如 <code>int</code>、<code>double</code> 等基本类型。 </p>
<p>装饰者模式有四个对象：</p>
<blockquote>
<p>1、抽象组件： 需要装饰的抽象对象（接口或者抽象父类）</p>
<p>2、 具体组件： 需要装饰的对象（如上例的Person类）</p>
<p>3、 抽象装饰类： 包含了对抽象组件的引用以及装饰者共有的方法（写到构造器里面）</p>
<p>4、 具体装饰类： 被装饰的对象</p>
</blockquote>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581953544852.png" class width="1581953544852">

<blockquote>
<p>装饰者与被装饰者拥有共同的超类，继承的目的是继承类型，而不是行为</p>
</blockquote>
<h3 id="模拟对人的声音放大"><a href="#模拟对人的声音放大" class="headerlink" title="模拟对人的声音放大"></a>模拟对人的声音放大</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 装饰者模式： 实现放大器对声音的放大功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 22:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecorateTest01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="number">10</span>);</span><br><span class="line">        p.say();</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        Amplifier am = <span class="keyword">new</span> Amplifier(p);</span><br><span class="line">        am.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Say</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Say</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vioce = <span class="number">10</span>; <span class="comment">// 10 db</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> vioce)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vioce = vioce;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVioce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vioce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人的声音为：&quot;</span>+ <span class="keyword">this</span>.getVioce());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Amplifier</span> <span class="keyword">implements</span> <span class="title">Say</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person p;</span><br><span class="line">    Amplifier(Person p)&#123;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人的声音为：&quot;</span>+ p.getVioce() * <span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;噪音.........&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>人的声音为：10<br>人的声音为：1000<br>噪音………</p>
</blockquote>
<h3 id="模拟咖啡"><a href="#模拟咖啡" class="headerlink" title="模拟咖啡"></a>模拟咖啡</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 装饰者模式： 模拟咖啡你</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 1、抽象组件： 需要装饰的抽象对象（接口或者抽象父类）</span></span><br><span class="line"><span class="comment"> * 2、 具体组件： 需要装饰的对象（如上例的Person类）</span></span><br><span class="line"><span class="comment"> * 3、 抽象装饰类： 包含了对抽象组件的引用以及装饰者共有的方法（写到构造器里面）</span></span><br><span class="line"><span class="comment"> * 4、 具体装饰类： 被装饰的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-17 22:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecorateTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Drink coffe = <span class="keyword">new</span> Coffe();</span><br><span class="line">        System.out.println(coffe.info() +<span class="string">&quot; ===&gt;&quot;</span>+ coffe.cost());</span><br><span class="line">        Drink suger = <span class="keyword">new</span> Sugar(coffe); <span class="comment">// 装饰  加糖</span></span><br><span class="line">        System.out.println(suger.info() +<span class="string">&quot; ===&gt;&quot;</span>+ suger.cost());</span><br><span class="line">        Drink milk = <span class="keyword">new</span> Milk(coffe); <span class="comment">//装饰 ， 加牛奶</span></span><br><span class="line">        System.out.println(milk.info() +<span class="string">&quot; ===&gt;&quot;</span>+ milk.cost());</span><br><span class="line">        <span class="comment">// 还可以混合： 既加糖也加牛奶</span></span><br><span class="line">        suger = <span class="keyword">new</span> Sugar(milk);</span><br><span class="line">        System.out.println(suger.info() +<span class="string">&quot; ===&gt;&quot;</span>+ suger.cost()); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 饮料接口 -===&gt; 抽象组件</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Drink</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>; <span class="comment">// 费用</span></span><br><span class="line">    <span class="function">String <span class="title">info</span><span class="params">()</span></span>; <span class="comment">// 说明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffe</span> <span class="keyword">implements</span> <span class="title">Drink</span></span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;原味咖啡&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象装饰类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Drink</span></span>&#123;</span><br><span class="line">    <span class="comment">//包含了对抽象组件的引用（写到构造器里面）</span></span><br><span class="line">    Drink drink;</span><br><span class="line">    Decorator(Drink drink)&#123;</span><br><span class="line">        <span class="keyword">this</span>.drink = drink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以及装饰者共有的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.drink.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.drink.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体装饰类： 被装饰的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    Milk(Drink drink) &#123;</span><br><span class="line">        <span class="keyword">super</span>(drink);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.drink.cost() * <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.drink.info() + <span class="string">&quot;加了牛奶&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体装饰类： 被装饰的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line">    Sugar(Drink drink) &#123;</span><br><span class="line">        <span class="keyword">super</span>(drink);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.drink.cost() * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.drink.info() + <span class="string">&quot;加了蔗糖&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>原味咖啡  = &gt;10.0<br>原味咖啡加了蔗糖 =&gt;20.0<br>原味咖啡加了牛奶 =&gt;40.0<br>原味咖啡加了牛奶加了蔗糖 ===&gt;80.0</p>
</blockquote>
<hr>
<h1 id="五、-IO-缓冲流"><a href="#五、-IO-缓冲流" class="headerlink" title="五、 IO-缓冲流"></a>五、 IO-缓冲流</h1><h2 id="缓冲字节流BufferedInputStream-、BufferedOutputStream"><a href="#缓冲字节流BufferedInputStream-、BufferedOutputStream" class="headerlink" title="缓冲字节流BufferedInputStream 、BufferedOutputStream"></a>缓冲字节流BufferedInputStream 、BufferedOutputStream</h2><img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1581995603824.png" alt="1581995603824" style="zoom:80%;">

<p>缓冲流可以提高性能，一开始的是字节流的read()方法，可以比喻成蚂蚁搬家，一个字节一个字节地读取，使用read(byte[] buff), 自己维护了一个字节数组，相当于叫了一个搬家公司用卡车搬；而这里的缓冲流是在内部维护了一个缓冲区，默认 8k，将字节流打包，放入缓冲流中，相当于使用了一个更大的卡车。可以提高性能，避免频繁去读写。</p>
<p>这里的缓冲流成为处理流，任何一个处理流，不管怎么嵌套，最底层都是一个节点流，没有节点流就没有处理流。</p>
<p>随着流越来越多，释放资源可以直接释放处理流，处理流内部会自动释放节点流。如果需要手动释放，释放的原则是：从里到外，一依次释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File src = <span class="keyword">new</span> File(<span class="string">&quot;./io/io.png&quot;</span>);</span><br><span class="line">        <span class="comment">// try... with...resource</span></span><br><span class="line">        <span class="keyword">try</span>(InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src)); OutputStream os = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./io/io_copy.png&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">int</span> cnt;</span><br><span class="line">            <span class="keyword">while</span> ((cnt = in.read(buff, <span class="number">0</span>, buff.length)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buff, <span class="number">0</span>, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符缓冲流BufferedReader、BufferedWriter"><a href="#字符缓冲流BufferedReader、BufferedWriter" class="headerlink" title="字符缓冲流BufferedReader、BufferedWriter"></a>字符缓冲流BufferedReader、BufferedWriter</h2><p>这两个流有许多新增方法，注意不要使用多态。</p>
<p><code>BufferedReader中的String readLine()</code>   读一行文字。 </p>
<p><code>BufferedWriter中的void</code>  <code>newLine()</code>  写一行行分隔符。</p>
<p>使用缓冲流实现纯文本的拷贝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 利用BufferedReader和BufferWriter实现纯文本拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-18 13:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTxt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File src = <span class="keyword">new</span> File(<span class="string">&quot;./io/dext.txt&quot;</span>);</span><br><span class="line">        File dest = <span class="keyword">new</span> File(<span class="string">&quot;./io/copy_dext.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(src)); BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(dest)))&#123;</span><br><span class="line">            String line = <span class="keyword">null</span>; <span class="comment">// 逐行读取</span></span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                bw.write(line);</span><br><span class="line">                bw.newLine();</span><br><span class="line">                bw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="转换流-InputStreamReader、OutputStreamWriter"><a href="#转换流-InputStreamReader、OutputStreamWriter" class="headerlink" title="转换流-InputStreamReader、OutputStreamWriter"></a>转换流-InputStreamReader、OutputStreamWriter</h2><p>1.将字节流转换成字符流。字节流可以处理一切内容，文本、图片、音频、视频。所以在很多框架和系统中底层返回的是一个字节流。但是里面是纯文本的时候，就需要进行转换。</p>
<p>如<code>System.in</code> 和 <code>System.out</code>都是属于字节流。</p>
<p>2.在底层中，如果是一个纯文本的话，涉及到一个字符集，将字节转换成字符叫做解码，如果工程中的字符集或者系统的字符集与源的字符集不一致的话，就会出现乱码问题。这时候我们需要自己<strong>指定字符集</strong>。</p>
<h3 id="InputStreamReader解码"><a href="#InputStreamReader解码" class="headerlink" title="InputStreamReader解码"></a>InputStreamReader解码</h3><img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1582006048234.png" alt="1582006048234" style="zoom:80%;">

<p><code>String  getEncoding()</code> : 返回此流使用的字符编码的名称。</p>
<h3 id="OutputStreamWriter编码"><a href="#OutputStreamWriter编码" class="headerlink" title="OutputStreamWriter编码"></a>OutputStreamWriter编码</h3><p><code>OutputStreamWriter</code>是字符流到字节流的桥梁：使用指定的字符编码<a href="../../java/nio/charset/Charset.html"><code>charset</code></a>将指定的字符编码成字节 。  它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集。 </p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1582006804461.png" alt="1582006804461" style="zoom:80%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 转换流：InputStreamReader  OutputStreamWrit</span></span><br><span class="line"><span class="comment"> * 功能： </span></span><br><span class="line"><span class="comment"> * 1. 以字符流的形式操作字节流 （纯文本） 本例</span></span><br><span class="line"><span class="comment"> * 2. 指定字符集</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-18 14:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 操作System.in  System.out</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将字节流转换成字符流 ,字符流一般用缓冲流包起来</span></span><br><span class="line">        <span class="keyword">try</span>(BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)) ; <span class="comment">// System.in 属于字节流</span></span><br><span class="line">        BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out)))&#123;</span><br><span class="line">            <span class="comment">// 循环读取键盘输入， 输出  exit退出</span></span><br><span class="line">            String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (!(msg = reader.readLine()).equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">                writer.write(msg);</span><br><span class="line">                writer.newLine();</span><br><span class="line">                writer.flush();  <span class="comment">//强制刷新，因为缓冲流内部数组比较大，字符会驻留在管道中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;操作异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1582007638508.png" alt="1582007638508" style="zoom:80%;">

<h1 id="六、-其他流（数据流、对象流、打印流）"><a href="#六、-其他流（数据流、对象流、打印流）" class="headerlink" title="六、 其他流（数据流、对象流、打印流）"></a>六、 其他流（数据流、对象流、打印流）</h1><h2 id="1-数据流"><a href="#1-数据流" class="headerlink" title="1. 数据流"></a>1. 数据流</h2><p>方便我们处理基本数据类型和字符串，不但保留了数据，还保存了数据类型。</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1582008278001.png" alt="1582008278001" style="zoom:80%;">

<h3 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h3><p>构造方法：  DataInputStream(InputStream in）</p>
<p>方法：</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1582008609861.png" alt="1582008609861" style="zoom:80%;">



<h3 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h3><p>用法与DataInputStream相似</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * s数据流</span></span><br><span class="line"><span class="comment"> * 1. 写出后读取</span></span><br><span class="line"><span class="comment"> * 2. 读取顺序与写出顺序要一致</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-18 14:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 写出</span></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(baos)); <span class="comment">// 加上缓冲流，提升性能</span></span><br><span class="line">        <span class="comment">// 操作数据类型</span></span><br><span class="line">        dos.writeUTF(<span class="string">&quot;良辰美景奈何天&quot;</span>);  <span class="comment">// 24个字节</span></span><br><span class="line">        dos.writeInt(<span class="number">19</span>);</span><br><span class="line">        dos.writeChar(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        dos.writeBoolean(<span class="keyword">false</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">        <span class="comment">//  读取</span></span><br><span class="line">        <span class="keyword">byte</span>[] datas = baos.toByteArray();</span><br><span class="line">        System.out.println(datas.length); <span class="comment">// 30</span></span><br><span class="line">        <span class="comment">// 加上缓冲流，提升性能</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> ByteArrayInputStream(datas)));</span><br><span class="line">        <span class="comment">// 读取顺序与写出顺序一致</span></span><br><span class="line">        String msg = dis.readUTF();</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串的大小： &quot;</span>+msg.getBytes().length); <span class="comment">// 这里变为21</span></span><br><span class="line">        <span class="keyword">int</span> a = dis.readInt();  <span class="comment">// 4个字节</span></span><br><span class="line">        <span class="keyword">char</span> c = dis.readChar(); <span class="comment">// 2个字节</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = dis.readBoolean(); <span class="comment">// 1个字节</span></span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>30<br>字符串的大小： 21<br>良辰美景奈何天<br>false</p>
</blockquote>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="2-打印流"><a href="#2-打印流" class="headerlink" title="2. 打印流"></a>2. 打印流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印流  PrintStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-18 19:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        PrintStream ps = System.out;</span><br><span class="line">        ps.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        ps.println(<span class="keyword">true</span>);</span><br><span class="line">        ps.flush();</span><br><span class="line">        ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./io/print.txt&quot;</span>,<span class="keyword">true</span>)), <span class="keyword">true</span>);</span><br><span class="line">        ps.println(<span class="string">&quot;这是打印流&quot;</span>);</span><br><span class="line">        ps.println(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 重定向输出端</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(<span class="string">&quot;我已经变了，不是输出到控制台了！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重回控制台</span></span><br><span class="line">        System.setOut(<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(FileDescriptor.out)), <span class="keyword">true</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;我回来啦！！！！&quot;</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Hello<br>true<br>我回来啦！！！！</p>
</blockquote>
<p>还有<code>PrintWriter</code>。</p>
<hr>
<h1 id="七、-对象操作"><a href="#七、-对象操作" class="headerlink" title="七、 对象操作"></a>七、 对象操作</h1><h2 id="1-序列化"><a href="#1-序列化" class="headerlink" title="1. 序列化"></a>1. 序列化</h2><h4 id="对象流-ObjectInputStream-amp-ObjectOutputStream"><a href="#对象流-ObjectInputStream-amp-ObjectOutputStream" class="headerlink" title="对象流 ObjectInputStream &amp; ObjectOutputStream"></a>对象流 ObjectInputStream &amp; ObjectOutputStream</h4><img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1582022257497.png" alt="1582022257497" style="zoom:80%;">

<p>不是所有的对象都是可以序列化。序列化就是将一个对象转换成字节序列，方便存储和传输。 </p>
<ul>
<li>序列化：<code>ObjectOutputStream.writeObject()</code></li>
<li>反序列化：<code>ObjectInputStream.readObject()</code></li>
</ul>
<p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象流</span></span><br><span class="line"><span class="comment"> * 1. 写出后读取</span></span><br><span class="line"><span class="comment"> * 2. 读取的顺序与写出保持一致</span></span><br><span class="line"><span class="comment"> * 3. 不是所有的对象都可以序列化 Serializable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-18 18:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 写出</span></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> BufferedOutputStream(baos)); <span class="comment">// 加上缓冲流，提升性能</span></span><br><span class="line">        <span class="comment">// 操作数据类型</span></span><br><span class="line">        oos.writeUTF(<span class="string">&quot;良辰美景奈何天&quot;</span>);  <span class="comment">// 24个字节</span></span><br><span class="line">        oos.writeInt(<span class="number">18</span>);</span><br><span class="line">        oos.writeChar(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        oos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 对象</span></span><br><span class="line">        oos.writeObject(<span class="string">&quot;花谢花飞花满天&quot;</span>);</span><br><span class="line">        Employee e = <span class="keyword">new</span> Employee(<span class="string">&quot;马云&quot;</span>, <span class="number">5000.0</span>);</span><br><span class="line">        oos.writeObject(e); <span class="comment">// 序列化</span></span><br><span class="line">        oos.flush();</span><br><span class="line">        <span class="comment">//  读取</span></span><br><span class="line">        <span class="keyword">byte</span>[] datas = baos.toByteArray();</span><br><span class="line">        System.out.println(datas.length); <span class="comment">// 30</span></span><br><span class="line">        <span class="comment">// 加上缓冲流，提升性能</span></span><br><span class="line">        ObjectInputStream dis = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> ByteArrayInputStream(datas)));</span><br><span class="line">        <span class="comment">// 读取顺序与写出顺序一致</span></span><br><span class="line">        String msg = dis.readUTF();</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串的大小： &quot;</span>+msg.getBytes().length); <span class="comment">// 这里变为21</span></span><br><span class="line">        <span class="keyword">int</span> a = dis.readInt();  <span class="comment">// 4个字节</span></span><br><span class="line">        <span class="keyword">char</span> c = dis.readChar(); <span class="comment">// 2个字节</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = dis.readBoolean(); <span class="comment">// 1个字节</span></span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">        Object str = dis.readObject();</span><br><span class="line">        Object employee = dis.readObject();  <span class="comment">//反序列化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( str <span class="keyword">instanceof</span>  String)&#123;</span><br><span class="line">            String ss = (String)str;</span><br><span class="line">            System.out.println(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(employee <span class="keyword">instanceof</span>  Employee)&#123;</span><br><span class="line">            Employee eee = (Employee)employee;</span><br><span class="line">            System.out.println(eee.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name +<span class="string">&quot;===&gt;&quot;</span>+ <span class="keyword">this</span>.money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-Serializable"><a href="#2-Serializable" class="headerlink" title="2. Serializable"></a>2. Serializable</h2><p>序列化的类需要实现 <code>Serializable</code> 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。 </p>
<h2 id="3-transient"><a href="#3-transient" class="headerlink" title="3. transient"></a>3. transient</h2><p><code>transient</code> 关键字可以使一些属性不会被序列化。</p>
<p><code>ArrayList</code> 中存储数据的数组 <code>elementData</code> 是用 <code>transient</code> 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="八、-commons-io组件"><a href="#八、-commons-io组件" class="headerlink" title="八、 commons-io组件"></a>八、 commons-io组件</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p> <a href="http://commons.apache.org/proper/commons-io/download_io.cgi">http://commons.apache.org/proper/commons-io/download_io.cgi</a> </p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>环境准备：<br>1.在idea中导入以下两个jar包</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1582035347762.png" alt="1582035347762" style="zoom:80%;">

<p>2.打开idea的project struct：</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1582035398847.png" alt="1582035398847" style="zoom:80%;">

<p>3,进入Dependencies</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1582035489216.png" alt="1582035489216" style="zoom:80%;">

<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1582035540089.png" alt="1582035540089" style="zoom:80%;">





<h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.DirectoryFileFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.EmptyFileFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.FileFilterUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.filefilter.SuffixFileFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-18 21:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CIO_test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 文件大小</span></span><br><span class="line">        <span class="keyword">long</span> len = FileUtils.sizeOf(<span class="keyword">new</span> File(<span class="string">&quot;./io/io.png&quot;</span>));</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        <span class="comment">//目录大小</span></span><br><span class="line">        len  = FileUtils.sizeOfDirectory(<span class="keyword">new</span> File(<span class="string">&quot;./io&quot;</span>));</span><br><span class="line">        System.out.println(len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列出当前目录下的文件</span></span><br><span class="line">        Collection&lt;File&gt; files = FileUtils.listFiles(<span class="keyword">new</span> File(<span class="string">&quot;./io&quot;</span>), EmptyFileFilter.NOT_EMPTY, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (File file: files)&#123;</span><br><span class="line">            System.out.println(file.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 列出当前目录下的件文</span></span><br><span class="line">        files = FileUtils.listFiles(<span class="keyword">new</span> File(<span class="string">&quot;./io&quot;</span>), EmptyFileFilter.NOT_EMPTY, DirectoryFileFilter.INSTANCE);</span><br><span class="line">        <span class="keyword">for</span> (File file: files)&#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">        files = FileUtils.listFiles(<span class="keyword">new</span> File(<span class="string">&quot;./io&quot;</span>),</span><br><span class="line">                FileFilterUtils.or(<span class="keyword">new</span> SuffixFileFilter(<span class="string">&quot;java&quot;</span>), <span class="keyword">new</span> SuffixFileFilter(<span class="string">&quot;txt&quot;</span>)), DirectoryFileFilter.INSTANCE);  <span class="comment">// 文件过滤</span></span><br><span class="line">        <span class="keyword">for</span> (File file: files)&#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>416160<br>1696597<br>a.txt<br>a_copy.txt<br>copy_dext.txt<br>dext.txt<br>io.iml<br>io.png<br>io_copy.png<br>io_copyppppp.png<br>ppp_img.png</p>
<p>print.txt</p>
<p>F:\java\base.\io\a.txt<br>F:\java\base.\io\a_copy.txt<br>F:\java\base.\io\copy_dext.txt<br>F:\java\base.\io\dext.txt<br>F:\java\base.\io\io.iml<br>F:\java\base.\io\io.png<br>F:\java\base.\io\io_copy.png<br>F:\java\base.\io\io_copyppppp.png<br>F:\java\base.\io\ppp_img.png<br>F:\java\base.\io\print.txt<br>F:\java\base.\io\src\CIOTest.java<br>F:\java\base.\io\src\CIO_test.java<br>F:\java\base.\io\src\ContentEncode.java<br>F:\java\base.\io\src\ConvertTest.java<br>F:\java\base.\io\src\CopyFile.java<br>F:\java\base.\io\src\CopyTxt.java<br>F:\java\base.\io\src\countFiles.java<br>F:\java\base.\io\src\DataTest.java<br>F:\java\base.\io\src\DecorateTest01.java<br>F:\java\base.\io\src\DecorateTest02.java<br>F:\java\base.\io\src\Demo1.java<br>F:\java\base.\io\src\DirCount.java<br>F:\java\base.\io\src\DirDemo1.java<br>F:\java\base.\io\src\FileDemo01.java<br>F:\java\base.\io\src\FileDemo02.java<br>F:\java\base.\io\src\FileUtils.java<br>F:\java\base.\io\src\IOTes02.java<br>F:\java\base.\io\src\IOTes04.java<br>F:\java\base.\io\src\IOTest01.java<br>F:\java\base.\io\src\IOTest03.java<br>F:\java\base.\io\src\listAllFiles.java<br>F:\java\base.\io\src\ObjectTest.java<br>F:\java\base.\io\src\Path.java<br>F:\java\base.\io\src\picTest.java</p>
<p>F:\java\base.\io\src\PrintTest.java</p>
<p>F:\java\base.\io\a.txt<br>F:\java\base.\io\a_copy.txt<br>F:\java\base.\io\copy_dext.txt<br>F:\java\base.\io\dext.txt<br>F:\java\base.\io\print.txt<br>F:\java\base.\io\src\CIOTest.java<br>F:\java\base.\io\src\CIO_test.java<br>F:\java\base.\io\src\ContentEncode.java<br>F:\java\base.\io\src\ConvertTest.java<br>F:\java\base.\io\src\CopyFile.java<br>F:\java\base.\io\src\CopyTxt.java<br>F:\java\base.\io\src\countFiles.java<br>F:\java\base.\io\src\DataTest.java<br>F:\java\base.\io\src\DecorateTest01.java<br>F:\java\base.\io\src\DecorateTest02.java<br>F:\java\base.\io\src\Demo1.java<br>F:\java\base.\io\src\DirCount.java<br>F:\java\base.\io\src\DirDemo1.java<br>F:\java\base.\io\src\FileDemo01.java<br>F:\java\base.\io\src\FileDemo02.java<br>F:\java\base.\io\src\FileUtils.java<br>F:\java\base.\io\src\IOTes02.java<br>F:\java\base.\io\src\IOTes04.java<br>F:\java\base.\io\src\IOTest01.java<br>F:\java\base.\io\src\IOTest03.java<br>F:\java\base.\io\src\listAllFiles.java<br>F:\java\base.\io\src\ObjectTest.java<br>F:\java\base.\io\src\Path.java<br>F:\java\base.\io\src\picTest.java<br>F:\java\base.\io\src\PrintTest.java</p>
</blockquote>
<h2 id="读取内容"><a href="#读取内容" class="headerlink" title="读取内容"></a>读取内容</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.LineIterator;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * commons-io</span></span><br><span class="line"><span class="comment"> * 读取内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-18 21:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CIOTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 读取文件</span></span><br><span class="line">        String msg = FileUtils.readFileToString(<span class="keyword">new</span> File(<span class="string">&quot;./io/dext.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="keyword">byte</span>[] datas = FileUtils.readFileToByteArray(<span class="keyword">new</span> File(<span class="string">&quot;./io/dext.txt&quot;</span>));</span><br><span class="line">        System.out.println(datas.length);</span><br><span class="line">        <span class="comment">// 逐行读取</span></span><br><span class="line">        List&lt;String&gt; msgs = FileUtils.readLines(<span class="keyword">new</span> File(<span class="string">&quot;./io/dext.txt&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String m: msgs)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LineIterator it = FileUtils.lineIterator(<span class="keyword">new</span> File(<span class="string">&quot;./io/dext.txt&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.nextLine());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="写出内容"><a href="#写出内容" class="headerlink" title="写出内容"></a>写出内容</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写出内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-19 11:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CIOtestWrite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 写出文件</span></span><br><span class="line">        FileUtils.write(<span class="keyword">new</span> File(<span class="string">&quot;./io/happy.txt&quot;</span>), <span class="string">&quot;今天天气真好！\r\n&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        FileUtils.writeStringToFile(<span class="keyword">new</span> File(<span class="string">&quot;./io/happy.txt&quot;</span>), <span class="string">&quot;河山大好，出去走走吧！&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        FileUtils.writeByteArrayToFile(<span class="keyword">new</span> File(<span class="string">&quot;./io/happy.txt&quot;</span>), <span class="string">&quot;河山大好，出去走走吧！&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>),<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出列表</span></span><br><span class="line">        List &lt;String&gt; datas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        datas.add(<span class="string">&quot;马云&quot;</span>);</span><br><span class="line">        datas.add(<span class="string">&quot;马化腾&quot;</span>);</span><br><span class="line">        datas.add(<span class="string">&quot;李嘉诚&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FileUtils.writeLines(<span class="keyword">new</span> File(<span class="string">&quot;./io/happy.txt&quot;</span>), datas, <span class="string">&quot;...&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">今天天气真好！河山大好，出去走走吧！河山大好，出去走走吧！马云...马化腾...李嘉诚...</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-19 11:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CIOCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 复制文件</span></span><br><span class="line">        FileUtils.copyFile(<span class="keyword">new</span> File(<span class="string">&quot;./io/io.png&quot;</span>), <span class="keyword">new</span> File(<span class="string">&quot;./io/cio.png&quot;</span>));</span><br><span class="line">        <span class="comment">// 拷贝文件到目录</span></span><br><span class="line">        FileUtils.copyFileToDirectory(<span class="keyword">new</span> File(<span class="string">&quot;./io/io.png&quot;</span>), <span class="keyword">new</span> File(<span class="string">&quot;./io/test&quot;</span>));</span><br><span class="line">        <span class="comment">// copy URL</span></span><br><span class="line">        String url = <span class="string">&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1582094003889&amp;di=8d3bc6164079cb45c6ba073ff143b591&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.bbra.cn%2FUploadFiles%2Fimgs%2F2015%2F11%2F02%2Fmm3%2F005.jpg&quot;</span>;</span><br><span class="line">        FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url), <span class="keyword">new</span> File(<span class="string">&quot;./io/girl.jpg&quot;</span>)); <span class="comment">// 可以下载一张图片</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="九、-NIO"><a href="#九、-NIO" class="headerlink" title="九、 NIO"></a>九、 NIO</h1><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。 </p>
<h2 id="1-流与块"><a href="#1-流与块" class="headerlink" title="1. 流与块"></a>1. 流与块</h2><p>​        I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以<strong>块的方式</strong>处理数据。</p>
<p>​        面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>​        面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>​        I/O 包和 NIO 已经很好地集成了，<code>java.io.*</code> 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，<code>java.io.*</code> 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>
<h2 id="2-通道与缓冲区"><a href="#2-通道与缓冲区" class="headerlink" title="2. 通道与缓冲区"></a>2. 通道与缓冲区</h2><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 <code>InputStream</code> 或者 <code>OutputStream</code> 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p>通道包括以下类型：</p>
<ul>
<li><code>FileChannel</code>：从文件中读写数据；</li>
<li><code>DatagramChannel</code>：通过 UDP 读写网络中数据；</li>
<li><code>SocketChannel</code>：通过 TCP 读写网络中数据；</li>
<li><code>ServerSocketChannel</code>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 <code>SocketChannel</code>。</li>
</ul>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<p>缓冲区包括以下类型：</p>
<ul>
<li><code>ByteBuffer</code></li>
<li><code>CharBuffer</code></li>
<li><code>ShortBuffer</code></li>
<li><code>IntBuffer</code></li>
<li><code>LongBuffer</code></li>
<li><code>FloatBuffer</code></li>
<li><code>DoubleBuffer</code></li>
</ul>
<h2 id="2-缓冲区状态变量"><a href="#2-缓冲区状态变量" class="headerlink" title="2. 缓冲区状态变量"></a>2. 缓冲区状态变量</h2><ul>
<li>capacity：最大容量；</li>
<li>position：当前已经读写的字节数；</li>
<li>limit：还可以读写的字节数。</li>
</ul>
<p>状态变量的改变过程举例： </p>
<p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。 </p>
 <img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1bea398f-17a7-4f67-a90b-9e2d243eaa9a.png" alt="img" style="zoom:100%;">

<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。 </p>
 <img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/80804f52-8815-4096-b506-48eef3eed5c6.png" alt="img" style="zoom:100%;">

<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。 </p>
 <img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/952e06bd-5a65-4cab-82e4-dd1536462f38.png" alt="img" style="zoom:100%;">

<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。 </p>
 <img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/b5bdcbe2-b958-4aef-9151-6ad963cb28b4.png" alt="img" style="zoom:100%;">

<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置 </p>
 <img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/67bf5487-c45d-49b6-b9c0-a058d8c68902.png" alt="img" style="zoom:100%;">

<h2 id="3-文件NIO实例"><a href="#3-文件NIO实例" class="headerlink" title="3. 文件NIO实例"></a>3. 文件NIO实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fastCopy</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得源文件的输入字节流 */</span></span><br><span class="line">    FileInputStream fin = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输入字节流的文件通道 */</span></span><br><span class="line">    FileChannel fcin = fin.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取目标文件的输出字节流 */</span></span><br><span class="line">    FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(dist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输出字节流的文件通道 */</span></span><br><span class="line">    FileChannel fcout = fout.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为缓冲区分配 1024 个字节 */</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从输入通道中读取数据到缓冲区中 */</span></span><br><span class="line">        <span class="keyword">int</span> r = fcin.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read() 返回 -1 表示 EOF */</span></span><br><span class="line">        <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 切换读写 */</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把缓冲区的内容写入输出文件中 */</span></span><br><span class="line">        fcout.write(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-选择器"><a href="#4-选择器" class="headerlink" title="4. 选择器"></a>4. 选择器</h2><p>​        NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>​        NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>​        通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>​        因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p>
<p>​        应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p>
<img src="/2020/02/17/Java%E4%B9%8BIO%E6%B5%81/1582088336265.png" alt="1582088336265" style="zoom:80%;">

<h3 id="创建选择器"><a href="#创建选择器" class="headerlink" title="创建选择器"></a>创建选择器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>

<h3 id="将通道注册到选择器上"><a href="#将通道注册到选择器上" class="headerlink" title="将通道注册到选择器上"></a>将通道注册到选择器上</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<p>​            通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>​            在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li><code>SelectionKey.OP_CONNECT</code></li>
<li><code>SelectionKey.OP_ACCEPT</code></li>
<li><code>SelectionKey.OP_READ</code></li>
<li><code>SelectionKey.OP_WRITE</code></li>
</ul>
<p>它们在 <code>SelectionKey</code> 的定义如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<h3 id="监听事情"><a href="#监听事情" class="headerlink" title="监听事情"></a>监听事情</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br></pre></td></tr></table></figure>

<p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。 </p>
<h3 id="获取到达的事件"><a href="#获取到达的事件" class="headerlink" title="获取到达的事件"></a>获取到达的事件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>​        因为一次 <code>select()</code> 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-套接字NIO实例"><a href="#5-套接字NIO实例" class="headerlink" title="5. 套接字NIO实例"></a>5. 套接字NIO实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = ssChannel.socket();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> n = sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) buffer.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        String s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-内存映射文件"><a href="#6-内存映射文件" class="headerlink" title="6. 内存映射文件"></a>6. 内存映射文件</h2><p>​        内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>​        向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p>​        下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<h2 id="7-对比"><a href="#7-对比" class="headerlink" title="7. 对比"></a>7. 对比</h2><p>NIO 与普通 I/O 的区别主要有以下两点：</p>
<ul>
<li>NIO 是非阻塞的；</li>
<li>NIO 面向块，I/O 面向流。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li> <a href="https://cyc2018.github.io/CS-Notes">https://cyc2018.github.io/CS-Notes</a> </li>
<li> <a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a> </li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的各种锁机制</title>
    <url>/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Java中的各种锁机制"><a href="#Java中的各种锁机制" class="headerlink" title="Java中的各种锁机制"></a>Java中的各种锁机制</h1><p>图片来自于美团技术团队<a href="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png">java主流锁</a></p>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/7f749fc8.png" class title="img">



<h1 id="一、公平锁和非公平锁"><a href="#一、公平锁和非公平锁" class="headerlink" title="一、公平锁和非公平锁"></a>一、公平锁和非公平锁</h1><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>​    是指多个线程按照申请<strong>锁的顺序</strong>来获取锁，类似排队打饭，先来后到</p>
<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>​    是指在多线程获取锁的顺序并不是按照申请锁的顺序, 有可能后申请的线程比先申请的线程优先获取到锁, 在高并发的情况下, 有可能造成优先级反转或者饥饿现象。</p>
<h2 id="公平锁-非公平锁区别"><a href="#公平锁-非公平锁区别" class="headerlink" title="公平锁/非公平锁区别"></a>公平锁/非公平锁区别</h2><p>  并发包ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁 （默认是非公平锁）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>公平锁：</strong> Thread acquire a fair lock in the order in which they requested it</p>
<p>公平锁就是很公平，在并发环境下，每个线程获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程时等待队列的第一个，就占有锁，否则就会被加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。</p>
<p><strong>非公平锁：</strong> 非公平锁比较粗鲁， 上来就直接尝试占有锁，如果尝试失败，就在采用类似公平锁那种方式。</p>
<p>ReentrantLock而言，通过构造函数指定该锁是否是公平锁。默认是非公平锁，非公平锁的优点在于吞吐量比公平锁大。</p>
<p>对于synchronized而言 也是一种非公平锁。</p>
<p>下面是ReentrantLock的公平锁和非公平锁源码</p>
<p>公平锁加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  <span class="comment">// 判断线程是不是同步队列中的第一个</span></span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非公平锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p>
<p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p>
<h1 id="二、可重入锁"><a href="#二、可重入锁" class="headerlink" title="二、可重入锁"></a>二、可重入锁</h1><p>也称为递归锁。指的是同一线程外层函数获得锁之后，内层的方法仍然可以获得该锁的代码。在同一个线程的外层方法获取锁的时候，在进入内层方法会自动获取锁。也就是说，线程可以进入任何一个它已经拥有锁的同步代码。</p>
<p>其最大的作用就是可以避免死锁。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>接下来证明<code>synchronized</code>是可重入锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t invoke sendMsg&quot;</span>);</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t $$$$$$$$$$$$$$$  invoke sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendMsg();</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendMsg();</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>11     invoke sendMsg<br>11     $$$$$$$$$$$$$$$  invoke sendEmail<br>12     invoke sendMsg<br>12     $$$$$$$$$$$$$$$  invoke sendEmail</p>
</blockquote>
<p>可以看到getID()返回的是同一个线程。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>下面再看看ReentrantLock是不是也是可重入的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot;\t invoke get()&quot;</span>);</span><br><span class="line">            set();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot;\t invoke set()&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">       </span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(phone, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(phone, <span class="string">&quot;t4&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>t3     invoke get()<br>t3     invoke set()<br>t4     invoke get()<br>t4     invoke set()</p>
</blockquote>
<h2 id="Synchronized与ReentrantLock的区别"><a href="#Synchronized与ReentrantLock的区别" class="headerlink" title="Synchronized与ReentrantLock的区别"></a>Synchronized与ReentrantLock的区别</h2><ol>
<li><p>原始构成： Synchronized是关键字，属于JVM层面的。monitorenter和monitorexit指令完成。</p>
<p>monitorenter 底层是通过monitor对象来完成的，其实wait/notify等方法也是依赖monitor对象  只有在同步块或者方法中才能调用wait/notify等方法。</p>
<p>而ReentrantLock是具体类，是api层面的锁。</p>
</li>
<li><p>使用方法：</p>
<p>Synchronized 不需要手动释放锁，当Synchronized代码执行完后系统会自动让线程释放对锁的占用。</p>
<p>ReentrantLock则需要用户手动释放，如果没有手动释放，就有可能导致死锁现象。lock和unlock方法配合try/finally语句块来完成。</p>
</li>
<li><p>等待是否可以中断</p>
<p>Synchronized 不可中断，除非抛出异常或正常运行完成。</p>
<p>ReentrantLock是可以中断的。1. 通过设置超时方法  trylock(long timeout, TimeUint unit)   2. lockInterruptibly()  放入代码块中，调用interrupt可中断。</p>
</li>
<li><p>加锁是否公平</p>
<p>Synchronized是非公平锁</p>
<p>ReentrantLock两者都可以，默认是非公平锁，构造方法可以传入boolean值，true为公平锁，false为非公平锁</p>
</li>
<li><p>锁绑定多个条件</p>
<p>Synchronized没有，只能随机唤醒一个或者全部唤醒</p>
<p>ReentrantLock可以实现精确唤醒</p>
</li>
</ol>
<h1 id="三、自旋锁spinlock"><a href="#三、自旋锁spinlock" class="headerlink" title="三、自旋锁spinlock"></a>三、自旋锁spinlock</h1><p>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p>
<p>自旋锁的好处： 循环比较直到获取成功为止，没有类似的wait的阻塞</p>
<h2 id="实现一个自旋锁"><a href="#实现一个自旋锁" class="headerlink" title="实现一个自旋锁"></a>实现一个自旋锁</h2><p>通过CAS操作完成自旋锁，A线程先进来调用mylock方法自己持有锁5秒钟，B随后进来后发现当有线程持有锁，不是null， 所以只能自旋等待，直到A释放锁后B随后抢到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-23-17:32</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现一个自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mylock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread(); <span class="comment">//当前进来的线程</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 进来了...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!atomicReference.compareAndSet(<span class="keyword">null</span>, thread))&#123;</span><br><span class="line">            <span class="comment">// spin</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread(); <span class="comment">//当前进来的线程</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLock lock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 获取锁</span></span><br><span class="line">            lock.mylock();</span><br><span class="line">            <span class="comment">// 休眠</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.mylock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mylock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。</p>
<h2 id="自旋锁存在的问题"><a href="#自旋锁存在的问题" class="headerlink" title="自旋锁存在的问题"></a>自旋锁存在的问题</h2><ol>
<li>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。</li>
<li>上面Java实现的自旋锁不是公平的，即<strong>无法满足等待时间最长的线程优先获取锁</strong>。不公平的锁就会存在“<strong>线程饥饿</strong>”问题。</li>
</ol>
<h2 id="自旋锁的优点"><a href="#自旋锁的优点" class="headerlink" title="自旋锁的优点"></a>自旋锁的优点</h2><ol>
<li>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</li>
<li>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</li>
</ol>
<h2 id="可重入的自旋锁和不可重入的自旋锁"><a href="#可重入的自旋锁和不可重入的自旋锁" class="headerlink" title="可重入的自旋锁和不可重入的自旋锁"></a>可重入的自旋锁和不可重入的自旋锁</h2><p>我们再来看一下我们实现的自旋锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mylock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread(); <span class="comment">//当前进来的线程</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 进来了...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!atomicReference.compareAndSet(<span class="keyword">null</span>, thread))&#123;</span><br><span class="line">            <span class="comment">// spin</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread(); <span class="comment">//当前进来的线程</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现我们上面的自旋锁不支持可重入，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新希望获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入<code>while</code>循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。</p>
<p>而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-25-15:55</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可重入的自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantSpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Thread&gt; threadAtomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"><span class="comment">//    private int count; // 计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span>(threadAtomicReference.get() == thread)&#123;</span><br><span class="line">            <span class="comment">// 如果当前线程已经获取到了该锁，计数器加1 ，然后直接返回</span></span><br><span class="line"><span class="comment">//            count.incrementAndGet();</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 已经获取了该锁,目前count值为&quot;</span>+ count.getAndIncrement()+<span class="string">&quot;，计数器为&quot;</span>+ count.get());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有获取，则通过CAS自旋</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 开始获取锁，进来了...&quot;</span>+count.get());</span><br><span class="line">        <span class="keyword">while</span> (!threadAtomicReference.compareAndSet(<span class="keyword">null</span>, thread))&#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span>(threadAtomicReference.get() == thread)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count.get() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//                count.decrementAndGet(); // 如果当前线程获取了锁，则通过count--来模拟释放一次锁</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot; count为&quot;</span>+ count.getAndDecrement()+<span class="string">&quot;，继续释放...&quot;</span>+ count.get());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 释放了全部锁...&quot;</span> + count.get());</span><br><span class="line">                <span class="comment">// count == 0 ， 可以将锁释放， 保证获取锁的次数与释放锁的次数一致</span></span><br><span class="line">                threadAtomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantSpinLock spinLock = <span class="keyword">new</span> ReentrantSpinLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                spinLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    spinLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                spinLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLock.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>AAA 开始获取锁，进来了…0<br>AAA 已经获取了该锁,目前count值为0，计数器为1<br>BBB 开始获取锁，进来了…1<br>AAA count为1，继续释放…0<br>AAA 释放了全部锁…0<br>BBB 释放了全部锁…0</p>
</blockquote>
<p>这样可以重入</p>
<h2 id="自旋锁的变种：TicketLock"><a href="#自旋锁的变种：TicketLock" class="headerlink" title="自旋锁的变种：TicketLock"></a>自旋锁的变种：TicketLock</h2><p><strong>TicketLock主要解决的是公平性的问题。</strong></p>
<p>思路：每当有线程获取锁的时候，就给该线程分配一个递增的id，我们称之为排队号，同时，锁对应一个服务号，每当有线程释放锁，服务号就会递增，此时如果服务号与某个线程排队号一致，那么该线程就获得锁，由于排队号是递增的，所以就保证了最先请求获取锁的线程可以最先获取到锁，就实现了公平性。</p>
<p>可以想象成银行办理业务排队，排队的每一个顾客都代表一个需要请求锁的线程，而银行服务窗口表示锁，每当有窗口服务完成就把自己的服务号加一，此时在排队的所有顾客中，只有自己的排队号与服务号一致的才可以得到服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketLockV2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger serviceNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排队号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger ticketNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增一个ThreadLocal，用于存储每个线程的排队号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; ticketNumHolder = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentTicketNum = ticketNum.incrementAndGet();</span><br><span class="line">        <span class="comment">// 获取锁的时候，将当前线程的排队号保存起来</span></span><br><span class="line">        ticketNumHolder.set(currentTicketNum);</span><br><span class="line">        <span class="keyword">while</span> (currentTicketNum != serviceNum.get()) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放锁，从ThreadLocal中获取当前线程的排队号</span></span><br><span class="line">        Integer currentTickNum = ticketNumHolder.get();</span><br><span class="line">        serviceNum.compareAndSet(currentTickNum, currentTickNum + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实现方式是将每个线程的排队号放到了ThreadLocal中。</p>
<p><strong>TicketLock存在的问题:</strong></p>
<p>多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</p>
<p>下面介绍的CLHLock就是解决这个问题的。</p>
<h2 id="自旋锁的变种CLHLock"><a href="#自旋锁的变种CLHLock" class="headerlink" title="自旋锁的变种CLHLock"></a>自旋锁的变种CLHLock</h2><p>CLH锁是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋，获得锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CLH的发明人是：Craig，Landin and Hagersten。</span></span><br><span class="line"><span class="comment"> * 代码来源：http://ifeve.com/java_lock_see2/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个节点，默认的lock状态为true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾部节点,只用一个节点即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> CLHNode tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;CLHNode&gt; LOCAL = <span class="keyword">new</span> ThreadLocal&lt;CLHNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class,</span><br><span class="line">            <span class="string">&quot;tail&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建节点并将节点与当前线程保存起来</span></span><br><span class="line">        CLHNode node = <span class="keyword">new</span> CLHNode();</span><br><span class="line">        LOCAL.set(node);</span><br><span class="line">        <span class="comment">// 将新建的节点设置为尾部节点，并返回旧的节点（原子操作），这里旧的节点实际上就是当前节点的前驱节点</span></span><br><span class="line">        CLHNode preNode = UPDATER.getAndSet(<span class="keyword">this</span>, node);</span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 前驱节点不为null表示当锁被其他线程占用，通过不断轮询判断前驱节点的锁标志位等待前驱节点释放锁</span></span><br><span class="line">            <span class="keyword">while</span> (preNode.isLocked) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode = <span class="keyword">null</span>;</span><br><span class="line">            LOCAL.set(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不存在前驱节点，表示该锁没有被其他线程占用，则当前线程获得锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程对应的节点</span></span><br><span class="line">        CLHNode node = LOCAL.get();</span><br><span class="line">        <span class="comment">// 如果tail节点等于node，则将tail节点更新为null，同时将node的lock状态职位false，表示当前线程释放了锁</span></span><br><span class="line">        <span class="keyword">if</span> (!UPDATER.compareAndSet(<span class="keyword">this</span>, node, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            node.isLocked = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="四、独占锁（写锁）-共享锁-读锁-互斥锁"><a href="#四、独占锁（写锁）-共享锁-读锁-互斥锁" class="headerlink" title="四、独占锁（写锁）/共享锁(读锁) /互斥锁"></a>四、独占锁（写锁）/共享锁(读锁) /互斥锁</h1><p>独占锁： 指该锁一次只能被一个线程锁持有。ReentrantLock和Synchronized都是独占锁</p>
<p>共享锁： 该锁可以被多个线程锁共享</p>
<p>对ReentrantReadWriteLock其读锁是共享的，写锁是独占的。</p>
<p>读锁的共享锁可以保证并发读是高效的，读写、写写、写读的过程是互斥的。</p>
<p>独享锁与共享锁是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>我们使用读写锁实现一个分布式缓存，要求写时独占，原子的，读操作可以共享。</p>
<p>先来看没有加锁的时候，会发生什么状况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-23-23:05</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 读写锁实践： 手写一个 缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 开始写入&quot;</span> + key);</span><br><span class="line">        <span class="comment">// 模拟网络延迟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 开始读取&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟网络延迟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object value = cache.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span>+ value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">readwriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程操作资源类</span></span><br><span class="line">        MyCache cache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟5个线程写，5个线程读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                cache.put(tmp+<span class="string">&quot;&quot;</span>, tmp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                cache.get(tmp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>1     开始写入1<br>2     开始写入2<br>3     开始写入3<br>4     开始写入4<br>5     开始写入5<br>1     开始读取<br>2     开始读取<br>3     开始读取<br>4     开始读取<br>5     开始读取<br>5     写入完成<br>1     读取完成：null<br>4     写入完成<br>3     写入完成<br>2     写入完成<br>1     写入完成<br>2     读取完成：2<br>3     读取完成：3<br>4     读取完成：4<br>5     读取完成：5</p>
</blockquote>
<p>可以发现，写操作被读操作中断了，而且还读到了一个null值。这是并发问题。</p>
<p>我们要实现写操作是原子的，应该为独占锁，读取操作是各个线程所共享的。可以使用JUC下面的<code>ReentrantReadWriteLock</code>， 称为读写锁。</p>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200823233234155.png" class title="image-20200823233234155">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-23-23:05</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 读写锁实践： 手写一个 缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用写锁</span></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 开始写入&quot;</span> + key);</span><br><span class="line">            <span class="comment">// 模拟网络延迟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 加读锁</span></span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 开始读取&quot;</span>);</span><br><span class="line">            <span class="comment">// 模拟网络延迟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Object value = cache.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span>+ value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">readwriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程操作资源类</span></span><br><span class="line">        MyCache cache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟5个线程写，5个线程读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                cache.put(tmp+<span class="string">&quot;&quot;</span>, tmp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                cache.get(tmp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>1     开始写入1<br>1     写入完成<br>2     开始写入2<br>2     写入完成<br>3     开始写入3<br>3     写入完成<br>4     开始写入4<br>4     写入完成<br>5     开始写入5<br>5     写入完成<br>1     开始读取<br>2     开始读取<br>4     开始读取<br>5     开始读取<br>3     开始读取<br>5     读取完成：5<br>2     读取完成：2<br>4     读取完成：4<br>3     读取完成：3<br>1     读取完成：1</p>
</blockquote>
<p>可以清楚看到，写操作是配对完成的，中间没有打断。读操作是并发的，可以无序。</p>
<h2 id="深入理解ReentrantReadWriteLock"><a href="#深入理解ReentrantReadWriteLock" class="headerlink" title="深入理解ReentrantReadWriteLock"></a>深入理解ReentrantReadWriteLock</h2><p>读写锁</p>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825194659342.png" class title="image-20200825194659342">

<p>读锁</p>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825194945583.png" class title="image-20200825194945583">

<p>写锁</p>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825195030328.png" class title="image-20200825195030328">

<p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p>
<p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p>
<p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825195420880.png" class title="image-20200825195420880">

<p>来看看写锁的加锁源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	Thread current = Thread.currentThread();</span><br><span class="line">	<span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line">	<span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line">	<span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">		<span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">		<span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li>
<li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li>
<li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li>
<li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li>
<li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li>
</ul>
</blockquote>
<p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>
<p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p>
<p>接着是读锁的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p>
</blockquote>
<h1 id="五、乐观锁和悲观锁"><a href="#五、乐观锁和悲观锁" class="headerlink" title="五、乐观锁和悲观锁"></a>五、乐观锁和悲观锁</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>顾名思义，很悲观，每次去拿数据的时候都担心别人回来修改数据，所以会加锁，其他线程需要这个资源的话只能被阻塞。直到释放锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>很乐观，总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号机制</strong>和<strong>CAS</strong>算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<h2 id="两种锁的适用场景"><a href="#两种锁的适用场景" class="headerlink" title="两种锁的适用场景"></a>两种锁的适用场景</h2><p>乐观锁适用于<strong>多读</strong>的场景，可以提高吞吐量。但是<strong>多写</strong>的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
<h2 id="乐观锁的实现方法"><a href="#乐观锁的实现方法" class="headerlink" title="乐观锁的实现方法"></a>乐观锁的实现方法</h2><p>乐观锁一般会使用版本号机制或CAS（Compare-and-Swap，即比较并替换）算法实现。</p>
<h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>般是在数据表中加上一个数据版本号<code>version</code>字段，表示数据被修改的次数，当数据被修改时，<code>version</code>值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的<code>version</code>值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 50（50（100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 20（20（100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>
</ol>
<p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>即 compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时，CAS通过<strong>原子方式</strong>用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
<h2 id="CAS-底层实现原理？"><a href="#CAS-底层实现原理？" class="headerlink" title="CAS 底层实现原理？"></a>CAS 底层实现原理？</h2><p>通过自旋锁+UNSafe类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p><code>UnSafe</code>是CAS的核心类。由于Java 方法无法直接访问底层 ，需要通过本地(native)方法来访问， <code>UnSafe</code>可以直接操作特的内存数据。UnSafe类在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的助兴依赖于UNSafe类的方法。Unsafe它提供了硬件级别的<strong>原子操作</strong>。<strong>注意UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务。</strong></p>
</li>
<li><p>变量<code>ValueOffset</code>，便是该变量在内存中的偏移地址，因为<code>UnSafe</code>就是根据内存偏移地址获取数据的。</p>
</li>
</ol>
<h2 id="AtomicReference原子引用"><a href="#AtomicReference原子引用" class="headerlink" title="AtomicReference原子引用"></a>AtomicReference原子引用</h2><p><code>AtomicReference</code>是作用是对”<strong>对象”</strong>进行原子操作。<br>提供了一种读和写都是原子性的对象引用变量。原子意味着多个线程试图改变同一个<code>AtomicReference</code>(例如比较和交换操作)将不会使得<code>AtomicReference</code>处于不一致的状态。</p>
<p><code>AtomicReference</code>和<code>AtomicInteger</code>非常类似，不同之处就在于<code>AtomicInteger</code>是对整数的封装，底层采用的是<code>compareAndSwapInt</code>实现CAS，比较的是数值是否相等，而<code>AtomicReference</code>则对应普通的对象引用，底层使用的是<code>compareAndSwapObject</code>实现CAS，比较的是两个对象的地址是否相等。也就是它可以保证你在修改对象引用时的线程安全性。</p>
<h2 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h2><h3 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1. ABA 问题"></a>1. ABA 问题</h3><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？</p>
<p>很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p>
<p>JDK 1.5 以后的 <code>AtomicStampedReference 类</code>就提供了此种能力，其中的 <code>compareAndSet 方法</code>就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-25-16:33</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CAS 的 ABA问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===以下是ABA问题的产生===&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//先暂停1秒 保证完成ABA</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===以下是ABA问题的解决===&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第1次版本号&quot;</span> + stamp + <span class="string">&quot;\t值是&quot;</span> + stampedReference.getReference());</span><br><span class="line">            <span class="comment">//暂停1秒钟t3线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第2次版本号&quot;</span> + stampedReference.getStamp() + <span class="string">&quot;\t值是&quot;</span> + stampedReference.getReference());</span><br><span class="line">            stampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第3次版本号&quot;</span> + stampedReference.getStamp() + <span class="string">&quot;\t值是&quot;</span> + stampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第1次版本号&quot;</span> + stamp + <span class="string">&quot;\t值是&quot;</span> + stampedReference.getReference());</span><br><span class="line">            <span class="comment">//保证线程3完成1次ABA</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 修改成功否&quot;</span> + result + <span class="string">&quot;\t最新版本号&quot;</span> + stampedReference.getStamp());</span><br><span class="line">            System.out.println(<span class="string">&quot;最新的值\t&quot;</span> + stampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>===以下是ABA问题的产生===<br>true    2019<br>===以下是ABA问题的解决===<br>t3     第1次版本号1    值是100<br>t4     第1次版本号1    值是100<br>t3     第2次版本号2    值是101<br>t3     第3次版本号3    值是100<br>t4     修改成功否false    最新版本号3<br>最新的值    100</p>
</blockquote>
<h3 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2. 循环时间长开销大"></a>2. 循环时间长开销大</h3><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销</strong>。 </p>
<p>如果JVM能支持处理器提供的<code>pause</code>指令，那么效率会有一定的提升，<code>pause</code>指令有两个作用，第一它可以<strong>延迟流水线执行指令</strong>（<code>de-pipeline</code>），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因<strong>内存顺序冲突</strong>（<code>memory order violation</code>）而引起CPU流水线被清空（<code>CPU pipeline flush</code>），从而提高CPU的执行效率。</p>
<h3 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3. 只能保证一个共享变量的原子操作"></a>3. 只能保证一个共享变量的原子操作</h3><p><strong>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。</strong>但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p>
<h2 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h2><p>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），<code>synchronized</code>适用于写比较多的情况下（多写场景，冲突一般较多）</p>
<ul>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ul>
<blockquote>
<p>补充： Java并发编程这个领域中<code>synchronized</code>关键字一直都是元老级的角色，很久之前很多人都会称它为 “<strong>重量级锁</strong>” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它各种优化之后变得在某些情况下并不是那么重了。<code>synchronized</code>的底层实现主要依靠 <code>Lock-Free</code> 的队列，基本思路是 <strong>自旋后阻塞</strong>，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>
</blockquote>
<h1 id="六、无锁VS偏向锁VS轻量级锁VS重量级锁"><a href="#六、无锁VS偏向锁VS轻量级锁VS重量级锁" class="headerlink" title="六、无锁VS偏向锁VS轻量级锁VS重量级锁"></a>六、无锁VS偏向锁VS轻量级锁VS重量级锁</h1><p>先了解几个概念，对象、对象头、Monitor</p>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/object.jpg" class title="img">

<p><strong>Mark Word</strong>默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p><strong>Monitor：</strong> Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825180516629.png" class title="image-20200825180516629">



<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<p><strong>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</strong></p>
<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“<strong>偏向锁”</strong>和“<strong>轻量级锁</strong>”。</p>
<p>所以目前锁一共有4种状态，级别从低到高依次是：<strong>无锁、偏向锁、轻量级锁和重量级锁</strong>。<strong>锁状态只能升级不能降级。</strong></p>
<p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825180621058.png" class title="image-20200825180621058">

<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p><strong>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价</strong>。</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。<strong>其目标就是在只有一个线程执行同步代码块时能够提高性能。</strong></p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h2><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a><strong>重量级锁</strong></h2><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<h1 id="七、锁膨胀"><a href="#七、锁膨胀" class="headerlink" title="七、锁膨胀"></a>七、锁膨胀</h1><p>锁膨胀的过程：</p>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825182846021.png" class title="image-20200825182846021">

<h2 id="轻量级锁获取锁过程"><a href="#轻量级锁获取锁过程" class="headerlink" title="轻量级锁获取锁过程"></a><strong>轻量级锁获取锁过程</strong></h2><ol>
<li>在线程进入同步方法、同步块的时候，如果<strong>同步对象锁状态为无锁状态(锁标志位为”01”状态，是否为偏向锁为”0”)<strong>，虚拟机首先将在当前线程的栈帧中</strong>建立一个名为锁记录(Lock Recored)的空间</strong>，用于储存锁对象目前的Mark Word的拷贝(官方把这份拷贝加了个Displaced前缀，即Displaced Mark Word)。</li>
</ol>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/1.jpg" class title="img">



<ol>
<li>将对象头的<code>Mark Word</code>拷贝到线程的锁记录(Lock Recored)中。</li>
<li>拷贝成功后，虚拟机将使用<code>CAS</code>操作<strong>尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针</strong>。如果这个更新成功了，则执行步骤<code>4</code>，否则执行步骤<code>5</code>。</li>
<li>更新成功，这个<strong>线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为”00”，即表示此对象处于轻量级锁的状态。</strong>。</li>
</ol>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/2.jpg" class title="img">



<ol start="4">
<li>更新失败，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其其它线程抢占了。<strong>进行自旋执行步骤<code>3</code>，如果自旋结束仍然没有获得锁，轻量级锁就需要膨胀为重量级锁，锁标志位状态值变为”10”，Mark Word中储存就是指向<code>monitor</code>对象的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</strong></li>
</ol>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/3.jpg" class title="img">



<h2 id="轻量级释放锁的过程"><a href="#轻量级释放锁的过程" class="headerlink" title="轻量级释放锁的过程"></a><strong>轻量级释放锁的过程</strong></h2><ol>
<li>使用<code>CAS</code>操作将对象当前的<code>Mark Word</code>和线程中复制的<code>Displaced Mark Word</code>替换回来(依据<code>Mark Word</code>中锁记录指针是否还指向本线程的锁记录)，如果替换成功，则执行步骤<code>2</code>，否则执行步骤<code>3</code>。</li>
<li>如果替换成功，整个同步过程就完成了，恢复到无锁的状态(01)。</li>
<li>如果替换失败，说明有其他线程尝试获取该锁(此时锁已膨胀)，那就要在释放锁的同时，唤醒被挂起的线程。</li>
</ol>
<h2 id="偏向锁获取锁的过程"><a href="#偏向锁获取锁的过程" class="headerlink" title="偏向锁获取锁的过程"></a>偏向锁获取锁的过程</h2><p><strong>获取锁的过程</strong>：</p>
<ol>
<li>检查<code>Mark Word</code>是否为<strong>可偏向锁的状态</strong>，即是否偏向锁即为1即表示支持可偏向锁，否则为0表示不支持可偏向锁。</li>
<li>如果是可偏向锁，则**检查<code>Mark Word</code>储存的线程<code>ID</code>是否为当前线程<code>ID</code>**，如果是则执行同步块，否则执行步骤<code>3</code>。</li>
<li>如果检查到<code>Mark Word</code>的<code>ID</code>不是本线程的<code>ID</code>，则通过<code>CAS</code>操作去修改线程<code>ID</code>修改成本线程的<code>ID</code>，如果修改成功则执行同步代码块，否则执行步骤<code>4</code>。</li>
<li>当拥有该锁的线程到达安全点之后，挂起这个线程，升级为轻量级锁。</li>
</ol>
<h2 id="偏向锁释放锁的过程"><a href="#偏向锁释放锁的过程" class="headerlink" title="偏向锁释放锁的过程"></a>偏向锁释放锁的过程</h2><p><strong>锁释放的过程</strong>：</p>
<ol>
<li>有其他线程来获取这个锁，偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。</li>
<li>等待全局安全点(在这个是时间点上没有字节码正在执行)。</li>
<li>暂停拥有偏向锁的线程，检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置为无锁状态，否则设置为被锁定状态。如果锁对象处于<strong>无锁状态，则恢复到无锁状态(01)<strong>，以允许其他线程竞争，如果</strong>锁对象处于锁定状态</strong>，则挂起持有偏向锁的线程，并将对象头<code>Mark Word</code>的锁记录指针改成当前线程的锁记录，锁**升级为轻量级锁状态(00)**。</li>
</ol>
<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/4.jpg" class title="img">

<h2 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h2><img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/5.jpg" class title="img">






<img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825204734448.png" class title="image-20200825204734448">



<h1 id="八、-AQS"><a href="#八、-AQS" class="headerlink" title="八、 AQS"></a>八、 AQS</h1><h2 id="AQS-介绍"><a href="#AQS-介绍" class="headerlink" title="AQS 介绍"></a>AQS 介绍</h2><p>AQS：<code>AbstractQueneSynchronizer</code>抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。<br>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包</p>
<blockquote>
<p><strong>AQS的核心思想</strong>是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。<br>CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。<br><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</strong></p>
</blockquote>
<p><strong>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</strong></p>
<p><strong>注意：AQS是自旋锁：在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功</strong></p>
<p><strong>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</strong></p>
<h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><img src="/2021/07/23/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825213325244.png" class title="image-20200825213325244">

<p>AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：</p>
<blockquote>
<ol>
<li>getState();</li>
<li>setState();</li>
<li>compareAndSetState();</li>
</ol>
</blockquote>
<p>AQS 定义了两种资源共享方式：</p>
<blockquote>
<p>1.<strong>Exclusive</strong>：独占，只有一个线程能执行，如ReentrantLock<br>2.<strong>Share</strong>：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p>
<p>不同的自定义的同步器争用共享资源的方式也不同。</p>
</blockquote>
<p><strong>AQS底层使用了模板方法模式</strong>： </p>
<p>同步器的设计是基<strong>于模板方法模式</strong>的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li>
<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。<br>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</li>
</ol>
<p>自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现的时候主要实现下面几种方法：</p>
<blockquote>
<ol>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ol>
</blockquote>
<p>以ReentrantLock为例（可重入独占式锁）：state初始化为0，表示未锁定状态，A线程lock()时，会调用tryAcquire()独占锁并将state+1。之后其他线程再想tryAcquire的时候就会失败，直到A线程unlock（）到state=0为止，其他线程才有机会获取该锁。A释放锁之前，自己也是可以重复获取此锁（state累加），这就是可重入的概念。<br><strong>注意：获取多少次锁就要释放多少次锁，保证state是能回到零态的。</strong></p>
<p>以CountDownLatch为例，任务分N个子线程去执行，state就初始化 为N，N个线程并行执行，每个线程执行完之后countDown() 一次，state就会CAS减一。当N子线程全部执行完毕，state=0，会unpark()主调用线程，主调用线程就会从await()函数返回，继续之后的动作。</p>
<p>一般来说，自定义同步器要么是独占方式，要么是共享方式，他们也只需实现tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时<strong>实现独占和共享两种方式，如ReentrantReadWriteLock。</strong><br>在acquire() 、acquireShared()两种方式下，线程在等待队列中都是忽略中断的，<strong>acquireInterruptibly()/acquireSharedInterruptibly()是支持响应中断</strong>的。</p>
<h2 id="AQS的简单应用"><a href="#AQS的简单应用" class="headerlink" title="AQS的简单应用"></a><strong>AQS的简单应用</strong></h2><p>Mutex：不可重入互斥锁，锁资源（state）只有两种状态：0：未被锁定；1：锁定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否锁定状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正同步类的实现都依赖继承于AQS的自定义同步器！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlock&lt;--&gt;release。两者语文一样：释放资源。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁是否占有状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。</p>
<h1 id="九、-参考"><a href="#九、-参考" class="headerlink" title="九、 参考"></a>九、 参考</h1><ol>
<li><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></p>
</li>
<li><p>《深入理解Java虚拟机》</p>
</li>
<li><p>《Java并发编程之美》</p>
</li>
<li><p><a href="https://juejin.im/post/6844903805121740814">深入分析synchronized原理和锁膨胀过程(二)</a></p>
</li>
<li><p><a href="https://blog.csdn.net/mulinsen77/article/details/84583716">https://blog.csdn.net/mulinsen77/article/details/84583716</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java高并发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC学习笔记</title>
    <url>/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="JDBC核心技术"><a href="#JDBC核心技术" class="headerlink" title="JDBC核心技术"></a>JDBC核心技术</h1><p>来自于尚硅谷宋红康老师的笔记</p>
<hr>
<h2 id="第1章：JDBC概述"><a href="#第1章：JDBC概述" class="headerlink" title="第1章：JDBC概述"></a>第1章：JDBC概述</h2><h3 id="1-1-数据的持久化"><a href="#1-1-数据的持久化" class="headerlink" title="1.1 数据的持久化"></a>1.1 数据的持久化</h3><ul>
<li><p>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</p>
</li>
<li><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1566741430592.png" class width="1566741430592"> </li>
</ul>
<h3 id="1-2-Java中的数据存储技术"><a href="#1-2-Java中的数据存储技术" class="headerlink" title="1.2 Java中的数据存储技术"></a>1.2 Java中的数据存储技术</h3><ul>
<li><p>在Java中，数据库存取技术可分为如下几类：</p>
<ul>
<li><p><strong>JDBC</strong>直接访问数据库</p>
</li>
<li><p>JDO (Java Data Object )技术</p>
</li>
<li><p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p>
</li>
</ul>
</li>
<li><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p>
</li>
</ul>
<h3 id="1-3-JDBC介绍"><a href="#1-3-JDBC介绍" class="headerlink" title="1.3 JDBC介绍"></a>1.3 JDBC介绍</h3><ul>
<li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</li>
<li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li>
<li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li>
<li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555575760234.png" class width="1555575760234">

<hr>
<ul>
<li>有了JDBC，Java程序访问数据库时是这样的：</li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555575981203.png" class width="1555575981203">

<hr>
<ul>
<li>总结如下：</li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1566741692804.png" class width="1566741692804">

<h3 id="1-4-JDBC体系结构"><a href="#1-4-JDBC体系结构" class="headerlink" title="1.4 JDBC体系结构"></a>1.4 JDBC体系结构</h3><ul>
<li>JDBC接口（API）包括两个层次：<ul>
<li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li>
<li> <strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p>
<p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                                                ————面向接口编程</strong></p>
</blockquote>
<h3 id="1-5-JDBC程序编写步骤"><a href="#1-5-JDBC程序编写步骤" class="headerlink" title="1.5 JDBC程序编写步骤"></a>1.5 JDBC程序编写步骤</h3><img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1565969323908.png" class width="1565969323908">

<blockquote>
<p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p>
</blockquote>
<h2 id="第2章：获取数据库连接"><a href="#第2章：获取数据库连接" class="headerlink" title="第2章：获取数据库连接"></a>第2章：获取数据库连接</h2><h3 id="2-1-要素一：Driver接口实现类"><a href="#2-1-要素一：Driver接口实现类" class="headerlink" title="2.1 要素一：Driver接口实现类"></a>2.1 要素一：Driver接口实现类</h3><h4 id="2-1-1-Driver接口介绍"><a href="#2-1-1-Driver接口介绍" class="headerlink" title="2.1.1 Driver接口介绍"></a>2.1.1 Driver接口介绍</h4><ul>
<li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p>
</li>
<li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p>
<ul>
<li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li>
<li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li>
</ul>
</li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555576157618.png" class width="1555576157618">

<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555576170074.png" class width="1555576170074">

<ul>
<li>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。</li>
</ul>
 <img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1566134718955.png" class width="1566134718955">

<p>在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path</p>
 <img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1566134781682.png" class width="1566134781682">

<p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p>
 <img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1566135290460.png" class width="1566135290460">

<h4 id="2-1-2-加载与注册JDBC驱动"><a href="#2-1-2-加载与注册JDBC驱动" class="headerlink" title="2.1.2 加载与注册JDBC驱动"></a>2.1.2 加载与注册JDBC驱动</h4><ul>
<li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p>
<ul>
<li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li>
</ul>
</li>
<li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p>
<ul>
<li><p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p>
</li>
<li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类<strong>都</strong>包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1566136831283.png" class width="1566136831283"></li>
</ul>
</li>
</ul>
<h3 id="2-2-要素二：URL"><a href="#2-2-要素二：URL" class="headerlink" title="2.2 要素二：URL"></a>2.2 要素二：URL</h3><ul>
<li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p>
</li>
<li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p>
<ul>
<li><strong>jdbc:子协议:子名称</strong></li>
<li><strong>协议</strong>：JDBC URL中的协议总是jdbc </li>
<li><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</li>
<li><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></li>
</ul>
</li>
<li><p>举例：</p>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555576477107.png" class width="1555576477107"></li>
<li><p><strong>几种常用数据库的 JDBC URL</strong></p>
<ul>
<li><p>MySQL的连接URL编写方式：</p>
<ul>
<li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li>
<li>jdbc:mysql://localhost:3306/atguigu</li>
<li>jdbc:mysql://localhost:3306/atguigu**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li>
<li>jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456</li>
</ul>
</li>
<li><p>Oracle 9i的连接URL编写方式：</p>
<ul>
<li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li>
<li>jdbc:oracle:thin:@localhost:1521:atguigu</li>
</ul>
</li>
<li><p>SQLServer的连接URL编写方式：</p>
<ul>
<li><p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p>
</li>
<li><p>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-要素三：用户名和密码"><a href="#2-3-要素三：用户名和密码" class="headerlink" title="2.3 要素三：用户名和密码"></a>2.3 要素三：用户名和密码</h3><ul>
<li>user,password可以用“属性名=属性值”方式告诉数据库</li>
<li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li>
</ul>
<h3 id="2-4-数据库连接方式举例"><a href="#2-4-数据库连接方式举例" class="headerlink" title="2.4 数据库连接方式举例"></a>2.4 数据库连接方式举例</h3><h4 id="2-4-1-连接方式一"><a href="#2-4-1-连接方式一" class="headerlink" title="2.4.1 连接方式一"></a>2.4.1 连接方式一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">           Driver driver = <span class="keyword">null</span>;</span><br><span class="line">           driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：上述代码中显式出现了第三方数据库的API</p>
</blockquote>
<h4 id="2-4-2-连接方式二"><a href="#2-4-2-连接方式二" class="headerlink" title="2.4.2 连接方式二"></a>2.4.2 连接方式二</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.实例化Driver</span></span><br><span class="line">           String className = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">           Class clazz = Class.forName(className);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">           info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p>
</blockquote>
<h4 id="2-4-3-连接方式三"><a href="#2-4-3-连接方式三" class="headerlink" title="2.4.3 连接方式三"></a>2.4.3 连接方式三</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.实例化Driver</span></span><br><span class="line">           Class clazz = Class.forName(driverName);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           DriverManager.registerDriver(driver);</span><br><span class="line">           <span class="comment">//4.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p>
</blockquote>
<h4 id="2-4-4-连接方式四"><a href="#2-4-4-连接方式四" class="headerlink" title="2.4.4 连接方式四"></a>2.4.4 连接方式四</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           String password = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           String driverName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">           Class.forName(driverName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">           static &#123;</span></span><br><span class="line"><span class="comment">               try &#123;</span></span><br><span class="line"><span class="comment">                   DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">               &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                   throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p>
</blockquote>
<h4 id="2-4-5-连接方式五-最终版"><a href="#2-4-5-连接方式五-最终版" class="headerlink" title="2.4.5 连接方式五(最终版)"></a>2.4.5 连接方式五(最终版)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   	<span class="comment">//1.加载配置文件</span></span><br><span class="line">       InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">       Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">       pros.load(is);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//2.读取配置信息</span></span><br><span class="line">       String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">       String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">       String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">       String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.加载驱动</span></span><br><span class="line">       Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.获取连接</span></span><br><span class="line">       Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">       System.out.println(conn);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p>
<p><strong>使用配置文件的好处：</strong></p>
<p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程。</p>
</blockquote>
<h2 id="第3章：使用PreparedStatement实现CRUD操作"><a href="#第3章：使用PreparedStatement实现CRUD操作" class="headerlink" title="第3章：使用PreparedStatement实现CRUD操作"></a>第3章：使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h3><ul>
<li><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p>
</li>
<li><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p>
<ul>
<li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </li>
<li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li>
<li>CallableStatement：用于执行 SQL 存储过程</li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1566573842140.png" class width="1566573842140"></li>
</ul>
<h3 id="3-2-使用Statement操作数据表的弊端"><a href="#3-2-使用Statement操作数据表的弊端" class="headerlink" title="3.2 使用Statement操作数据表的弊端"></a>3.2 使用Statement操作数据表的弊端</h3><ul>
<li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p>
</li>
<li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> excuteUpdate(String <span class="keyword">sql</span>)：执行更新操作<span class="keyword">INSERT</span>、UPDATE、<span class="keyword">DELETE</span></span><br><span class="line">ResultSet executeQuery(String <span class="keyword">sql</span>)：执行查询操作<span class="keyword">SELECT</span></span><br></pre></td></tr></table></figure></li>
<li><p>但是使用Statement操作数据表存在弊端：</p>
<ul>
<li><strong>问题一：存在拼串操作，繁琐</strong></li>
<li><strong>问题二：存在SQL注入问题</strong></li>
</ul>
</li>
<li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p>
</li>
<li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p>
</li>
<li><p>代码演示：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">		System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">		String userName = scan.nextLine();</span><br><span class="line">		System.out.print(<span class="string">&quot;密   码：&quot;</span>);</span><br><span class="line">		String password = scan.nextLine();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span></span><br><span class="line">		String sql = <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password</span><br><span class="line">				+ <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">		User user = get(sql, User.class);</span><br><span class="line">		<span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">		Statement st = <span class="keyword">null</span>;</span><br><span class="line">		ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 1.加载配置文件</span></span><br><span class="line">			InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">			Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">			pros.load(is);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 2.读取配置信息</span></span><br><span class="line">			String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">			String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">			String url = pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">			String driverClass = pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3.加载驱动</span></span><br><span class="line">			Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 4.获取连接</span></span><br><span class="line">			conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">			st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">			rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取结果集的元数据</span></span><br><span class="line">			ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取结果集的列数</span></span><br><span class="line">			<span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">				t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">					<span class="comment">// //1. 获取列的名称</span></span><br><span class="line">					<span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">// 1. 获取列的别名</span></span><br><span class="line">					String columnName = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line">					Object columnVal = rs.getObject(columnName);</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 3. 将数据表中得到的数据，封装进对象</span></span><br><span class="line">					Field field = clazz.getDeclaredField(columnName);</span><br><span class="line">					field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">					field.set(t, columnVal);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 关闭资源</span></span><br><span class="line">			<span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					rs.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					st.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					conn.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上：</p>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1566569819744.png" class width="1566569819744">

<h3 id="3-3-PreparedStatement的使用"><a href="#3-3-PreparedStatement的使用" class="headerlink" title="3.3 PreparedStatement的使用"></a>3.3 PreparedStatement的使用</h3><h4 id="3-3-1-PreparedStatement介绍"><a href="#3-3-1-PreparedStatement介绍" class="headerlink" title="3.3.1 PreparedStatement介绍"></a>3.3.1 PreparedStatement介绍</h4><ul>
<li><p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p>
</li>
<li><p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p>
</li>
<li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p>
</li>
</ul>
<h4 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h4><ul>
<li><p>代码的可读性和可维护性。</p>
</li>
<li><p><strong>PreparedStatement 能最大可能提高性能：</strong></p>
<ul>
<li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li>
<li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li>
<li>(语法检查，语义检查，翻译成二进制命令，缓存)</li>
</ul>
</li>
<li><p>PreparedStatement 可以防止 SQL 注入 </p>
</li>
</ul>
<h4 id="3-3-3-Java与SQL对应数据类型转换表"><a href="#3-3-3-Java与SQL对应数据类型转换表" class="headerlink" title="3.3.3 Java与SQL对应数据类型转换表"></a>3.3.3 Java与SQL对应数据类型转换表</h4><table>
<thead>
<tr>
<th>Java类型</th>
<th>SQL类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>int</td>
<td>INTEGER</td>
</tr>
<tr>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>String</td>
<td>CHAR,VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td>byte   array</td>
<td>BINARY  ,    VAR BINARY</td>
</tr>
<tr>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
</tbody></table>
<h4 id="3-3-4-使用PreparedStatement实现增、删、改操作"><a href="#3-3-4-使用PreparedStatement实现增、删、改操作" class="headerlink" title="3.3.4 使用PreparedStatement实现增、删、改操作"></a>3.3.4 使用PreparedStatement实现增、删、改操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String sql,Object ... args)</span></span>&#123;</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//1.获取数据库的连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		<span class="comment">//3.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4.执行sql语句</span></span><br><span class="line">		ps.execute();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="comment">//5.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(conn, ps);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-5-使用PreparedStatement实现查询操作"><a href="#3-3-5-使用PreparedStatement实现查询操作" class="headerlink" title="3.3.5 使用PreparedStatement实现查询操作"></a>3.3.5 使用PreparedStatement实现查询操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取数据库连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">		rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line">		ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值</span></span><br><span class="line">		<span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line">		<span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">			T t = clazz.newInstance();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 遍历每一个列</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 获取列值</span></span><br><span class="line">				Object columnVal = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line">				String columnLabel = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">				<span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line">				Field field = clazz.getDeclaredField(columnLabel);</span><br><span class="line">				field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">				field.set(t, columnVal);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 7.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p>
</blockquote>
<h3 id="3-4-ResultSet与ResultSetMetaData"><a href="#3-4-ResultSet与ResultSetMetaData" class="headerlink" title="3.4 ResultSet与ResultSetMetaData"></a>3.4 ResultSet与ResultSetMetaData</h3><h4 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h4><ul>
<li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p>
</li>
<li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p>
</li>
<li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p>
</li>
<li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p>
</li>
<li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p>
<ul>
<li>例如: getInt(1), getString(“name”)</li>
<li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li>
</ul>
</li>
<li><p>ResultSet 接口的常用方法：</p>
<ul>
<li><p>boolean next()</p>
</li>
<li><p>getString()</p>
</li>
<li><p>…</p>
</li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555580152530.png" class width="1555580152530"></li>
</ul>
<h4 id="3-4-2-ResultSetMetaData"><a href="#3-4-2-ResultSetMetaData" class="headerlink" title="3.4.2 ResultSetMetaData"></a>3.4.2 ResultSetMetaData</h4><ul>
<li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p>
</li>
<li><p>ResultSetMetaData meta = rs.getMetaData();</p>
<ul>
<li><p><strong>getColumnName</strong>(int column)：获取指定列的名称</p>
</li>
<li><p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p>
</li>
<li><p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。 </p>
</li>
<li><p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 </p>
</li>
<li><p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 </p>
</li>
<li><p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。 </p>
</li>
<li><p> isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </p>
</li>
</ul>
</li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555579494691.png" class width="1555579494691">

<p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p>
<p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p>
<p><strong>问题2：关于ResultSetMetaData</strong></p>
<ol>
<li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li>
<li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li>
<li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li>
</ol>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555579816884.png" class width="1555579816884">

<h3 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h3><ul>
<li>释放ResultSet, Statement,Connection。</li>
<li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li>
<li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li>
</ul>
<h3 id="3-6-JDBC-API小结"><a href="#3-6-JDBC-API小结" class="headerlink" title="3.6 JDBC API小结"></a>3.6 JDBC API小结</h3><ul>
<li><p>两种思想</p>
<ul>
<li><p>面向接口编程的思想</p>
</li>
<li><p>ORM思想(object relational mapping)</p>
<ul>
<li>一个数据表对应一个java类</li>
<li>表中的一条记录对应java类的一个对象</li>
<li>表中的一个字段对应java类的一个属性</li>
</ul>
</li>
</ul>
<blockquote>
<p>sql是需要结合列名和表的属性名来写。注意起别名。</p>
</blockquote>
</li>
<li><p>两种技术</p>
<ul>
<li>JDBC结果集的元数据：ResultSetMetaData<ul>
<li>获取列数：getColumnCount()</li>
<li>获取列的别名：getColumnLabel()</li>
</ul>
</li>
<li>通过反射，创建指定类的对象，获取指定的属性并赋值</li>
</ul>
</li>
</ul>
<hr>
<h2 id="章节练习"><a href="#章节练习" class="headerlink" title="章节练习"></a>章节练习</h2><p><strong>练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：</strong></p>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555580275036.png" class width="1555580275036">



<p><strong>练习题2：创立数据库表 examstudent，表结构如下：</strong></p>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555580735377.png" class width="1555580735377">

<p>向数据表中添加如下数据：</p>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555580763636.png" class width="1555580763636">

<p><strong>代码实现1：插入一个新的student 信息</strong></p>
<p>请输入考生的详细信息</p>
<p>Type:<br>IDCard:<br>ExamCard:<br>StudentName:<br>Location:<br>Grade:</p>
<p>信息录入成功!</p>
<p><strong>代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：</strong></p>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555580937490.png" class width="1555580937490">

<p><strong>代码实现3：完成学生信息的删除功能</strong></p>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555580965019.png" class width="1555580965019">

<hr>
<h2 id="第4章-操作BLOB类型字段"><a href="#第4章-操作BLOB类型字段" class="headerlink" title="第4章 操作BLOB类型字段"></a>第4章 操作BLOB类型字段</h2><h3 id="4-1-MySQL-BLOB类型"><a href="#4-1-MySQL-BLOB类型" class="headerlink" title="4.1 MySQL BLOB类型"></a>4.1 MySQL BLOB类型</h3><ul>
<li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p>
</li>
<li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p>
</li>
<li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p>
</li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555581069798.png" class width="1555581069798">

<ul>
<li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li>
<li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li>
<li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li>
</ul>
<h3 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">String sql = <span class="string">&quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;徐海强&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">&quot;xhq@126.com&quot;</span>);</span><br><span class="line">ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> Date(<span class="keyword">new</span> java.util.Date().getTime()));</span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;xhq.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">4</span>, fis);</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">ps.execute();</span><br><span class="line">		</span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-3-修改数据表中的Blob类型字段"><a href="#4-3-修改数据表中的Blob类型字段" class="headerlink" title="4.3 修改数据表中的Blob类型字段"></a>4.3 修改数据表中的Blob类型字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">String sql = <span class="string">&quot;update customers set photo = ? where id = ?&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;coffee.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">1</span>, fis);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>



<h3 id="4-4-从数据表中读取大数据类型"><a href="#4-4-从数据表中读取大数据类型" class="headerlink" title="4.4 从数据表中读取大数据类型"></a>4.4 从数据表中读取大数据类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;</span>;</span><br><span class="line">conn = getConnection();</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">	Integer id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String name = rs.getString(<span class="number">2</span>);</span><br><span class="line">	String email = rs.getString(<span class="number">3</span>);</span><br><span class="line">    Date birth = rs.getDate(<span class="number">4</span>);</span><br><span class="line">	Customer cust = <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">    System.out.println(cust); </span><br><span class="line">    <span class="comment">//读取Blob类型的字段</span></span><br><span class="line">	Blob photo = rs.getBlob(<span class="number">5</span>);</span><br><span class="line">	InputStream is = photo.getBinaryStream();</span><br><span class="line">	OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c.jpg&quot;</span>);</span><br><span class="line">	<span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">		os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">	&#125;</span><br><span class="line">    JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">		is.close();</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(os !=  <span class="keyword">null</span>)&#123;</span><br><span class="line">		os.close();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第5章-批量插入"><a href="#第5章-批量插入" class="headerlink" title="第5章 批量插入"></a>第5章 批量插入</h2><h3 id="5-1-批量执行SQL语句"><a href="#5-1-批量执行SQL语句" class="headerlink" title="5.1 批量执行SQL语句"></a>5.1 批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p>
<p>JDBC的批量处理语句包括下面三个方法：</p>
<ul>
<li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li>
<li><strong>executeBatch()：执行批量处理语句；</strong></li>
<li><strong>clearBatch():清空缓存的数据</strong></li>
</ul>
<p>通常我们会遇到两种批量执行SQL语句的情况：</p>
<ul>
<li>多条SQL语句的批量处理；</li>
<li>一个SQL语句的批量传参；</li>
</ul>
<h3 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p>
<ul>
<li>数据库中提供一个goods表。创建如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="5-2-1-实现层次一：使用Statement"><a href="#5-2-1-实现层次一：使用Statement" class="headerlink" title="5.2.1 实现层次一：使用Statement"></a>5.2.1 实现层次一：使用Statement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">	String sql = <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;</span><br><span class="line">	st.executeUpdate(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-2-2-实现层次二：使用PreparedStatement"><a href="#5-2-2-实现层次二：使用PreparedStatement" class="headerlink" title="5.2.2 实现层次二：使用PreparedStatement"></a>5.2.2 实现层次二：使用PreparedStatement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">	ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">	ps.executeUpdate();</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//82340</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-实现层次三"><a href="#5-2-3-实现层次三" class="headerlink" title="5.2.3 实现层次三"></a>5.2.3 实现层次三</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 修改1： 使用 addBatch() / executeBatch() / clearBatch()</span></span><br><span class="line"><span class="comment"> * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。</span></span><br><span class="line"><span class="comment"> * 		 ?rewriteBatchedStatements=true 写在配置文件的url后面</span></span><br><span class="line"><span class="comment"> * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">	Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">	PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//1.“攒”sql</span></span><br><span class="line">		ps.addBatch();</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//2.执行</span></span><br><span class="line">			ps.executeBatch();</span><br><span class="line">			<span class="comment">//3.清空</span></span><br><span class="line">			ps.clearBatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">	System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//20000条：625                                                                         //1000000条:14733  </span></span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-4-实现层次四"><a href="#5-2-4-实现层次四" class="headerlink" title="5.2.4 实现层次四"></a>5.2.4 实现层次四</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 层次四：在层次三的基础上操作</span></span><br><span class="line"><span class="comment">* 使用Connection 的 setAutoCommit(false)  /  commit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">	Connection conn = JDBCUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//1.设置为不自动提交数据</span></span><br><span class="line">	conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">	PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//1.“攒”sql</span></span><br><span class="line">		ps.addBatch();</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//2.执行</span></span><br><span class="line">			ps.executeBatch();</span><br><span class="line">			<span class="comment">//3.清空</span></span><br><span class="line">			ps.clearBatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//2.提交数据</span></span><br><span class="line">	conn.commit();</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">	System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第6章：-数据库事务"><a href="#第6章：-数据库事务" class="headerlink" title="第6章： 数据库事务"></a>第6章： 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul>
<li><p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p>
</li>
<li><p><strong>事务处理（事务操作）：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都**被提交(commit)<strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务</strong>回滚(rollback)**到最初状态。</p>
</li>
<li><p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 </p>
</li>
</ul>
<h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul>
<li><p>数据一旦提交，就不可回滚。</p>
</li>
<li><p>数据什么时候意味着提交？</p>
<ul>
<li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li>
<li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li>
</ul>
</li>
<li><p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p>
<ul>
<li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li>
<li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li>
<li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li>
</ul>
<blockquote>
<p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p>
</blockquote>
</li>
</ul>
<p>【案例：用户AA向用户BB转账100】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBCTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取数据库连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line">		<span class="comment">// 2.开启事务</span></span><br><span class="line">		conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// 3.进行数据库操作</span></span><br><span class="line">		String sql1 = <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">		update(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 模拟网络异常</span></span><br><span class="line">		<span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"></span><br><span class="line">		String sql2 = <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">		update(conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">		<span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">		conn.commit();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		<span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">			conn.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//7.关闭连接</span></span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，对数据库操作的方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> </span>&#123;</span><br><span class="line">	PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		<span class="comment">// 2.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3.执行sql语句</span></span><br><span class="line">		ps.execute();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 4.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(<span class="keyword">null</span>, ps);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a>6.3 事务的ACID属性</h3><ol>
<li><p><strong>原子性（Atomicity）</strong><br> 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p>
</li>
<li><p><strong>一致性（Consistency）</strong><br> 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
</li>
<li><p><strong>隔离性（Isolation）</strong><br> 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><strong>持久性（Durability）</strong><br> 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
</li>
</ol>
<h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><ul>
<li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li>
</ul>
</li>
<li><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>
</li>
<li><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p>
</li>
</ul>
<h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><ul>
<li><p>数据库提供的4种事务隔离级别：</p>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555586275271.png" class width="1555586275271"></li>
<li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p>
</li>
</ul>
<ul>
<li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li>
</ul>
<h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 在MySql中设置隔离级别</h4><ul>
<li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p>
</li>
<li><p>查看当前的隔离级别: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure></li>
<li><p>设置当前 mySQL 连接的隔离级别:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set  transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li>
<li><p>设置数据库系统的全局的隔离级别:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li>
<li><p>补充操作：</p>
<ul>
<li><p>创建mysql数据库用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user tom identified by &#x27;abc123&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>授予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">grant all privileges on *.* to tom@&#x27;%&#x27;  identified by &#x27;abc123&#x27;; </span><br><span class="line"></span><br><span class="line"> #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;; </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="第7章：DAO及相关实现类"><a href="#第7章：DAO及相关实现类" class="headerlink" title="第7章：DAO及相关实现类"></a>第7章：DAO及相关实现类</h2><ul>
<li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li>
<li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li>
<li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1566726681515.png" class width="1566726681515">

<ul>
<li>层次结构：</li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1566745811244.png" class width="1566745811244">

<h3 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HanYanBing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	<span class="comment">// 定义一个变量来接收泛型的类型</span></span><br><span class="line">	<span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BaseDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取子类的类型</span></span><br><span class="line">		Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line">		<span class="comment">// 获取父类的类型</span></span><br><span class="line">		<span class="comment">// getGenericSuperclass()用来获取当前类的父类的类型</span></span><br><span class="line">		<span class="comment">// ParameterizedType表示的是带泛型的类型</span></span><br><span class="line">		ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();</span><br><span class="line">		<span class="comment">// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型</span></span><br><span class="line">		<span class="comment">// 这个方法会返回一个Type的数组</span></span><br><span class="line">		Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line">		<span class="comment">// 获取具体的泛型的类型·</span></span><br><span class="line">		<span class="keyword">this</span>.type = (Class&lt;T&gt;) types[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通用的增删改操作</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			count = queryRunner.update(conn, sql, params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取一个对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getBean</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanHandler&lt;T&gt;(type), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取所有对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getBeanList</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		List&lt;T&gt; list = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			list = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanListHandler&lt;T&gt;(type), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">		Object count = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 调用queryRunner的query方法获取一个单一的值</span></span><br><span class="line">			count = queryRunner.query(conn, sql, <span class="keyword">new</span> ScalarHandler&lt;&gt;(), params);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从数据库中查询出所有的记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向数据库中插入一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从数据库中根据图书的id删除一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据图书的id从数据库中查询出一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据图书的id从数据库中更新一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取带分页的图书信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取带分页和价格范围的图书信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据User对象中的用户名和密码从数据库中获取一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> User 数据库中有记录 null 数据库中无此记录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据User对象中的用户名从数据库中获取一条记录</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> true 数据库中有记录 false 数据库中无此记录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向数据库中插入User对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中得到一个List的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;</span>;</span><br><span class="line">		beanList = getBeanList(conn,sql);</span><br><span class="line">		<span class="keyword">return</span> beanList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;DELETE FROM books WHERE id = ?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用增删改的方法</span></span><br><span class="line">		update(conn,sql, bookId);</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		Book book = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;</span>;</span><br><span class="line">		book = getBean(conn,sql, bookId);</span><br><span class="line">		<span class="keyword">return</span> book;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">		String sql = <span class="string">&quot;select count(*) from books&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line">		<span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql);</span><br><span class="line">		<span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">		page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">		String sql2 = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line">		<span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">		page.setList(beanList);</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">		String sql = <span class="string">&quot;select count(*) from books where price between ? and ?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line">		<span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql,minPrice,maxPrice);</span><br><span class="line">		<span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">		page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">		String sql2 = <span class="string">&quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;</span>;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">		List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line">		<span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">		page.setList(beanList);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		User bean = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,username,password,email from users where username = ? and password = ?&quot;</span>;</span><br><span class="line">		bean = getBean(conn,sql, user.getUsername(), user.getPassword());</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">		User bean = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;select id,username,password,email from users where username = ?&quot;</span>;</span><br><span class="line">		bean = getBean(conn,sql, user.getUsername());</span><br><span class="line">		<span class="keyword">return</span> bean != <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//写sql语句</span></span><br><span class="line">		String sql = <span class="string">&quot;insert into users(username,password,email) values(?,?,?)&quot;</span>;</span><br><span class="line">		<span class="comment">//调用BaseDao中通用的增删改的方法</span></span><br><span class="line">		update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String title; <span class="comment">// 书名</span></span><br><span class="line">	<span class="keyword">private</span> String author; <span class="comment">// 作者</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> price; <span class="comment">// 价格</span></span><br><span class="line">	<span class="keyword">private</span> Integer sales; <span class="comment">// 销量</span></span><br><span class="line">	<span class="keyword">private</span> Integer stock; <span class="comment">// 库存</span></span><br><span class="line">	<span class="keyword">private</span> String imgPath = <span class="string">&quot;static/img/default.jpg&quot;</span>; <span class="comment">// 封面图片的路径</span></span><br><span class="line">	<span class="comment">//构造器，get()，set()，toString()方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页码类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_SIZE = <span class="number">4</span>; <span class="comment">// 每页显示的记录数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> pageNo; <span class="comment">// 当前页</span></span><br><span class="line"><span class="comment">//	private int totalPageNo; // 总页数，通过计算得到</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> totalRecord; <span class="comment">// 总记录数，通过查询数据库得到</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第8章：数据库连接池"><a href="#第8章：数据库连接池" class="headerlink" title="第8章：数据库连接池"></a>第8章：数据库连接池</h2><h3 id="8-1-JDBC数据库连接池的必要性"><a href="#8-1-JDBC数据库连接池的必要性" class="headerlink" title="8.1 JDBC数据库连接池的必要性"></a>8.1 JDBC数据库连接池的必要性</h3><ul>
<li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</p>
<ul>
<li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li>
<li><strong>进行sql操作</strong></li>
<li><strong>断开数据库连接</strong></li>
</ul>
</li>
<li><p>这种模式开发，存在的问题:</p>
<ul>
<li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li>
<li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</li>
<li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </li>
</ul>
</li>
</ul>
<h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul>
<li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p>
</li>
<li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p>
</li>
<li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p>
</li>
<li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p>
</li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555593464033.png" class width="1555593464033">

<ul>
<li><strong>工作原理：</strong></li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555593598606.png" class width="1555593598606">

<ul>
<li><p><strong>数据库连接池技术的优点</strong></p>
<p><strong>1. 资源重用</strong></p>
<p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p>
<p><strong>2. 更快的系统反应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p>
<p><strong>3. 新的资源分配手段</strong></p>
<p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p>
<p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p>
<p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p>
</li>
</ul>
<h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul>
<li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul>
<li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li>
<li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用</li>
<li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li>
<li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li>
<li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li>
</ul>
</li>
<li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li>
<li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li>
<li>特别注意：<ul>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
</ul>
</li>
</ul>
<h4 id="8-3-1-C3P0数据库连接池"><a href="#8-3-1-C3P0数据库连接池" class="headerlink" title="8.3.1 C3P0数据库连接池"></a>8.3.1 C3P0数据库连接池</h4><ul>
<li>获取连接方式一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">	cpds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); </span><br><span class="line">	cpds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">	cpds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	cpds.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//	cpds.setMaxPoolSize(100);</span></span><br><span class="line">	</span><br><span class="line">	Connection conn = cpds.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>获取连接方式二</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource cpds = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">&quot;helloc3p0&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">	Connection conn = cpds.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【c3p0-config.xml】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="8-3-2-DBCP数据库连接池"><a href="#8-3-2-DBCP数据库连接池" class="headerlink" title="8.3.2 DBCP数据库连接池"></a>8.3.2 DBCP数据库连接池</h4><ul>
<li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
</li>
<li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
<li>配置属性说明</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>initialSize</td>
<td>0</td>
<td>连接池启动时创建的初始化连接数量</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>连接池中可同时连接的最大的连接数</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td>
</tr>
<tr>
<td>minIdle</td>
<td>0</td>
<td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td>
</tr>
<tr>
<td>maxWait</td>
<td>无限制</td>
<td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>开启池的Statement是否prepared</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>无限制</td>
<td>开启池的prepared 后的同时最大连接数</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td>
</tr>
<tr>
<td>removeAbandonedTimeout</td>
<td>300</td>
<td>超过时间限制，回收没有用(废弃)的连接</td>
</tr>
<tr>
<td>removeAbandoned</td>
<td>false</td>
<td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td>
</tr>
</tbody></table>
<ul>
<li>获取连接方式一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	BasicDataSource source = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">		</span><br><span class="line">	source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">	source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);</span><br><span class="line">	source.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	source.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	source.setInitialSize(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">	Connection conn = source.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取连接方式二：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource source = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">		</span><br><span class="line">		InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line">			</span><br><span class="line">		pros.load(is);</span><br><span class="line">		<span class="comment">//根据提供的BasicDataSourceFactory创建对应的DataSource对象</span></span><br><span class="line">		source = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">	Connection conn = source.getConnection();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【dbcp.properties】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>



<h4 id="8-3-3-Druid（德鲁伊）数据库连接池"><a href="#8-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="8.3.3 Druid（德鲁伊）数据库连接池"></a>8.3.3 Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDruid</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Properties pro = <span class="keyword">new</span> Properties();		 pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">		DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">		Connection conn = ds.getConnection();</span><br><span class="line">		System.out.println(conn);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【druid.properties】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">maxActive=<span class="number">20</span></span><br><span class="line">maxWait=<span class="number">1000</span></span><br><span class="line">filters=wall</span><br></pre></td></tr></table></figure>

<ul>
<li>详细配置参数：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>配置</strong></th>
<th><strong>缺省</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td>
</tr>
<tr>
<td>url</td>
<td></td>
<td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个DruidDataSource只支持一个EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody></table>
<h2 id="第9章：Apache-DBUtils实现CRUD操作"><a href="#第9章：Apache-DBUtils实现CRUD操作" class="headerlink" title="第9章：Apache-DBUtils实现CRUD操作"></a>第9章：Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils简介"><a href="#9-1-Apache-DBUtils简介" class="headerlink" title="9.1 Apache-DBUtils简介"></a>9.1 Apache-DBUtils简介</h3><ul>
<li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p>
</li>
<li><p>API介绍：</p>
<ul>
<li>org.apache.commons.dbutils.QueryRunner</li>
<li>org.apache.commons.dbutils.ResultSetHandler</li>
<li>工具类：org.apache.commons.dbutils.DbUtils   </li>
</ul>
</li>
<li><p>API包说明：</p>
</li>
</ul>
<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555595163263.png" class width="1555595163263">

<img src="/2020/03/15/JDBC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1555595198644.png" class width="1555595198644">





<h3 id="9-2-主要API的使用"><a href="#9-2-主要API的使用" class="headerlink" title="9.2 主要API的使用"></a>9.2 主要API的使用</h3><h4 id="9-2-1-DbUtils"><a href="#9-2-1-DbUtils" class="headerlink" title="9.2.1 DbUtils"></a>9.2.1 DbUtils</h4><ul>
<li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul>
<li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li>
<li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li>
<li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li>
<li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li>
<li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li>
<li>public static void rollbackAndClose(Connection conn)throws SQLException</li>
<li>rollbackAndCloseQuietly(Connection)</li>
<li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li>
</ul>
</li>
</ul>
<h4 id="9-2-2-QueryRunner类"><a href="#9-2-2-QueryRunner类" class="headerlink" title="9.2.2 QueryRunner类"></a>9.2.2 QueryRunner类</h4><ul>
<li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p>
</li>
<li><p>QueryRunner类提供了两个构造器：</p>
<ul>
<li>默认的构造器</li>
<li>需要一个 javax.sql.DataSource 来作参数的构造器</li>
</ul>
</li>
<li><p>QueryRunner类的主要方法：</p>
<ul>
<li><strong>更新</strong><ul>
<li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li>
<li> ……</li>
</ul>
</li>
<li><strong>插入</strong><ul>
<li>public <T> T insert(Connection conn,String sql,ResultSetHandler<T> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</T></T></li>
<li>….</li>
</ul>
</li>
<li><strong>批处理</strong><ul>
<li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li>
<li>public <T> T insertBatch(Connection conn,String sql,ResultSetHandler<T> rsh,Object[][] params)throws SQLException：只支持INSERT语句</T></T></li>
<li>…..</li>
</ul>
</li>
<li><strong>查询</strong><ul>
<li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li>
<li>…… </li>
</ul>
</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试添加</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">	String sql = <span class="string">&quot;insert into customers(name,email,birth)values(?,?,?)&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> count = runner.update(conn, sql, <span class="string">&quot;何成飞&quot;</span>, <span class="string">&quot;he@qq.com&quot;</span>, <span class="string">&quot;1992-09-08&quot;</span>);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;添加了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">	String sql = <span class="string">&quot;delete from customers where id &lt; ?&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> count = runner.update(conn, sql,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;删除了&quot;</span> + count + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-2-3-ResultSetHandler接口及实现类"><a href="#9-2-3-ResultSetHandler接口及实现类" class="headerlink" title="9.2.3 ResultSetHandler接口及实现类"></a>9.2.3 ResultSetHandler接口及实现类</h4><ul>
<li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p>
</li>
<li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p>
</li>
<li><p>接口的主要实现类：</p>
<ul>
<li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li>
<li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li>
<li><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li>
<li><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li>
<li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li>
<li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li>
<li><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li>
<li><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li>
<li><strong>ScalarHandler：</strong>查询单个值对象</li>
</ul>
</li>
<li><p>测试</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Customer.class);</span><br><span class="line">	Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">	System.out.println(customer);	</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询多条记录构成的集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanListHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	BeanListHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanListHandler&lt;&gt;(Customer.class);</span><br><span class="line">	List&lt;Customer&gt; list = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">	list.forEach(System.out::println);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义ResultSetHandler的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	String sql = <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> ResultSetHandler&lt;Customer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Customer <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;handle&quot;</span>);</span><br><span class="line"><span class="comment">//			return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L));</span></span><br><span class="line">				</span><br><span class="line">			<span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">				<span class="keyword">int</span> id = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">				String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">				String email = rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">				Date birth = rs.getDate(<span class="string">&quot;birth&quot;</span>);</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">		</span><br><span class="line">	Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">		</span><br><span class="line">	System.out.println(customer);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，</span></span><br><span class="line"><span class="comment"> * 使用ScalarHandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">	Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//测试一：</span></span><br><span class="line"><span class="comment">//	String sql = &quot;select count(*) from customers where id &lt; ?&quot;;</span></span><br><span class="line"><span class="comment">//	ScalarHandler handler = new ScalarHandler();</span></span><br><span class="line"><span class="comment">//	long count = (long) runner.query(conn, sql, handler, 20);</span></span><br><span class="line"><span class="comment">//	System.out.println(count);</span></span><br><span class="line">		</span><br><span class="line">	<span class="comment">//测试二：</span></span><br><span class="line">	String sql = <span class="string">&quot;select max(birth) from customers&quot;</span>;</span><br><span class="line">	ScalarHandler handler = <span class="keyword">new</span> ScalarHandler();</span><br><span class="line">	Date birth = (Date) runner.query(conn, sql, handler);</span><br><span class="line">	System.out.println(birth);</span><br><span class="line">		</span><br><span class="line">	JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">总结</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateWithTx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	Connection conn = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//1.获取连接的操作（</span></span><br><span class="line">		<span class="comment">//① 手写的连接：JDBCUtils.getConnection();</span></span><br><span class="line">		<span class="comment">//② 使用数据库连接池：C3P0;DBCP;Druid</span></span><br><span class="line">		<span class="comment">//2.对数据表进行一系列CRUD操作</span></span><br><span class="line">		<span class="comment">//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)</span></span><br><span class="line"><span class="comment">//version2.0的增删改public void update(Connection conn,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line"><span class="comment">//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args)&#123;&#125;</span></span><br><span class="line">		<span class="comment">//② 使用dbutils提供的jar包中提供的QueryRunner类</span></span><br><span class="line">			</span><br><span class="line">		<span class="comment">//提交数据</span></span><br><span class="line">		conn.commit();</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//回滚数据</span></span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="comment">//3.关闭连接等操作</span></span><br><span class="line">		<span class="comment">//① JDBCUtils.closeResource();</span></span><br><span class="line">		<span class="comment">//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作</span></span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-集合框架</title>
    <url>/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>​        集合是存储对象的容器，集合中可以存储任意类型的对象，而且长度可变。在程序中有可能无法预先知道需要多少个对象，那么用数组来装对象的话，长度不好定义，而集合解决了这样的问题。</p>
<p>​         容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 </p>
<img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1580527655939.png" alt="1580527655939" style="zoom:80%;">

<p><code>                                                                        注： 带对号的是线程安全类。</code></p>
<h3 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h3><p>数组和集合类都是容器</p>
<ul>
<li><p>数组长度是<strong>固定的</strong>，集合长度是<strong>可变的</strong>。数组中可以存储基本数据类型，<strong>集合只能存储对象</strong></p>
</li>
<li><p>数组中存储数据类型是单一的，集合中可以存储任意类型的对象。</p>
</li>
<li><p>集合类的特点：<code>用于存储对象，长度是可变的，可以存储不同类型的对象。</code></p>
</li>
</ul>
<img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/collection.png" alt="collection" style="zoom:80%;">

<ul>
<li>从上图可以看到，Set、List、Queue都是继承Collection接口。（Map是接口，下面会详细描述）</li>
<li>Set下面有HashSet、LinkedHashSet以及一个SortedSet接口，TreeSet继承SortedSet接口，说明TreeSet里面的元素一定是有序的。</li>
<li>List下面有ArrayList、Vector、 LinkedList</li>
<li>Queue下面有LinkedList和PriorityQueue类(堆结构：优先级队列)，说明LinkedLIst可以当做队列来使用。</li>
</ul>
<h3 id="1-Set：唯一性"><a href="#1-Set：唯一性" class="headerlink" title="1. Set：唯一性"></a>1. Set：唯一性</h3><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>基于<strong>红黑树</strong>实现，支持<strong>有序性</strong>操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。红黑树的算法规则是<strong>左小右大</strong>。</p>
<ol>
<li><p>红黑树是一种特定类型的二叉树， 是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质： </p>
<p>​    性质1：每个节点要么是黑色，要么是红色。</p>
<p>​    性质2：根节点是黑色。</p>
<p>​    性质3：每个叶子节点（NIL）是黑色。</p>
<p>​    性质4：每个红色结点的两个子结点一定都是黑色。</p>
<p>​    <strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></p>
<img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/2392382-4996bbfb4017a3b2.png" class title="img"> 

<p>红黑树以后会补上，详解见： <a href="https://www.jianshu.com/p/e136ec79235c">30张图带你彻底理解红黑树</a></p>
</li>
<li><p>TreeSet可以自然排序，那么TreeSet必定具有排序规则的</p>
<p>​    ① 元素自身具有比较性，需要实现Comparable接口，重写compareTo方法。这种方式叫做元素的自然排序</p>
<p>​    ② 容器具备比较性，当元素不具备比较性，或者自身具备的比较性不是所需要的，那么此时也可以让容器自身具备。需要定义一个类实现Comparator接口， 重写compare方法，并将该接口的子类实例对象作为参数传递给TreeSet集合的构造方法。（<code>注： 当Comparable比较方式和Comparator比较方式同时存在，以Comparator为主</code>）</p>
<p>​    ③ 基本数据类型具备自身比较性，比如String， int等，String内部已经继承了Comparable接口，所以具备比较性，我们自己定义的元素，想要存入TreeSet中，就必须自己实现该接口，也就是说要让对象具备就比较性，如果存入相同的元素则只会存入一个到TreeSet中。</p>
<p>​    ④ TreeSet中如何保证元素的唯一性： 通过compareTo或者compare方法来保证元素的唯一性。</p>
<p>Person类中有name和age属性，下面是重写的compareTo方法以及hashCode和equals方法。这是使元素自身具备比较性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nama.hashCode() + age*<span class="number">33</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!(obj  <span class="keyword">instanceof</span>  Person))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       Person p = (Person)obj;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.nama.equals(p.nama) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       Person p = (Person)o;</span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.age &gt; p.age)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.age &lt;  p.age)&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.nama.compareTo(p.nama);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>下面是是使容器自身具备比较性，要自定义比较器：定义一个类实现Comparator接口， 重写compare方法，并将该接口的子类实例对象作为参数传递给TreeSet集合的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        Person p1 = (Person) o1;</span><br><span class="line">        Person p2 = (Person) o2;</span><br><span class="line">        <span class="comment">// 首先比较年龄，年龄不一样就是不同元素，因为存在同名的人</span></span><br><span class="line">        <span class="keyword">if</span>(p1.getAge() &gt; p2.getAge())&#123; <span class="comment">// 按照年龄升序排列</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( p1.getAge() &lt; p2.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果年龄相同则比较姓名</span></span><br><span class="line">        <span class="keyword">return</span> p1.getNama().compareTo(p2.getNama());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> MyComparator()); <span class="comment">// 传入比较器</span></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">5</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>, <span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="string">&quot;tom&quot;</span>, <span class="number">24</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="string">&quot;tom&quot;</span> , <span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person p: set)&#123;</span><br><span class="line">            out.println(p.getNama()+<span class="string">&quot;   &quot;</span>+p.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">输出： </span><br><span class="line">李四   <span class="number">5</span></span><br><span class="line">张三   <span class="number">12</span></span><br><span class="line">李四   <span class="number">12</span></span><br><span class="line">tom   <span class="number">24</span></span><br><span class="line"></span><br><span class="line">可以看到重名的tom是相同的元素，智慧添加一个到TreeSet中，并且输出的顺序是按照年龄大小排列的</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>基于<strong>哈希表</strong>实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。（无序）</p>
<ol>
<li><p>HashSet是按照哈希值来存数据的，所以取数据也是按照哈希值取得的。</p>
</li>
<li><p>Set具有元素的唯一性，所以HashSet也具有此特性。</p>
</li>
<li><p>HashSet如何检查重复呢？</p>
<blockquote>
<p>​    HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放对个元素。元素的哈希值是通过元素的hashCode方法来获取的， HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法；如果hashCode不一样就不会再调用equals方法了。如果equals方法返回true，那么HashSet认为新加入的对象重复了加入失败。如果equals方法为false那么HashSet认为新加入的对象没有重复，新元素可以加入。</p>
</blockquote>
</li>
</ol>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>具有 HashSet 的查找效率，并且内部使用<strong>双向链表</strong>维护元素的插入顺序。（有序）</p>
<ol>
<li>由链表保证元素有序</li>
<li>由哈希表保证元素唯一 </li>
</ol>
<h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><p>List特有的方法</p>
<blockquote>
<p>1： 增加</p>
<p>​                    void add(int index, E elem) 指定位置添加元素</p>
<p>​                    boolean addAll(int index, COllection c)   指定位置添加集合</p>
<p>2： 删除</p>
<p>​                    E remove(int index)                删除指定位置元素</p>
<p>3： 查找</p>
<p>​                    E get(int index)            注意 IndexOutOfBoundsException</p>
<p>​                    int indexOf(Object o)         找不到返回 -1 </p>
<p>​                    lastIndexOf(Object o)         </p>
<p>4： 修改</p>
<p>​                    E set(int index, E elem)               返回的是需要替换的集合中的元素</p>
<p>5： 求子集合</p>
<p>​                    List<E> subList(int fromIndex, int toIndex)  //   包含toIndex</E></p>
</blockquote>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>基于动态数组实现，支持随机访问。 底层采用数组实现， 默认为10. 查询快，增删慢。在实际开发过程中，ArrayList 是使用频率最高的一个集合。</p>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>和 ArrayList 类似，但它是线程安全的。描述的是一个线程安全的ArrayList</p>
<p>ArrayList： 单线程效率高</p>
<p>Vector：  多线程安全， 所以效率低</p>
<p>特有的方法</p>
<blockquote>
<p>​    void addElement(E obj)     在集合末尾添加元素</p>
<p>​    E elementAt(int index)        返回指定角标的元素</p>
<p>​    Enumeration elements()  返回集合中的所有元素， 封装到Enumeration对象中</p>
<p>​    Enumeration 接口：</p>
<p>​            boolean hashMoreElements()             测试此枚举的对象是否包含更多的元素</p>
<p>​            E  nextElement()            返回下一个元素</p>
</blockquote>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，<strong>LinkedList 还可以用作栈、队列和双向队列。</strong></p>
<p>​    1. 特有方法：</p>
<blockquote>
<p>​    addFirst(E  e)</p>
<p>​    addLast(E  e)</p>
<p>​    getFirst( )</p>
<p>​    getLast( )</p>
<p>​    removeFirst()</p>
<p>​    removeLast()</p>
</blockquote>
<ol start="2">
<li><p>数据结构</p>
<blockquote>
<p>1： 栈（1.6）：push()   pop()</p>
<p>2:   队列 ： offer()    poll()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈</span></span><br><span class="line">   LinkedList list  = <span class="keyword">new</span> LinkedList();</span><br><span class="line">   list.push(<span class="number">2</span>);</span><br><span class="line">   list.push(<span class="number">4</span>);</span><br><span class="line">   list.push(<span class="number">5</span>);</span><br><span class="line">   list.push(<span class="number">6</span>);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   Iterator it = list.iterator();</span><br><span class="line">   <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">       out.println(it.next());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>6<br>5<br>4<br>2</p>
<p>模拟队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList q  = <span class="keyword">new</span> LinkedList();</span><br><span class="line">  q.offer(<span class="number">2</span>);</span><br><span class="line">  q.offer(<span class="number">3</span>);</span><br><span class="line">  q.offer(<span class="number">5</span>);</span><br><span class="line">   </span><br><span class="line">  q.poll();</span><br><span class="line">   </span><br><span class="line">  Iterator it1 = q.iterator();</span><br><span class="line">  <span class="keyword">while</span> (it1.hasNext())&#123;</span><br><span class="line">      out.println(it1.next());</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>返回逆序的迭代器对</p>
<blockquote>
<p>​    descendingItrerator()   返回逆序的迭代器对象</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h3><h4 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>​    可以用它来实现双向队列。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>​    基于堆结构实现，可以用它来实现优先队列。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>看到Array： 想到角标</p>
<p>看到Link： 想到first、last</p>
<p>看到Hash： 想到hashCode、equals</p>
<p>看到Tree： 想到两个接口： Comparable、 Comparator</p>
</blockquote>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map与Collection在框架中属并两列存在。interface Map&lt;K, V&gt;</p>
<img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1580552945802.png" alt="map" style="zoom:80%;">

<p>Map一次存储一对元素，Collection一次存一个。Map的键不能重复，保证唯一。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>​        基于红黑树实现。可以对键进行排序。排序方法和TreeSet中类似，对于不具备比较性的对象需要自定义比较器传入容器中。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>​        基于哈希表实现， 无序，线程不同步，要保证键的唯一性，需要重写hashCode方法和equals方法。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><ul>
<li>和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li> Hashtable不允许null值，HashMap允许null值（key和value都允许 )</li>
<li>效率比HashMap低</li>
</ul>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>​        继承了HashMap。使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><blockquote>
<p>迭代器： 为了方便处理集合中的元素，出现了迭代器对象。这个对象比较特殊，不能通过new来创建，它是以<strong>内部类</strong>的形式存在于每个集合的内部。</p>
</blockquote>
<p>​        每个容器都能取出元素的功能，定义一样，只不过不同的容器使用的数据结构不同而导致取出元素的具体实现不一样，将共性抽取出来形成Iterator接口。每一个容易在其内部进行了内部类的实现。也就是将取出元素的方式的细节进行封装。</p>
<h3 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h3><p>JDK1.5后的新接口。Collection继承了此接口，实现了Iterable的类就是可以进行迭代的，并且支持增强for循环。</p>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>Iterable 接口只有一个返回迭代器的方法Iterator().  Iterator是迭代器对象。</p>
<blockquote>
<p>Iteartor<T>   Iterator()   返回该集合的迭代器对象</T></p>
</blockquote>
<p>while循环进行迭代器遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      LinkedList list  = <span class="keyword">new</span> LinkedList();</span><br><span class="line">      list.push(<span class="number">2</span>);</span><br><span class="line">      list.push(<span class="number">4</span>);</span><br><span class="line">      list.push(<span class="number">5</span>);</span><br><span class="line">      list.push(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line">      Iterator it = list.iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">          out.println(it.next());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>for循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator it = list.iterator(); it.hasNext();)&#123;</span><br><span class="line">            out.println(it.next());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>推荐使用for循环，因为可以进行内存上的优化。</p>
<blockquote>
<ol>
<li><p>如果迭代器的指针已经指向了集合的末尾， 那么如果再调用next() 会返NoSuchElementException                                  异常。</p>
</li>
<li><p>如果调用move方法之前没用调用next是不合法的。会抛出IllegaStateException</p>
</li>
</ol>
</blockquote>
<h3 id="迭代器原理"><a href="#迭代器原理" class="headerlink" title="迭代器原理"></a>迭代器原理</h3><p>ArrayList： 看源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看看Itr()  方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return 下一个元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 如果当前的下标大小不等于容器个元素个数 就 说明还有下一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 返回下一个元素</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)  <span class="comment">//  没有下一个元素了</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>; <span class="comment">// 当前的cursor要指向下一个</span></span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];  <span class="comment">// 返回元素 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>来看看上面代码的<code>checkForComodification();</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>​        在对集合进行迭代过程中，不允许出现迭代器以外的对元素的操作， 因为这样会产生安全隐患，java会抛出异常并发修改异常<code>ConcurrentModificationException</code>， 普通迭代器只支持在迭代过程中的删除操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;eee&quot;</span>);</span><br><span class="line">       System.out.println(list);</span><br><span class="line">       Iterator it =  list.iterator();</span><br><span class="line">       <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">           it.next();</span><br><span class="line">           it.remove();</span><br><span class="line">           list.add(<span class="string">&quot;aaaaa&quot;</span>); <span class="comment">// 出现了迭代器以外的对元素的操作</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​        报错：</p>
<img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1580558907260.png" alt="1580558907260" style="zoom:80%;">



<h3 id="List-特有的迭代器ListIterator"><a href="#List-特有的迭代器ListIterator" class="headerlink" title="List 特有的迭代器ListIterator"></a>List 特有的迭代器ListIterator</h3><p>如果想在迭代元素的过程中操作集合的元素，那么可以使用LIst特有的迭代器对象ListIterator，该迭代器可支持在迭代的过程中添加元素和修改元素。</p>
<p>implements ListIterator<E> 接口</E></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">           <span class="keyword">super</span>();</span><br><span class="line">           cursor = index;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 是否有前一个元素</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> cursor != <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">// 返回下一个元素的下标</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> cursor;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">// 返回前一个元素的下标</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">// 返回前一个元素： 可以逆序访问</span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           checkForComodification();</span><br><span class="line">           <span class="keyword">int</span> i = cursor - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">           Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           cursor = i;</span><br><span class="line">           <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">// 用指定元素替换next或者 previous返回的最后一个元素</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">           checkForComodification();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ArrayList.<span class="keyword">this</span>.set(lastRet, e);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">// 将指定的元素加入列表，钙元素直接插入到next元素的后面</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">           checkForComodification();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">int</span> i = cursor;</span><br><span class="line">               ArrayList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">               cursor = i + <span class="number">1</span>;</span><br><span class="line">               lastRet = -<span class="number">1</span>;</span><br><span class="line">               expectedModCount = modCount;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试 set方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">       list.add(<span class="string">&quot;eee&quot;</span>);</span><br><span class="line">       System.out.println(list);</span><br><span class="line">       ListIterator it = list.listIterator();</span><br><span class="line">      System.out.println(it.next());</span><br><span class="line">      it.set(<span class="string">&quot;zhu&quot;</span>);</span><br><span class="line">      System.out.println(list);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p>[aaa, bbb, ccc, ddd, eee]<br>aaa<br>[zhu, bbb, ccc, ddd, eee]</p>
</blockquote>
<p>测试 add方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;eee&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        ListIterator it = list.listIterator();</span><br><span class="line">       System.out.println(it.next());</span><br><span class="line">       it.add(<span class="string">&quot;zhu&quot;</span>);  <span class="comment">// 在aaa之后添加zhu</span></span><br><span class="line">       System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
<p>[aaa, bbb, ccc, ddd, eee]<br>aaa<br>[aaa, zhu, bbb, ccc, ddd, eee]</p>
</blockquote>
<h3 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h3><p>有三种方式：</p>
<ol>
<li>keySet() 获取Map中的所有键，转换成Set集合，然后遍历该Set，通过get方法获取键对应的值</li>
<li>values() 方法来获取所有值 ：Collection<V> values()  不能获取到key对象</V></li>
<li><strong>Map.Entry对象：重点！！！！推荐使用</strong>： Interface Map.Entry&lt;K,V&gt;</li>
</ol>
<h4 id="Map-Entry"><a href="#Map-Entry" class="headerlink" title="Map.Entry"></a>Map.Entry</h4><p><code>public static interface Map.Entry&lt;K,V&gt;</code></p>
<p>将map集合中的键值对关系打包成一个Map.Entry对象，将该对象存入Set结合中，使用getKey() 和 getValue()来获取键和值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">&quot;aaa&quot;</span>, <span class="number">123</span>);</span><br><span class="line">       map.put(<span class="string">&quot;bbb&quot;</span>, <span class="number">345</span>);</span><br><span class="line">       map.put(<span class="string">&quot;ccc&quot;</span>, <span class="number">121</span>);</span><br><span class="line">       map.put(<span class="string">&quot;ddd&quot;</span>, <span class="number">675</span>);</span><br><span class="line"></span><br><span class="line">       Set&lt;Map.Entry&lt;String, Integer&gt;&gt; s = map.entrySet();</span><br><span class="line">       Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = s.iterator();</span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">           Map.Entry&lt;String, Integer&gt; en = iterator.next();</span><br><span class="line">           System.out.println(<span class="string">&quot;键： &quot;</span>+ en.getKey()+<span class="string">&quot; 值：&quot;</span>+ en.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>键： aaa 值：123<br>键： ccc 值：121<br>键： bbb 值：345<br>键： ddd 值：675</p>
</blockquote>
<hr>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p> 如果没有特别说明，以下源码分析基于 JDK 1.8。 </p>
<hr>
<h3 id="一、-ArrayList"><a href="#一、-ArrayList" class="headerlink" title="一、 ArrayList"></a>一、 ArrayList</h3><h4 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h4><p> 因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Default initial capacity.  数组的默认大小为10</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581256240358.png" alt="1581256240358" style="zoom:80%;" align="center">

<h4 id="2-扩容"><a href="#2-扩容" class="headerlink" title="2. 扩容"></a>2. 扩容</h4><p>​        添加元素时使用  <code>ensureCapacityInternal()</code>  方法来保证容量足够，如果不够时，需要使用 <code>grow()</code> 方法进行扩容，新容量的大小为   <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>  ，也就是旧容量的 1.5 倍。</p>
<p>​         扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3. 删除元素"></a>3. 删除元素</h4><pre><code>     需要调用      `System.arraycopy()`     将    `index+1 `      后面的元素都复制到 `index` 位置上，该操作的时间复杂度为 `O(N)`，可以看到 ArrayList 删除元素的代价是非常高的。 
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-序列化"><a href="#4-序列化" class="headerlink" title="4. 序列化"></a>4. 序列化</h4><p>​        ArrayList 基于数组实现，并且具有<strong>动态扩容特性</strong>，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>​        保存元素的数组 elementData 使用 <code>transient</code> 修饰，<strong>该关键字声明数组默认不会被序列化</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>

<p>​    ArrayList 实现了 <code>writeObject()</code> 和 <code>readObject()</code> 来控制只序列化数组中有元素填充那部分内容。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,</span></span><br><span class="line"><span class="comment">     * deserialize it).  反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in capacity</span></span><br><span class="line">        s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">            <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">            ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">            Object[] a = elementData;</span><br><span class="line">            <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">                a[i] = s.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span></span><br><span class="line"><span class="comment">    * is, serialize it).  序列化</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serialData</span> The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">    *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment">    *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span></span><br><span class="line"><span class="comment">    				只序列化数组中有元素填充那部分内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">       <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">       <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">       s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">       s.writeInt(size);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">           s.writeObject(elementData[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​         序列化时需要使用 <code>ObjectOutputStream</code> 的 <code>writeObject()</code> 将对象转换为字节流并输出。而 <code>writeObject()</code> 方法在传入的对象存在 <code>writeObject()</code> 的时候会去反射调用该对象的 <code>writeObject()</code> 来实现序列化。反序列化使用的是 <code>ObjectInputStream</code> 的 <code>readObject()</code> 方法，原理类似。 </p>
<h4 id="5-Fail-Fast"><a href="#5-Fail-Fast" class="headerlink" title="5. Fail-Fast"></a>5. Fail-Fast</h4><p>​        <strong><code>modCount</code> 用来记录 ArrayList 结构发生变化的次数</strong>。</p>
<blockquote>
<p>​        结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
</blockquote>
<p>​        在进行序列化或者迭代等操作时，需要比较操作前后 <code>modCount</code> 是否改变，如果改变了需要抛出 <code>ConcurrentModificationException</code>。代码参考上节序列化中的 <code>writeObject()</code> 方法。</p>
<p>​         <code>fail-fast</code> 机制是Java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生<code>fail-fast</code>事件。例如：当某一个线程A通过<code>iterator</code>去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出<code>ConcurrentModificationException</code>异常，产生<code>fail-fast</code>事件。</p>
<blockquote>
<p>​     <code>ConcurrentModificationException</code> 异常 ：  当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出该异常。 </p>
</blockquote>
<p>​        诚然，迭代器的<strong>快速失败</strong>行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出<code>ConcurrentModificationException</code>异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：<code>ConcurrentModificationException</code> 应该仅用于检测 bug。</p>
<p>​         线程环境下产生该异常的原因是在迭代器遍历集合时，使用了集合本身的<code>remove</code>方法而不是迭代器的； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在ArrayList进行<code>add</code>，<code>remove</code>，<code>clear</code>等涉及到修改集合中的元素个数的操作时，<code>modCount</code>就会发生改变<code>(modCount ++)</code>,所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使<code>modCount</code>发生变化，这样在<code>checkForComodification</code>方法中就会抛出<code>ConcurrentModificationException</code>异常。</p>
<p> <code>fail-fast</code>会在以下两种情况下抛出<code>ConcurrentModificationException</code> ：</p>
<blockquote>
<p>（1）单线程环境</p>
<p>集合被创建后，在遍历它的过程中修改了结构。</p>
<p>注意 <code>remove()</code>方法会让<code>expectModcount</code>和<code>modcount</code> 相等，所以是不会抛出这个异常。</p>
<p>（2）多线程环境</p>
<p>当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。</p>
</blockquote>
<p><strong>问题</strong>： fail-fast机制是如何检测的？</p>
<p>​        迭代器在遍历过程中是直接访问内部数据的，因此内部的数据在遍历的过程中无法被修改。为了保证不被修改，迭代器内部维护了一个标记 “<code>modCount</code>” ，当集合结构改变（添加删除或者修改），标记”<code>modCount</code>“会被修改，而迭代器每次的<code>hasNext()</code>和<code>next()</code>方法都会检查该”<code>modCount</code>“是否被改变，当检测到被修改时，抛出<code>ConcurrentModificationException</code> </p>
<h5 id="单线程情况"><a href="#单线程情况" class="headerlink" title="单线程情况"></a>单线程情况</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ ) &#123;</span><br><span class="line">           list.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                list.remove(<span class="number">3</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(iterator.next());</span><br><span class="line">           i ++;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是ArrayList单线程环境下的fail-fast ， 该段代码定义了一个Arraylist集合，并使用迭代器遍历，在遍历过程中，刻意在某一步迭代中remove一个元素，这个时候，就会发生fail-fast。 </p>
<img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581309298345.png" alt="1581309298345" style="zoom:80%;" align="center">

<p>如果将以上代码修改成在next之后进行迭代器的remove操作，就不会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ ) &#123;</span><br><span class="line">            list.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                iterator.remove(); <span class="comment">//  在next之后进行迭代器的remove操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>[0, 1, 2, 4, 5, 6, 7, 8, 9]</p>
</blockquote>
<p>​        所以，在对集合进行迭代过程中，<strong>不允许出现迭代器以外的对元素的操作</strong>， 因为这样会产生安全隐患，java会抛出异常并发修改异常<code>ConcurrentModificationException</code>， 普通迭代器只支持在迭代过程中的删除操作。</p>
<p>类似的，hashMap中发生的原理也是一样的。 </p>
<p> HashMap发生fail-fast ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++ ) &#123;</span><br><span class="line">           map.put(i+<span class="string">&quot;&quot;</span>, i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Iterator&lt;Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                map.remove(<span class="number">3</span>+<span class="string">&quot;&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">           System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">           i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该段代码定义了一个hashmap对象并存放了10个键值对，在迭代遍历过程中，使用map的remove方法移除了一个元素，导致抛出了<code>ConcurrentModificationException</code>异常： </p>
<p>​        <img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581310117229.png" alt="1581310117229" style="zoom:80%;" align="center"></p>
<p>类似，next之后调用迭代器的remove就可以成功删除。</p>
<h5 id="多线程情况"><a href="#多线程情况" class="headerlink" title="多线程情况"></a>多线程情况</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-10 12:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailFastTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                String s = iterator.next();</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">&quot;:&quot;</span> + s);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2:&quot;</span> + i);</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                    list.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            list.add(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MyThread1 thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">        MyThread2 thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        thread1.setName(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 启动两个线程，分别对其中一个对list进行迭代，另一个在线程1的迭代过程中去remove一个元素，结果也是抛出了<code>java.util.ConcurrentModificationException</code> </p>
<img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581310760678.png" alt="1581310760678" style="zoom:80%;" align="center">

<h5 id="避免fail-fast"><a href="#避免fail-fast" class="headerlink" title="避免fail-fast"></a><strong>避免fail-fast</strong></h5><p>方法一:</p>
<pre><code>     在单线程的遍历过程中，如果要进行`remove`操作，可以调用迭代器的`remove`方法而不是集合类的`remove`方法。看看ArrayList中迭代器的remove方法的源码:
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;  <span class="comment">/// 不会修改modCount，而是令其余expectedModCount相等</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​         可以看到，该remove方法并不会修改<code>modCount</code>的值，并且不会对后面的遍历造成影响，因为该方法remove不能指定元素，只能remove当前遍历过的那个元素，所以调用该方法并不会发生<code>fail-fast</code>现象。该方法有局限性，就是上面说的，只能代用next方法之后再调用迭代器的remove方法。</p>
<p>方法二：安全失败</p>
<p>​        使用java并发包<code>(java.util.concurrent)</code>中的类来代替ArrayList 和hashMap。<br>​        比如使用 <code>CopyOnWriterArrayList</code>代替<code>ArrayList</code>，<code>CopyOnWriterArrayList</code>在是使用上跟<code>ArrayList</code>几乎一样，<code>CopyOnWriter</code>是写时复制的容器(COW)，在读写时是线程安全的。该容器在对<code>add</code>和<code>remove</code>等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于<code>CopyOnWriterArrayLis</code>t在迭代过程并不会发生<code>fail-fast</code>现象。<strong>但 <code>CopyOnWrite</code>容器只能保证数据的最终一致性，不能保证数据的实时一致性。</strong><br>​        对于<code>HashMap</code>，可以使用<code>ConcurrentHashMap</code>，<code>ConcurrentHashMap</code>采用了<strong>锁机制</strong>，<strong>是线程安全的</strong>。在迭代方面，<code>ConcurrentHashMap</code>使用了一种不同的迭代方式。在这种迭代方式中，当<code>iterator</code>被创建后集合再发生改变就不再是抛出<code>ConcurrentModificationException</code>，取而代之的是：在改变时<code>new</code>新的数据从而不影响原有的数据 ，<code>iterator</code>完成后再将头指针替换为新的数据 ，这样<code>iterator</code>线程可以使用原来老的数据，而写线程也可以并发的完成改变。即迭代不会发生<code>fail-fast</code>，但不保证获取的是最新的数据。</p>
<h4 id="6-安全失败（fail—safe）"><a href="#6-安全失败（fail—safe）" class="headerlink" title="6. 安全失败（fail—safe）"></a>6. 安全失败（fail—safe）</h4><blockquote>
<pre><code>     快速失败（Fail-Fast）的场景： `java.util`包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。 
</code></pre>
</blockquote>
<p>​        采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。比如上面说的COW</p>
<blockquote>
<pre><code>   **原理：**由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。

   **缺点：**基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。
</code></pre>
</blockquote>
<p>​     场景：<code>java.util.concurrent</code>包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
<blockquote>
<p> 并发修改 ： 当一个或多个线程正在遍历一个集合Collection，此时另一个线程修改了这个集合的内容（添加，删除或者修改）。这就是并发修改 。</p>
</blockquote>
<p>fail-safe机制有两个问题</p>
<p>（1）需要复制集合，产生大量的无效对象，开销大。</p>
<p>（2）无法保证读取的数据是目前原始数据结构中的数据。</p>
<h4 id="7-fail-fast和-fail-safe-的区别"><a href="#7-fail-fast和-fail-safe-的区别" class="headerlink" title="7.  fail-fast和 fail-safe 的区别"></a>7.  fail-fast和 fail-safe 的区别</h4><table>
<thead>
<tr>
<th></th>
<th align="center">Fail Fast Iterator</th>
<th>Fail Safe Iterator</th>
</tr>
</thead>
<tbody><tr>
<td>Throw ConcurrentModification Exception</td>
<td align="center">Yes</td>
<td>No</td>
</tr>
<tr>
<td>Clone object</td>
<td align="center">No</td>
<td>Yes</td>
</tr>
<tr>
<td>Memory Overhead</td>
<td align="center">No</td>
<td>Yes</td>
</tr>
<tr>
<td>Examples</td>
<td align="center">HashMap,Vector,ArrayList,HashSet</td>
<td>CopyOnWriteArrayList, ConcurrentHashMap</td>
</tr>
</tbody></table>
<hr>
<h3 id="二、-Vector"><a href="#二、-Vector" class="headerlink" title="二、 Vector"></a>二、 Vector</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>也继承了RandomAccess接口， 可以随机访问。</p>
<h4 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h4><pre><code>     **它的实现与 ArrayList 类似，但是使用了 `synchronized` 进行同步。**
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-扩容-1"><a href="#2-扩容-1" class="headerlink" title="2 . 扩容"></a>2 . 扩容</h4><p>​            Vector 的构造函数可以传入 <code>capacityIncrement</code> 参数，它的作用是在扩容时使容量 <code>capacity</code> 增长 <code>capacityIncrement</code>。如果这个参数的值小于等于 0，扩容时每次都令 <code>capacity</code> 为原来的两倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs an empty vector with the specified initial capacity and</span></span><br><span class="line"><span class="comment">    * capacity increment. 构造函数</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   initialCapacity     数组的初始容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   capacityIncrement   扩容时使容量 `capacity` 增长 `capacityIncrement`</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">    *         is negative</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    	<span class="comment">// 如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​        调用没有 <code>capacityIncrement</code> 的构造函数时，<code>capacityIncrement</code> 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-与ArrayList的比较"><a href="#3-与ArrayList的比较" class="headerlink" title="3. 与ArrayList的比较"></a>3. 与ArrayList的比较</h4><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>
</ul>
<h4 id="4-替代方案"><a href="#4-替代方案" class="headerlink" title="4. 替代方案"></a>4. 替代方案</h4><p> 可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;</span><br><span class="line">       return (list instanceof RandomAccess ?</span><br><span class="line">               new SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">               new SynchronizedList&lt;&gt;(list));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list, Object mutex) &#123;</span><br><span class="line">       return (list instanceof RandomAccess ?</span><br><span class="line">               new SynchronizedRandomAccessList&lt;&gt;(list, mutex) :</span><br><span class="line">               new SynchronizedList&lt;&gt;(list, mutex));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p> 也可以使用 <code>concurrent</code> 并发包下的 <code>CopyOnWriteArrayList</code> 类。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="三、-CopyOnWriteArrayList"><a href="#三、-CopyOnWriteArrayList" class="headerlink" title="三、 CopyOnWriteArrayList"></a>三、 CopyOnWriteArrayList</h3><h4 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1. 读写分离"></a>1. 读写分离</h4><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     * 添加一个元素： 写操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);  <span class="comment">// 复制数组</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements); <span class="comment">// 写操作结束之后需要把原始数组指向新的复制数组。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 去锁操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h4><p>​        <code>CopyOnWriteArrayList</code> 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合<strong>读多写少</strong>的应用场景。</p>
<p>​    但是 <code>CopyOnWriteArrayList</code> 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 <code>CopyOnWriteArrayList</code> 不适合内存敏感以及对实时性要求很高的场景。</p>
<hr>
<h3 id="四、-Collections-与-Arrays"><a href="#四、-Collections-与-Arrays" class="headerlink" title="四、 Collections 与 Arrays"></a>四、 Collections 与 Arrays</h3><p>集合框架中的工具类中的方法都是静态的</p>
<p><strong>Collection中的常见方法：</strong></p>
<ol>
<li><p>对List进行二分查找： int binarySearch(list, key)</p>
<p>​     int binarySearch(list, key, Comparator)</p>
<p>​    二分查找需要列表有序</p>
</li>
<li><p>对list集合进行排序</p>
<p>sort(list):  其实是使用list容器中对象的CompareTo方法</p>
<p>sort(list, comparator) //按照指定比较器进行排序</p>
</li>
<li><p>对集合取最大值或者最小值 </p>
<p>​    max（collection）   min（collection）</p>
</li>
<li><p>对集合进行反转</p>
<p>​    reverse(list)</p>
</li>
<li><p>对比较方式强行逆转</p>
<p>​    Comparator reverseOrder();</p>
<p>​    Comparator reverseOrder(Comparator);</p>
</li>
<li><p>对list中的元素的位置进行替换</p>
<p>​    swap(list, x, y);</p>
</li>
<li><p>对集合中的元素进行替换， 如果被替换的元素不存在， 那么原来的集合不变</p>
<p>​        replaceAll(list, old, new);</p>
</li>
<li><p>将集合变成数组</p>
<p>​    Collection.toArray()  【collection不是Collections工具类】</p>
</li>
</ol>
<p>Arrays： 用于对数组操作的工具类: Arrays.方法()</p>
<ol>
<li><p>二分查找， 需要数组有序</p>
<p>binarySearch(int [])</p>
</li>
<li><p>数组排序</p>
<p>sort(int [])</p>
</li>
<li><p> 将数组变成字符串</p>
</li>
</ol>
<p>   toString(int [])</p>
<ol start="4">
<li><p>复制数组</p>
<p>​    copyOf()</p>
</li>
<li><p>复制部分数组</p>
<p>copyOfRange()</p>
</li>
<li><p>比较两个数组是否相同</p>
<p>equals(int [], int [])</p>
</li>
<li><p><strong>将数组变成集合</strong>：<br>List  asList(T [])</p>
<p>这样可以通过结合的操作来操作数组中的元素，但是不可以死使用增删方法， add， remove，因为数组的长度固定，会出现UnsupportOperationException.</p>
<hr>
</li>
</ol>
<h3 id="五、-LinkedList"><a href="#五、-LinkedList" class="headerlink" title="五、 LinkedList"></a>五、 LinkedList</h3><h4 id="1-概览-1"><a href="#1-概览-1" class="headerlink" title="1. 概览"></a>1. 概览</h4><p>​         基于双向链表实现，使用 Node 存储链表节点信息。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to first node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointer to last node.</span></span><br><span class="line"><span class="comment">     * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">     *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个链表存储了first和last指针，用Node来保存链表节点信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581314794535.png" alt="1581314794535" style="zoom:80%;" align="center">



<h4 id="2-与ArrayList的比较"><a href="#2-与ArrayList的比较" class="headerlink" title="2.与ArrayList的比较"></a>2.与ArrayList的比较</h4><p>​    <code>ArrayList</code> 基于动态数组实现，<code>LinkedList</code> 基于双向链表实现。<code>ArrayList</code> 和 <code>LinkedList</code> 的区别可以归结为数组和链表的区别：</p>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li>
<li>链表不支持随机访问，但插入删除只需要改变指针。</li>
</ul>
<hr>
<h3 id="六、-HashMap"><a href="#六、-HashMap" class="headerlink" title="六、 HashMap"></a>六、 HashMap</h3><p>为了便于理解，以下源码分析以 JDK 1.7 为主。 </p>
<h4 id="1-存储结构"><a href="#1-存储结构" class="headerlink" title="1. 存储结构"></a>1. 存储结构</h4><p>内部包含了一个 <code>Entry</code> 类型的数组 <code>table</code>。<code>Entry</code> 存储着键值对。它包含了四个字段，从 <code>next</code> 字段我们可以看出 <code>Entry</code> 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。<code>HashMap</code> 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 <code>Entry</code>。 </p>
<img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581315156142.png" alt="1581315156142" style="zoom:80%;" align="center">

<p>以下源码基于JDK1.7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        HashMap中两个参数会影响他的性能：初始容量和装载因子。初始容量是指哈希表中桶的个数，即哈希表的大小； 装载因子是表示hash表中元素的填满的程度，装 载因子越大，填满的元素越多，好处是，空间利用率高了，但冲突的机会加大了；反之，加载因子越小，填满的元素越少，好处是冲突的机会减小了，但空间浪费多了。</p>
<p>​        冲突的机会越大，则查找的成本越高。反之，查找的成本越小，查找时间就越小。 因此，必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷，这种平衡与折衷本质上是数据结构中有名的**”时-空”矛盾**的平衡与折衷。</p>
<p>​        HashMap默认的装载因子是0.75，最大容量是16，因此可以得出HashMap的默认容量是：0.75*16=12。</p>
<p>用户可以自定义最大容量和装载因子。</p>
<p>​    HashMap 包含如下几个构造器：</p>
<ul>
<li>HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。</li>
<li>HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。</li>
<li>HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。</li>
</ul>
<h4 id="2-拉链法工作原理"><a href="#2-拉链法工作原理" class="headerlink" title="2. 拉链法工作原理"></a>2. 拉链法工作原理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;K1&quot;</span>, <span class="string">&quot;V1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K2&quot;</span>, <span class="string">&quot;V2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K3&quot;</span>, <span class="string">&quot;V3&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>新建一个 HashMap，默认大小为 16；</p>
</li>
<li><p>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</p>
</li>
<li><p>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</p>
</li>
<li><p>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</p>
<p>​    应该注意到链表的插入是以<strong>头插法</strong>方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。查找需要分成两步进行：</p>
</li>
<li><p> 计算键值对所在的桶；</p>
</li>
<li><p>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</p>
</li>
</ul>
<img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/1581331248644.png" alt="1581331248644" style="zoom:80%;" align="center">

<p>​    </p>
<h4 id="3-put操作"><a href="#3-put操作" class="headerlink" title="3. put操作"></a>3. put操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​     使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在JDK1-8中的put操作："><a href="#在JDK1-8中的put操作：" class="headerlink" title="在JDK1.8中的put操作："></a><strong>在JDK1.8中的put操作：</strong></h5> <img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/58e67eae921e4b431782c07444af824e_hd.png" alt="img" style="zoom:80%;" align="center"> 

<p> 思路如下：</p>
<p>1.table[]是否为空</p>
<p>2.判断table[i]处是否插入过值</p>
<p>3.判断链表长度是否大于8，如果大于就转换为<strong>红黑二叉树</strong>，并插入树中</p>
<p>4.判断key是否和原有key相同，如果相同就覆盖原有key的value，并返回原有value</p>
<p>5.如果key不相同，就插入一个key，记录结构变化一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">//判断table是否为空，如果是空的就创建一个table，并获取他的长度</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="comment">//如果计算出来的索引位置之前没有放过数据，就直接放入</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;  <span class="comment">//进入这里说明索引位置已经放入过数据了</span></span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//判断put的数据和之前的数据是否重复</span></span><br><span class="line">             <span class="comment">//key的地址或key的equals()只要有一个相等就认为key重复了，就直接覆盖原来key的value</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断是否是红黑树，如果是红黑树就直接插入树中</span></span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123; <span class="comment">//如果不是红黑树，就遍历每个节点，判断链表长度是否大于8，如果大于就转换为红黑树</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash); <span class="comment">// 转换为红黑树</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                    <span class="comment">// 判断索引每个元素的key是否可要插入的key相同，如果相同就直接覆盖</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果e不是null，说明没有迭代到最后就跳出了循环，说明链表中有相同的key，因此只需要将value覆盖，并将oldValue返回即可</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//说明没有key相同，因此要插入一个key-value，并记录内部结构变化次数</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// 扩容</span></span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict); <span class="comment">// 这个是给LinkedHashMap用的，HashMap里也是个空实现</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 添加成功返回null</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-确定桶下标"><a href="#4-确定桶下标" class="headerlink" title="4. 确定桶下标"></a>4. 确定桶下标</h4><p> 很多操作都需要先确定一个键值对所在的桶下标。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>

<h5 id="4-1-计算-hash-值（1-7）"><a href="#4-1-计算-hash-值（1-7）" class="headerlink" title="4.1  计算 hash 值（1.7）"></a>4.1  计算 hash 值（1.7）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-取模"><a href="#4-2-取模" class="headerlink" title="4.2  取模"></a><strong>4.2  取模</strong></h5><p> 令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x   : <span class="number">00010000</span></span><br><span class="line">x<span class="number">-1</span> : <span class="number">00001111</span></span><br></pre></td></tr></table></figure>

<p> 令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">y       : <span class="number">10110010</span></span><br><span class="line">x-<span class="number">1</span>     : <span class="number">00001111</span></span><br><span class="line">y&amp;(x-<span class="number">1</span>) : <span class="number">00000010</span></span><br></pre></td></tr></table></figure>

<p> 这个性质和 y 对 x 取模效果是一样的： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">y   : <span class="number">10110010</span></span><br><span class="line">x   : <span class="number">00010000</span></span><br><span class="line">y%x : <span class="number">00000010</span></span><br></pre></td></tr></table></figure>

<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-4-在JDK1-8中的hash方法"><a href="#4-4-在JDK1-8中的hash方法" class="headerlink" title="4.4 在JDK1.8中的hash方法"></a>4.4 在JDK1.8中的hash方法</h5><p> <code>hash()</code>方法其实顾名思义就是用来获取key的hash的一个hash值的,但是HashMap里的hash()方法似乎与一般的直接key.hashCode()不太一样，我们先看看它到底是什么样的神奇操作。 其源码如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;  </span><br><span class="line">    <span class="comment">// key是null就返回0，key不是null就先取hashCode（）然后与这个hashCode（）无符号右移进行亦或运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); <span class="comment">// 将hashCode的值异或他的高16位获取到hash值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这是因为找key的位置时，<code>(n - 1) &amp; hash</code>是table的索引，n的长度不够大时，只和hashCode()的低16位有关，这样发生冲突的概率就变高</p>
<p>​    为减少这种影响，设计者权衡了speed, utility, and quality，将高16位与低16位异或来减少这种影响。设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，既减少了系统的开销，也不会造成的因为高16位没有参与下标的计算(table长度比较小时)而引起的碰撞。</p>
<p>​         我们知道hashCode本身是一个32位的int类型，进行这样的操作就等于将hashCode的高16位异或它的低16位得到一个新的hash值。 </p>
 <img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/8e8203c1b51be6446cda4026eaaccf19_hd.png" alt="img" style="zoom:80%;" align="center">  

<p>但是拿到这样一个hash值的作用是什么呢？我们可以先想一下如何利用key的hash值确定每个key的哈希桶索引位置而且还需要尽量均衡。第一个想到的当然是用hash值对哈希桶的长度(length)进行取模的操作。即:                                          <strong>index = hash % length</strong> </p>
<p>这种方式可以用随机的hash值算出随机的索引并且分配也尽量均匀。没错！!HashMap也是这么想的。但是这种取模运算本身是对CPU运算开销比较大的，为了优化速度，HashMap采取了更优雅的方式，在putVal的核心代码可以看到HashMap采用了hash值”与”length-1的方式来确定索引位置。即：</p>
<p>​                                        <strong>index = hash &amp; length-1</strong></p>
<p>hash()方法中的高16位异或16位的计算方式，是在JDK1.8之后才加上的，在JDK1.7及之前的版本里是indexFor()方法，直接用hashCode&amp;length-1计算出索引位置。这个是jdk1.7和jdk1.8中的区别。</p>
<h4 id="5-扩容-基本原理"><a href="#5-扩容-基本原理" class="headerlink" title="5. 扩容-基本原理"></a>5. 扩容-基本原理</h4><p>设 HashMap 的 table 长度为 <code>M</code>，需要存储的键值对数量为 <code>N</code>，如果哈希函数满足<strong>均匀性</strong>的要求，那么每条链表的长度大约为 <code>N/M</code>，因此查找的复杂度为 <code>O(N/M)</code>。</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td align="center">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td>size</td>
<td align="center">键值对数量。</td>
</tr>
<tr>
<td>threshold</td>
<td align="center">size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td>loadFactor</td>
<td align="center">装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;  <span class="comment">// 默认的初始容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//  最大容量  2 的 30次方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;  <span class="comment">// 默认的装载因子为0.75</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">// size就是HashMap中键值对的总个数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold;  <span class="comment">// size 的临界值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">// 记录是发生内部结构变化的次数， fail-fast需要用</span></span><br><span class="line"> <span class="comment">// 如果put值，但是put的值是覆盖原有的值，这样是不算内部结构变化的。</span></span><br></pre></td></tr></table></figure>

<p>​         <code>threshold=装载因子 * capacity</code>  ，也就是说数组长度固定以后， 如果负载因子越大，所能容纳的元素个数越多，如果超过这个值就会进行扩容(默认是扩容为原来的2倍)，0.75这个值是权衡过空间和时间得出的，建议大家不要随意修改，如果在一些特殊情况下，比如空间比较多，但要求速度比较快，这时候就可以把扩容因子调小以较少hash冲突的概率。相反就增大扩容因子(这个值可以大于1)。 </p>
<p>​     因为HashMap扩容每次都是扩容为原来的2倍，所以<code>capacity</code> 总是2的次方，这是非常规的设置，<strong>常规设置是把桶的大小设置为素数，因为素数发生hash冲突的概率要小于合数</strong>，比如HashTable的默认值设置为11，就是桶的大小为素数的应用(HashTable扩容后不能保证是素数)。HashMap采用这种设置是为了在取模和扩容的时候做出优化。 </p>
<p> 从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);  <span class="comment">// 两倍扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 扩容使用 <code>resize()</code> 实现，需要注意的是，扩容操作同样需要把 <code>oldTable</code> 的所有键值对重新插入 <code>newTable</code> 中，因此这一步是很费时的。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;<span class="comment">// 传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;  <span class="comment">// 引用扩容前的Entry数组</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123; <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity]; <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);  <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable; <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor); <span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table; <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j]; <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>; <span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                newTable[i] = e; <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next; <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 </p>
<p>​        下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 </p>
 <img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/e5aa99e811d1814e010afa7779b759d4_hd.png" alt="img" style="zoom:80%;"> 

<p>​        下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
  <img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/a285d9b2da279a18b052fe5eed69afe9_hd.png" alt="img" style="zoom:80%;" align="center"> 

<p>​        元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： </p>
 <img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/b2cb057773e3d67976c535d6ef547d51_hd.png" alt="img" style="zoom:80%;" align="center"> 

<p>​        因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
 <img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/544caeb82a329fa49cc99842818ed1ba_hd.png" alt="img" style="zoom:80%;" align="center"> 

<p>​        这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-扩容-重新计算桶下标"><a href="#6-扩容-重新计算桶下标" class="headerlink" title="6. 扩容-重新计算桶下标"></a>6. 扩容-重新计算桶下标</h4><p>​        在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash%capacity 来确定桶下标。HashMap <code>capacity</code> 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p>
<p>​        假设原数组长度 <code>capacity</code> 为 16，扩容之后 <code>new capacity</code> 为 32：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">capacity     : <span class="number">00010000</span></span><br><span class="line"><span class="keyword">new</span> capacity : <span class="number">00100000</span></span><br></pre></td></tr></table></figure>

<p> 对于一个 Key，它的哈希值 hash 在第 5 位： </p>
<ul>
<li>为 0，那么 <code>hash%00010000 = hash%00100000</code>，桶位置和原来一致；</li>
<li>为 1，<code>hash%00010000 = hash%00100000 + 16</code>，桶位置是原位置 + 16。</li>
</ul>
<h4 id="7-计算数组容量"><a href="#7-计算数组容量" class="headerlink" title="7. 计算数组容量"></a>7. 计算数组容量</h4><p>​    这里先了解一下基本的位运算</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">计算方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">与 &amp;</td>
<td align="center">只有两个数同一位都是1才会返回1</td>
</tr>
<tr>
<td align="center">或 l</td>
<td align="center">两个数同一位只要存在一个1就是1</td>
</tr>
<tr>
<td align="center">异或 ^</td>
<td align="center">两个数同一位不能相同才为1</td>
</tr>
<tr>
<td align="center">左移 &lt;&lt;</td>
<td align="center">所有位置左移，低位补0</td>
</tr>
<tr>
<td align="center">右移 &gt;&gt;</td>
<td align="center">正数：所有位置右移，高位补0 负数：写出补码（符号位不变，其余位置取反，然后加1），所有位置右移高位补1，然后再获取原码（符号位不变，其余位置取反，然后加1）</td>
</tr>
<tr>
<td align="center">无符号右移 &gt;&gt;</td>
<td align="center">无论正负高位补0</td>
</tr>
</tbody></table>
<p>​        HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到： 用num与num左移的数字做或运算赋给num 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mask |= mask &gt;&gt; <span class="number">1</span>    <span class="number">11011000</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="number">2</span>    <span class="number">11111110</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="number">4</span>    <span class="number">11111111</span></span><br></pre></td></tr></table></figure>

<p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">num     <span class="number">10010000</span></span><br><span class="line">mask+<span class="number">1</span> <span class="number">100000000</span></span><br></pre></td></tr></table></figure>

<p> 以下是 HashMap 中计算数组容量的代码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-链表转红黑树"><a href="#8-链表转红黑树" class="headerlink" title="8. 链表转红黑树"></a>8. 链表转红黑树</h4><p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</p>
  <img src="/2020/02/01/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/8db4a3bdfb238da1a1c4431d2b6e075c_r.jpg" alt="preview" style="zoom:80%;">  







<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p><a href="https://cyc2018.github.io/CS-Notes">https://cyc2018.github.io/CS-Notes</a> </p>
</li>
<li><p><a href="https://www.cnblogs.com/cdream-zs/p/9997861.html">超详细的HashMap解析(jdk1.8)</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/duodushuduokanbao/p/9492952.html">HashMap JDK1.8实现原理</a></p>
</li>
<li><p><a href="https://blog.csdn.net/zymx14/article/details/78394464">java中的fail-fast(快速失败)机制</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/songanwei/p/9387745.html">面试题思考：java中快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/21673805">Java 8系列之重新认识HashMap</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里巴巴开源的Java性能诊断工具Arthas详解</title>
    <url>/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="一、Arthas"><a href="#一、Arthas" class="headerlink" title="一、Arthas"></a>一、Arthas</h1><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。</p>
<p>当你遇到以下类似问题而束手无策时，<code>Arthas</code>可以帮助你解决：</p>
<ol>
<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>
<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到JVM的实时运行状态？</li>
<li>怎么快速定位应用的热点，生成火焰图？</li>
<li>怎样直接从JVM内查找某个类的实例？</li>
</ol>
<p><code>Arthas</code>支持JDK6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p>
<h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><h2 id="使用arthas-boot（推荐）"><a href="#使用arthas-boot（推荐）" class="headerlink" title="使用arthas-boot（推荐）"></a>使用<code>arthas-boot</code>（推荐）</h2><p>下载<code>arthas-boot.jar</code>，然后用<code>java -jar</code>的方式启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p>打印帮助信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar arthas-boot.jar -h</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果下载速度比较慢，可以使用aliyun的镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar arthas-boot.jar --repo-mirror aliyun --use-http</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用as-sh"><a href="#使用as-sh" class="headerlink" title="使用as.sh"></a>使用<code>as.sh</code></h2><p>Arthas 支持在 Linux/Unix/Mac 等平台上一键安装，请复制以下内容，并粘贴到命令行中，敲 <code>回车</code> 执行即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://arthas.aliyun.com/install.sh | sh</span><br></pre></td></tr></table></figure>

<p>上述命令会下载启动脚本文件 <code>as.sh</code> 到当前目录，你可以放在任何地方或将其加入到 <code>$PATH</code> 中。</p>
<p>直接在shell下面执行<code>./as.sh</code>，就会进入交互界面。</p>
<p>也可以执行<code>./as.sh -h</code>来获取更多参数信息。</p>
<h2 id="全量安装"><a href="#全量安装" class="headerlink" title="全量安装"></a>全量安装</h2><p>最新版本，点击下载：<a href="https://arthas.aliyun.com/download/latest_version?mirror=aliyun"><img src="https://img.shields.io/maven-central/v/com.taobao.arthas/arthas-packaging.svg?style=flat-square" alt="Arthas"></a></p>
<p>解压后，在文件夹里有<code>arthas-boot.jar</code>，直接用<code>java -jar</code>的方式启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<h1 id="三、快速使用"><a href="#三、快速使用" class="headerlink" title="三、快速使用"></a>三、快速使用</h1><h2 id="1-启动math-game"><a href="#1-启动math-game" class="headerlink" title="1. 启动math-game"></a>1. 启动math-game</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/math-game.jar</span><br><span class="line">java -jar math-game.jar</span><br></pre></td></tr></table></figure>

<p><code>math-game</code>是一个简单的程序，每隔一秒生成一个随机数，再执行质因数分解，并打印出分解结果。</p>
<p><code>math-game</code>源代码：<a href="https://github.com/alibaba/arthas/blob/master/math-game/src/main/java/demo/MathGame.java">查看</a></p>
<h2 id="2-启动arthas"><a href="#2-启动arthas" class="headerlink" title="2. 启动arthas"></a>2. 启动arthas</h2><p>在命令行下面执行（使用和目标进程一致的用户启动，否则可能attach失败）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<ul>
<li>执行该程序的用户需要和目标进程具有相同的权限。比如以<code>admin</code>用户来执行：<code>sudo su admin &amp;&amp; java -jar arthas-boot.jar</code> 或 <code>sudo -u admin -EH java -jar arthas-boot.jar</code>。</li>
<li>如果attach不上目标进程，可以查看<code>~/logs/arthas/</code> 目录下的日志。</li>
<li>如果下载速度比较慢，可以使用aliyun的镜像：<code>java -jar arthas-boot.jar --repo-mirror aliyun --use-http</code></li>
<li><code>java -jar arthas-boot.jar -h</code> 打印更多参数信息。</li>
</ul>
<p>选择应用java进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ $ java -jar arthas-boot.jar</span><br><span class="line">* [1]: 35542</span><br><span class="line">  [2]: 71560 math-game.jar</span><br></pre></td></tr></table></figure>

<p><code>math-game</code>进程是第2个，则输入2，再输入<code>回车/enter</code>。Arthas会attach到目标进程上，并输出日志</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626505201869.png" class width="1626505201869">

<h1 id="四、常用命令"><a href="#四、常用命令" class="headerlink" title="四、常用命令"></a>四、常用命令</h1><ol>
<li>dashboard仪表盘</li>
<li>通过thread命令来获取到arthas-demo进程的Main Class</li>
<li>通过jad反编译Main Class</li>
<li>watch</li>
</ol>
<h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><h3 id="1-dashboard仪表盘"><a href="#1-dashboard仪表盘" class="headerlink" title="1. dashboard仪表盘"></a>1. dashboard仪表盘</h3><p> 输入<a href="https://arthas.aliyun.com/doc/dashboard.html">dashboard</a>，按<code>回车/enter</code>，会展示当前进程的信息，按<code>ctrl+c</code>可以中断执行。 </p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626505589443.png" class width="1626505589443">

<ol>
<li>第一部分是显示JVM中运行的所有线程：所在的线程组，优先级，线程的状态，CPU的利用率，是否是后台进程等。</li>
<li>第二部分显示的是JVM内存的使用情况等</li>
<li>第三部分是操作系统的一些信息和Java版本号</li>
</ol>
<ul>
<li>ID: Java级别的线程ID，注意这个ID不能跟jstack中的nativeID一一对应。</li>
<li>NAME: 线程名</li>
<li>GROUP: 线程组名</li>
<li>PRIORITY: 线程优先级, 1~10之间的数字，越大表示优先级越高</li>
<li>STATE: 线程的状态</li>
<li>CPU%: 线程的cpu使用率。比如采样间隔1000ms，某个线程的增量cpu时间为100ms，则cpu使用率=100/1000=10%</li>
<li>DELTA_TIME: 上次采样之后线程运行增量CPU时间，数据格式为<code>秒</code></li>
<li>TIME: 线程运行总CPU时间，数据格式为<code>分:秒</code></li>
<li>INTERRUPTED: 线程当前的中断位状态</li>
<li>DAEMON: 是否是daemon线程</li>
</ul>
<h3 id="2-通过thread命令来获取到arthas-demo进程的Main-Class"><a href="#2-通过thread命令来获取到arthas-demo进程的Main-Class" class="headerlink" title="2. 通过thread命令来获取到arthas-demo进程的Main Class"></a>2. 通过thread命令来获取到arthas-demo进程的Main Class</h3><p>获取到arthas-demo进程的Main Class</p>
<p>thread 1 会打印线程ID为1 的栈信息，通常是main函数的线程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Threads Total: 24, NEW: 0, RUNNABLE: 7, BLOCKED: 0, WAITING: 4, TIMED_WAITING: 3, TERMINATED: 0, Internal threads: 10</span><br><span class="line">ID      NAME                                              GROUP                    PRIORITY         STATE            %CPU            DELTA_TIME       TIME             INTERRUPTED     DAEMON</span><br><span class="line">-1      VM Periodic Task Thread                           -                        -1               -                0.13            0.000            0:0.804          false           true</span><br><span class="line">22      arthas-command-execute                            system                   5                RUNNABLE         0.09            0.000            0:0.004          false           true</span><br><span class="line">-1      C1 CompilerThread2                                -                        -1               -                0.06            0.000            0:0.587          false           true</span><br><span class="line">2       Reference Handler                                 system                   10               WAITING          0.0             0.000            0:0.001          false           true</span><br><span class="line">3       Finalizer                                         system                   8                WAITING          0.0             0.000            0:0.004          false           true</span><br><span class="line">4       Signal Dispatcher                                 system                   9                RUNNABLE         0.0             0.000            0:0.000          false           true</span><br><span class="line">9       Attach Listener                                   system                   9                RUNNABLE         0.0             0.000            0:0.010          false           true</span><br><span class="line">11      arthas-timer                                      system                   9                WAITING          0.0             0.000            0:0.000          false           true</span><br><span class="line">14      arthas-NettyHttpTelnetBootstrap-3-1               system                   5                RUNNABLE         0.0             0.000            0:0.020          false           true</span><br><span class="line">15      arthas-NettyWebsocketTtyBootstrap-4-1             system                   5                RUNNABLE         0.0             0.000            0:0.001          false           true</span><br><span class="line">16      arthas-NettyWebsocketTtyBootstrap-4-2             system                   5                RUNNABLE         0.0             0.000            0:0.002          false           true</span><br><span class="line">17      arthas-shell-server                               system                   9                TIMED_WAITING    0.0             0.000            0:0.002          false           true</span><br><span class="line">18      arthas-session-manager                            system                   9                TIMED_WAITING    0.0             0.000            0:0.001          false           true</span><br><span class="line">19      arthas-UserStat                                   system                   9                WAITING          0.0             0.000            0:0.000          false           true</span><br><span class="line">21      arthas-NettyHttpTelnetBootstrap-3-2               system                   5                RUNNABLE         0.0             0.000            0:0.200          false           true</span><br><span class="line">1       main                                              main                     5                TIMED_WAITING    0.0             0.000            0:0.230          false           false</span><br><span class="line">-1      GC task thread#1 (ParallelGC)                     -                        -1               -                0.0             0.000            0:0.030          false           true</span><br><span class="line">-1      VM Thread                                         -                        -1               -                0.0             0.000            0:0.152          false           true</span><br><span class="line">-1      GC task thread#2 (ParallelGC)                     -                        -1               -                0.0             0.000            0:0.031          false           true</span><br><span class="line">-1      GC task thread#3 (ParallelGC)                     -                        -1               -                0.0             0.000            0:0.030          false           true</span><br><span class="line">-1      GC task thread#0 (ParallelGC)                     -                        -1               -                0.0             0.000            0:0.028          false           true</span><br><span class="line">-1      C2 CompilerThread0                                -                        -1               -                0.0             0.000            0:0.704          false           true</span><br><span class="line">-1      Service Thread                                    -                        -1               -                0.0             0.000            0:0.000          false           true</span><br><span class="line">-1      C2 CompilerThread1                                -                        -1               -                0.0             0.000            0:0.535          false           true</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">thread 1</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626506001436.png" class width="1626506001436">

<h3 id="3-通过jad反编译Main-Class"><a href="#3-通过jad反编译Main-Class" class="headerlink" title="3. 通过jad反编译Main Class"></a>3. 通过jad反编译Main Class</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jad demo.MathGame</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626506236303.png" class width="1626506236303">

<h3 id="4-watch监视-（debug）"><a href="#4-watch监视-（debug）" class="headerlink" title="4. watch监视 （debug）"></a>4. watch监视 （debug）</h3><p>通过watch命令来查看<code>demo.MathGame#primeFactors</code> 函数的返回值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch demo.MathGame primeFactors returnObj</span><br><span class="line">		包名+类名      函数名		ongl表达式</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[arthas@29058]$</span><span class="bash"> watch demo.MathGame primeFactors returnObj</span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class count: 1 , method count: 1) cost in 77 ms, listenerId: 1</span><br><span class="line">method=demo.MathGame.primeFactors location=AtExceptionExit</span><br><span class="line">ts=2021-07-17 15:22:29; [cost=0.58359ms] result=null</span><br><span class="line">method=demo.MathGame.primeFactors location=AtExit</span><br><span class="line">ts=2021-07-17 15:22:30; [cost=0.09676ms] result=@ArrayList[</span><br><span class="line">    @Integer[2], # 第一个整数</span><br><span class="line">    @Integer[7],</span><br><span class="line">    @Integer[11],</span><br><span class="line">    @Integer[557],</span><br><span class="line">]</span><br><span class="line">method=demo.MathGame.primeFactors location=AtExit</span><br><span class="line">ts=2021-07-17 15:22:31; [cost=0.03972ms] result=@ArrayList[</span><br><span class="line">    @Integer[2],</span><br><span class="line">    @Integer[3],</span><br><span class="line">    @Integer[17],</span><br><span class="line">    @Integer[1151],</span><br><span class="line">]</span><br><span class="line">method=demo.MathGame.primeFactors location=AtExceptionExit</span><br><span class="line">ts=2021-07-17 15:22:32; [cost=0.049295ms] result=null # 不能分解</span><br><span class="line">method=demo.MathGame.primeFactors location=AtExit</span><br><span class="line">ts=2021-07-17 15:22:33; [cost=0.763201ms] result=@ArrayList[</span><br><span class="line">    @Integer[65809],</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-退出arthas"><a href="#5-退出arthas" class="headerlink" title="5. 退出arthas"></a>5. 退出arthas</h3><p>如果只是退出当前的连接，可以用<code>quit</code>或者<code>exit</code>命令。Attach到目标进程上的arthas还会继续运行，端口会保持开放，下次连接时可以直接连接上。</p>
<p>如果想完全退出arthas，可以执行<code>stop</code>命令。</p>
<h1 id="五、基础命令"><a href="#五、基础命令" class="headerlink" title="五、基础命令"></a>五、基础命令</h1><ul>
<li><p>help——查看命令帮助信息</p>
</li>
<li><p><a href="https://arthas.aliyun.com/doc/cat.html">cat</a>——打印文件内容，和linux里的cat命令类似</p>
</li>
<li><p><a href="https://arthas.aliyun.com/doc/echo.html">echo</a>–打印参数，和linux里的echo命令类似</p>
</li>
<li><p><a href="https://arthas.aliyun.com/doc/grep.html">grep</a>——匹配查找，和linux里的grep命令类似</p>
<p>但是它只能用于管道命令</p>
<p>语法：</p>
<hr>
<table>
<thead>
<tr>
<th align="center">参数列表</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-n</td>
<td align="center">显示行号</td>
</tr>
<tr>
<td align="center">-i</td>
<td align="center">忽略大小写查找</td>
</tr>
<tr>
<td align="center">-m 行数</td>
<td align="center">最大显示行数，要与查询字符串一起使用</td>
</tr>
<tr>
<td align="center">-e “正则表达式”</td>
<td align="center">使用正则表达式查找</td>
</tr>
</tbody></table>
<p> 如：</p>
<ol>
<li><p>只显示包含java字符串的行系统属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysprop | grep java</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626509042267.png" class width="1626509042267"></li>
<li><p>只显示10行，并显示出行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysprop | grep java -n -m10</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><a href="https://arthas.aliyun.com/doc/base64.html">base64</a>——base64编码转换，和linux里的base64命令类似</p>
</li>
<li><p><a href="https://arthas.aliyun.com/doc/tee.html">tee</a>——复制标准输入到标准输出和指定的文件，和linux里的tee命令类似</p>
<p> tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EXAMPLES:</span><br><span class="line">  sysprop | tee /path/to/logfile | grep java</span><br><span class="line">  sysprop | tee -a /path/to/logfile | grep java</span><br></pre></td></tr></table></figure>

<p>-a 参数是追加到文件</p>
</li>
<li><p><a href="https://arthas.aliyun.com/doc/pwd.html">pwd</a>——返回当前的工作目录，和linux命令类似</p>
</li>
<li><p>cls——清空当前屏幕区域</p>
</li>
<li><p>session——查看当前会话的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Name        Value</span><br><span class="line">--------------------------------------------------</span><br><span class="line"> JAVA_PID    29058</span><br><span class="line"> SESSION_ID  dfad3e36-c62f-49b4-906f-494f030a5c50</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://arthas.aliyun.com/doc/reset.html">reset</a>——重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭时会重置所有增强过的类。</p>
<blockquote>
<p>Arthas在 watch/trace 等命令时，实际上是修改了应用的字节码，插入增强的代码。显式执行 <code>reset</code> 命令，可以清除掉这些增强代码。 </p>
</blockquote>
<p>语法：</p>
<p>1、 还原指定类：reset Test</p>
<p>2、还原所有以List结尾的类：reset *List</p>
<p>3、还原所有的类：reset</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626510139591.png" class width="1626510139591"></li>
<li><p>version——输出当前目标 Java 进程所加载的 Arthas 版本号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[arthas@29058]$</span><span class="bash"> version</span></span><br><span class="line">3.5.2</span><br></pre></td></tr></table></figure></li>
<li><p>history——打印命令历史</p>
</li>
<li><p>quit——退出当前 Arthas 客户端，其他 Arthas 客户端不受影响</p>
</li>
<li><p>stop——关闭 Arthas 服务端，所有 Arthas 客户端全部退出</p>
</li>
<li><p><a href="https://arthas.aliyun.com/doc/keymap.html">keymap</a>——Arthas快捷键列表及自定义快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>快捷键说明</th>
<th>命令名称</th>
<th>命令说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;\C-a&quot;</code></td>
<td>ctrl + a</td>
<td>beginning-of-line</td>
<td>跳到行首</td>
</tr>
<tr>
<td><code>&quot;\C-e&quot;</code></td>
<td>ctrl + e</td>
<td>end-of-line</td>
<td>跳到行尾</td>
</tr>
<tr>
<td><code>&quot;\C-f&quot;</code></td>
<td>ctrl + f</td>
<td>forward-word</td>
<td>向前移动一个单词</td>
</tr>
<tr>
<td><code>&quot;\C-b&quot;</code></td>
<td>ctrl + b</td>
<td>backward-word</td>
<td>向后移动一个单词</td>
</tr>
<tr>
<td><code>&quot;\e[D&quot;</code></td>
<td>键盘左方向键</td>
<td>backward-char</td>
<td>光标向前移动一个字符</td>
</tr>
<tr>
<td><code>&quot;\e[C&quot;</code></td>
<td>键盘右方向键</td>
<td>forward-char</td>
<td>光标向后移动一个字符</td>
</tr>
<tr>
<td><code>&quot;\e[B&quot;</code></td>
<td>键盘下方向键</td>
<td>next-history</td>
<td>下翻显示下一个命令</td>
</tr>
<tr>
<td><code>&quot;\e[A&quot;</code></td>
<td>键盘上方向键</td>
<td>previous-history</td>
<td>上翻显示上一个命令</td>
</tr>
<tr>
<td><code>&quot;\C-h&quot;</code></td>
<td>ctrl + h</td>
<td>backward-delete-char</td>
<td>向后删除一个字符</td>
</tr>
<tr>
<td><code>&quot;\C-?&quot;</code></td>
<td>ctrl + shift + /</td>
<td>backward-delete-char</td>
<td>向后删除一个字符</td>
</tr>
<tr>
<td><code>&quot;\C-u&quot;</code></td>
<td>ctrl + u</td>
<td>undo</td>
<td>撤销上一个命令，相当于清空当前行</td>
</tr>
<tr>
<td><code>&quot;\C-d&quot;</code></td>
<td>ctrl + d</td>
<td>delete-char</td>
<td>删除当前光标所在字符</td>
</tr>
<tr>
<td><code>&quot;\C-k&quot;</code></td>
<td>ctrl + k</td>
<td>kill-line</td>
<td>删除当前光标到行尾的所有字符</td>
</tr>
<tr>
<td><code>&quot;\C-i&quot;</code></td>
<td>ctrl + i</td>
<td>complete</td>
<td>自动补全，相当于敲<code>TAB</code></td>
</tr>
<tr>
<td><code>&quot;\C-j&quot;</code></td>
<td>ctrl + j</td>
<td>accept-line</td>
<td>结束当前行，相当于敲回车</td>
</tr>
<tr>
<td><code>&quot;\C-m&quot;</code></td>
<td>ctrl + m</td>
<td>accept-line</td>
<td>结束当前行，相当于敲回车</td>
</tr>
<tr>
<td><code>&quot;\C-w&quot;</code></td>
<td></td>
<td>backward-delete-word</td>
<td></td>
</tr>
<tr>
<td><code>&quot;\C-x\e[3~&quot;</code></td>
<td></td>
<td>backward-kill-line</td>
<td></td>
</tr>
<tr>
<td><code>&quot;\e\C-?&quot;</code></td>
<td></td>
<td>backward-kill-word</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>任何时候 <code>tab</code> 键，会根据当前的输入给出提示</li>
<li>命令后敲 <code>-</code> 或 <code>--</code> ，然后按 <code>tab</code> 键，可以展示出此命令具体的选项</li>
</ul>
<p>中文版：供参考</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626510324269.png" class width="1626510324269"></li>
</ul>
<h1 id="六、JVM相关命令"><a href="#六、JVM相关命令" class="headerlink" title="六、JVM相关命令"></a>六、JVM相关命令</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>dashboard 仪表板</li>
<li>thread 线程相关</li>
<li>jvm虚拟机相关</li>
<li>sysprop 系统属性相关</li>
<li>sysenv 查看jvm环境信息</li>
</ol>
<h2 id="1-dashboard"><a href="#1-dashboard" class="headerlink" title="1. dashboard"></a>1. dashboard</h2><img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626512647773.png" class width="1626512647773">

<h3 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h3><ul>
<li>ID: Java级别的线程ID，注意这个ID不能跟jstack中的nativeID一一对应。</li>
<li>NAME: 线程名</li>
<li>GROUP: 线程组名</li>
<li>PRIORITY: 线程优先级, 1~10之间的数字，越大表示优先级越高</li>
<li>STATE: 线程的状态</li>
<li>CPU%: 线程的cpu使用率。比如采样间隔1000ms，某个线程的增量cpu时间为100ms，则cpu使用率=100/1000=10%</li>
<li>DELTA_TIME: 上次采样之后线程运行增量CPU时间，数据格式为<code>秒</code></li>
<li>TIME: 线程运行总CPU时间，数据格式为<code>分:秒</code></li>
<li>INTERRUPTED: 线程当前的中断位状态</li>
<li>DAEMON: 是否是daemon线程</li>
</ul>
<h3 id="JVM内部线程"><a href="#JVM内部线程" class="headerlink" title="JVM内部线程"></a>JVM内部线程</h3><p>Java 8之后支持获取JVM内部线程CPU时间，这些线程只有名称和CPU时间，没有ID及状态等信息（显示ID为-1）。 通过内部线程可以观测到JVM活动，如GC、JIT编译等占用CPU情况，方便了解JVM整体运行状况。</p>
<ul>
<li>当JVM 堆(heap)/元数据(metaspace)空间不足或OOM时，可以看到GC线程的CPU占用率明显高于其他的线程。</li>
<li>当执行<code>trace/watch/tt/redefine</code>等命令后，可以看到JIT线程活动变得更频繁。因为JVM热更新class字节码时清除了此class相关的JIT编译结果，需要重新编译。</li>
</ul>
<p>JVM内部线程包括下面几种：</p>
<ul>
<li>JIT编译线程: 如 <code>C1 CompilerThread0</code>, <code>C2 CompilerThread0</code></li>
<li>GC线程: 如<code>GC Thread0</code>, <code>G1 Young RemSet Sampling</code></li>
<li>其它内部线程: 如<code>VM Periodic Task Thread</code>, <code>VM Thread</code>, <code>Service Thread</code></li>
</ul>
<h3 id="JIT即时编译"><a href="#JIT即时编译" class="headerlink" title="JIT即时编译"></a>JIT即时编译</h3><p> JIT是just in time的缩写，也就是即时编译。通过JIT技术，能够做到Java程序执行速度的加速。</p>
<p>注： JIT即时编译： <a href="https://blog.csdn.net/qq_34902684/article/details/85538895">https://blog.csdn.net/qq_34902684/article/details/85538895</a></p>
<h2 id="2-thread"><a href="#2-thread" class="headerlink" title="2. thread"></a>2. thread</h2><p>查看当前JVM的线程堆栈信息（ 查看当前线程信息，查看线程的堆栈 ）</p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th align="center">参数名称</th>
<th align="center">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">线程id</td>
</tr>
<tr>
<td align="center">[n:]</td>
<td align="center">指定最忙的前N个线程并打印堆栈</td>
</tr>
<tr>
<td align="center">[b]</td>
<td align="center">找出当前阻塞其他线程的线程</td>
</tr>
<tr>
<td align="center">[i ]</td>
<td align="center">指定cpu占比统计的采样间隔，单位为毫秒指定cpu使用率统计的采样间隔，，默认值为200</td>
</tr>
<tr>
<td align="center">[–all]</td>
<td align="center">显示所有匹配的线程</td>
</tr>
</tbody></table>
<h3 id="cpu使用率是如何统计出来的？"><a href="#cpu使用率是如何统计出来的？" class="headerlink" title="cpu使用率是如何统计出来的？"></a>cpu使用率是如何统计出来的？</h3><p>这里的cpu使用率与linux 命令<code>top -H -p </code> 的线程<code>%CPU</code>类似，一段采样间隔时间内，当前JVM里各个线程的增量cpu时间与采样间隔时间的比例。</p>
<blockquote>
<p>工作原理说明：</p>
</blockquote>
<ul>
<li>首先第一次采样，获取所有线程的CPU时间(调用的是<code>java.lang.management.ThreadMXBean#getThreadCpuTime()</code>及<code>sun.management.HotspotThreadMBean.getInternalThreadCpuTimes()</code>接口)</li>
<li>然后睡眠等待一个间隔时间（默认为200ms，可以通过<code>-i</code>指定间隔时间）</li>
<li>再次第二次采样，获取所有线程的CPU时间，对比两次采样数据，计算出每个线程的增量CPU时间</li>
<li>线程CPU使用率 = 线程增量CPU时间 / 采样间隔时间 * 100%</li>
</ul>
<blockquote>
<p>注意： 这个统计也会产生一定的开销（JDK这个接口本身开销比较大），因此会看到as的线程占用一定的百分比，为了降低统计自身的开销带来的影响，可以把采样间隔拉长一些，比如5000毫秒。</p>
<p>另外一种查看Java进程的线程cpu使用率方法：可以使用<a href="https://github.com/oldratlee/useful-scripts/blob/master/docs/java.md#-show-busy-java-threads">show-busy-java-threads</a>这个脚本</p>
</blockquote>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>如： 显示当前最忙的前3个线程并打印堆栈信息：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">thread -n 3</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626514227687.png" class width="1626514227687">

<ul>
<li>没有线程ID，包含<code>[Internal]</code>表示为JVM内部线程，参考<code>dashboard</code>命令的介绍。</li>
<li><code>cpuUsage</code>为采样间隔时间内线程的CPU使用率，与<code>dashboard</code>命令的数据一致。</li>
<li><code>deltaTime</code>为采样间隔时间内线程的增量CPU时间，小于1ms时被取整显示为0ms。</li>
<li><code>time</code> 线程运行总CPU时间。</li>
</ul>
<h3 id="当没有参数时，显示第一页线程信息"><a href="#当没有参数时，显示第一页线程信息" class="headerlink" title="当没有参数时，显示第一页线程信息"></a>当没有参数时，显示第一页线程信息</h3><p>默认按照CPU增量时间降序排列，只显示第一页数据，避免滚屏。</p>
<h3 id="thread-–all-显示所有匹配的线程"><a href="#thread-–all-显示所有匹配的线程" class="headerlink" title="thread –all, 显示所有匹配的线程"></a>thread –all, 显示所有匹配的线程</h3><p>显示所有匹配线程信息，有时需要获取全部JVM的线程数据进行分析。</p>
<h3 id="thread-id，-显示指定线程的运行堆栈"><a href="#thread-id，-显示指定线程的运行堆栈" class="headerlink" title="thread id， 显示指定线程的运行堆栈"></a>thread id， 显示指定线程的运行堆栈</h3><p>查看线程ID 1的栈：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">thread 1</span><br></pre></td></tr></table></figure>

<h3 id="thread-i-指定采样时间间隔"><a href="#thread-i-指定采样时间间隔" class="headerlink" title="thread -i, 指定采样时间间隔"></a>thread -i, 指定采样时间间隔</h3><ul>
<li><p><code>thread -i 1000</code> : 统计最近1000ms内的线程CPU时间。</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626514828921.png" class width="1626514828921"></li>
<li><p><code>thread -n 3 -i 1000</code> : 列出1000ms内最忙的3个线程栈</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626514851368.png" class width="1626514851368"></li>
</ul>
<h3 id="thread-–state-，查看指定状态的线程"><a href="#thread-–state-，查看指定状态的线程" class="headerlink" title="thread –state ，查看指定状态的线程"></a>thread –state ，查看指定状态的线程</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">thread --state WAITING </span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626514992047.png" class width="1626514992047">



<h3 id="thread-b-找出当前阻塞其他线程的线程"><a href="#thread-b-找出当前阻塞其他线程的线程" class="headerlink" title="thread -b, 找出当前阻塞其他线程的线程"></a>thread -b, 找出当前阻塞其他线程的线程</h3><p>有时候我们发现应用卡住了， 通常是由于某个线程拿住了某个锁， 并且其他线程都在等待这把锁造成的。 为了排查这类问题， arthas提供了<code>thread -b</code>， 一键找出那个罪魁祸首。</p>
<blockquote>
<p><strong>注意， 目前只支持找出synchronized关键字阻塞住的线程， 如果是<code>java.util.concurrent.Lock</code>， 目前还不支持。</strong> </p>
</blockquote>
<p>写一个死锁程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-17 17:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DinnerLockThread thread = <span class="keyword">new</span> DinnerLockThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">&quot;Jack&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">&quot;Rose&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DinnerLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String lock1 = <span class="string">&quot;第一根筷子&quot;</span>;</span><br><span class="line">    String lock2 = <span class="string">&quot;第二根筷子&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Jack&quot;</span>.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Jack 拿到了&quot;</span>+lock1);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Jack 拿到了&quot;</span>+lock2);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Rose 拿到了&quot;</span>+lock2);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (lock1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Rose 拿到了&quot;</span>+lock1);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@castile arthas]# java -cp demo-arthas-deadlock-1.0-SNAPSHOT.jar com.hongliang.Main</span><br><span class="line">Jack 拿到了第一根筷子</span><br><span class="line">Rose 拿到了第二根筷子</span><br><span class="line">... 出现死锁了...</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626516068279.png" class width="1626516068279">

<p>可以看到上面的Jack和Rose的线程已经Blocked</p>
<p>接下来使用arthas来诊断具体那个线程造成的死锁：</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626516191083.png" class width="1626516191083">

<h2 id="3-jvm-查看当前JVM信息"><a href="#3-jvm-查看当前JVM信息" class="headerlink" title="3.  jvm 查看当前JVM信息"></a>3.  jvm 查看当前JVM信息</h2><p> 查看当前JVM信息 </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"> RUNTIME</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MACHINE-NAME                                               31604@castile.com</span><br><span class="line"> JVM-START-TIME                                             2021-07-17 17:59:24</span><br><span class="line"> MANAGEMENT-SPEC-VERSION                                    1.2</span><br><span class="line"> SPEC-NAME                                                  Java Virtual Machine Specification</span><br><span class="line"> SPEC-VENDOR                                                Oracle Corporation</span><br><span class="line"> SPEC-VERSION                                               1.8</span><br><span class="line"> VM-NAME                                                    Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line"> VM-VENDOR                                                  Oracle Corporation</span><br><span class="line"> VM-VERSION                                                 25.251-b08</span><br><span class="line"> INPUT-ARGUMENTS                                            []</span><br><span class="line"> CLASS-PATH                                                 demo-arthas-deadlock-1.0-SNAPSHOT.jar</span><br><span class="line"> BOOT-CLASS-PATH                                            /usr/jdk/jdk1.8.0_251/jre/lib/resources.jar:/usr/jdk/jdk1.8.0_251/jre/lib/rt.jar:/usr/jdk/jdk1.8.0_251/jre/lib/sunrsasign.jar:/usr/jdk/jdk1.8.0_251</span><br><span class="line">                                                            /jre/lib/jsse.jar:/usr/jdk/jdk1.8.0_251/jre/lib/jce.jar:/usr/jdk/jdk1.8.0_251/jre/lib/charsets.jar:/usr/jdk/jdk1.8.0_251/jre/lib/jfr.jar:/usr/jdk/j</span><br><span class="line">                                                            dk1.8.0_251/jre/classes</span><br><span class="line"> LIBRARY-PATH                                               /usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> CLASS-LOADING</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> LOADED-CLASS-COUNT                                         3457</span><br><span class="line"> TOTAL-LOADED-CLASS-COUNT                                   3457</span><br><span class="line"> UNLOADED-CLASS-COUNT                                       0</span><br><span class="line"> IS-VERBOSE                                                 false</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> COMPILATION</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> NAME                                                       HotSpot 64-Bit Tiered Compilers</span><br><span class="line"> TOTAL-COMPILE-TIME                                         804</span><br><span class="line"> [time (ms)]</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> GARBAGE-COLLECTORS</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> PS Scavenge                                                name : PS Scavenge</span><br><span class="line"> [count/time (ms)]                                          collectionCount : 6</span><br><span class="line">                                                            collectionTime : 31</span><br><span class="line"></span><br><span class="line"> PS MarkSweep                                               name : PS MarkSweep</span><br><span class="line"> [count/time (ms)]                                          collectionCount : 1</span><br><span class="line">                                                            collectionTime : 31</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY-MANAGERS</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> CodeCacheManager                                           Code Cache</span><br><span class="line"></span><br><span class="line"> Metaspace Manager                                          Metaspace</span><br><span class="line">                                                            Compressed Class Space</span><br><span class="line"></span><br><span class="line"> PS Scavenge                                                PS Eden Space</span><br><span class="line">                                                            PS Survivor Space</span><br><span class="line"></span><br><span class="line"> PS MarkSweep                                               PS Eden Space</span><br><span class="line">                                                            PS Survivor Space</span><br><span class="line">                                                            PS Old Gen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY <span class="comment"># 内存相关</span></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> HEAP-MEMORY-USAGE                                          init : 31457280(30.0 MiB)</span><br><span class="line"> [memory in bytes]                                          used : 23836240(22.7 MiB)</span><br><span class="line">                                                            committed : 66060288(63.0 MiB)</span><br><span class="line">                                                            max : 425197568(405.5 MiB)</span><br><span class="line"></span><br><span class="line"> NO-HEAP-MEMORY-USAGE                                       init : 2555904(2.4 MiB)</span><br><span class="line"> [memory in bytes]                                          used : 27348920(26.1 MiB)</span><br><span class="line">                                                            committed : 28573696(27.3 MiB)</span><br><span class="line">                                                            max : -1(-1 B)</span><br><span class="line"></span><br><span class="line"> PENDING-FINALIZE-COUNT                                     0</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> OPERATING-SYSTEM<span class="comment">#系统相关</span></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> OS                                                         Linux</span><br><span class="line"> ARCH                                                       amd64</span><br><span class="line"> PROCESSORS-COUNT                                           4</span><br><span class="line"> LOAD-AVERAGE                                               0.0</span><br><span class="line"> VERSION                                                    3.10.0-1127.el7.x86_64</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> THREAD</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> COUNT                                                      16</span><br><span class="line"> DAEMON-COUNT                                               13</span><br><span class="line"> PEAK-COUNT                                                 17</span><br><span class="line"> STARTED-COUNT                                              20</span><br><span class="line"> DEADLOCK-COUNT                                             2</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> FILE-DESCRIPTOR <span class="comment"># 文件描述符</span></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MAX-FILE-DESCRIPTOR-COUNT                                  4096</span><br><span class="line"> OPEN-FILE-DESCRIPTOR-COUNT                                 103</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="THREAD相关"><a href="#THREAD相关" class="headerlink" title="THREAD相关"></a>THREAD相关</h3><ul>
<li>COUNT: JVM当前活跃的线程数</li>
<li>DAEMON-COUNT: JVM当前活跃的守护线程数</li>
<li>PEAK-COUNT: 从JVM启动开始曾经活着的最大线程数</li>
<li>STARTED-COUNT: 从JVM启动开始总共启动过的线程次数</li>
<li>DEADLOCK-COUNT: JVM当前死锁的线程数</li>
</ul>
<h3 id="文件描述符相关"><a href="#文件描述符相关" class="headerlink" title="文件描述符相关"></a>文件描述符相关</h3><ul>
<li>MAX-FILE-DESCRIPTOR-COUNT：JVM进程最大可以打开的文件描述符数</li>
<li>OPEN-FILE-DESCRIPTOR-COUNT：JVM当前打开的文件描述符数</li>
</ul>
<h2 id="4-sysprop-系统属性相关"><a href="#4-sysprop-系统属性相关" class="headerlink" title="4. sysprop 系统属性相关"></a>4. sysprop 系统属性相关</h2><h3 id="查看单个属性"><a href="#查看单个属性" class="headerlink" title="查看单个属性"></a>查看单个属性</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysprop java.version</span></span><br><span class="line">java.version=1.8.0_51</span><br></pre></td></tr></table></figure>

<h3 id="修改单个属性"><a href="#修改单个属性" class="headerlink" title="修改单个属性"></a>修改单个属性</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysprop user.country</span></span><br><span class="line">user.country=US</span><br><span class="line"><span class="meta">$</span><span class="bash"> sysprop user.country CN</span></span><br><span class="line">Successfully changed the system property.</span><br><span class="line">user.country=CN</span><br></pre></td></tr></table></figure>

<h2 id="5-sysenv-查看jvm环境信息"><a href="#5-sysenv-查看jvm环境信息" class="headerlink" title="5. sysenv 查看jvm环境信息"></a>5. sysenv 查看jvm环境信息</h2><img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626517078834.png" class width="1626517078834">

<p>也可以只看其中一个环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[arthas@31604]$</span><span class="bash"> sysenv JAVA_HOME</span></span><br><span class="line"> KEY                                       VALUE</span><br><span class="line"> JAVA_HOME                                 /usr/jdk/jdk1.8.0_251</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[arthas@31604]$</span><span class="bash"> sysenv CLASSPATH</span></span><br><span class="line"> KEY                                       VALUE</span><br><span class="line"> CLASSPATH                               .:/usr/jdk/jdk1.8.0_251/lib.tools.jar</span><br></pre></td></tr></table></figure>

<h2 id="6-vmoption查看，更新VM诊断相关的参数"><a href="#6-vmoption查看，更新VM诊断相关的参数" class="headerlink" title="6. vmoption查看，更新VM诊断相关的参数"></a>6. vmoption查看，更新VM诊断相关的参数</h2><p> 查看，更新VM诊断相关的参数 </p>
<ul>
<li><p>vmoption   : 查看所有的option</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626517607909.png" class width="1626517607909"></li>
<li><p>vmoption PrintGCDetails  : 查看指定的option</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">arthas@31604]$</span><span class="bash"> vmoption PrintGCDetails</span></span><br><span class="line"> KEY              VALUE                ORIGIN             WRITEABLE</span><br><span class="line"> PrintGCDetails   false                DEFAULT              true</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>vmoption PrintGCDetails true ： 更新指定的option</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626529130220.png" class width="1626529130220"></li>
</ul>
<h2 id="7-getstatic查看类的静态属性"><a href="#7-getstatic查看类的静态属性" class="headerlink" title="7. getstatic查看类的静态属性"></a>7. getstatic查看类的静态属性</h2><p> 通过getstatic命令可以方便的查看类的静态属性。使用方法为<code>getstatic class_name field_name</code> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[arthas@34093]$</span><span class="bash"> getstatic demo.MathGame random <span class="comment"># 查看MathGame里面的random字段</span></span></span><br><span class="line">field: random # 字段</span><br><span class="line">@Random[</span><br><span class="line">    serialVersionUID=@Long[3905348978240129619],</span><br><span class="line">    seed=@AtomicLong[144884610029513],</span><br><span class="line">    multiplier=@Long[25214903917],</span><br><span class="line">    addend=@Long[11],</span><br><span class="line">    mask=@Long[281474976710655],</span><br><span class="line">    DOUBLE_UNIT=@Double[1.1102230246251565E-16],</span><br><span class="line">    BadBound=@String[bound must be positive],</span><br><span class="line">    BadRange=@String[bound must be greater than origin],</span><br><span class="line">    BadSize=@String[size must be non-negative],</span><br><span class="line">    seedUniquifier=@AtomicLong[3620162808252824828],</span><br><span class="line">    nextNextGaussian=@Double[0.0],</span><br><span class="line">    haveNextNextGaussian=@Boolean[false],</span><br><span class="line">    serialPersistentFields=@ObjectStreamField[][isEmpty=false;size=3],</span><br><span class="line">    unsafe=@Unsafe[sun.misc.Unsafe@2b0f66cd],</span><br><span class="line">    seedOffset=@Long[24],</span><br><span class="line">]</span><br><span class="line">Affect(row-cnt:1) cost in 10 ms.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 推荐直接使用<a href="https://arthas.aliyun.com/doc/ognl.html">ognl</a>命令，更加灵活 。</p>
<table>
<thead>
<tr>
<th><em>express</em></th>
<th>执行的表达式</th>
</tr>
</thead>
<tbody><tr>
<td><code>[c:]</code></td>
<td>执行表达式的 ClassLoader 的 hashcode，默认值是SystemClassLoader</td>
</tr>
<tr>
<td><code>[classLoaderClass:]</code></td>
<td>指定执行表达式的 ClassLoader 的 class name</td>
</tr>
<tr>
<td>[x]</td>
<td>结果对象的展开层次，默认值1</td>
</tr>
</tbody></table>
<p>调用静态函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl <span class="string">&#x27;@java.lang.System@out.println(&quot;hello&quot;)&#x27;</span></span></span><br><span class="line">返回null</span><br></pre></td></tr></table></figure>

<p> 获取静态类的静态字段： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl <span class="string">&#x27;@demo.MathGame@random&#x27;</span></span></span><br><span class="line">@Random[</span><br><span class="line">    serialVersionUID=@Long[3905348978240129619],</span><br><span class="line">    seed=@AtomicLong[125451474443703],</span><br><span class="line">    multiplier=@Long[25214903917],</span><br><span class="line">    addend=@Long[11],</span><br><span class="line">    mask=@Long[281474976710655],</span><br><span class="line">    DOUBLE_UNIT=@Double[1.1102230246251565E-16],</span><br><span class="line">    BadBound=@String[bound must be positive],</span><br><span class="line">    BadRange=@String[bound must be greater than origin],</span><br><span class="line">    BadSize=@String[size must be non-negative],</span><br><span class="line">    seedUniquifier=@AtomicLong[-3282039941672302964],</span><br><span class="line">    nextNextGaussian=@Double[0.0],</span><br><span class="line">    haveNextNextGaussian=@Boolean[false],</span><br><span class="line">    serialPersistentFields=@ObjectStreamField[][isEmpty=false;size=3],</span><br><span class="line">    unsafe=@Unsafe[sun.misc.Unsafe@28ea5898],</span><br><span class="line">    seedOffset=@Long[24],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p> 执行多行表达式，赋值给临时变量，返回一个List： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span><br><span class="line"> </span><br><span class="line"> @ArrayList[</span><br><span class="line">    @String[/opt/java/8.0.181-zulu/jre],</span><br><span class="line">    @String[OpenJDK Runtime Environment],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li>
<li>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li>
</ul>
<h1 id="八、Class-ClassLoader相关命令"><a href="#八、Class-ClassLoader相关命令" class="headerlink" title="八、Class/ClassLoader相关命令"></a>八、Class/ClassLoader相关命令</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ol>
<li>sc：  Search-Class 。查看JVM已加载的类信息   </li>
<li>sm：  Search-Method 。 查看已加载类的方法信息 </li>
<li>jad: 把字节码反编译成源代码</li>
</ol>
<h2 id="1-sc查看JVM已加载的类信息"><a href="#1-sc查看JVM已加载的类信息" class="headerlink" title="1. sc查看JVM已加载的类信息"></a>1. sc查看JVM已加载的类信息</h2><p> Search-Class” 的简写，这个命令能搜索出所有已经加载到 JVM 中的 Class 信息，这个命令支持的参数有 <code>[d]</code>、<code>[E]</code>、<code>[f]</code> 和 <code>[x:]</code>。 </p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>class-pattern</em></td>
<td>类名表达式匹配</td>
</tr>
<tr>
<td><em>method-pattern</em></td>
<td>方法名表达式匹配</td>
</tr>
<tr>
<td>[d]</td>
<td>输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。 如果一个类被多个ClassLoader所加载，则会出现多次</td>
</tr>
<tr>
<td>[E]</td>
<td>开启正则表达式匹配，默认为通配符匹配</td>
</tr>
<tr>
<td>[f]</td>
<td>输出当前类的成员变量信息（需要配合参数-d一起使用）</td>
</tr>
<tr>
<td>[x:]</td>
<td>指定输出静态变量时属性的遍历深度，默认为 0，即直接使用 <code>toString</code> 输出</td>
</tr>
<tr>
<td><code>[c:]</code></td>
<td>指定class的 ClassLoader 的 hashcode</td>
</tr>
<tr>
<td><code>[classLoaderClass:]</code></td>
<td>指定执行表达式的 ClassLoader 的 class name</td>
</tr>
<tr>
<td><code>[n:]</code></td>
<td>具有详细信息的匹配类的最大数量（默认为100）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sc com.hongliang.DinnerLockThread -d</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626531356962.png" class width="1626531356962">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sc com.hongliang.DinnerLockThread -df</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626531485542.png" class width="1626531485542">

<p> sc 默认开启了子类匹配功能，也就是说所有当前类的子类也会被搜索出来，想要精确的匹配，请打开<code>options disable-sub-class true</code>开关 </p>
<h2 id="2-sm查看已加载类的方法信息"><a href="#2-sm查看已加载类的方法信息" class="headerlink" title="2. sm查看已加载类的方法信息"></a>2. sm查看已加载类的方法信息</h2><p> “Search-Method” 的简写，这个命令能搜索出所有已经加载了 Class 信息的<strong>方法信息</strong>。 </p>
<p> <code>sm</code> 命令只能看到由当前类所声明 (declaring) 的方法，父类则无法看到。 </p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>class-pattern</em></td>
<td>类名表达式匹配</td>
</tr>
<tr>
<td><em>method-pattern</em></td>
<td>方法名表达式匹配</td>
</tr>
<tr>
<td>[d]</td>
<td>展示每个方法的详细信息</td>
</tr>
<tr>
<td>[E]</td>
<td>开启正则表达式匹配，默认为通配符匹配</td>
</tr>
<tr>
<td><code>[c:]</code></td>
<td>指定class的 ClassLoader 的 hashcode</td>
</tr>
<tr>
<td><code>[classLoaderClass:]</code></td>
<td>指定执行表达式的 ClassLoader 的 class name</td>
</tr>
<tr>
<td><code>[n:]</code></td>
<td>具有详细信息的匹配类的最大数量（默认为100）</td>
</tr>
</tbody></table>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626531726921.png" class width="1626531726921">

<h2 id="3-jad-把字节码反编译成源代码"><a href="#3-jad-把字节码反编译成源代码" class="headerlink" title="3.  jad: 把字节码反编译成源代码"></a>3.  jad: 把字节码反编译成源代码</h2><p><code>jad</code> 命令将 JVM 中实际运行的 class 的 byte code 反编译成 java 代码，便于你理解业务逻辑；</p>
<ul>
<li>在 Arthas Console 上，反编译出来的源码是带<strong>语法高亮</strong>的，阅读更方便</li>
<li>当然，反编译出来的 java 代码可能会存在语法错误，但不影响你进行阅读理解</li>
</ul>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>class-pattern</em></td>
<td>类名表达式匹配</td>
</tr>
<tr>
<td><code>[c:]</code></td>
<td>类所属 ClassLoader 的 hashcode</td>
</tr>
<tr>
<td><code>[classLoaderClass:]</code></td>
<td>指定执行表达式的 ClassLoader 的 class name</td>
</tr>
<tr>
<td>[E]</td>
<td>开启正则表达式匹配，默认为通配符匹配</td>
</tr>
</tbody></table>
<h3 id="反编译java-lang-String"><a href="#反编译java-lang-String" class="headerlink" title="反编译java.lang.String"></a>反编译<code>java.lang.String</code></h3><img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626533128923.png" class width="1626533128923">

<h3 id="反编译时只显示源代码"><a href="#反编译时只显示源代码" class="headerlink" title="反编译时只显示源代码"></a>反编译时只显示源代码</h3><p> 默认情况下，反编译结果里会带有<code>ClassLoader</code>信息，通过<code>--source-only</code>选项，可以只打印源代码。方便和<a href="https://arthas.aliyun.com/doc/mc.html">mc</a>/<a href="https://arthas.aliyun.com/doc/retransform.html">retransform</a>命令结合使用。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jad --source-only demo.MathGame </span><br></pre></td></tr></table></figure>

<h3 id="反编译时指定ClassLoader"><a href="#反编译时指定ClassLoader" class="headerlink" title="反编译时指定ClassLoader"></a>反编译时指定ClassLoader</h3><p> 当有多个 <code>ClassLoader</code> 都加载了这个类时，<code>jad</code> 命令会输出对应 <code>ClassLoader</code> 实例的 <code>hashcode</code>，然后你只需要重新执行 <code>jad</code> 命令，并使用参数 <code>-c </code> 就可以反编译指定 ClassLoader 加载的那个类了； </p>
<h3 id="反编译指定的函数"><a href="#反编译指定的函数" class="headerlink" title="反编译指定的函数"></a>反编译指定的函数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jad demo.MathGame main</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626533435556.png" class width="1626533435556">



<h2 id="4-mc内存编译"><a href="#4-mc内存编译" class="headerlink" title="4. mc内存编译"></a>4. mc内存编译</h2><p> Memory Compiler/内存编译器，编译<code>.java</code>文件生成<code>.class</code>。 </p>
<p>可以通过<code>-d</code>命令指定输出目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mc -d /tmp/output /tmp/ClassA.java /tmp/ClassB.java</span><br></pre></td></tr></table></figure>

<p> 编译生成<code>.class</code>文件之后，可以结合<a href="https://arthas.aliyun.com/doc/retransform.html">retransform</a>命令实现热更新代码。 </p>
<p> 注意，mc命令有可能失败。如果编译失败可以在本地编译好<code>.class</code>文件，再上传到服务器。具体参考<a href="https://arthas.aliyun.com/doc/retransform.html">retransform</a>命令说明。 </p>
<p>可以通过<code>-c</code>参数指定classloader：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mc -c 327a647b /tmp/Test.java</span><br></pre></td></tr></table></figure>

<h2 id="5-redefine"><a href="#5-redefine" class="headerlink" title="5. redefine"></a>5. redefine</h2><p> 加载外部的<code>.class</code>文件，redefine jvm已加载的类。 </p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li>redefine的class不能<strong>修改、添加、删除</strong>类的<strong>field</strong>和<strong>method</strong>，包括<strong>方法参数</strong>、<strong>方法名称</strong>及<strong>返回值</strong></li>
<li>如果<code>mc</code>失败，可以在本地开发环境编译好class文件，上传到目标系统，使用<code>redefine</code>热加载class</li>
<li>目前<code>redefine</code> 和watch/trace/jad/tt等命令冲突，以后重新实现redefine功能会解决此问题</li>
</ul>
<blockquote>
<p>注意， redefine后的原来的类不能恢复，redefine有可能失败（比如增加了新的field），参考jdk本身的文档。</p>
<p><code>reset</code>命令对<code>redefine</code>的类无效。如果想重置，需要<code>redefine</code>原始的字节码。</p>
<p><code>redefine</code>命令和<code>jad</code>/<code>watch</code>/<code>trace</code>/<code>monitor</code>/<code>tt</code>等命令会冲突。执行完<code>redefine</code>之后，如果再执行上面提到的命令，则会把<code>redefine</code>的字节码重置。 原因是jdk本身redefine和Retransform是不同的机制，同时使用两种机制来更新字节码，只有最后修改的会生效。</p>
</blockquote>
<h3 id="redefine的限制"><a href="#redefine的限制" class="headerlink" title="redefine的限制"></a>redefine的限制</h3><ul>
<li>不允许新增加field/method</li>
<li>正在跑的函数，没有退出不能生效。</li>
</ul>
<h3 id="举例热更新代码"><a href="#举例热更新代码" class="headerlink" title="举例热更新代码"></a>举例热更新代码</h3><h4 id="源码准备"><a href="#源码准备" class="headerlink" title="源码准备"></a>源码准备</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-17 23:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        PrintNum p = <span class="keyword">new</span> PrintNum();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1L</span>);</span><br><span class="line"><span class="comment">//             System.out.println(&quot;我是在main中新增的代码&quot;);</span></span><br><span class="line">            p.run(i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> i)</span>   </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;在run中新增的代码&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;run--&gt;&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中注释的是要即将修改的代码！！！</p>
<h4 id="jad反编译"><a href="#jad反编译" class="headerlink" title="jad反编译"></a>jad反编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jad --source-only com.hongliang.PrintNum &gt; /tmp/PrintNum.java</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626537037313.png" class width="1626537037313">

<h4 id="sc查找加载PrintNum的ClassLoader"><a href="#sc查找加载PrintNum的ClassLoader" class="headerlink" title="sc查找加载PrintNum的ClassLoader"></a>sc查找加载PrintNum的ClassLoader</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[arthas@35673]$</span><span class="bash"> sc -d com.hongliang.PrintNum | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   7852e922</span><br></pre></td></tr></table></figure>

<h4 id="mc编译"><a href="#mc编译" class="headerlink" title="mc编译"></a>mc编译</h4><p>保存好<code>/tmp/PrintNum.java</code>之后，使用<code>mc</code>(Memory Compiler)命令来编译，并且通过<code>-c</code>参数指定ClassLoader的hash</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[arthas@35673]$</span><span class="bash"> mc -c 7852e922 /tmp/PrintNum.java -d /tmp/</span></span><br><span class="line">Memory compiler output:</span><br><span class="line">/tmp/com/hongliang/PrintNum.class</span><br><span class="line">Affect(row-cnt:1) cost in 831 ms.</span><br></pre></td></tr></table></figure>

<h4 id="redefine"><a href="#redefine" class="headerlink" title="redefine"></a>redefine</h4><p>再使用<code>redefine</code>命令重新加载新编译好的<code>PrintNum.class</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[arthas@35673]$</span><span class="bash"> redefine /tmp/com/hongliang/PrintNum.class</span></span><br><span class="line">redefine success, size: 1, classes:</span><br><span class="line">com.hongliang.PrintNum</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626537314248.png" class width="1626537314248">

<h4 id="注：使用jad等命令导致重置"><a href="#注：使用jad等命令导致重置" class="headerlink" title="注：使用jad等命令导致重置"></a>注：使用jad等命令导致重置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jad com.hongliang.PrintNum</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626537438540.png" class width="1626537438540">

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626537404225.png" class width="1626537404225">

<h2 id="6-dump"><a href="#6-dump" class="headerlink" title="6. dump"></a>6. dump</h2><p>将已经加载类的字节码文件保存到特定目录： logs/arthas/classdump/</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td><em>class-pattern</em></td>
<td>类名表达式匹配</td>
</tr>
<tr>
<td><code>[c:]</code></td>
<td>类所属 ClassLoader 的 hashcode</td>
</tr>
<tr>
<td><code>[classLoaderClass:]</code></td>
<td>指定执行表达式的 ClassLoader 的 class name</td>
</tr>
<tr>
<td><code>[d:]</code></td>
<td>设置类文件的目标目录</td>
</tr>
<tr>
<td>[E]</td>
<td>开启正则表达式匹配，默认为通配符匹配</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dump -d /tmp/output java.lang.String # String类的字节码文件放到指定目录中</span><br><span class="line">dump demo.* # </span><br><span class="line">HASHCODE  CLASSLOADER                                    LOCATION</span><br><span class="line"> 3d4eac69  +-sun.misc.Launcher$AppClassLoader@3d4eac69    /Users/admin/logs/arthas/classdump/sun.misc.Launcher$AppClassLoader-3d4eac69/demo/MathGame.class</span><br><span class="line">             +-sun.misc.Launcher$ExtClassLoader@66350f69</span><br><span class="line">Affect(row-cnt:1) cost in 39 ms.</span><br></pre></td></tr></table></figure>



<h2 id="7-classloader"><a href="#7-classloader" class="headerlink" title="7. classloader"></a>7. classloader</h2><p> 查看classloader的继承树，urls，类加载信息 </p>
<p><code>classloader</code> 命令将 JVM 中所有的classloader的信息统计出来，并可以展示<strong>继承树</strong>，urls等。</p>
<p>可以让指定的classloader去getResources，打印出所有查找到的resources的url。对于<code>ResourceNotFoundException</code>比较有用。</p>
<table>
<thead>
<tr>
<th align="center">参数名称</th>
<th align="center">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[l]</td>
<td align="center">按类加载实例进行统计</td>
</tr>
<tr>
<td align="center">[t]</td>
<td align="center">打印所有ClassLoader的继承树</td>
</tr>
<tr>
<td align="center">[a]</td>
<td align="center">列出所有ClassLoader加载的类，请谨慎使用</td>
</tr>
<tr>
<td align="center"><code>[c:]</code></td>
<td align="center">ClassLoader的hashcode</td>
</tr>
<tr>
<td align="center"><code>[classLoaderClass:]</code></td>
<td align="center">指定执行表达式的 ClassLoader 的 class name</td>
</tr>
<tr>
<td align="center"><code>[c: r:]</code></td>
<td align="center">用ClassLoader去查找resource</td>
</tr>
<tr>
<td align="center"><code>[c: load:]</code></td>
<td align="center">用ClassLoader去加载指定的类</td>
</tr>
</tbody></table>
<ol>
<li><p>显示所有类加载器的信息</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626576723307.png" class width="1626576723307"></li>
<li><p>获取某个类加载器所在的jar包</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626576966746.png" class width="1626576966746"></li>
<li><p>获取某个资源在哪个jar包中</p>
</li>
<li><p>加载某个类</p>
</li>
</ol>
<h1 id="九、增强命令"><a href="#九、增强命令" class="headerlink" title="九、增强命令"></a>九、增强命令</h1><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><ol>
<li>monitor 方法执行监控 </li>
<li>watch方法执行数据观测 </li>
<li>trace 输出当前方法的调用路径</li>
<li>tt 方法执行数据的时空隧道 </li>
<li>profiler 火焰图</li>
</ol>
<h2 id="1-monitor方法执行监控"><a href="#1-monitor方法执行监控" class="headerlink" title="1. monitor方法执行监控"></a>1. monitor方法执行监控</h2><p>对匹配 <code>class-pattern</code>／<code>method-pattern</code>的类、方法的调用进行监控。</p>
<p><code>monitor</code> 命令是一个<strong>非实时</strong>返回命令.</p>
<blockquote>
<p>实时返回命令是输入之后立即返回，而非实时返回的命令，则是不断的等待目标 Java 进程返回信息，直到用户输入 <code>Ctrl+C</code> 为止。</p>
</blockquote>
<p>服务端是以任务的形式在后台跑任务，植入的代码随着任务的中止而不会被执行，所以任务关闭后，不会对原有性能产生太大影响，而且原则上，任何Arthas命令不会引起原有业务逻辑的改变。</p>
<h3 id="监控的维度说明"><a href="#监控的维度说明" class="headerlink" title="监控的维度说明"></a>监控的维度说明</h3><table>
<thead>
<tr>
<th align="center">监控项</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">timestamp</td>
<td align="center">时间戳</td>
</tr>
<tr>
<td align="center">class</td>
<td align="center">Java类</td>
</tr>
<tr>
<td align="center">method</td>
<td align="center">方法（构造方法、普通方法）</td>
</tr>
<tr>
<td align="center">total</td>
<td align="center">调用次数</td>
</tr>
<tr>
<td align="center">success</td>
<td align="center">成功次数</td>
</tr>
<tr>
<td align="center">fail</td>
<td align="center">失败次数</td>
</tr>
<tr>
<td align="center">rt</td>
<td align="center">平均RT(平均耗时)</td>
</tr>
<tr>
<td align="center">fail-rate</td>
<td align="center">失败率</td>
</tr>
</tbody></table>
<p>方法拥有一个命名参数 <code>[c:]</code>，意思是统计周期（cycle of output），拥有一个整型的参数值</p>
<table>
<thead>
<tr>
<th align="right">参数名称</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="right"><em>class-pattern</em></td>
<td align="left">类名表达式匹配</td>
</tr>
<tr>
<td align="right"><em>method-pattern</em></td>
<td align="left">方法名表达式匹配</td>
</tr>
<tr>
<td align="right">[E]</td>
<td align="left">开启正则表达式匹配，默认为通配符匹配</td>
</tr>
<tr>
<td align="right"><code>[c:]</code></td>
<td align="left">统计周期，默认值为<strong>120</strong>秒</td>
</tr>
</tbody></table>
<p>每5s监控一次，类demo.MathGame中的primeFactors方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">monitor -c 5 demo.MathGame primeFactors</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626577463368.png" class width="1626577463368">



<h2 id="2-watch-方法执行数据观测"><a href="#2-watch-方法执行数据观测" class="headerlink" title="2. watch 方法执行数据观测"></a>2. watch 方法执行数据观测</h2><p> 让你能方便的观察到指定方法的调用情况。能观察到的范围为：<code>返回值</code>、<code>抛出异常</code>、<code>入参</code>，通过编写 OGNL 表达式进行对应变量的查看。 </p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>watch 的参数比较多，主要是因为它能在 4 个不同的场景观察对象</p>
<table>
<thead>
<tr>
<th align="center">参数名称</th>
<th align="center">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>class-pattern</em></td>
<td align="center">类名表达式匹配</td>
</tr>
<tr>
<td align="center"><em>method-pattern</em></td>
<td align="center">方法名表达式匹配</td>
</tr>
<tr>
<td align="center"><em>express</em></td>
<td align="center">观察表达式</td>
</tr>
<tr>
<td align="center"><em>condition-express</em></td>
<td align="center">条件表达式</td>
</tr>
<tr>
<td align="center">[b]</td>
<td align="center">在<strong>方法调用之前</strong>观察</td>
</tr>
<tr>
<td align="center">[e]</td>
<td align="center">在<strong>方法异常之后</strong>观察</td>
</tr>
<tr>
<td align="center">[s]</td>
<td align="center">在<strong>方法返回之后</strong>观察</td>
</tr>
<tr>
<td align="center">[f]</td>
<td align="center">在<strong>方法结束之后</strong>(正常返回和异常返回)观察</td>
</tr>
<tr>
<td align="center">[E]</td>
<td align="center">开启正则表达式匹配，默认为通配符匹配</td>
</tr>
<tr>
<td align="center">[x:]</td>
<td align="center">指定输出结果的属性遍历深度，默认为 1</td>
</tr>
</tbody></table>
<p>这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写<code>&quot;&#123;params,returnObj&#125;&quot;</code>，只要是一个合法的 ognl 表达式，都能被正常支持。</p>
<p>观察的维度也比较多，主要体现在参数 <code>advice</code> 的数据结构上。<code>Advice</code> 参数最主要是封装了通知节点的所有信息。请参考<a href="https://katacoda.com/embed/arthas/command-watch-cn/advice-class.md">表达式核心变量</a>中关于该节点的描述。</p>
<ul>
<li>特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li>
<li>OGNL表达式官网：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li>
</ul>
<p><strong>特别说明</strong>：</p>
<ul>
<li>watch 命令定义了4个观察事件点，即 <code>-b</code> 方法调用前，<code>-e</code> 方法异常后，<code>-s</code> 方法返回后，<code>-f</code> 方法结束后</li>
<li>4个观察事件点 <code>-b</code>、<code>-e</code>、<code>-s</code> 默认关闭，<code>-f</code> 默认打开，当指定观察点被打开后，在相应事件点会对观察表达式进行求值并输出</li>
<li>这里要注意<code>方法入参</code>和<code>方法出参</code>的区别，有可能在中间被修改导致前后不一致，除了 <code>-b</code> 事件点 <code>params</code> 代表方法入参外，其余事件都代表方法出参</li>
<li>当使用 <code>-b</code> 时，由于观察事件点是在方法调用前，此时返回值或异常均不存在</li>
</ul>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><ol>
<li><p>观察demo.MathGame类中primeFactors方法<strong>出参和返回值</strong>，结果属性遍历深度为2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &quot;&#123;params,returnObj&#125;&quot; -x 2</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626581994840.png" class width="1626581994840"></li>
<li><p>观察方法的入参</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &quot;&#123;params,returnObj&#125;&quot; -x 2 -b</span><br></pre></td></tr></table></figure>

<p>对比前一个例子，返回值为空（事件点为方法执行前，因此获取不到返回值）</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626582118394.png" class width="1626582118394"></li>
<li><p>观察当前对象中的属性，如果想查看方法运行前后当前对象中的属性，可以使用target关键字代表当前对象。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &quot;&#123;params,target,returnObj&#125;&quot; -x 2 -b -s -n 2</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626584425202.png" class width="1626584425202"></li>
</ol>
<ul>
<li>参数里<code>-n 2</code>，表示只执行两次</li>
<li>这里输出结果中，第一次输出的是方法调用前的观察表达式的结果，第二次输出的是方法返回后的表达式的结果</li>
<li>结果的输出顺序和事件发生的先后顺序一致，和命令中 <code>-s -b</code> 的顺序无关</li>
</ul>
<ol start="4">
<li><p>调整<code>-x</code>的值，观察具体的方法参数值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &quot;&#123;params,target&#125;&quot; -x 3</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626584539103.png" class width="1626584539103"></li>
</ol>
<ul>
<li><code>-x</code>表示遍历深度，可以调整来打印具体的参数和结果内容，默认值是1。</li>
</ul>
<ol start="5">
<li><p>条件表达式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &quot;&#123;params[0],target&#125;&quot; &quot;params[0]&lt;0&quot;</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626584640497.png" class width="1626584640497"></li>
</ol>
<ul>
<li>只有满足条件的调用，才会有响应。</li>
<li><code>watch-express</code> 单个值可以不加’{}’，多个值需要加’{a,b,c}’。</li>
<li><code>condition-express</code> 不能加’{}’，可以使用逗号分隔子表达式，取表达式最后一个值来判断。</li>
</ul>
<p> 如果watch的方法存在<strong>同名</strong>的其它<strong>重载方法</strong>，可以通过下面的办法进行过滤： </p>
<p>根据参数类型进行过滤</p>
<p><code>watch demo.MathGame primeFactors &#39;&#123;params, params[0].class.name&#125;&#39; &#39;params[0].class.name == &quot;java.lang.Integer&quot;&#39;</code></p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626584764553.png" class width="1626584764553">

<p>根据参数个数进行过滤</p>
<p><code>watch demo.MathGame primeFactors &#39;&#123;params, params.length&#125;&#39; &#39;params.length==1&#39;</code></p>
<ol start="6">
<li><p>观察异常信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &quot;&#123;params[0],throwExp&#125;&quot; -e -x 2 </span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626584867367.png" class width="1626584867367"></li>
</ol>
<ul>
<li><p><code>-e</code>表示抛出异常时才触发</p>
</li>
<li><p>express中，表示异常信息的变量是<code>throwExp</code></p>
</li>
<li><p>根据异常类型或者message进行过滤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &#x27;&#123;params, throwExp&#125;&#x27; &#x27;#msg=throwExp.toString(), #msg.contains(&quot;IllegalArgumentException&quot;)&#x27; -e -x 2</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626585063811.png" class width="1626585063811"></li>
</ul>
<ol start="7">
<li><p>观察当前对象中的属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &#x27;target&#x27;</span><br></pre></td></tr></table></figure>

<p>如果想查看方法运行前后，当前对象中的属性，可以使用<code>target</code>关键字，代表当前对象 .</p>
<p>然后使用<code>target.field_name</code>访问当前对象的某个属性 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch demo.MathGame primeFactors &#x27;target.illegalArgumentCount&#x27;</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626585179744.png" class width="1626585179744"></li>
</ol>
<h2 id="3-trace-方法内部调用路径追踪"><a href="#3-trace-方法内部调用路径追踪" class="headerlink" title="3. trace 方法内部调用路径追踪"></a>3. trace 方法内部调用路径追踪</h2><p>方法内部调用路径，并输出方法路径上的每个节点上耗时。</p>
<p> <code>trace</code> 命令能主动搜索 <code>class-pattern</code>／<code>method-pattern</code> 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。 </p>
<h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><table>
<thead>
<tr>
<th align="center">参数名称</th>
<th align="center">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>class-pattern</em></td>
<td align="center">类名表达式匹配</td>
</tr>
<tr>
<td align="center"><em>method-pattern</em></td>
<td align="center">方法名表达式匹配</td>
</tr>
<tr>
<td align="center"><em>condition-express</em></td>
<td align="center">条件表达式</td>
</tr>
<tr>
<td align="center">[E]</td>
<td align="center">开启正则表达式匹配，默认为通配符匹配</td>
</tr>
<tr>
<td align="center"><code>[n:]</code></td>
<td align="center">命令执行次数</td>
</tr>
<tr>
<td align="center"><code>#cost</code></td>
<td align="center">方法执行耗时</td>
</tr>
</tbody></table>
<p>观察的维度也比较多，主要体现在参数 <code>advice</code> 的数据结构上。<code>Advice</code> 参数最主要是封装了通知节点的所有信息。 </p>
<p>很多时候我们只想看到某个方法的rt大于某个时间之后的trace结果，现在Arthas可以按照方法执行的耗时来进行过滤了，例如<code>trace *StringUtils isBlank &#39;#cost&gt;100&#39;</code>表示当执行时间超过100ms的时候，才会输出trace的结果。</p>
<blockquote>
<p>watch/stack/trace这个三个命令都支持<code>#cost</code>  </p>
</blockquote>
<p><code>trace</code> 能方便的帮助你定位和发现因 RT 高而导致的性能问题缺陷，但其每次只能跟踪一级方法的调用链路。</p>
<p>参考：<a href="https://github.com/alibaba/arthas/issues/597">Trace命令的实现原理</a></p>
<p>3.3.0 版本后，可以使用动态Trace功能，不断增加新的匹配类，参考下面的示例。</p>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><ol>
<li><p>trace函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trace demo.MathGame run</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626586964556.png" class width="1626586964556"></li>
<li><p>trace次数限制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trace demo.MathGame run -n 1</span><br></pre></td></tr></table></figure></li>
<li><p>包含jdk的函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trace --skipJDKMethod false demo.MathGame run</span><br></pre></td></tr></table></figure>

<p>默认情况下，trace不会包含jdk里的函数调用，如果希望trace jdk里的函数，需要显式设置<code>--skipJDKMethod false</code>。</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626587115355.png" class width="1626587115355"></li>
<li><p>根据调用耗时来过滤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">trace demo.MathGame run &#x27;#cost &gt; 10&#x27;</span><br></pre></td></tr></table></figure>

<p> 只会展示耗时大于10ms的调用路径，有助于在排查问题的时候，只关注异常情况</p>
</li>
</ol>
<h2 id="4-stack输出当前方法的调用路径"><a href="#4-stack输出当前方法的调用路径" class="headerlink" title="4. stack输出当前方法的调用路径"></a>4. stack输出当前方法的调用路径</h2><p>很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你需要的是 stack 命令。 </p>
<h3 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h3><table>
<thead>
<tr>
<th align="center">参数名称</th>
<th align="center">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>class-pattern</em></td>
<td align="center">类名表达式匹配</td>
</tr>
<tr>
<td align="center"><em>method-pattern</em></td>
<td align="center">方法名表达式匹配</td>
</tr>
<tr>
<td align="center"><em>condition-express</em></td>
<td align="center">条件表达式</td>
</tr>
<tr>
<td align="center">[E]</td>
<td align="center">开启正则表达式匹配，默认为通配符匹配</td>
</tr>
<tr>
<td align="center"><code>[n:]</code></td>
<td align="center">执行次数限制</td>
</tr>
</tbody></table>
<h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><ol>
<li><p>展示primeFactors的调用路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stack demo.MathGame primeFactors</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626588168229.png" class width="1626588168229"></li>
<li><p>参数小于0的，执行两次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stack demo.MathGame primeFactors &#x27;params[0]&lt;0&#x27; -n 2</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626588540360.png" class width="1626588540360"></li>
<li><p>根据执行时间过滤。大于0.5ms的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">stack demo.MathGame primeFactors &#x27;#cost&gt;0.5&#x27;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-tt-方法执行数据的时空隧道"><a href="#5-tt-方法执行数据的时空隧道" class="headerlink" title="5. tt 方法执行数据的时空隧道"></a>5. tt 方法执行数据的时空隧道</h2><blockquote>
<p>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</p>
</blockquote>
<p><code>watch</code> 虽然很方便和灵活，但需要提前想清楚观察表达式的拼写，这对排查问题而言要求太高，因为很多时候我们并不清楚问题出自于何方，只能靠蛛丝马迹进行猜测。</p>
<p>这个时候如果能记录下当时方法调用的所有入参和返回值、抛出的异常会对整个问题的思考与判断非常有帮助。</p>
<p>于是乎，TimeTunnel 命令就诞生了。</p>
<h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><ol>
<li> 记录下当前方法的每次调用环境现场 </li>
</ol>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tt -t demo.MathGame primeFactors</span><br></pre></td></tr></table></figure>

   <img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626591019239.png" class width="1626591019239">

<ul>
<li><p>命令参数解析</p>
<ul>
<li><p><code>-t</code></p>
<p>tt 命令有很多个主参数，<code>-t</code> 就是其中之一。这个参数的表明希望记录下类 <code>*Test</code> 的 <code>print</code> 方法的每次执行情况。</p>
</li>
<li><p><code>-n 3</code></p>
<p>当你执行一个调用量不高的方法时可能你还能有足够的时间用 <code>CTRL+C</code> 中断 tt 命令记录的过程，但如果遇到调用量非常大的方法，瞬间就能将你的 JVM 内存撑爆。</p>
<p>此时你可以通过 <code>-n</code> 参数指定你需要记录的次数，当达到记录次数时 Arthas 会主动中断tt命令的记录过程，避免人工操作无法停止的情况。</p>
</li>
</ul>
</li>
<li><table>
<thead>
<tr>
<th align="left">表格字段</th>
<th align="center">字段解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INDEX</td>
<td align="center">时间片段记录编号，每一个编号代表着一次调用，后续tt还有很多命令都是基于此编号指定记录操作，非常重要。</td>
</tr>
<tr>
<td align="left">TIMESTAMP</td>
<td align="center">方法执行的本机时间，记录了这个时间片段所发生的本机时间</td>
</tr>
<tr>
<td align="left">COST(ms)</td>
<td align="center">方法执行的耗时</td>
</tr>
<tr>
<td align="left">IS-RET</td>
<td align="center">方法是否以正常返回的形式结束</td>
</tr>
<tr>
<td align="left">IS-EXP</td>
<td align="center">方法是否以抛异常的形式结束</td>
</tr>
<tr>
<td align="left">OBJECT</td>
<td align="center">执行对象的<code>hashCode()</code>，注意，曾经有人误认为是对象在JVM中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体</td>
</tr>
<tr>
<td align="left">CLASS</td>
<td align="center">执行的类名</td>
</tr>
<tr>
<td align="left">METHOD</td>
<td align="center">执行的方法名</td>
</tr>
</tbody></table>
<ul>
<li><p>条件表达式</p>
<p>不知道大家是否有在使用过程中遇到以下困惑</p>
<ul>
<li><p>Arthas 似乎很难区分出重载的方法</p>
</li>
<li><p>我只需要观察特定参数，但是 tt 却全部都给我记录了下来</p>
<p>条件表达式也是用 <code>OGNL</code> 来编写，核心的判断对象依然是 <code>Advice</code> 对象。除了 <code>tt</code> 命令之外，<code>watch</code>、<code>trace</code>、<code>stack</code> 命令也都支持条件表达式。</p>
</li>
</ul>
</li>
<li><p>解决方法重载</p>
<p><code>tt -t *Test print params.length==1</code></p>
<p>通过制定参数个数的形式解决不同的方法签名，如果参数个数一样，你还可以这样写</p>
<p><code>tt -t *Test print &#39;params[1] instanceof Integer&#39;</code></p>
</li>
<li><p>解决指定参数</p>
<p><code>tt -t *Test print params[0].mobile==&quot;13989838402&quot;</code></p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>检索调用记录</p>
<p>当你用 <code>tt</code> 记录了一大片的时间片段之后，你希望能从中筛选出自己需要的时间片段，这个时候你就需要对现有记录进行检索。</p>
<p>假设我们有这些记录: tt -l</p>
<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626591664645.png" class width="1626591664645">

<p> 我需要筛选出 <code>primeFactors</code> 方法的调用信息 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tt -s &#x27;method.name==&quot;primeFactors&quot;&#x27;</span><br></pre></td></tr></table></figure>

<p> 你需要一个 <code>-s</code> 参数。同样的，搜索表达式的核心对象依旧是 <code>Advice</code> 对象。 </p>
</li>
<li><p>查看调用信息</p>
<p>对于具体一个时间片的信息而言，你可以通过 <code>-i</code> 参数后边跟着对应的 <code>INDEX</code> 编号查看到他的详细信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tt -i 1003</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626591823165.png" class width="1626591823165"></li>
<li><p>重新做一次调用</p>
<p>当你稍稍做了一些调整之后，你可能需要前端系统重新触发一次你的调用，此时得求爷爷告奶奶的需要前端配合联调的同学再次发起一次调用。而有些场景下，这个调用不是这么好触发的。</p>
<p><code>tt</code> 命令由于保存了当时调用的所有现场信息，所以我们可以自己主动对一个 <code>INDEX</code> 编号的时间片自主发起一次调用，从而解放你的沟通成本。此时你需要 <code>-p</code> 参数。通过 <code>--replay-times</code> 指定 调用次数，通过 <code>--replay-interval</code> 指定多次调用间隔(单位ms, 默认1000ms)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tt -i 1004 -p</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626591945850.png" class width="1626591945850">

<p>你会发现结果虽然一样，但调用的路径发生了变化，由原来的程序发起变成了 Arthas 自己的内部线程发起的调用了。 </p>
<ul>
<li><p>需要强调的点</p>
<ol>
<li><p><strong>ThreadLocal 信息丢失</strong></p>
<p>很多框架偷偷的将一些环境变量信息塞到了发起调用线程的 ThreadLocal 中，由于调用线程发生了变化，这些 ThreadLocal 线程信息无法通过 Arthas 保存，所以这些信息将会丢失。</p>
<p>一些常见的 CASE 比如：鹰眼的 TraceId 等。</p>
</li>
<li><p><strong>引用的对象</strong></p>
<p>需要强调的是，<code>tt</code> 命令是将当前环境的对象引用保存起来，但仅仅也只能保存一个引用而已。如果方法内部对入参进行了变更，或者返回的对象经过了后续的处理，那么在 <code>tt</code> 查看的时候将无法看到当时最准确的值。这也是为什么 <code>watch</code> 命令存在的意义。</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="6-profiler"><a href="#6-profiler" class="headerlink" title="6. profiler"></a>6. profiler</h2><p> <code>profiler</code> 命令支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集到的采样结果生成火焰图。 </p>
<p> <code>profiler</code> 命令基本运行结构是 <code>profiler action [actionArg]</code> </p>
<h3 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h3><table>
<thead>
<tr>
<th align="center">参数名称</th>
<th align="center">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>action</em></td>
<td align="center">要执行的操作</td>
</tr>
<tr>
<td align="center"><em>actionArg</em></td>
<td align="center">属性名模式</td>
</tr>
<tr>
<td align="center">[i:]</td>
<td align="center">采样间隔（单位：ns）（默认值：10’000’000，即10 ms）</td>
</tr>
<tr>
<td align="center">[f:]</td>
<td align="center">将输出转储到指定路径</td>
</tr>
<tr>
<td align="center">[d:]</td>
<td align="center">运行评测指定秒</td>
</tr>
<tr>
<td align="center">[e:]</td>
<td align="center">要跟踪哪个事件（cpu, alloc, lock, cache-misses等），默认是cpu</td>
</tr>
</tbody></table>
<h3 id="开始采样"><a href="#开始采样" class="headerlink" title="开始采样"></a>开始采样</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">profiler start</span><br><span class="line"><span class="meta">[arthas@46284]$</span><span class="bash"> profiler start</span></span><br><span class="line">Started [cpu] profiling</span><br></pre></td></tr></table></figure>

<h3 id="获取已采集的sample的数量"><a href="#获取已采集的sample的数量" class="headerlink" title="获取已采集的sample的数量"></a>获取已采集的sample的数量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">profiler getSamples</span><br><span class="line">$ profiler getSamples</span><br><span class="line">23</span><br></pre></td></tr></table></figure>

<h3 id="查看profiler状态"><a href="#查看profiler状态" class="headerlink" title="查看profiler状态"></a>查看profiler状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">profiler status</span><br><span class="line">$ profiler status</span><br><span class="line">[itimer] profiling is running for 4 seconds</span><br></pre></td></tr></table></figure>

<p>可以查看当前profiler在采样哪种<code>event</code>和采样时间。</p>
<h3 id="停止profiler"><a href="#停止profiler" class="headerlink" title="停止profiler"></a>停止profiler</h3><h4 id="生成svg格式结果"><a href="#生成svg格式结果" class="headerlink" title="生成svg格式结果"></a>生成svg格式结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">profiler stop</span><br><span class="line">profiler output file: /tmp/demo/arthas-output/20191125-135546.svg</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>默认情况下，生成的结果保存到应用的<code>工作目录</code>下的<code>arthas-output</code>目录。可以通过 <code>--file</code>参数来指定输出结果路径。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">profiler stop --file /tmp/output.svg</span><br><span class="line">$ profiler stop --file /tmp/output.svg</span><br><span class="line">profiler output file: /tmp/output.svg</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h4 id="生成html格式结果"><a href="#生成html格式结果" class="headerlink" title="生成html格式结果"></a>生成html格式结果</h4><p>默认情况下，结果文件是<code>svg</code>格式，如果想生成<code>html</code>格式，可以用<code>--format</code>参数指定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">profiler stop --format html</span><br><span class="line">$ profiler stop --format html</span><br><span class="line">profiler output file: /tmp/test/arthas-output/20191125-143329.html</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>或者在<code>--file</code>参数里用文件名指名格式。比如<code>--file /tmp/result.html</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">profiler stop --file /tmp/result.html</span><br></pre></td></tr></table></figure>

<img src="/2021/07/25/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90%E7%9A%84Java%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E8%AF%A6%E8%A7%A3/1626595368642.png" class width="1626595368642">

<h4 id="火焰图的含义"><a href="#火焰图的含义" class="headerlink" title="火焰图的含义"></a>火焰图的含义</h4><p>火焰图是基于pref结果产生的SVG图片，用来展示CPU的调用栈。</p>
<p>y轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p>
<p>x轴表示抽样数，如果一个函数在x轴占据的宽度越宽，就表示它被抽到的次数越多，即执行时间长。注意，x轴不代表时间，而是所有调用栈合并后，按照字母顺序排列的。</p>
<p><strong>火焰图就是看顶层的哪个函数占据的宽度最大。只要有“平顶”(plateaus)，就表示该函数可能存在性能问题。</strong>颜色没有特殊含义，以为火焰图表示的是CPU的繁忙程度，所以一般选择暖色调。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>GC垃圾回收机制</title>
    <url>/2020/06/15/jvm05/</url>
    <content><![CDATA[<img src="/2020/06/15/jvm05/1592128480578.png" class width="1592128480578">

<p> 垃圾收集主要是针对<strong>堆和方法区</strong>进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><img src="/2020/06/15/jvm05/1592185580737.png" class width="1592185580737">

<p>在次数上频繁收集发生在<code>young</code>区，在次数上较少收集发生在<code>old</code>区。在元空间/永久代基本不动。</p>
<p><code>JVM</code>在进行<code>GC</code>时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。因此<code>GC</code>按照回收的区域又分了两种类型，一种是普通GC（<code>minor GC</code>），一种是全局GC（<code>major GC or Full GC</code>）</p>
<blockquote>
<p><code>Minor GC</code>和<code>Full GC</code>的区别：<br>　　普通GC（<code>minor GC</code>）：只针对新生代区域的<code>GC</code>，指发生在新生代的垃圾收集动作，因为大多数<code>Java</code>对象存活率都不高，所以<code>Minor GC</code>非常频繁，一般回收速度也比较快。<br>　　全局GC（<code>major GC or Full GC</code>）：指发生在老年代的垃圾收集动作，出现了<code>Major GC</code>，经常会伴随至少一次的<code>Minor GC</code>（但并不是绝对的）。<code>Major GC</code>的速度一般要比<code>Minor GC</code>慢上10倍以上 ，因为收集的区域较大。</p>
</blockquote>
<h1 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h1><p>在垃圾回收器对堆内存回收前，需要判断对象是否存活。</p>
<ul>
<li>引用计数算法: 给每个对象添加一个引用计数器,每当对象被引用,，对象的引用计数器就加1,当引用失效时，引用计数器就减1。 直到引用计数器为0,就代表对象不再被引用。</li>
<li>可达性算法: 通过<code>GC ROO</code>T的对象节点往下搜索，节点走过的路径被称为<strong>引用链</strong>。 如果一个对象不处于任何引用链，那么就可以判断此对象是不可达的。</li>
</ul>
<h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>在两个对象出现<strong>循环引用</strong>的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为<strong>循环引用</strong>的存在，因此 <code>Java</code> 虚拟机不使用引用计数算法。而且每次对对象赋值时都需要维护一个引用计数器，且计数器本身也有一定的消耗。</p>
<img src="/2020/06/15/jvm05/1592185999338.png" class width="1592185999338">

<p>下面的代码来自《深入理解Java虚拟机》 第三版中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.atguigu.jvm;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/**@Description:-verbose:gc*/</span><br><span class="line">public class RefCountGC</span><br><span class="line">&#123;</span><br><span class="line">  private byte[] bigSize = new byte[2 * 1024 * 1024];//这个成员属性唯一的作用就是占用一点内存</span><br><span class="line">  Object instance = null;</span><br><span class="line"> </span><br><span class="line">  public static void main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line">    RefCountGC objectA = new RefCountGC();</span><br><span class="line">    RefCountGC objectB = new RefCountGC();</span><br><span class="line">    objectA.instance = objectB;</span><br><span class="line">    objectB.instance = objectA;</span><br><span class="line">    objectA = null;</span><br><span class="line">    objectB = null;</span><br><span class="line"> </span><br><span class="line">    System.gc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>objectA</code>和<code>objectB</code>引用的对象实例互相持有了对象的引用，因此把<code>objectA</code>和<code>objectB</code>的引用去除后，由于两个对象之间还存在相互的引用，所以就无法回收这两个<code>RefCountGC</code>对象。</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2> <img src="/2020/06/15/jvm05/1592186859818.png" class width="1592186859818">

<p>通过<code>GC ROOT</code>的对象节点往下搜索，节点走过的路径被称为<strong>引用链</strong>。 如果一个对象不处于任何引用链，那么就可以判断此对象是不可达的。</p>
<p>以 <code>GC Roots</code> 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p>
<p><code>Java</code> 虚拟机使用该算法来判断对象是否可被回收，<code>GC Roots</code> 一般包含以下内容：</p>
<ul>
<li>虚拟机栈中<strong>局部变量表中引用的对象</strong>（stack）</li>
<li>本地方法栈中 <code>JNI</code> （ <code>Java Native Interface</code> ）中引用的对象</li>
<li>方法区中类静态属性引用的对象（static）</li>
<li>方法区中的常量引用的对象 （finnal）</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（<code>synchronized</code>关键字）持有的对象。</li>
</ul>
<h1 id="方法区的回收【见jvm01】"><a href="#方法区的回收【见jvm01】" class="headerlink" title="方法区的回收【见jvm01】"></a>方法区的回收【见jvm01】</h1><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p>
<p><strong>主要是对常量池的回收和对类的卸载</strong>。</p>
<p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ul>
<h1 id="四大引用类型"><a href="#四大引用类型" class="headerlink" title="四大引用类型"></a>四大引用类型</h1><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>被强引用关联的对象不会被回收。使用 new 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>被软引用关联的对象只有在内存不够的情况下才会被回收。使用 <code>SoftReference</code> 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p><strong>被弱引用关联的对象一定会被回收</strong>，也就是说它只能存活到下一次垃圾回收发生之前。使用 <code>WeakReference</code> 类来创建弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 <code>PhantomReference</code> 来创建虚引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>



<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>常见的垃圾回收算法主要有以下4种:</p>
<ol>
<li>复制算法（copying）</li>
<li>标记-清除算法</li>
<li>标记-整理算法</li>
<li>分代收集算法</li>
</ol>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>新生代使用的<code>GC</code>是<code>Minor GC</code>，这一个阶段主要使用的是复制算法来进行垃圾回收。</p>
<p><code>Minor GC</code>会把<code>Eden</code>中的所有活的对象都移到<code>Survivor</code>区域中，如果<code>Survivor</code>区中放不下，那么剩下的活的对象就被移到<code>Old  generation</code>中，也即一旦收集后，<code>Eden</code>是就变成空的了。</p>
<p>当对象在 <code>Eden</code> ( 包括一个 <code>Survivor</code> 区域，这里假设是 <code>from</code> 区域 ) 出生后，在经过一次 <code>Minor GC</code> 后，如果对象还存活，并且能够被另外一块 <code>Survivor</code> 区域所容纳( 上面已经假设为 <code>from</code> 区域，这里应为 <code>to</code> 区域，即 <code>to</code> 区域有足够的内存空间来存储 <code>Eden</code> 和 <code>from</code> 区域中存活的对象 )，则使用<strong>复制算法</strong>将这些仍然还存活的对象复制到另外一块 <code>Survivor</code> 区域 ( 即 <code>to</code> 区域 ) 中，然后清理所使用过的 <code>Eden</code> 以及 <code>Survivor</code> 区域 ( 即 <code>from</code> 区域 )，并且将这些对象的年龄设置为1，以后对象在 <code>Survivor</code> 区每熬过一次 <code>Minor GC</code>，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过-XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为<strong>老年代</strong>。</p>
<blockquote>
<p>-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数</p>
</blockquote>
<p><code>HotSpot JVM</code>把年轻代分为了三部分：1个<code>Eden</code>区和2个<code>Survivor</code>区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理)，这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，<strong>所以在年轻代的垃圾回收算法使用的是复制算法，</strong>复制算法的基本思想就是将内存分为两块（from 、 to。 伊甸+from的copy到to中），每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。<strong>复制算法不会产生内存碎片</strong>。</p>
<p><strong>所以复制算法总结起来就是： 将堆内存分为2块大小相等的内存空间， 每次只使用其中的一块内存，另一块则空闲。 当其中一块内存使用完后， 就将仍然存活的对象复制到另一块空闲内存空间，再清理已使用的内存。</strong> </p>
<p><img src="/2020/06/15/jvm05/jvm05%5C1592188602891.png" alt="1592188602891"></p>
<p> <code>HotSpot</code> 虚拟机的 <code>Eden</code> 和 <code>Survivor</code> 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 <code>Survivor</code> 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。 </p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>复制算法它的缺点也是相当明显的。<br>　　1、它浪费了一半的内存，这太要命了。  只使用了内存的一半。<br>　　2、如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</p>
<h2 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h2><p>标记-清除算法分为2个步骤：标记和清除。</p>
<p>首先标记出所有可达(存活)的对象，在标记完成后， 统一回收所有未被标记(不可达)的对象。</p>
<p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p>
<p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p>
<p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p>
<p><img src="/2020/06/15/jvm05/jvm05%5C1592189240852.png" alt="1592189240852"></p>
<p>用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。</p>
<p>标记：从引用根节点开始标记遍历所有的<code>GC Roots</code>， 先标记出要回收的对象。</p>
<p>清除：遍历整个堆，把标记的对象清除。 </p>
<p><strong>标记-清除算法一般用于老年代。</strong> 因为老年代中的对象存活率较高，几乎很少被回收， 所以标记-清除和标记-整理算法<code>GC</code>的时间不会太长， <code>GC</code>的对象相比新生代更少。 </p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>  缺点：此算法需要暂停整个应用，会产生内存碎片 。</p>
<ul>
<li>标记和清除过程效率都不高；</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。 <strong>对象在内存中的分布可能是不连续的，分散的，标记-清除后可能造成不连续的内存碎片。</strong> 当内存碎片过多后，后续想要分配较大的对象时，无法找到足够大的内存碎片， 可能又需要触发<code>GC</code>。 </li>
</ul>
<h2 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a>标记-整理算法(Mark-Compact)</h2><p><img src="/2020/06/15/jvm05/jvm05%5C1592189477014.png" alt="1592189477014"></p>
<p> 标记-整理算法是对标记-清除算法的一种改进。 </p>
<p>标记-整理算法与标记-清除算法的在标记阶段是相同的， 都是首先标记出所有可达(存活)的对象。 但<strong>标记之后并不直接清理未被标记(不可达)的对象， 而是使被标记(存活)的对象向内存一端移动，然后清理掉这一端外的内存。</strong></p>
<p><strong>标记-整理算法的优点是: 几乎不会如标记-清除算法那样产生不连续的内存碎片。 但，所谓慢工出细活，标记-整理的效率是比标记-清除要低的。</strong></p>
<p><strong>标记-整理算法和标记-清除算法一样，一般用于老年代。</strong></p>
<h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h3 id="年轻代-Young-Gen"><a href="#年轻代-Young-Gen" class="headerlink" title="年轻代(Young Gen)"></a>年轻代(Young Gen)</h3><p>年轻代特点是区域相对老年代较小，对像存活率低。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过<code>hotspot</code>中的两个<code>survivor</code>的设计得到缓解。</p>
<h3 id="老年代-Tenure-Gen"><a href="#老年代-Tenure-Gen" class="headerlink" title="老年代(Tenure Gen)"></a>老年代(Tenure Gen)</h3><p>老年代的特点是区域较大，对象存活率高。</p>
<p>这种情况，存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。</p>
<p><code>Mark</code>阶段的开销与存活对象的数量成正比，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过<strong>多核/线程利用</strong>，对并发、并行的形式提标记效率。</p>
<p><code>Sweep</code>阶段的开销与所管理区域的大小成正相关，但Sweep“就地处决”的特点，回收的过程没有对象的移动。使其相对其它有<code>对像</code>移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。</p>
<p><code>Compact</code>阶段的开销与存活对象的数据成开比，如上一条所描述，对于大量对象的移动是很大开销的，做为老年代的第一选择并不合适。</p>
<p>基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的<code>Concurrent Mode Failure</code>时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>
<hr>
<h2 id="内存分配与垃圾回收策略"><a href="#内存分配与垃圾回收策略" class="headerlink" title="内存分配与垃圾回收策略"></a>内存分配与垃圾回收策略</h2><ol>
<li>对象优先在<code>eden</code>区域被分配</li>
<li>大对象将直接进入老年代 (大对象是指需要大量连续的内存空间的对象，如长字符串，大数组等。)</li>
<li>长期存活的对象将进入老年代</li>
</ol>
<h2 id="总结：一次GC的过程"><a href="#总结：一次GC的过程" class="headerlink" title="总结：一次GC的过程"></a>总结：一次GC的过程</h2><p>首先堆分为新生代，老年代，新生代又分为伊甸区和两个幸存者区（from， to）。</p>
<p>对象优先在eden区被分配，当<code>eden</code>区内存不足时， <code>JVM</code>发起<code>Minor GC</code>。<code>Minor GC</code>的范围包括<code>eden</code>和<code>From Survivor</code>:</p>
<p>首先<code>JVM</code>会根据可达性算法标记出所有存活的对象。</p>
<p>如果存活的对象中，有的对象的年龄已经达到晋升阈值 (阈值是动态计算的，可以通过-XX:MaxTenuringThreshold设置最大年龄阈值)， 那么将已经达到阈值的对象复制到老年代中。</p>
<p>如果<code>To Survivor</code>空间不足以存放剩余存活对象， 则直接将存活的对象提前复制到老年代。 如果老年代也没有足够的空间存放存活的对象， 那么将触发<code>Full GC</code>(GC整个堆，包括新生代和老年代)。</p>
<p>如果<code>To Survivor</code>可以存放存活的对象， 那么将对象复制到<code>To Survivor</code>空间，并清理<code>eden</code>和<code>From Survivor</code>。</p>
<p>此时<code>From Survivor</code>为空， 那么<code>From Survivor</code>就成为了下一次的<code>To Survivor</code>， 此时<code>To Survivor</code>存放着存活的对象，就成为了下一次的<code>From Survivor</code>。 这样<code>From Survivor</code>与<code>To Survivor</code>就是不断交替复制的使用。</p>
<p><strong>老年代的空间比新生代的空间要大， 所以老年代的Major GC要比Minor GC耗时更长。 根据垃圾回收器的不同，老年代的GC算法也不同。</strong></p>
<h2 id="动态年龄阈值"><a href="#动态年龄阈值" class="headerlink" title="动态年龄阈值"></a>动态年龄阈值</h2><p><code>JVM</code>并不要求对象年龄一定要达到 MaxTenuringThreshold 才会 晋升到老年代，晋升的年龄阈值是<strong>动态计算</strong>的。￼￼￼￼￼ 如果在<code>Survivor</code>中，某个相同年龄阶段的所有对象大小的总和 大于<code>Survivor</code>区域的一半，则大于等于这个年龄的所有对象可以直接进入老年代，无需等到<code>MaxTenuringThreshold</code>。</p>
<hr>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>在发生 <code>Minor GC</code> 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 <code>Minor GC</code> 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 <code>HandlePromotionFailure</code> 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 <code>Minor GC</code>；如果小于，或者 <code>HandlePromotionFailure</code> 的值不允许冒险，那么就要进行一次 <code>Full GC</code>。</p>
<blockquote>
<p>解释一下“冒险”是冒了什么风险：前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个<code>Survivor</code>空间来作为轮换备份，因此当出现大量对象在<code>Minor GC</code>后仍然存活的情况——最极端的情况就是内存回收后新生代中所有对象都存活，需要老年代进行分配担保，把<code>Survivor</code>无法容纳的对象直接送入老年代，这与生活中贷款担保类似。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，但一共有多少对象会在这次回收中活下来在实际完成内存回收之前是无法明确知道的，所以只能取之前每一次回收晋升到老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行<code>Full GC</code>来让老年代腾出更多空间。</p>
<p>取历史平均值来比较其实仍然是一种赌概率的解决办法，也就是说假如某次<code>Minor GC</code>存活后的对象突增，远远高于历史平均值的话，依然会导致担保失败。如果出现了担保失败，那就只好老老实实地重新发起一次<code>Full GC</code>，这样停顿时间就很长了。虽然担保失败时绕的圈子是最大的，但通常情况下都还是会将<code>-XX：HandlePromotionFailure</code>开关打开，避免<code>Full GC</code>过于频繁。</p>
<p>​                                                                                                —-《深入理解java虚拟机》</p>
</blockquote>
<h3 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h3><p>对于 <code>Minor GC</code>，其触发条件非常简单，当 <code>Eden</code> 空间满时，就将触发一次 <code>Minor GC</code>。而 <code>Full GC</code> 则相对复杂，有以下条件：</p>
<h4 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h4><p> 只是建议虚拟机执行 <code>Full GC</code>，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 </p>
<h4 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 <code>Full GC</code>，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 <code>-Xmn</code> 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<h4 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h4><p> 使用复制算法的 <code>Minor GC</code> 需要老年代的内存空间作担保，如果担保失败会执行一次 <code>Full GC</code>。具体内容请参考上面的</p>
<h4 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4.  JDK 1.7 及以前的永久代空间不足"></a>4.  JDK 1.7 及以前的永久代空间不足</h4><p>在 JDK 1.7 及以前，<code>HotSpot</code> 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 <code>Class</code> 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 <code>CMS GC</code> 的情况下也会执行 <code>Full GC</code>。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 <code>java.lang.OutOfMemoryError</code>。</p>
<p>为避免以上原因引起的 <code>Full GC</code>，可采用的方法为增大永久代空间或转为使用 <code>CMS GC</code>。</p>
<h4 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h4><p> 执行 <code>CMS GC</code> 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 <code>GC</code> 过程中浮动垃圾过多导致暂时性的空间不足），便会报 <code>Concurrent Mode Failure</code> 错误，并触发 <code>Full GC</code>。 </p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><img src="/2020/06/15/jvm05/jvm05%5C1592191499688.png" alt="1592191499688"></p>
<p>以上是 <code>HotSpot</code> 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li>
</ul>
<h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p><img src="/2020/06/15/jvm05/jvm05%5C1592205518320.png" alt="1592205518320"></p>
<p>Serial收集器为单线程环境设计,并只使用一个线程进行垃圾回收。 在回收时，会暂停用户线程,并不适用于并发环境。</p>
<p>Serial收集器在单线程环境中是很高效的,它没有多线程切换的消耗。</p>
<p><strong>Serial收集器采用复制算法</strong></p>
<h2 id="Serial-Old-串行收集器-老年代版本"><a href="#Serial-Old-串行收集器-老年代版本" class="headerlink" title="Serial Old 串行收集器(老年代版本)"></a>Serial Old 串行收集器(老年代版本)</h2><p><img src="/2020/06/15/jvm05/jvm05%5C1592205613073.png" alt="1592205613073"></p>
<p>它是 <code>Serial</code>收集器的老年代使用的<code>GC</code>收集器，同样是一个单线程的垃圾收集器。</p>
<p><strong>Serial Old收集器采用的是标记-整理算法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** 开启串行收集器使用 -XX:+UseSerialGC , </span></span><br><span class="line"><span class="comment">  * 这样默认新生代使用 Serial 收集器,</span></span><br><span class="line"><span class="comment">  * 老年代使用 Serial Old 收集器. </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 设置VM参数:</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * -XX:+Xlogs:gc* 打印gc信息</span></span><br><span class="line"><span class="comment">  * -XX:+PrintCommandLineFlags  打印java版本信息</span></span><br><span class="line"><span class="comment">  * -XX:+UseSerialGC 使用串行GC</span></span><br><span class="line"><span class="comment">  */</span>                      </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果程序正常运行,日志会显示 :</span></span><br><span class="line"><span class="comment">// 新生代的信息为:  def new generation.....</span></span><br><span class="line"><span class="comment">// 老年代的信息为:  tenured generation.....</span></span><br></pre></td></tr></table></figure>

<h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p><img src="/2020/06/15/jvm05/jvm05%5C1592205736354.png" alt="1592205736354"></p>
<p>它是 Serial 收集器的多线程版本。</p>
<p>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
<p> <strong>ParNew收集器采用复制算法</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 设置ParNewGC回收器的参数为:</span></span><br><span class="line"><span class="comment">     * -XX:+UseConcMarkSweepGC</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">Chapter 2. The Structure of the Java Virtual Machine</a></p>
</li>
<li><p><a href="https://www.slideshare.net/benewu/jvm-memory">Jvm memory</a> <a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html">Getting Started with the G1 Garbage Collector</a></p>
</li>
<li><p><a href="http://electrofriends.com/articles/jni/jni-part1-java-native-interface/">JNI Part1: Java Native Interface Introduction and “Hello World” application</a></p>
</li>
<li><p><a href="https://hackthejava.wordpress.com/2015/01/09/memory-architecture-by-jvmruntime-data-areas/">Memory Architecture Of JVM(Runtime Data Areas)</a></p>
</li>
<li><p><a href="https://www.programcreek.com/2013/04/jvm-run-time-data-areas/">JVM Run-Time Data Areas</a></p>
</li>
<li><p><a href="http://www.drdobbs.com/architecture-and-design/android-on-x86-java-native-interface-and/240166271">Android on x86: Java Native Interface and the Android Native Development Kit</a></p>
</li>
<li><p><a href="https://crowhawk.github.io/2017/08/10/jvm_2/">深入理解 JVM(2)——GC 算法与内存分配策略</a></p>
</li>
<li><p><a href="https://crowhawk.github.io/2017/08/15/jvm_3/">深入理解 JVM(3)——7 种垃圾收集器</a></p>
</li>
<li><p><a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a></p>
</li>
<li><p><a href="http://www.baeldung.com/java-weakhashmap">Guide to WeakHashMap in Java</a></p>
</li>
<li><p><a href="https://alvinalexander.com/java/jwarehouse/apache-tomcat-6.0.16/java/org/apache/el/util/ConcurrentCache.java.shtml">Tomcat example source code file (ConcurrentCache.java)</a></p>
</li>
<li><p> <a href="https://guang19.github.io/framework-learning/gitbook_doc/jdk-jvm-juc/GC.html#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E7%9A%84%E6%96%B9%E6%B3%95">https://guang19.github.io/framework-learning/gitbook_doc/jdk-jvm-juc/GC.html#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E7%9A%84%E6%96%B9%E6%B3%95</a> </p>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper的安装及其配置参数</title>
    <url>/2021/08/01/ZooKeeper1/</url>
    <content><![CDATA[<h1 id="ZooKeeper的安装及其配置参数"><a href="#ZooKeeper的安装及其配置参数" class="headerlink" title="ZooKeeper的安装及其配置参数"></a>ZooKeeper的安装及其配置参数</h1><p>ZooKeeper下载:<a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a></p>
<p>Zookeeper 是一个开源的分布式的，为分布式框架提供协调服务的 Apache 项目。 </p>
<img src="/2021/08/01/ZooKeeper1/1.png" class width="1627817015110">

<h1 id="ZooKeeper安装"><a href="#ZooKeeper安装" class="headerlink" title="ZooKeeper安装"></a>ZooKeeper安装</h1><ol>
<li><p>首先将下载的tar包上传到服务器中</p>
<p>apache-zookeeper-3.5.7-bin.tar.gz</p>
</li>
<li><p>在/opt/下面解压出来, 并改名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-zookeeper-3.5.7-bin.tar.gz</span><br><span class="line">mv apache-zookeeper-3.5.7-bin zookeeper-3.5.7</span><br></pre></td></tr></table></figure></li>
<li></li>
<li><p>修改配置文件： 将/opt/zookeeper-3.5.7/conf 这个路径下的 zoo_sample.cfg 修改为 zoo.cfg； </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></li>
<li><p> 打开 zoo.cfg 文件，修改 dataDir 路径： 因为dataDir是存放节点数据，默认 放在/tmp目录下，但是tmp是临时目录，linux会定期删除，所以我们 需要另外指定目录。</p>
</li>
</ol>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> The number of milliseconds of each tick</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="meta">#</span><span class="bash"> The number of ticks that the initial</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> synchronization phase can take</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="meta">#</span><span class="bash"> The number of ticks that can pass between</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> sending a request and getting an acknowledgement</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="meta">#</span><span class="bash"> the directory <span class="built_in">where</span> the snapshot is stored.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">do</span> not use /tmp <span class="keyword">for</span> storage, /tmp here is just</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> example sakes.</span></span><br><span class="line">dataDir=/opt/zookeeper-3.5.7/zkData</span><br><span class="line"><span class="meta">#</span><span class="bash"> the port at <span class="built_in">which</span> the clients will connect</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta">#</span><span class="bash"> the maximum number of client connections.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> increase this <span class="keyword">if</span> you need to handle more clients</span></span><br><span class="line"><span class="meta">#</span><span class="bash">maxClientCnxns=60</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Be sure to read the maintenance section of the</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># The number of snapshots to retain in dataDir</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Purge task interval <span class="keyword">in</span> hours</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set to <span class="string">&quot;0&quot;</span> to <span class="built_in">disable</span> auto purge feature</span></span><br><span class="line"><span class="meta">#</span><span class="bash">autopurge.purgeInterval=1</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>启动zookeeper, 使用jps命令查看zookeeper进程QuorumPeerMain</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/zkServer.sh start</span><br><span class="line">[root@castile zookeeper-3.5.7]# ./bin/zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper-3.5.7/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br><span class="line">[root@castile zookeeper-3.5.7]# jps</span><br><span class="line">50058 QuorumPeerMain</span><br><span class="line">50077 Jps</span><br></pre></td></tr></table></figure></li>
<li><p>客户端连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/zkCli.sh</span><br></pre></td></tr></table></figure>

<img src="/2021/08/01/ZooKeeper1/1627820023872.png" class width="1627820023872"></li>
<li><p>停止ZooKeeper</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/zkServer.sh stop</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="配置参数解读"><a href="#配置参数解读" class="headerlink" title="配置参数解读"></a>配置参数解读</h1><p> Zookeeper中的配置文件zoo.cfg中参数含义解读如下 ：</p>
<ol>
<li><p> tickTime = 2000：通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒。 </p>
</li>
<li><p> initLimit = 10：LF初始通信时限。 Leader和Follower<strong>初始连接</strong>时能容忍的最多心跳数。也就是初始化集群时集群节点同步超时时间为20s。</p>
</li>
<li><p> syncLimit = 5：LF同步通信时限。 Leader和Follower之间通信时间如果超过syncLimit * tickTime，Leader认为Follwer死 掉，从服务器列表中删除Follwer。 即集群在运行过程中同步数据超时时间为10s。</p>
</li>
<li><p> dataDir：保存Zookeeper中的数据。 注意：默认的tmp目录，容易被Linux系统定期删除，所以一般不用默认的tmp目录。</p>
</li>
<li><p> clientPort = 2181：客户端连接端口，服务监听的端口号。通常不做修改。  </p>
</li>
<li><p>maxClientCnxns=60: 线程池数量为60个。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7防火墙问题:Unit iptables.service could not be found.</title>
    <url>/2021/08/05/centos%E9%98%B2%E7%81%AB%E5%A2%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Centos7防火墙问题-Unit-iptables-service-could-not-be-found"><a href="#Centos7防火墙问题-Unit-iptables-service-could-not-be-found" class="headerlink" title="Centos7防火墙问题:Unit iptables.service could not be found."></a>Centos7防火墙问题:Unit iptables.service could not be found.</h1><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在搭建zookeeper集群的时候出错，查看防火墙状态发现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@castile zookeeper-3.5.7]# service iptables status</span><br><span class="line">Redirecting to /bin/systemctl status iptables.service</span><br><span class="line">Unit iptables.service could not be found.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/08/05/centos%E9%98%B2%E7%81%AB%E5%A2%99%E9%97%AE%E9%A2%98/1628093509711.png" class width="1628093509711">



<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ol>
<li><p>安装iptables-services</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install iptables-services</span><br></pre></td></tr></table></figure>

<img src="/2021/08/05/centos%E9%98%B2%E7%81%AB%E5%A2%99%E9%97%AE%E9%A2%98/1628093561277.png" class width="1628093561277">

<img src="/2021/08/05/centos%E9%98%B2%E7%81%AB%E5%A2%99%E9%97%AE%E9%A2%98/1628093584574.png" class width="1628093584574"></li>
<li><p> 启动iptables 并查看状态</p>
</li>
</ol>
   <img src="/2021/08/05/centos%E9%98%B2%E7%81%AB%E5%A2%99%E9%97%AE%E9%A2%98/1628093708413.png" class width="1628093708413">



<p>其他：</p>
<p>service iptables stop ： 关闭防火墙</p>
<p>chkconfig iptables off</p>
]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper集群安装</title>
    <url>/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="ZooKeeper的集群安装"><a href="#ZooKeeper的集群安装" class="headerlink" title="ZooKeeper的集群安装"></a>ZooKeeper的集群安装</h1><h1 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h1><ol>
<li>需要三台服务器，至少三台吧。在三台节点上都部署zookeeper</li>
<li>zookeeper安装包</li>
<li>三个节点的ip分别为：192.168.175.130、192.168.175.129、192.168.175.128</li>
</ol>
<h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><h2 id="zookeeper安装"><a href="#zookeeper安装" class="headerlink" title="zookeeper安装"></a>zookeeper安装</h2><p>将zookeeper安装包都复制到对应节点的/opt/目录下: 使用scp命令用于给远程服务器传输数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp apache-zookeeper-3.5.7-bin.tar.gz root@192.168.175.128:/opt/</span><br><span class="line">scp apache-zookeeper-3.5.7-bin.tar.gz root@192.168.175.129:/opt/</span><br></pre></td></tr></table></figure>

<img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628090850078.png" class width="1628090850078">

<h2 id="配置服务器编号"><a href="#配置服务器编号" class="headerlink" title="配置服务器编号"></a>配置服务器编号</h2><p> 在/opt/zookeeper-3.5.7/这个目录下创建 zkData</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir zkData</span><br></pre></td></tr></table></figure>

<p>然后在zkData里面创建一个myid文件，文件名称必须是myid。 在文件中添加与 server 对应的编号（注意：上下不要有空行，左右不要有空格） </p>
<img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628091420086.png" class width="1628091420086">

<blockquote>
<p> 注意：添加 myid 文件，一定要在 Linux 里面创建，在 notepad++里面很可能乱码 </p>
</blockquote>
<p>在其他的节点上也做这样的配置（可以复制过去）。</p>
<h2 id="配置zoo-cfg文件"><a href="#配置zoo-cfg文件" class="headerlink" title="配置zoo.cfg文件"></a>配置zoo.cfg文件</h2><ol>
<li>注意其他节点也需要修改对应的conf目录下的zoo.cfg配置中dataDir为zkData。</li>
</ol>
<img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628091383165.png" class width="1628091383165">

<ol start="2">
<li> 增加如下配置 </li>
</ol>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">######################cluster##########################</span></span> </span><br><span class="line">server.2=192.168.175.130:2888:3888 </span><br><span class="line">server.3=192.168.175.128:2888:3888 </span><br><span class="line">server.4=192.168.175.129:2888:3888  </span><br></pre></td></tr></table></figure>

   <img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628092299227.png" class width="1628092299227">

<p>   配置参数解读 server.A=B:C:D:</p>
<ul>
<li><p>A 是一个数字，表示这个是第几号服务器； 集群模式下配置一个文件 <strong>myid</strong>，这个文件在 dataDir 目录下，这个文件里面有一个数据 就是 A 的值，<strong>Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个 server</strong>。 </p>
</li>
<li><p>B 是这个服务器的地址； </p>
</li>
<li><p> C 是这个服务器 Follower 与集群中的 Leader 服务器交换信息的端口； </p>
</li>
<li><p> D 是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。 </p>
</li>
</ul>
<p>   注意：这个zoo.cfg文件里面千万不能有空格！！！！！！！！！！！不然启动报错。。。</p>
   <img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628094627852.png" class width="1628094627852">

<p>   查看日志说是配置文件的问题：</p>
   <img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628094725792.png" class width="1628094725792">

   <img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628094610804.png" class width="1628094610804">

<p>   修改后可以顺利启动。</p>
   <img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628094785082.png" class width="1628094785082">

<ol start="3">
<li><p>同步zoo.cfg配置文件</p>
<p>​    <code>xsync zoo.cfg</code></p>
</li>
</ol>
<p>上述命令需要配置集群，修改hostname 已经hosts文件。暂未配置。</p>
<p>这一步骤将zoo.cfg同步到其他节点中。</p>
<h2 id="集群操作"><a href="#集群操作" class="headerlink" title="集群操作"></a>集群操作</h2><ol>
<li><p>分别在三个节点上启动 zookeeper</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628092937560.png" class width="1628092937560"></li>
<li><p>查看各个节点的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/zkServer.sh status</span><br></pre></td></tr></table></figure>

<p> 192.168.175.128：follower<img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628094864634.png" class width="1628094864634"></p>
<p>192.168.175.129：leader</p>
<img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628094914963.png" class width="1628094914963">

<p>192.168.175.130：follower</p>
<img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628095309051.png" class width="1628095309051"></li>
</ol>
<p>至此，三个节点搭建完毕。</p>
<h1 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h1><p>ip地址可以更换，配置。</p>
<p>每次都需要输入ip地址来连接很麻烦，我们为三台虚拟机的主机重命名为castile、castile2、castile3</p>
<ol>
<li> 修改/etc/sysconf/network</li>
</ol>
   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/network</span><br><span class="line">添加：</span><br><span class="line"></span><br><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=castile2</span><br></pre></td></tr></table></figure>

   <img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628401084187.png" class width="1628401084187">

<ol start="2">
<li><p>修改hosts文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>

<img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628401134032.png" class width="1628401134032">

<p>也可以将其他两台机器的ip和hostname进行配置。</p>
</li>
<li><p>重启网卡</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sevice network restart</span><br></pre></td></tr></table></figure></li>
<li><p>设置主机名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname castile2</span><br></pre></td></tr></table></figure></li>
<li><p>重启即可</p>
</li>
</ol>
<h1 id="集群ssh免密登录"><a href="#集群ssh免密登录" class="headerlink" title="集群ssh免密登录"></a>集群ssh免密登录</h1><p>集群之间操作登录其他虚拟机的时候需要输入密码，非常麻烦，可以设置ssh免密登录。</p>
<ol>
<li><p>在主要操作的机器中使用ssh-keygen生成公钥和私钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>一路回车即可，秘钥保存在~/.ssh/ 中，其中id_rsa为私钥，id_rsa.pub为公钥。</p>
<img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628401396313.png" class width="1628401396313"></li>
<li><p>将公钥的内容复制到authorized_keys里面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">cat authorized_keys</span><br></pre></td></tr></table></figure>

<img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628401519477.png" class width="1628401519477"></li>
<li><p>在另外两台虚拟机进行同样的操作，并将他们的公钥内容复制到主机器的authorized_keys中，然后将这个authorized_keys复制到其他两台机器中~/.ssh/中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@castile .ssh]# cat ~/.ssh/id2.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">[root@castile .ssh]# cat ~/.ssh/id3.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">[root@castile .ssh]# cat authorized_keys</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCkWhPVxk5SoFeQ1KX4Haxvhhrwai3w3A8MhVqoq3aS/shiMrxbGNLcN9O0s7KgULKt1N4vB0zM2LHuNTj8hfleyuM26tNHvZ4hj6w91AoNtrdpWc7NyuYXrVZUe/EEmr+r7OG30eR1mVvP5zXH0a5RMhF8FWa/FBeMKqFJicf9NVAo3r9h0ly9MnYP6D6E7ZRzqWSmZb0ifssyU4lSVC+wKtSEo32YGVegPMeEJQN5XPIdKy04C/7r6IfaKGxQ9B6HMLZ0y3ACFecivV36YYSOpffN6Ihvw6Aj0v1QM0C3jyRFDFryVj4Km2SE+CSJqHFjCKssFGv/AEpWA2XE9XIv root@castile.com</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDk6hJBiXtUNi5RY+iDuzYrsg4fg5aLDnluecSXbGyzK+qb5p2xyKmh7dvVOFBer4EgzIm0uj84csvmnP03jtq+4iVDmqy01AE7VQKm11bTiK861FnPoeIeuITk+/YFvVA8zVMWdMpd1R7ZDAFUHKaIPHKKpk7z94SM9j62GDPg8E6Am0rozSAAeRZA09/uDHqCZ4nsK5CyL6Ycg/ZIyIEfHMesnsWUMTMUdRMIACLMYxDrbki30Zt6qZmTsqEFeRDD0URQ2jwUFynlWe8hhXQgT4R0GJQwZDvQ5TksqP6cON0KBcyQH+SVw4oJgJlDeYsEU0WgYTeQoMFdfn8JBCXT root@castile2</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDNgPj2aqwx2fXCWvEdf0lgf3AZPD7CDNiZiB5XlLiLzoUxDp/+graEr28ORY2/pDDTRGqge+UwJj+7/foCfyp662dceW9et5gnGE2HdmBGjo+ASdgSNu677cOx81E9iGjjLQTsp4GCGoFPEY8coYnR9S7MIb96BXLG7Ai0WzHocPETLUypFwnRDrc116+QO751fsmXL1R9s+ScbJj3AJVJ1Ef0aMG/VTpVHBj8bej67mKcV8A5rNCX1eVwh3XEqpGcvSymWXRAWat2fbiT3kKq4F4yg+4mm0qjKpXIYKyGmgvsHJ1LI2PIyes/fbLEVJPzaclh3I93SeXuE5jydRVx root@castile3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@castile .ssh]# scp -r authorized_keys root@192.168.160.201:~/.ssh/</span><br><span class="line">root@192.168.160.201&#x27;s password:</span><br><span class="line">authorized_keys                                                                                  100% 1188   529.8KB/s   00:00</span><br><span class="line">[root@castile .ssh]# scp -r authorized_keys root@192.168.160.203:~/.ssh/</span><br><span class="line">root@192.168.160.203&#x27;s password:</span><br><span class="line">authorized_keys                                                                                  100% 1188   200.3KB/s   00:00</span><br><span class="line">[root@castile .ssh]# ssh castile2</span><br><span class="line">ssh: Could not resolve hostname castile2: Name or service not known</span><br><span class="line">[root@castile .ssh]# ssh 192.168.160.203</span><br><span class="line">Last login: Sun Aug  8 13:22:27 2021 from 192.168.160.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/08/08/ZooKeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/1628401667425.png" class width="1628401667425"></li>
</ol>
<h1 id="ZK-集群启动停止脚本"><a href="#ZK-集群启动停止脚本" class="headerlink" title="ZK 集群启动停止脚本"></a>ZK 集群启动停止脚本</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim zk.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">	&quot;start&quot; )&#123;</span><br><span class="line">		for i in castile castile2 castile3; do</span><br><span class="line"><span class="meta">			#</span><span class="bash">statements</span></span><br><span class="line">			echo --------------zookeeper $i start ---------------</span><br><span class="line">			ssh $i &quot;/opt/zookeeper-3.5.7/bin/zkServer.sh start&quot;</span><br><span class="line">		done</span><br><span class="line">		</span><br><span class="line">	&#125;;;</span><br><span class="line">	&quot;stop&quot; )&#123;</span><br><span class="line">		for i in castile castile2 castile3; do</span><br><span class="line"><span class="meta">			#</span><span class="bash">statements</span></span><br><span class="line">			echo --------------zookeeper $i stop ---------------</span><br><span class="line">			ssh $i &quot;/opt/zookeeper-3.5.7/bin/zkServer.sh stop&quot;</span><br><span class="line">		done</span><br><span class="line">		</span><br><span class="line">	&#125;;;</span><br><span class="line">	&quot;status&quot; )&#123;</span><br><span class="line">		for i in castile castile2 castile3; do</span><br><span class="line"><span class="meta">			#</span><span class="bash">statements</span></span><br><span class="line">			echo --------------zookeeper $i status ---------------</span><br><span class="line">			ssh $i &quot;/opt/zookeeper-3.5.7/bin/zkServer.sh status&quot;</span><br><span class="line">		done</span><br><span class="line">		</span><br><span class="line">	&#125;;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>ZooKeeper</tag>
        <tag>hosts</tag>
        <tag>ssh免密</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO基础</title>
    <url>/2021/08/22/Netty01-nio/</url>
    <content><![CDATA[<h1 id="一-NIO-基础"><a href="#一-NIO-基础" class="headerlink" title="一. NIO 基础"></a>一. NIO 基础</h1><p>non-blocking io 非阻塞 IO</p>
<h2 id="1-三大组件"><a href="#1-三大组件" class="headerlink" title="1. 三大组件"></a>1. 三大组件</h2><h3 id="1-1-Channel-amp-Buffer"><a href="#1-1-Channel-amp-Buffer" class="headerlink" title="1.1 Channel &amp; Buffer"></a>1.1 Channel &amp; Buffer</h3><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">channel --&gt; buffer</span><br><span class="line">buffer --&gt; channel</span><br></pre></td></tr></table></figure>

<p>常见的 Channel 有</p>
<ul>
<li>FileChannel ：文件数据传输通道</li>
<li>DatagramChannel ：UDP数据</li>
<li>SocketChannel ：TCP数据</li>
<li>ServerSocketChannel</li>
</ul>
<p>buffer 则用来缓冲读写数据，常见的 buffer 有</p>
<ul>
<li>ByteBuffer<ul>
<li>MappedByteBuffer</li>
<li>DirectByteBuffer</li>
<li>HeapByteBuffer</li>
</ul>
</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
<li>CharBuffer</li>
</ul>
<h3 id="1-2-Selector"><a href="#1-2-Selector" class="headerlink" title="1.2 Selector"></a>1.2 Selector</h3><p>selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途</p>
<h4 id="多线程版设计"><a href="#多线程版设计" class="headerlink" title="多线程版设计"></a>多线程版设计</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 多线程版</span><br><span class="line">t1(thread) --&gt; s1(socket1)</span><br><span class="line">t2(thread) --&gt; s2(socket2)</span><br><span class="line">t3(thread) --&gt; s3(socket3)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="⚠️-多线程版缺点"><a href="#⚠️-多线程版缺点" class="headerlink" title="⚠️ 多线程版缺点"></a>⚠️ 多线程版缺点</h4><ul>
<li>内存占用高</li>
<li>线程上下文切换成本高</li>
<li>只适合连接数少的场景</li>
</ul>
<h4 id="线程池版设计"><a href="#线程池版设计" class="headerlink" title="线程池版设计"></a>线程池版设计</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 线程池版</span><br><span class="line">t4(thread) --&gt; s4(socket1)</span><br><span class="line">t5(thread) --&gt; s5(socket2)</span><br><span class="line">t4(thread) -.-&gt; s6(socket3)</span><br><span class="line">t5(thread) -.-&gt; s7(socket4)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="⚠️-线程池版缺点"><a href="#⚠️-线程池版缺点" class="headerlink" title="⚠️ 线程池版缺点"></a>⚠️ 线程池版缺点</h4><ul>
<li>阻塞模式下，线程仅能处理一个 socket 连接</li>
<li>仅适合短连接场景</li>
</ul>
<h4 id="selector-版设计"><a href="#selector-版设计" class="headerlink" title="selector 版设计"></a>selector 版设计</h4><p>selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph selector 版</span><br><span class="line">thread --&gt; selector</span><br><span class="line">selector --&gt; c1(channel)</span><br><span class="line">selector --&gt; c2(channel)</span><br><span class="line">selector --&gt; c3(channel)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理</p>
<h2 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2. ByteBuffer"></a>2. ByteBuffer</h2><p>有一普通文本文件 data.txt，内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1234567890abcd</span><br></pre></td></tr></table></figure>

<p>使用 FileChannel 来读取文件内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;helloword/data.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">            FileChannel channel = file.getChannel();</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 向 buffer 写入</span></span><br><span class="line">                <span class="keyword">int</span> len = channel.read(buffer);</span><br><span class="line">                log.debug(<span class="string">&quot;读到字节数：&#123;&#125;&quot;</span>, len);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换 buffer 读模式</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, (<span class="keyword">char</span>)buffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换 buffer 写模式</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1</span><br></pre></td></tr></table></figure>



<h3 id="2-1-ByteBuffer-正确使用姿势"><a href="#2-1-ByteBuffer-正确使用姿势" class="headerlink" title="2.1  ByteBuffer 正确使用姿势"></a>2.1  ByteBuffer 正确使用姿势</h3><ol>
<li>向 buffer 写入数据，例如调用 channel.read(buffer)</li>
<li>调用 flip() 切换至<strong>读模式</strong></li>
<li>从 buffer 读取数据，例如调用 buffer.get()</li>
<li>调用 clear() 或 compact() 切换至<strong>写模式</strong></li>
<li>重复 1~4 步骤</li>
</ol>
<h3 id="2-2-ByteBuffer-结构"><a href="#2-2-ByteBuffer-结构" class="headerlink" title="2.2 ByteBuffer 结构"></a>2.2 ByteBuffer 结构</h3><p>ByteBuffer 有以下重要属性</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>一开始</p>
<img src="/2021/08/22/Netty01-nio/0021.png" class>

<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p>
<img src="/2021/08/22/Netty01-nio/0018.png" class>

<p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p>
<img src="/2021/08/22/Netty01-nio/0019.png" class>

<p>读取 4 个字节后，状态</p>
<img src="/2021/08/22/Netty01-nio/0020.png" class>

<p>clear 动作发生后，状态</p>
<img src="/2021/08/22/Netty01-nio/0021.png" class>

<p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p>
<img src="/2021/08/22/Netty01-nio/0022.png" class>



<h4 id="💡-调试工具类"><a href="#💡-调试工具类" class="headerlink" title="💡 调试工具类"></a>💡 调试工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] BYTE2CHAR = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] HEXDUMP_TABLE = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span> * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXPADDING = <span class="keyword">new</span> String[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="keyword">new</span> String[<span class="number">65536</span> &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTE2HEX = <span class="keyword">new</span> String[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTEPADDING = <span class="keyword">new</span> String[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] DIGITS = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            HEXDUMP_TABLE[i &lt;&lt; <span class="number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0F</span>];</span><br><span class="line">            HEXDUMP_TABLE[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = DIGITS[i &amp; <span class="number">0x0F</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for hex dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXPADDING.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> padding = HEXPADDING.length - i;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(padding * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            HEXPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">12</span>);</span><br><span class="line">            buf.append(NEWLINE);</span><br><span class="line">            buf.append(Long.toHexString(i &lt;&lt; <span class="number">4</span> &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            buf.setCharAt(buf.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            buf.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-hex-dump conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;</span><br><span class="line">            BYTE2HEX[i] = <span class="string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> padding = BYTEPADDING.length - i;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(padding);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            BYTEPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-char conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0x1f</span> || i &gt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">                BYTE2CHAR[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BYTE2CHAR[i] = (<span class="keyword">char</span>) i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印所有内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debugAll</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldlimit = buffer.limit();</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        StringBuilder origin = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(origin, buffer, <span class="number">0</span>, buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);</span><br><span class="line">        System.out.println(origin);</span><br><span class="line">        buffer.limit(oldlimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印可读取内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debugRead</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendPrettyHexDump</span><span class="params">(StringBuilder dump, ByteBuffer buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(</span><br><span class="line">                    <span class="string">&quot;expected: &quot;</span> + <span class="string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="string">&quot;) &lt;= offset + length(&quot;</span> + length</span><br><span class="line">                            + <span class="string">&quot;) &lt;= &quot;</span> + <span class="string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dump.append(</span><br><span class="line">                <span class="string">&quot;         +-------------------------------------------------+&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> startIndex = offset;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> fullRows = length &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> remainder = length &amp; <span class="number">0xF</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the rows which have 16 bytes.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; fullRows; row++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rowStartIndex = (row &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Per-row prefix.</span></span><br><span class="line">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="keyword">int</span> rowEndIndex = rowStartIndex + <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ASCII dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the last row which has less than 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rowStartIndex = (fullRows &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="keyword">int</span> rowEndIndex = rowStartIndex + remainder;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(HEXPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ascii dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(BYTEPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dump.append(NEWLINE +</span><br><span class="line">                <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHexDumpRowPrefix</span><span class="params">(StringBuilder dump, <span class="keyword">int</span> row, <span class="keyword">int</span> rowStartIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;</span><br><span class="line">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dump.append(NEWLINE);</span><br><span class="line">            dump.append(Long.toHexString(rowStartIndex &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            dump.setCharAt(dump.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">short</span> <span class="title">getUnsignedByte</span><span class="params">(ByteBuffer buffer, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>) (buffer.get(index) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-ByteBuffer-常见方法"><a href="#2-3-ByteBuffer-常见方法" class="headerlink" title="2.3 ByteBuffer 常见方法"></a>2.3 ByteBuffer 常见方法</h3><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang.netty.c1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-22 0:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocateByteBufferTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(ByteBuffer.allocate(<span class="number">16</span>).getClass());</span><br><span class="line">        System.out.println(ByteBuffer.allocateDirect(<span class="number">16</span>).getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>class java.nio.HeapByteBuffer : 堆中分配， 受到GC影响，读写效率低下</p>
<p>class java.nio.DirectByteBuffer： 直接内存， 读写效率高（少一次复制）， 不会受GC影响，分配效率低（需要调用OS系统函数分配）。</p>
<h4 id="向-buffer-写入数据"><a href="#向-buffer-写入数据" class="headerlink" title="向 buffer 写入数据"></a>向 buffer 写入数据</h4><p>有两种办法</p>
<ul>
<li>调用 channel 的 read 方法</li>
<li>调用 buffer 自己的 put 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readBytes = channel.read(buf);</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buf.put((<span class="keyword">byte</span>)<span class="number">127</span>);</span><br></pre></td></tr></table></figure>



<h4 id="从-buffer-读取数据"><a href="#从-buffer-读取数据" class="headerlink" title="从 buffer 读取数据"></a>从 buffer 读取数据</h4><p>同样有两种办法</p>
<ul>
<li>调用 channel 的 write 方法</li>
<li>调用 buffer 自己的 get 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> writeBytes = channel.write(buf);</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = buf.get();</span><br></pre></td></tr></table></figure>

<p>get 方法会让 position 读指针向后走，如果想重复读取数据</p>
<ul>
<li>可以调用 rewind 方法将 position 重新置为 0</li>
<li>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li>
</ul>
<h4 id="mark-和-reset"><a href="#mark-和-reset" class="headerlink" title="mark 和 reset"></a>mark 和 reset</h4><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p>
<blockquote>
<p><strong>注意</strong></p>
<p>rewind 和 flip 都会清除 mark 位置</p>
</blockquote>
<h4 id="字符串与-ByteBuffer-互转"><a href="#字符串与-ByteBuffer-互转" class="headerlink" title="字符串与 ByteBuffer 互转"></a>字符串与 ByteBuffer 互转</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">ByteBuffer buffer2 = Charset.forName(<span class="string">&quot;utf-8&quot;</span>).encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"></span><br><span class="line">debug(buffer1);</span><br><span class="line">debug(buffer2);</span><br><span class="line"></span><br><span class="line">CharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);</span><br><span class="line">System.out.println(buffer3.getClass());</span><br><span class="line">System.out.println(buffer3.toString());</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">class java.nio.HeapCharBuffer</span><br><span class="line">你好</span><br></pre></td></tr></table></figure>



<h4 id="⚠️-Buffer-的线程安全"><a href="#⚠️-Buffer-的线程安全" class="headerlink" title="⚠️ Buffer 的线程安全"></a>⚠️ Buffer 的线程安全</h4><blockquote>
<p>Buffer 是<strong>非线程安全的</strong></p>
</blockquote>
<h3 id="2-4-Scattering-Reads"><a href="#2-4-Scattering-Reads" class="headerlink" title="2.4 Scattering Reads"></a>2.4 Scattering Reads</h3><p>分散读取，有一个文本文件 3parts.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onetwothree</span><br></pre></td></tr></table></figure>

<p>使用如下方式读取，可以将数据填充至多个 buffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;helloword/3parts.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">    FileChannel channel = file.getChannel();</span><br><span class="line">    ByteBuffer a = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    ByteBuffer b = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    ByteBuffer c = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    channel.read(<span class="keyword">new</span> ByteBuffer[]&#123;a, b, c&#125;);</span><br><span class="line">    a.flip();</span><br><span class="line">    b.flip();</span><br><span class="line">    c.flip();</span><br><span class="line">    debug(a);</span><br><span class="line">    debug(b);</span><br><span class="line">    debug(c);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6f 6e 65                                        |one             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 74 77 6f                                        |two             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 74 68 72 65 65                                  |three           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<h3 id="2-5-Gathering-Writes"><a href="#2-5-Gathering-Writes" class="headerlink" title="2.5 Gathering Writes"></a>2.5 Gathering Writes</h3><p>使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;helloword/3parts.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">    FileChannel channel = file.getChannel();</span><br><span class="line">    ByteBuffer d = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    ByteBuffer e = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    channel.position(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    d.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;);</span><br><span class="line">    e.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;);</span><br><span class="line">    d.flip();</span><br><span class="line">    e.flip();</span><br><span class="line">    debug(d);</span><br><span class="line">    debug(e);</span><br><span class="line">    channel.write(<span class="keyword">new</span> ByteBuffer[]&#123;d, e&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 6f 75 72                                     |four            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 69 76 65                                     |five            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onetwothreefourfive</span><br></pre></td></tr></table></figure>



<h3 id="2-6-练习"><a href="#2-6-练习" class="headerlink" title="2.6 练习"></a>2.6 练习</h3><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p>
<ul>
<li>Hello,world\n</li>
<li>I’m zhangsan\n</li>
<li>How are you?\n</li>
</ul>
<p>变成了下面的两个 byteBuffer (黏包，半包)</p>
<ul>
<li>Hello,world\nI’m zhangsan\nHo</li>
<li>w are you?\n</li>
</ul>
<p>现在要求你编写程序，将错乱的数据恢复成原始的按 \n 分隔的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer source = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">    <span class="comment">//                     11            24</span></span><br><span class="line">    source.put(<span class="string">&quot;Hello,world\nI&#x27;m zhangsan\nHo&quot;</span>.getBytes());</span><br><span class="line">    split(source);</span><br><span class="line"></span><br><span class="line">    source.put(<span class="string">&quot;w are you?\nhaha!\n&quot;</span>.getBytes());</span><br><span class="line">    split(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer source)</span> </span>&#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">int</span> oldLimit = source.limit();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldLimit; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            ByteBuffer target = ByteBuffer.allocate(i + <span class="number">1</span> - source.position());</span><br><span class="line">            <span class="comment">// 0 ~ limit</span></span><br><span class="line">            source.limit(i + <span class="number">1</span>);</span><br><span class="line">            target.put(source); <span class="comment">// 从source 读，向 target 写</span></span><br><span class="line">            debugAll(target);</span><br><span class="line">            source.limit(oldLimit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-文件编程"><a href="#3-文件编程" class="headerlink" title="3. 文件编程"></a>3. 文件编程</h2><h3 id="3-1-FileChannel"><a href="#3-1-FileChannel" class="headerlink" title="3.1 FileChannel"></a>3.1 FileChannel</h3><h4 id="⚠️-FileChannel-工作模式"><a href="#⚠️-FileChannel-工作模式" class="headerlink" title="⚠️ FileChannel 工作模式"></a>⚠️ FileChannel 工作模式</h4><blockquote>
<p>FileChannel 只能工作在阻塞模式下</p>
</blockquote>
<h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p>
<ul>
<li>通过 FileInputStream 获取的 channel 只能读</li>
<li>通过 FileOutputStream 获取的 channel 只能写</li>
<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li>
</ul>
<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readBytes = channel.read(buffer);</span><br></pre></td></tr></table></figure>



<h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>写入的正确姿势如下， SocketChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ...;</span><br><span class="line">buffer.put(...); <span class="comment">// 存入数据</span></span><br><span class="line">buffer.flip();   <span class="comment">// 切换读模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>获取当前位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> pos = channel.position();</span><br></pre></td></tr></table></figure>

<p>设置当前位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> newPos = ...;</span><br><span class="line">channel.position(newPos);</span><br></pre></td></tr></table></figure>

<p>设置当前位置时，如果设置为文件的末尾</p>
<ul>
<li>这时读取会返回 -1 </li>
<li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li>
</ul>
<h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><p>使用 size 方法获取文件的大小</p>
<h4 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h4><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p>
<h3 id="3-2-两个-Channel-传输数据"><a href="#3-2-两个-Channel-传输数据" class="headerlink" title="3.2 两个 Channel 传输数据"></a>3.2 两个 Channel 传输数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String FROM = <span class="string">&quot;helloword/data.txt&quot;</span>;</span><br><span class="line">String TO = <span class="string">&quot;helloword/to.txt&quot;</span>;</span><br><span class="line"><span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line"><span class="keyword">try</span> (FileChannel from = <span class="keyword">new</span> FileInputStream(FROM).getChannel();</span><br><span class="line">     FileChannel to = <span class="keyword">new</span> FileOutputStream(TO).getChannel();</span><br><span class="line">    ) &#123;</span><br><span class="line">    from.transferTo(<span class="number">0</span>, from.size(), to);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;transferTo 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transferTo 用时：8.2011</span><br></pre></td></tr></table></figure>



<p>超过 2g 大小的文件传输</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileChannelTransferTo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                FileChannel from = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;data.txt&quot;</span>).getChannel();</span><br><span class="line">                FileChannel to = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;to.txt&quot;</span>).getChannel();</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 效率高，底层会利用操作系统的零拷贝进行优化</span></span><br><span class="line">            <span class="keyword">long</span> size = from.size();</span><br><span class="line">            <span class="comment">// left 变量代表还剩余多少字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> left = size; left &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;position:&quot;</span> + (size - left) + <span class="string">&quot; left:&quot;</span> + left);</span><br><span class="line">                left -= from.transferTo((size - left), left, to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际传输一个超大文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">position:0 left:7769948160</span><br><span class="line">position:2147483647 left:5622464513</span><br><span class="line">position:4294967294 left:3474980866</span><br><span class="line">position:6442450941 left:1327497219</span><br></pre></td></tr></table></figure>



<h3 id="3-3-Path"><a href="#3-3-Path" class="headerlink" title="3.3 Path"></a>3.3 Path</h3><p>jdk7 引入了 Path 和 Paths 类</p>
<ul>
<li>Path 用来表示文件路径</li>
<li>Paths 是工具类，用来获取 Path 实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">&quot;1.txt&quot;</span>); <span class="comment">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span></span><br><span class="line"></span><br><span class="line">Path source = Paths.get(<span class="string">&quot;d:\\1.txt&quot;</span>); <span class="comment">// 绝对路径 代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line">Path source = Paths.get(<span class="string">&quot;d:/1.txt&quot;</span>); <span class="comment">// 绝对路径 同样代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line">Path projects = Paths.get(<span class="string">&quot;d:\\data&quot;</span>, <span class="string">&quot;projects&quot;</span>); <span class="comment">// 代表了  d:\data\projects</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>.</code> 代表了当前路径</li>
<li><code>..</code> 代表了上一级路径</li>
</ul>
<p>例如目录结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d:</span><br><span class="line">	|- data</span><br><span class="line">		|- projects</span><br><span class="line">			|- a</span><br><span class="line">			|- b</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;d:\\data\\projects\\a\\..\\b&quot;</span>);</span><br><span class="line">System.out.println(path);</span><br><span class="line">System.out.println(path.normalize()); <span class="comment">// 正常化路径</span></span><br></pre></td></tr></table></figure>

<p>会输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d:\data\projects\a\..\b</span><br><span class="line">d:\data\projects\b</span><br></pre></td></tr></table></figure>



<h3 id="3-4-Files"><a href="#3-4-Files" class="headerlink" title="3.4 Files"></a>3.4 Files</h3><p>检查文件是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">System.out.println(Files.exists(path));</span><br></pre></td></tr></table></figure>



<p>创建一级目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;helloword/d1&quot;</span>);</span><br><span class="line">Files.createDirectory(path);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果目录已存在，会抛异常 FileAlreadyExistsException</li>
<li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li>
</ul>
<p>创建多级目录用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;helloword/d1/d2&quot;</span>);</span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>



<p>拷贝文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">Path target = Paths.get(<span class="string">&quot;helloword/target.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.copy(source, target);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果文件已存在，会抛异常 FileAlreadyExistsException</li>
</ul>
<p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>



<p>移动文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">Path target = Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>

<ul>
<li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li>
</ul>
<p>删除文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path target = Paths.get(<span class="string">&quot;helloword/target.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果文件不存在，会抛异常 NoSuchFileException</li>
</ul>
<p>删除目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path target = Paths.get(<span class="string">&quot;helloword/d1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li>
</ul>
<p>遍历目录文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Path path = Paths.get(<span class="string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);</span><br><span class="line">    AtomicInteger dirCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    AtomicInteger fileCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    Files.walkFileTree(path, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(dir);</span><br><span class="line">            dirCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(dirCount); <span class="comment">// 133</span></span><br><span class="line">    System.out.println(fileCount); <span class="comment">// 1479</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>统计 jar 的数目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);</span><br><span class="line">AtomicInteger fileCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.toFile().getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(fileCount); <span class="comment">// 724</span></span><br></pre></td></tr></table></figure>



<p>删除多级目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;d:\\a&quot;</span>);</span><br><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Files.delete(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Files.delete(dir);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="⚠️-删除很危险"><a href="#⚠️-删除很危险" class="headerlink" title="⚠️ 删除很危险"></a>⚠️ 删除很危险</h4><blockquote>
<p>删除是危险操作，确保要递归删除的文件夹没有重要内容</p>
</blockquote>
<p>拷贝多级目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">String source = <span class="string">&quot;D:\\Snipaste-1.16.2-x64&quot;</span>;</span><br><span class="line">String target = <span class="string">&quot;D:\\Snipaste-1.16.2-x64aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line">Files.walk(Paths.get(source)).forEach(path -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String targetName = path.toString().replace(source, target);</span><br><span class="line">        <span class="comment">// 是目录</span></span><br><span class="line">        <span class="keyword">if</span> (Files.isDirectory(path)) &#123;</span><br><span class="line">            Files.createDirectory(Paths.get(targetName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是普通文件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Files.isRegularFile(path)) &#123;</span><br><span class="line">            Files.copy(path, Paths.get(targetName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br></pre></td></tr></table></figure>





<h2 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4. 网络编程"></a>4. 网络编程</h2><h3 id="4-1-非阻塞-vs-阻塞"><a href="#4-1-非阻塞-vs-阻塞" class="headerlink" title="4.1 非阻塞 vs 阻塞"></a>4.1 非阻塞 vs 阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>阻塞模式下，相关方法都会导致线程暂停<ul>
<li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li>
<li>SocketChannel.read 会在没有数据可读时让线程暂停</li>
<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li>
</ul>
</li>
<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>
<li>但多线程下，有新的问题，体现在以下方面<ul>
<li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>
</ul>
</li>
</ul>
<p>服务器端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    log.debug(<span class="string">&quot;connecting...&quot;</span>);</span><br><span class="line">    SocketChannel sc = ssc.accept(); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">    log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">    channels.add(sc);</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        log.debug(<span class="string">&quot;before read... &#123;&#125;&quot;</span>, channel);</span><br><span class="line">        channel.read(buffer); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        debugRead(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SocketChannel sc = SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul>
<li>非阻塞模式下，相关方法都会不会让线程暂停<ul>
<li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li>
<li>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept </li>
<li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li>
</ul>
</li>
<li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</li>
<li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li>
</ul>
<p>服务器端，客户端代码不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解非阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    SocketChannel sc = ssc.accept(); <span class="comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span></span><br><span class="line">    <span class="keyword">if</span> (sc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line">        channels.add(sc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        <span class="keyword">int</span> read = channel.read(buffer);<span class="comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debugRead(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>
<ul>
<li>多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用</li>
<li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入<ul>
<li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-Selector"><a href="#4-2-Selector" class="headerlink" title="4.2 Selector"></a>4.2 Selector</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph selector 版</span><br><span class="line">thread --&gt; selector</span><br><span class="line">selector --&gt; c1(channel)</span><br><span class="line">selector --&gt; c2(channel)</span><br><span class="line">selector --&gt; c3(channel)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<p>好处</p>
<ul>
<li>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li>
<li>让这个线程能够被充分利用</li>
<li>节约了线程的数量</li>
<li>减少了线程上下文切换</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>



<h4 id="绑定-Channel-事件"><a href="#绑定-Channel-事件" class="headerlink" title="绑定 Channel 事件"></a>绑定 Channel 事件</h4><p>也称之为注册事件，绑定的事件 selector 才会关心 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, 绑定事件);</span><br></pre></td></tr></table></figure>

<ul>
<li>channel 必须工作在非阻塞模式</li>
<li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li>
<li>绑定的事件类型可以有<ul>
<li>connect - 客户端连接成功时触发</li>
<li>accept - 服务器端成功接受连接时触发</li>
<li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li>
<li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>
</ul>
</li>
</ul>
<h4 id="监听-Channel-事件"><a href="#监听-Channel-事件" class="headerlink" title="监听 Channel 事件"></a>监听 Channel 事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p>
<p>方法1，阻塞直到绑定事件发生</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = selector.select();</span><br></pre></td></tr></table></figure>



<p>方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = selector.select(<span class="keyword">long</span> timeout);</span><br></pre></td></tr></table></figure>



<p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = selector.selectNow();</span><br></pre></td></tr></table></figure>



<h4 id="💡-select-何时不阻塞"><a href="#💡-select-何时不阻塞" class="headerlink" title="💡 select 何时不阻塞"></a>💡 select 何时不阻塞</h4><blockquote>
<ul>
<li>事件发生时<ul>
<li>客户端发起连接请求，会触发 accept 事件</li>
<li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li>
<li>channel 可写，会触发 write 事件</li>
<li>在 linux 下 nio bug 发生时</li>
</ul>
</li>
<li>调用 selector.wakeup()</li>
<li>调用 selector.close()</li>
<li>selector 所在线程 interrupt</li>
</ul>
</blockquote>
<h3 id="4-3-处理-accept-事件"><a href="#4-3-处理-accept-事件" class="headerlink" title="4.3 处理 accept 事件"></a>4.3 处理 accept 事件</h3><p>客户端代码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)) &#123;</span><br><span class="line">            System.out.println(socket);</span><br><span class="line">            socket.getOutputStream().write(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>服务器端代码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelDemo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocketChannel channel = ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line"><span class="comment">//                int count = selector.selectNow();</span></span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"><span class="comment">//                if(count &lt;= 0) &#123;</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        ServerSocketChannel c = (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        SocketChannel sc = c.accept();</span><br><span class="line">                        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="💡-事件发生后能否不处理"><a href="#💡-事件发生后能否不处理" class="headerlink" title="💡 事件发生后能否不处理"></a>💡 事件发生后能否不处理</h4><blockquote>
<p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p>
</blockquote>
<h3 id="4-4-处理-read-事件"><a href="#4-4-处理-read-事件" class="headerlink" title="4.4 处理 read 事件"></a>4.4 处理 read 事件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelDemo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocketChannel channel = ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line"><span class="comment">//                int count = selector.selectNow();</span></span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"><span class="comment">//                if(count &lt;= 0) &#123;</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        ServerSocketChannel c = (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        SocketChannel sc = c.accept();</span><br><span class="line">                        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        log.debug(<span class="string">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                        <span class="keyword">int</span> read = sc.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            sc.close();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debug(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启两个客户端，修改一下发送文字，输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]</span><br><span class="line">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]</span><br><span class="line">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]</span><br><span class="line">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 6f 72 6c 64                                  |world           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<h4 id="💡-为何要-iter-remove"><a href="#💡-为何要-iter-remove" class="headerlink" title="💡 为何要 iter.remove()"></a>💡 为何要 iter.remove()</h4><blockquote>
<p>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p>
<ul>
<li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey </li>
<li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li>
</ul>
</blockquote>
<img src="/2021/08/22/Netty01-nio/1667653959651.png" class width="1667653959651">



<h4 id="💡-cancel-的作用"><a href="#💡-cancel-的作用" class="headerlink" title="💡 cancel 的作用"></a>💡 cancel 的作用</h4><blockquote>
<p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p>
<p>客户端断开后会触发read事件, 需要将key取消（从selector的keys集合中真正删除 key）</p>
</blockquote>
<p>不论是异常断开还是正常断开（sc.close()）,都会触发读事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> read = channel.read(buffer); <span class="comment">// 正常断开， read 为-1</span></span><br><span class="line"><span class="keyword">if</span>(read == -<span class="number">1</span>)&#123;</span><br><span class="line">    key.cancel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="⚠️-不处理边界的问题"><a href="#⚠️-不处理边界的问题" class="headerlink" title="⚠️  不处理边界的问题"></a>⚠️  不处理边界的问题</h4><p>以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss=<span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket s = ss.accept();</span><br><span class="line">            InputStream in = s.getInputStream();</span><br><span class="line">            <span class="comment">// 这里这么写，有没有问题</span></span><br><span class="line">            <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> read = in.read(arr);</span><br><span class="line">                <span class="comment">// 这里这么写，有没有问题</span></span><br><span class="line">                <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(arr, <span class="number">0</span>, read));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket max = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        OutputStream out = max.getOutputStream();</span><br><span class="line">        out.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">&quot;你好&quot;</span>.getBytes());</span><br><span class="line">        max.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hell</span><br><span class="line">owor</span><br><span class="line">ld�</span><br><span class="line">�好</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为什么？</p>
<h4 id="处理消息的边界"><a href="#处理消息的边界" class="headerlink" title="处理消息的边界"></a>处理消息的边界</h4><img src="/2021/08/22/Netty01-nio/0023.png" class>

<ul>
<li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li>
<li>另一种思路是按分隔符拆分，缺点是效率低</li>
<li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul>
<li>Http 1.1 是 TLV 格式</li>
<li>Http 2.0 是 LTV 格式</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant c1 as 客户端1</span><br><span class="line">participant s as 服务器</span><br><span class="line">participant b1 as ByteBuffer1</span><br><span class="line">participant b2 as ByteBuffer2</span><br><span class="line">c1 -&gt;&gt; s: 发送 01234567890abcdef3333\r</span><br><span class="line">s -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 扩容</span><br><span class="line">b1 -&gt;&gt; b2: 拷贝 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 第二次 read 存入 3333\r</span><br><span class="line">b2 -&gt;&gt; b2: 01234567890abcdef3333\r</span><br></pre></td></tr></table></figure>

<p>服务器端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer source)</span> </span>&#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">        <span class="comment">// 找到一条完整消息</span></span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = i + <span class="number">1</span> - source.position();</span><br><span class="line">            <span class="comment">// 把这条完整消息存入新的 ByteBuffer</span></span><br><span class="line">            ByteBuffer target = ByteBuffer.allocate(length);</span><br><span class="line">            <span class="comment">// 从 source 读，向 target 写</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                target.put(source.get());</span><br><span class="line">            &#125;</span><br><span class="line">            debugAll(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.compact(); <span class="comment">// 0123456789abcdef  position 16 limit 16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建 selector, 管理多个 channel</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 2. 建立 selector 和 channel 的联系（注册）</span></span><br><span class="line">    <span class="comment">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span></span><br><span class="line">    SelectionKey sscKey = ssc.register(selector, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// key 只关注 accept 事件</span></span><br><span class="line">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">    log.debug(<span class="string">&quot;sscKey:&#123;&#125;&quot;</span>, sscKey);</span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">        <span class="comment">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class="comment">// accept, read</span></span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = iter.next();</span><br><span class="line">            <span class="comment">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span></span><br><span class="line">            iter.remove();</span><br><span class="line">            log.debug(<span class="string">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">            <span class="comment">// 5. 区分事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123; <span class="comment">// 如果是 accept</span></span><br><span class="line">                ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                SocketChannel sc = channel.accept();</span><br><span class="line">                sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>); <span class="comment">// attachment</span></span><br><span class="line">                <span class="comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span></span><br><span class="line">                SelectionKey scKey = sc.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">                scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                log.debug(<span class="string">&quot;scKey:&#123;&#125;&quot;</span>, scKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123; <span class="comment">// 如果是 read</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel(); <span class="comment">// 拿到触发事件的channel</span></span><br><span class="line">                    <span class="comment">// 获取 selectionKey 上关联的附件</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="keyword">int</span> read = channel.read(buffer); <span class="comment">// 如果是正常断开，read 的方法的返回值是 -1</span></span><br><span class="line">                    <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                        key.cancel();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        split(buffer);</span><br><span class="line">                        <span class="comment">// 需要扩容</span></span><br><span class="line">                        <span class="keyword">if</span> (buffer.position() == buffer.limit()) &#123;</span><br><span class="line">                            ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            newBuffer.put(buffer); <span class="comment">// 0123456789abcdef3333\n</span></span><br><span class="line">                            key.attach(newBuffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    key.cancel();  <span class="comment">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SocketChannel sc = SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">SocketAddress address = sc.getLocalAddress();</span><br><span class="line"><span class="comment">// sc.write(Charset.defaultCharset().encode(&quot;hello\nworld\n&quot;));</span></span><br><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123\n456789abcdef&quot;</span>));</span><br><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123456789abcdef3333\n&quot;</span>));</span><br><span class="line">System.in.read();</span><br></pre></td></tr></table></figure>





<h4 id="ByteBuffer-大小分配"><a href="#ByteBuffer-大小分配" class="headerlink" title="ByteBuffer 大小分配"></a>ByteBuffer 大小分配</h4><ul>
<li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer</li>
<li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer<ul>
<li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 <a href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li>
<li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li>
</ul>
</li>
</ul>
<h3 id="4-5-处理-write-事件"><a href="#4-5-处理-write-事件" class="headerlink" title="4.5 处理 write 事件"></a>4.5 处理 write 事件</h3><h4 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h4><ul>
<li>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li>
<li>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略<ul>
<li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li>
<li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li>
<li>如果不取消，会每次可写均会触发 write 事件</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    SelectionKey sckey = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// 1. 向客户端发送内容</span></span><br><span class="line">                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000000</span>; i++) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="keyword">int</span> write = sc.write(buffer);</span><br><span class="line">                    <span class="comment">// 3. write 表示实际写了多少字节</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="comment">// 4. 如果有剩余未读字节，才需要关注写事件</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        <span class="comment">// read 1  write 4</span></span><br><span class="line">                        <span class="comment">// 在原有关注事件的基础上，多关注 写事件</span></span><br><span class="line">                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">// 把 buffer 作为附件加入 sckey</span></span><br><span class="line">                        sckey.attach(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="keyword">int</span> write = sc.write(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining()) &#123; <span class="comment">// 写完了</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">                        key.attach(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    System.out.println(sc.finishConnect());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">                    count += sc.read(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="💡-write-为何要取消"><a href="#💡-write-为何要取消" class="headerlink" title="💡 write 为何要取消"></a>💡 write 为何要取消</h4><p>只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注</p>
<h3 id="4-6-更进一步"><a href="#4-6-更进一步" class="headerlink" title="4.6 更进一步"></a>4.6 更进一步</h3><h4 id="💡-利用多线程优化"><a href="#💡-利用多线程优化" class="headerlink" title="💡 利用多线程优化"></a>💡 利用多线程优化</h4><blockquote>
<p>现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费</p>
</blockquote>
<p>前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？</p>
<p>分两组选择器</p>
<ul>
<li>单线程配一个选择器，专门处理 accept 事件</li>
<li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelDemo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BossEventLoop().register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BossEventLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Selector boss;</span><br><span class="line">        <span class="keyword">private</span> WorkerEventLoop[] workers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> start = <span class="keyword">false</span>;</span><br><span class="line">        AtomicInteger index = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">                ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">                ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                boss = Selector.open();</span><br><span class="line">                SelectionKey ssckey = ssc.register(boss, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                ssckey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">                workers = initEventLoops();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">this</span>, <span class="string">&quot;boss&quot;</span>).start();</span><br><span class="line">                log.debug(<span class="string">&quot;boss start...&quot;</span>);</span><br><span class="line">                start = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> WorkerEventLoop[] initEventLoops() &#123;</span><br><span class="line"><span class="comment">//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];</span></span><br><span class="line">            WorkerEventLoop[] workerEventLoops = <span class="keyword">new</span> WorkerEventLoop[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workerEventLoops.length; i++) &#123;</span><br><span class="line">                workerEventLoops[i] = <span class="keyword">new</span> WorkerEventLoop(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> workerEventLoops;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    boss.select();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            ServerSocketChannel c = (ServerSocketChannel) key.channel();</span><br><span class="line">                            SocketChannel sc = c.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            log.debug(<span class="string">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                            workers[index.getAndIncrement() % workers.length].register(sc);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerEventLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Selector worker;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> start = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WorkerEventLoop</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                worker = Selector.open();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">this</span>, <span class="string">&quot;worker-&quot;</span> + index).start();</span><br><span class="line">                start = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasks.add(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SelectionKey sckey = sc.register(worker, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                    sckey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    worker.selectNow();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            worker.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    worker.select();</span><br><span class="line">                    Runnable task = tasks.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">int</span> read = sc.read(buffer);</span><br><span class="line">                                <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    key.cancel();</span><br><span class="line">                                    sc.close();</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    buffer.flip();</span><br><span class="line">                                    log.debug(<span class="string">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                                    debugAll(buffer);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                key.cancel();</span><br><span class="line">                                sc.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        iter.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="💡-如何拿到-cpu-个数"><a href="#💡-如何拿到-cpu-个数" class="headerlink" title="💡 如何拿到 cpu 个数"></a>💡 如何拿到 cpu 个数</h4><blockquote>
<ul>
<li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li>
<li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li>
</ul>
</blockquote>
<h3 id="4-7-UDP"><a href="#4-7-UDP" class="headerlink" title="4.7 UDP"></a>4.7 UDP</h3><ul>
<li>UDP 是无连接的，client 发送数据不会管 server 是否开启</li>
<li>server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃</li>
</ul>
<p>首先启动服务器端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (DatagramChannel channel = DatagramChannel.open()) &#123;</span><br><span class="line">            channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">            channel.receive(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debug(buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">waiting...</span><br></pre></td></tr></table></figure>



<p>运行客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (DatagramChannel channel = DatagramChannel.open()) &#123;</span><br><span class="line">            ByteBuffer buffer = StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">            channel.send(buffer, address);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来服务器端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>





<h2 id="5-NIO-vs-BIO"><a href="#5-NIO-vs-BIO" class="headerlink" title="5. NIO vs BIO"></a>5. NIO vs BIO</h2><h3 id="5-1-stream-vs-channel"><a href="#5-1-stream-vs-channel" class="headerlink" title="5.1 stream vs channel"></a>5.1 stream vs channel</h3><ul>
<li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>
<li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li>
<li>二者均为全双工，即读写可以同时进行</li>
</ul>
<h3 id="5-2-IO-模型"><a href="#5-2-IO-模型" class="headerlink" title="5.2 IO 模型"></a>5.2 IO 模型</h3><p>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞</p>
<ul>
<li>同步：线程自己去获取结果（一个线程）</li>
<li>异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）</li>
</ul>
<p>当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>
<ul>
<li>等待数据阶段</li>
<li>复制数据阶段</li>
</ul>
<img src="/2021/08/22/Netty01-nio/0033.png" class>

<ul>
<li><p>阻塞 IO</p>
<img src="/2021/08/22/Netty01-nio/0039.png" class></li>
<li><p>非阻塞  IO</p>
<img src="/2021/08/22/Netty01-nio/0035.png" class></li>
<li><p>多路复用</p>
<img src="/2021/08/22/Netty01-nio/0038.png" class></li>
<li><p>信号驱动</p>
</li>
<li><p>异步 IO</p>
<img src="/2021/08/22/Netty01-nio/0037.png" class></li>
<li><p>阻塞 IO vs 多路复用</p>
<img src="/2021/08/22/Netty01-nio/0034.png" class>

<img src="/2021/08/22/Netty01-nio/0036.png" class></li>
</ul>
<h4 id="🔖-参考"><a href="#🔖-参考" class="headerlink" title="🔖 参考"></a>🔖 参考</h4><p>UNIX 网络编程 - 卷 I</p>
<h3 id="5-3-零拷贝"><a href="#5-3-零拷贝" class="headerlink" title="5.3 零拷贝"></a>5.3 零拷贝</h3><h4 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line">Socket socket = ...;</span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>

<p>内部工作流程是这样的：</p>
<img src="/2021/08/22/Netty01-nio/0024.png" class>

<ol>
<li><p>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu</p>
<blockquote>
<p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p>
</blockquote>
</li>
<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p>
</li>
<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p>
</li>
<li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p>
</li>
</ol>
<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>
<ul>
<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>
<li>数据拷贝了共 4 次</li>
</ul>
<h4 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h4><p>通过 DirectByteBuf </p>
<ul>
<li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存</li>
<li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</li>
</ul>
<img src="/2021/08/22/Netty01-nio/0025.png" class>

<p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p>
<ul>
<li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li>
<li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul>
<li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li>
<li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li>
</ul>
</li>
<li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li>
</ul>
<p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p>
<img src="/2021/08/22/Netty01-nio/0026.png" class>

<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>可以看到</p>
<ul>
<li>只发生了一次用户态与内核态的切换</li>
<li>数据拷贝了 3 次</li>
</ul>
<p>进一步优化（linux 2.4）</p>
<img src="/2021/08/22/Netty01-nio/0027.png" class>

<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>
<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p>
<ul>
<li>更少的用户态与内核态的切换</li>
<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
<h3 id="5-3-AIO"><a href="#5-3-AIO" class="headerlink" title="5.3 AIO"></a>5.3 AIO</h3><p>AIO 用来解决数据复制阶段的阻塞问题</p>
<ul>
<li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li>
<li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li>
</ul>
<blockquote>
<p>异步模型需要底层操作系统（Kernel）提供支持</p>
<ul>
<li>Windows 系统通过 IOCP 实现了真正的异步 IO</li>
<li>Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势</li>
</ul>
</blockquote>
<h4 id="文件-AIO"><a href="#文件-AIO" class="headerlink" title="文件 AIO"></a>文件 AIO</h4><p>先来看看 AsynchronousFileChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            AsynchronousFileChannel s = </span><br><span class="line">                AsynchronousFileChannel.open(</span><br><span class="line">                	Paths.get(<span class="string">&quot;1.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            s.read(buffer, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read completed...&#123;&#125;&quot;</span>, result);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debug(buffer);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read failed...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;do other things...&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...</span><br><span class="line">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...</span><br><span class="line">13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 0d                                           |a.              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>可以看到</p>
<ul>
<li>响应文件读取成功的是另一个线程 Thread-5</li>
<li>主线程并没有 IO 操作阻塞</li>
</ul>
<h4 id="💡-守护线程"><a href="#💡-守护线程" class="headerlink" title="💡 守护线程"></a>💡 守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p>
<h4 id="网络-AIO"><a href="#网络-AIO" class="headerlink" title="网络 AIO"></a>网络 AIO</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open();</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        ssc.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptHandler(ssc));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeChannel</span><span class="params">(AsynchronousSocketChannel sc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;[%s] %s close\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReadHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == -<span class="number">1</span>) &#123;</span><br><span class="line">                    closeChannel(sc);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s read\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">                attachment.flip();</span><br><span class="line">                System.out.println(Charset.defaultCharset().decode(attachment));</span><br><span class="line">                attachment.clear();</span><br><span class="line">                <span class="comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span></span><br><span class="line">                sc.read(attachment, attachment, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">WriteHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span></span><br><span class="line">            <span class="keyword">if</span> (attachment.hasRemaining()) &#123;</span><br><span class="line">                sc.write(attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousServerSocketChannel ssc;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AcceptHandler</span><span class="params">(AsynchronousServerSocketChannel ssc)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ssc = ssc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel sc, Object attachment)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s connected\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 读事件由 ReadHandler 处理</span></span><br><span class="line">            sc.read(buffer, buffer, <span class="keyword">new</span> ReadHandler(sc));</span><br><span class="line">            <span class="comment">// 写事件由 WriteHandler 处理</span></span><br><span class="line">            sc.write(Charset.defaultCharset().encode(<span class="string">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class="number">16</span>), <span class="keyword">new</span> WriteHandler(sc));</span><br><span class="line">            <span class="comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span></span><br><span class="line">            ssc.accept(<span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>重构技巧（一）</title>
    <url>/2021/10/14/cleancode2/</url>
    <content><![CDATA[<h1 id="OO三要素"><a href="#OO三要素" class="headerlink" title="OO三要素"></a>OO三要素</h1><p>封装、继承、多态</p>
<p>为什么要有public、private、protected修饰符？</p>
<p>降低依赖。public公开，所有的成员都能使用，就增加了依赖，耦合</p>
<h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><img src="/2021/10/14/cleancode2/1627487392455.png" class width="1627489149017">

<p>A是当前设计的类，B是A要调用的类，称之为A的好朋友。什么类才会成为A的好朋友？</p>
<p>字段、B作为A方法的一个参数、A负责创建了B</p>
<img src="/2021/10/14/cleancode2/1627489270153.png" class width="1627489270153">

<p>C是B的朋友，对于A来说，C是朋友的朋友，并不是自己的朋友，相当于陌生人，故，迪米特法则也叫“不要和陌生人说话”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhuhongliang.refactoring.demeter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Paperboy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(Customer myCustomer, <span class="keyword">float</span> payment)</span> </span>&#123;</span><br><span class="line">        Wallet theWallet = myCustomer.getWallet();</span><br><span class="line">        <span class="keyword">if</span> (theWallet.getTotalMoney() &gt; payment) &#123;</span><br><span class="line">            theWallet.subtractMoney(payment);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//money not enough</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PaperBoy :超时收银员，charge收钱方法，需要接受顾客Customer参数传进来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhuhongliang.refactoring.demeter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Wallet myWallet;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wallet <span class="title">getWallet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myWallet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2021/10/14/cleancode2/1627489624377.png" class width="1627489624377">



<p>面向对象 拟人化，将每一个对象看做一个具有独立思考能力的人！</p>
<p>get、set</p>
<h1 id="信息专家模式"><a href="#信息专家模式" class="headerlink" title="信息专家模式"></a>信息专家模式</h1><img src="/2021/10/14/cleancode2/1627491522216.png" class width="1627491522216">

<img src="/2021/10/14/cleancode2/1627491643782.png" class width="1627491643782">

<p>下面是原来的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillParameters</span><span class="params">(HttpServletRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Parameter para : parameterGraph.getParameters()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (para <span class="keyword">instanceof</span> SimpleParameter) &#123;</span><br><span class="line">                SimpleParameter simplePara = (SimpleParameter) para;</span><br><span class="line">                String[] values = request.getParameterValues(simplePara.getName());</span><br><span class="line">                simplePara.setValue(values);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (para <span class="keyword">instanceof</span> ItemParameter) &#123;</span><br><span class="line">                    ItemParameter itemPara = (ItemParameter) para;</span><br><span class="line">                    <span class="keyword">for</span> (Item item : itemPara.getItems()) &#123;</span><br><span class="line">                        String[] values = request.getParameterValues(item.getName());</span><br><span class="line">                        item.setValues(values);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    TableParameter tablePara = (TableParameter) para;</span><br><span class="line">                    String[] rows =</span><br><span class="line">                            request.getParameterValues(tablePara.getRowName());</span><br><span class="line">                    String[] columns =</span><br><span class="line">                            request.getParameterValues(tablePara.getColumnName());</span><br><span class="line">                    String[] dataCells =</span><br><span class="line">                            request.getParameterValues(tablePara.getDataCellName());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> columnSize = columns.length;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns.length; j++) &#123;</span><br><span class="line">                            TableParameterElement element = <span class="keyword">new</span> TableParameterElement();</span><br><span class="line">                            element.setRow(rows[i]);</span><br><span class="line">                            element.setColumn(columns[j]);</span><br><span class="line">                            element.setDataCell(dataCells[columnSize * i + j]);</span><br><span class="line">                            tablePara.addElement(element);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>大量的if else ，看到if else就要敏感起来。</li>
<li>嵌套层次太多了，看看后面多少个大括号。</li>
<li>instanceof在静态语言中的使用可能会影响多态带来的好处。</li>
<li>信息专家模式： 让操作这些数据的行为分配给拥有这些数据的对象。</li>
</ol>
<img src="/2021/10/14/cleancode2/1627573518593.png" class width="1627573518593">

<h2 id="重构：-提取方法"><a href="#重构：-提取方法" class="headerlink" title="重构： 提取方法"></a>重构： 提取方法</h2><p>所以进行重构：Ctrl+Alt+M</p>
<img src="/2021/10/14/cleancode2/1627573717079.png" class width="1627573717079">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(HttpServletRequest request, TableParameter para)</span> </span>&#123;</span><br><span class="line">    TableParameter tablePara = para;</span><br><span class="line">    String[] rows =</span><br><span class="line">            request.getParameterValues(tablePara.getRowName());</span><br><span class="line">    String[] columns =</span><br><span class="line">            request.getParameterValues(tablePara.getColumnName());</span><br><span class="line">    String[] dataCells =</span><br><span class="line">            request.getParameterValues(tablePara.getDataCellName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> columnSize = columns.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns.length; j++) &#123;</span><br><span class="line">            TableParameterElement element = <span class="keyword">new</span> TableParameterElement();</span><br><span class="line">            element.setRow(rows[i]);</span><br><span class="line">            element.setColumn(columns[j]);</span><br><span class="line">            element.setDataCell(dataCells[columnSize * i + j]);</span><br><span class="line">            tablePara.addElement(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(HttpServletRequest request, ItemParameter para)</span> </span>&#123;</span><br><span class="line">    ItemParameter itemPara = para;</span><br><span class="line">    <span class="keyword">for</span> (Item item : itemPara.getItems()) &#123;</span><br><span class="line">        String[] values = request.getParameterValues(item.getName());</span><br><span class="line">        item.setValues(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(HttpServletRequest request, SimpleParameter para)</span> </span>&#123;</span><br><span class="line">    SimpleParameter simplePara = para;</span><br><span class="line">    String[] values = request.getParameterValues(simplePara.getName());</span><br><span class="line">    simplePara.setValue(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重构：-方法移动"><a href="#重构：-方法移动" class="headerlink" title="重构： 方法移动"></a>重构： 方法移动</h2><p>上面封装了是哪个函数，可以看到这些函数的参数是各自的Parameter（ItemParameter、SimpleParameter、TableParameter），所以需要移动这些方法到各自的类中，而不需要在当前ParameterController这个类里面。</p>
<p>移动方法的快捷键为： F6</p>
<img src="/2021/10/14/cleancode2/1627573893272.png" class width="1627573893272">

<p>然后方法名也需要做一定的修改：这个函数的意思是将request里面的value填充到parameter中，所以 应该是 parameter fill with request这样的语序。</p>
<p>修改完的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillParameters</span><span class="params">(HttpServletRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Parameter para : parameterGraph.getParameters()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (para <span class="keyword">instanceof</span> SimpleParameter) &#123;</span><br><span class="line">                ((SimpleParameter) para).fillWith(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (para <span class="keyword">instanceof</span> ItemParameter) &#123;</span><br><span class="line">                    ((ItemParameter) para).fillWIth(request);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ((TableParameter) para).fillWith(request);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="重构：-Pull-Members-Up-抽象接口"><a href="#重构：-Pull-Members-Up-抽象接口" class="headerlink" title="重构： Pull Members Up 抽象接口"></a>重构： Pull Members Up 抽象接口</h2><p>这个代码还有问题，可以看到这个三个Parameter类都有fillWith方法，他们都继承了Parameter接口，所以，可以将他们共有的方法抽象出来。放到接口这里。这里继续重构：Pull menbers Up</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhuhongliang.refactoring.report.engine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parameter</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fillWith</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在接口这里定义了一个抽象方法。</p>
<p>然后可以看到这三个地方都变灰色了，这是无效的类型转换</p>
<img src="/2021/10/14/cleancode2/1627575193866.png" class width="1627575193866">

<h2 id="重构：-用多态替换分支Replace-Switch-by-Polymorphism"><a href="#重构：-用多态替换分支Replace-Switch-by-Polymorphism" class="headerlink" title="重构： 用多态替换分支Replace Switch by Polymorphism"></a>重构： 用多态替换分支Replace Switch by Polymorphism</h2><p><strong>这是上述这写操作的目的</strong></p>
<p>可以发现代码一样，就不需要这么多if else了。。。</p>
<img src="/2021/10/14/cleancode2/1627575229335.png" class width="1627575229335">

<p>最终代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillParameters</span><span class="params">(HttpServletRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Parameter para : parameterGraph.getParameters()) &#123;</span><br><span class="line">            para.fillWith(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就很简洁了，而且多态的优势也体现出来了。</p>
<h2 id="特性依恋"><a href="#特性依恋" class="headerlink" title="特性依恋"></a>特性依恋</h2><img src="/2021/10/14/cleancode2/1627575470700.png" class width="1627575470700">

<p>特性依恋（嫉妒）就是原本不属于它的东西抢过来了，这是坏味道，需要重构。</p>
<h2 id="回顾迪米特法则"><a href="#回顾迪米特法则" class="headerlink" title="回顾迪米特法则"></a>回顾迪米特法则</h2><p>我们再看看现在的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillParameters</span><span class="params">(HttpServletRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Parameter para : parameterGraph.getParameters()) &#123;</span><br><span class="line">            para.fillWith(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于当前类：ParameterController， HttpServletRequest和ParameterGraph是他的朋友，但是Parameter属于ParameterGraph的朋友，那么，Parameter是当前类ParameterController朋友的朋友，破坏了迪米特法则，可以继续重构：for循环的代码不属于当前类的职责，应该是ParameterGraph的职责。</p>
<img src="/2021/10/14/cleancode2/1627577673473.png" class width="1627577673473">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterGraph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Parameter&gt; <span class="title">getParameters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillWith</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Parameter para : getParameters()) &#123;</span><br><span class="line">            para.fillWith(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillParameters</span><span class="params">(HttpServletRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</span><br><span class="line">        parameterGraph.fillWith(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><img src="/2021/10/14/cleancode2/1627577868111.png" class width="1627577868111">

<p>两个核心原则：</p>
<ol>
<li>面向接口设计</li>
<li>组合/聚合有限复用原则</li>
</ol>
<img src="/2021/10/14/cleancode2/1627577971877.png" class width="1627577971877">

<p>差异式编程，无差异，无继承。</p>
<h2 id="重构案例：-JDBC数据库访问框架"><a href="#重构案例：-JDBC数据库访问框架" class="headerlink" title="重构案例： JDBC数据库访问框架"></a>重构案例： JDBC数据库访问框架</h2><p>PartDB的案例体现了关注点分离原则。重构后的代码遵循单一抽象层次原则（SLAP），即方法中的所有操作应该处于同一个抽象层次。例如如下概念就不在同一个抽象的层次上：</p>
<p>苹果、香蕉、土豆、蔬菜、水果、大白菜。</p>
<p>很明显，苹果和香蕉都是属于水果，水果属于上一层的； 同理，土豆和大白菜都属于蔬菜。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartDB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER_CLASS = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_SELECT_PARTS = <span class="string">&quot;select * from part&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Part&gt; partList = <span class="keyword">new</span> ArrayList&lt;Part&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(DRIVER_CLASS);</span><br><span class="line">            c = DriverManager.getConnection(DB_URL, USER, PASSWORD);</span><br><span class="line">            Statement stmt = c.createStatement();</span><br><span class="line">            ResultSet rs = stmt.executeQuery(SQL_SELECT_PARTS);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                Part p = <span class="keyword">new</span> Part();</span><br><span class="line">                p.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                p.setBrand(rs.getString(<span class="string">&quot;brand&quot;</span>));</span><br><span class="line">                p.setRetailPrice(rs.getDouble(<span class="string">&quot;retail_price&quot;</span>));</span><br><span class="line">                partList.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            c.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>违背了关注点分离原则，技术上的关注点和业务上的关注点。</p>
<p>上下分离，上就是泛化，下就是特定，可以使用继承。把通用的东西往上提，把特定的东西往下走。左右分离也是另一种关注点分离。</p>
<p>下面对上述代码进行重构：</p>
<h3 id="重构：对代码进行按照职责分离，抽取方法"><a href="#重构：对代码进行按照职责分离，抽取方法" class="headerlink" title="重构：对代码进行按照职责分离，抽取方法"></a>重构：对代码进行按照职责分离，抽取方法</h3><img src="/2021/10/14/cleancode2/1627656648456.png" class width="1627656648456">

<p>上述三个职责，可以单独提取方法出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartDB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER_CLASS = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Part&gt; partList = <span class="keyword">new</span> ArrayList&lt;Part&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> (Connection connection = getConnection()) &#123;</span><br><span class="line">            ResultSet rs = executeQuery(connection);</span><br><span class="line">            PopulateEntities(rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PopulateEntities</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            Part p = <span class="keyword">new</span> Part();</span><br><span class="line">            p.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            p.setBrand(rs.getString(<span class="string">&quot;brand&quot;</span>));</span><br><span class="line">            p.setRetailPrice(rs.getDouble(<span class="string">&quot;retail_price&quot;</span>));</span><br><span class="line">            partList.add(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ResultSet <span class="title">executeQuery</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Statement stmt = connection.createStatement();</span><br><span class="line">        <span class="keyword">return</span> stmt.executeQuery(getSql());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;select * from part&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Connection <span class="title">executeQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class.forName(DRIVER_CLASS);</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL, USER, PASSWORD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个方法都是在做一件相对内聚的事情。将具体的操作抽象出来，对于当前类，了解得越少越好。所谓抽象，就是关注what to do？ 比如getConnection()就主要是获取连接，但是怎么获取的我不需要知道，隐藏了细节。 populate()方法就比较简洁。</p>
<h3 id="重构：-继承，通用的往上提"><a href="#重构：-继承，通用的往上提" class="headerlink" title="重构： 继承，通用的往上提"></a>重构： 继承，通用的往上提</h3><p>我们再看这三个方法（popu：late() 、executeQuery、executeQuery），这是哪个方法无论是抽象层次还是实现层次都跟业务无关，都是通用的代码。唯一跟业务有关的就是sql语句和PopulateEntities方法。</p>
<p>快捷键： Ctrl+Shift+Alt+T –&gt; Extract super CLass</p>
<img src="/2021/10/14/cleancode2/1627657889393.png" class width="1627657889393">

<p>DataBase 单独抽取一个父类出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhuhongliang.cleancode.composemethods;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-07-30 23:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER_CLASS = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Connection connection = getConnection()) &#123;</span><br><span class="line">            ResultSet rs = executeQuery(connection);</span><br><span class="line">            PopulateEntities(rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PopulateEntities</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ResultSet <span class="title">executeQuery</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Statement stmt = connection.createStatement();</span><br><span class="line">        <span class="keyword">return</span> stmt.executeQuery(getSql());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getSql</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class.forName(DRIVER_CLASS);</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL, USER, PASSWORD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="重构案例-电子商务订单处理案例"><a href="#重构案例-电子商务订单处理案例" class="headerlink" title="重构案例 电子商务订单处理案例"></a>重构案例 电子商务订单处理案例</h2><p>电子商务订单处理案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zhuhongliang.cleancode.slap.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> zhuhongliang.cleancode.slap.entity.Customer;</span><br><span class="line"><span class="keyword">import</span> zhuhongliang.cleancode.slap.entity.Training;</span><br><span class="line"><span class="keyword">import</span> zhuhongliang.cleancode.slap.infrastructure.DatabasePool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainingService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DatabasePool dbPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(List&lt;Training&gt; trainings, Customer customer)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection c = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        Statement s = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> transactionState = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s = c.createStatement();</span><br><span class="line">            transactionState = c.getAutoCommit();</span><br><span class="line">            c.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (Training training : trainings) &#123;</span><br><span class="line">                addTrainingItem(customer, training);</span><br><span class="line">            &#125;</span><br><span class="line">            addOrder(customer, trainings);</span><br><span class="line">            c.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException sqlx) &#123;</span><br><span class="line">            c.rollback();</span><br><span class="line">            <span class="keyword">throw</span> sqlx;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.setAutoCommit(transactionState);</span><br><span class="line">                dbPool.release(c);</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="keyword">null</span>) s.close();</span><br><span class="line">                <span class="keyword">if</span> (ps != <span class="keyword">null</span>) ps.close();</span><br><span class="line">                <span class="keyword">if</span> (rs != <span class="keyword">null</span>) rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOrder</span><span class="params">(Customer customer, List&lt;Training&gt; trainings)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addTrainingItem</span><span class="params">(Customer customer, Training training)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>CleanCode</category>
      </categories>
      <tags>
        <tag>refactory</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty 入门</title>
    <url>/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="二-Netty-入门"><a href="#二-Netty-入门" class="headerlink" title="二. Netty 入门"></a>二. Netty 入门</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-Netty-是什么？"><a href="#1-1-Netty-是什么？" class="headerlink" title="1.1 Netty 是什么？"></a>1.1 Netty 是什么？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Netty is an asynchronous event-driven network application framework</span><br><span class="line">for rapid development of maintainable high performance protocol servers &amp; clients.</span><br></pre></td></tr></table></figure>

<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>
<h3 id="1-2-Netty-的作者"><a href="#1-2-Netty-的作者" class="headerlink" title="1.2 Netty 的作者"></a>1.2 Netty 的作者</h3><img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0005.png" class>

<p>他还是另一个著名网络应用框架 Mina 的重要贡献者</p>
<h3 id="1-3-Netty-的地位"><a href="#1-3-Netty-的地位" class="headerlink" title="1.3 Netty 的地位"></a>1.3 Netty 的地位</h3><p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p>
<p>以下的框架都使用了 Netty，因为它们有网络通信需求！</p>
<ul>
<li>Cassandra - nosql 数据库</li>
<li>Spark - 大数据分布式计算框架</li>
<li>Hadoop - 大数据分布式存储框架</li>
<li>RocketMQ - ali 开源的消息队列</li>
<li>ElasticSearch - 搜索引擎</li>
<li>gRPC - rpc 框架</li>
<li>Dubbo - rpc 框架</li>
<li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li>
<li>Zookeeper - 分布式协调框架</li>
</ul>
<h3 id="1-4-Netty-的优势"><a href="#1-4-Netty-的优势" class="headerlink" title="1.4 Netty 的优势"></a>1.4 Netty 的优势</h3><ul>
<li>Netty vs NIO，工作量大，bug 多<ul>
<li>需要自己构建协议</li>
<li>解决 TCP 传输问题，如粘包、半包</li>
<li>epoll 空轮询导致 CPU 100%</li>
<li>对 API 进行增强，使之更易用，如 FastThreadLocal =&gt; ThreadLocal，ByteBuf =&gt; ByteBuffer</li>
</ul>
</li>
<li>Netty vs 其它网络应用框架<ul>
<li>Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀</li>
<li>久经考验，16年，Netty 版本<ul>
<li>2.x 2004</li>
<li>3.x 2008</li>
<li>4.x 2013</li>
<li>5.x 已废弃（没有明显的性能提升，维护成本高）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello World"></a>2. Hello World</h2><h3 id="2-1-目标"><a href="#2-1-目标" class="headerlink" title="2.1 目标"></a>2.1 目标</h3><p>开发一个简单的服务器端和客户端</p>
<ul>
<li>客户端向服务器端发送 hello, world</li>
<li>服务器仅接收，不返回</li>
</ul>
<p>加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.39.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="2-2-服务器端"><a href="#2-2-服务器端" class="headerlink" title="2.2 服务器端"></a>2.2 服务器端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动器， 负责组装 netty组件，启动服务器</span></span><br><span class="line"><span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioServerSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder()); <span class="comment">// 5</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123; <span class="comment">// 6</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 打印上一步处理好的字符串</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>代码解读</p>
<ul>
<li><p>1 处，创建 NioEventLoopGroup，可以简单理解为 <code>线程池 + Selector</code> 后面会详细展开</p>
</li>
<li><p>2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有</p>
<img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0006.png" class></li>
<li><p>3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器.</p>
</li>
<li><p>4 处，ServerSocketChannel 绑定的监听端口</p>
</li>
<li><p>5 处，SocketChannel 的处理器，解码 ByteBuf =&gt; String</p>
</li>
<li><p>6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果</p>
</li>
</ul>
<h3 id="2-3-客户端"><a href="#2-3-客户端" class="headerlink" title="2.3 客户端"></a>2.3 客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder()); <span class="comment">// 8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>) <span class="comment">// 4</span></span><br><span class="line">    .sync() <span class="comment">// 5</span></span><br><span class="line">    .channel() <span class="comment">// 6</span></span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> Date() + <span class="string">&quot;: hello world!&quot;</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>代码解读</p>
<ul>
<li><p>1 处，创建 NioEventLoopGroup，同 Server</p>
</li>
<li><p>2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有</p>
<img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0007.png" class></li>
<li><p>3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>
</li>
<li><p>4 处，指定要连接的服务器和端口</p>
</li>
<li><p>5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕</p>
</li>
<li><p>6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作</p>
</li>
<li><p>7 处，写入消息并清空缓冲区</p>
</li>
<li><p>8 处，消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 发出</p>
</li>
<li><p>数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程</p>
</li>
</ul>
<h3 id="2-4-流程梳理"><a href="#2-4-流程梳理" class="headerlink" title="2.4 流程梳理"></a>2.4 流程梳理</h3><img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0040.png" class>

<h4 id="💡-提示"><a href="#💡-提示" class="headerlink" title="💡 提示"></a>💡 提示</h4><blockquote>
<p>一开始需要树立正确的观念</p>
<ul>
<li>把 channel 理解为数据的通道</li>
<li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>
<li>把 handler 理解为数据的处理工序<ul>
<li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>
<li>handler 分 Inbound 和 Outbound 两类<ul>
<li>Inbound  入站 ，数据输入的时候处理</li>
<li>Outbound 出站， 数据向客户端写出的时候处理</li>
</ul>
</li>
</ul>
</li>
<li>把 eventLoop 理解为处理数据的工人<ul>
<li>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）</li>
<li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>
<li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3-组件"><a href="#3-组件" class="headerlink" title="3. 组件"></a>3. 组件</h2><h3 id="3-1-EventLoop"><a href="#3-1-EventLoop" class="headerlink" title="3.1 EventLoop"></a>3.1 EventLoop</h3><p>事件循环对象</p>
<p>EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 i o 事件。</p>
<p>它的继承关系比较复杂</p>
<ul>
<li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul>
<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li>
</ul>
</li>
</ul>
<p>事件循环组</p>
<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>
<ul>
<li>继承自 netty 自己的 EventExecutorGroup<ul>
<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>
<li>另有 next 方法获取集合中下一个 EventLoop</li>
</ul>
</li>
</ul>
<p>以一个简单的实现为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程</span></span><br><span class="line">DefaultEventLoopGroup group = <span class="keyword">new</span> DefaultEventLoopGroup(<span class="number">2</span>);</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br></pre></td></tr></table></figure>

<p>也可以使用 for 循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoopGroup group = <span class="keyword">new</span> DefaultEventLoopGroup(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (EventExecutor eventLoop : group) &#123;</span><br><span class="line">    System.out.println(eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br></pre></td></tr></table></figure>



<h4 id="💡-优雅关闭"><a href="#💡-优雅关闭" class="headerlink" title="💡 优雅关闭"></a>💡 优雅关闭</h4><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>
<h4 id="细分EventLoopGroup"><a href="#细分EventLoopGroup" class="headerlink" title="细分EventLoopGroup"></a>细分EventLoopGroup</h4><ol>
<li><p>细分1： boss线程只负责ServerSocketChannel上的accept事件， worker 只负责socketChannel上的读写。</p>
</li>
<li><p>细分2： 一个worker可以处理多个channel，但是如果一个channel的任务执行较长，会影响到其他channel上的任务。所以 可以将耗时的任务单独让一个EventLoop来执行、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hongliang.netty01.eventloop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-25 12:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 细分2</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> DefaultEventLoopGroup();</span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                <span class="comment">// 细分1：  boss只负责 ServerSocketChannel 上的accept 事件。   worker</span></span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup(), <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>))</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="string">&quot;handler1&quot;</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">                                log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                                <span class="comment">// 让消息传递给下一个handler</span></span><br><span class="line">                                ctx.fireChannelRead(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).addLast(group, <span class="string">&quot;handler2&quot;</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">( ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                ByteBuf buf = (ByteBuf)msg;</span><br><span class="line">                                log.debug(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="演示-NioEventLoop-处理-io-事件"><a href="#演示-NioEventLoop-处理-io-事件" class="headerlink" title="演示 NioEventLoop 处理 io 事件"></a>演示 NioEventLoop 处理 io 事件</h4><p>服务器端两个 nio worker 工人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>), <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">                    ByteBuf byteBuf = msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        ByteBuf len = byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> String(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></table></figure>

<p>客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>))</span><br><span class="line">            .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .channel(NioSocketChannel.class).connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">            .sync()</span><br><span class="line">            .channel();</span><br><span class="line"></span><br><span class="line">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;wangwu&quot;</span>.getBytes()));</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;wangwu&quot;</span>.getBytes()));</span><br></pre></td></tr></table></figure>

<p>最后输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        </span><br><span class="line">22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         </span><br></pre></td></tr></table></figure>

<p>可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定</p>
<img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0042.png" class>



<p>再增加两个非 nio 工人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoopGroup normalWorkers = <span class="keyword">new</span> DefaultEventLoopGroup(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>), <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span>  </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">            ch.pipeline().addLast(normalWorkers,<span class="string">&quot;myhandler&quot;</span>,</span><br><span class="line">              <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">                    ByteBuf byteBuf = msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        ByteBuf len = byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> String(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></table></figure>

<p>客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class="line">22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class="line">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class="line">22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class="line">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED</span><br><span class="line">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE</span><br><span class="line">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class="line">22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class="line">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class="line">22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class="line">22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br><span class="line">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class="line">22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br></pre></td></tr></table></figure>

<p>可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）</p>
<img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0041.png" class>



<h4 id="💡-handler-执行中如何换人？"><a href="#💡-handler-执行中如何换人？" class="headerlink" title="💡 handler 执行中如何换人？"></a>💡 handler 执行中如何换人？</h4><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是，直接调用， 当前handler中的线程是否和eventLoop是同一个</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果两个 handler 绑定的是同一个线程，那么就直接调用</li>
<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用</li>
</ul>
<h4 id="演示-NioEventLoop-处理普通任务"><a href="#演示-NioEventLoop-处理普通任务" class="headerlink" title="演示 NioEventLoop 处理普通任务"></a>演示 NioEventLoop 处理普通任务</h4><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup nioWorkers = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.execute(()-&gt;&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;normal task...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...</span><br><span class="line">22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以用来执行耗时较长的任务</p>
</blockquote>
<h4 id="演示-NioEventLoop-处理定时任务"><a href="#演示-NioEventLoop-处理定时任务" class="headerlink" title="演示 NioEventLoop 处理定时任务"></a>演示 NioEventLoop 处理定时任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup nioWorkers = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...</span><br><span class="line">22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以用来执行定时任务</p>
</blockquote>
<h3 id="3-2-Channel"><a href="#3-2-Channel" class="headerlink" title="3.2 Channel"></a>3.2 Channel</h3><p>channel 的主要作用</p>
<ul>
<li>close() 可以用来关闭 channel</li>
<li>closeFuture() 用来处理 channel 的关闭<ul>
<li>sync 方法作用是同步等待 channel 关闭</li>
<li>而 addListener 方法是异步等待 channel 关闭</li>
</ul>
</li>
<li>pipeline() 方法添加处理器</li>
<li>write() 方法将数据写入</li>
<li>writeAndFlush() 方法将数据写入并刷出</li>
</ul>
<h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>这时刚才的客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .sync()</span><br><span class="line">    .channel()</span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> Date() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在把它拆开来看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">channelFuture.sync().channel().writeAndFlush(<span class="keyword">new</span> Date() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象</li>
</ul>
<p><strong>注意</strong> connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象</p>
<p>实验如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.sync(); <span class="comment">// 2</span></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行到 1 时，连接未建立，打印 <code>[id: 0x2e1884dd]</code></li>
<li>执行到 2 时，sync 方法是同步等待连接建立完成</li>
<li>执行到 3 时，连接肯定建立了，打印 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code></li>
</ul>
<p>除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">    System.out.println(future.channel()); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>执行到 1 时，连接未建立，打印 <code>[id: 0x749124ba]</code></li>
<li>ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 <code>[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]</code></li>
</ul>
<h4 id="CloseFuture"><a href="#CloseFuture" class="headerlink" title="CloseFuture"></a>CloseFuture</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseFutureClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup group= <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 在连接建立后被调用</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        Channel channel = channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String line = scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">                    channel.close(); <span class="comment">// close 异步操作 1s 之后</span></span><br><span class="line"><span class="comment">//                    log.debug(&quot;处理关闭之后的操作&quot;); // 不能在这里善后</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;input&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭</span></span><br><span class="line">        ChannelFuture closeFuture = channel.closeFuture();</span><br><span class="line">        <span class="comment">/*log.debug(&quot;waiting close...&quot;);</span></span><br><span class="line"><span class="comment">        closeFuture.sync();</span></span><br><span class="line"><span class="comment">        log.debug(&quot;处理关闭之后的操作&quot;);*/</span></span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="💡-异步提升的是什么"><a href="#💡-异步提升的是什么" class="headerlink" title="💡 异步提升的是什么"></a>💡 异步提升的是什么</h4><ul>
<li><p>有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接</p>
</li>
<li><p>还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的</p>
</li>
</ul>
<p>思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：<code>4 * 8 * 3 = 96</code></p>
<img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0044.png" class>















<p>经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下</p>
<img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0048.png" class>











<p>因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 <code>4 * 8 * 12</code> 效率几乎是原来的四倍</p>
<img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0047.png" class>

<p>要点</p>
<ul>
<li>单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势</li>
<li>异步并没有缩短响应时间，反而有所增加</li>
<li>合理进行任务拆分，也是利用异步的关键</li>
</ul>
<h3 id="3-3-Future-amp-Promise"><a href="#3-3-Future-amp-Promise" class="headerlink" title="3.3 Future &amp; Promise"></a>3.3 Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口</p>
<p>首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>
<ul>
<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>
<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li>
<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li>
</ul>
<table>
<thead>
<tr>
<th>功能/名称</th>
<th>jdk Future</th>
<th>netty Future</th>
<th>Promise</th>
</tr>
</thead>
<tbody><tr>
<td>cancel</td>
<td>取消任务</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isCanceled</td>
<td>任务是否取消</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isDone</td>
<td>任务是否完成，不能区分成功失败</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>get</td>
<td>获取任务结果，阻塞等待</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>getNow</td>
<td>-</td>
<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>
<td>-</td>
</tr>
<tr>
<td>await</td>
<td>-</td>
<td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td>
<td>-</td>
</tr>
<tr>
<td>sync</td>
<td>-</td>
<td>等待任务结束，如果任务失败，抛出异常</td>
<td>-</td>
</tr>
<tr>
<td>isSuccess</td>
<td>-</td>
<td>判断任务是否成功</td>
<td>-</td>
</tr>
<tr>
<td>cause</td>
<td>-</td>
<td>获取失败信息，非阻塞，如果没有失败，返回null</td>
<td>-</td>
</tr>
<tr>
<td>addLinstener</td>
<td>-</td>
<td>添加回调，异步接收结果</td>
<td>-</td>
</tr>
<tr>
<td>setSuccess</td>
<td>-</td>
<td>-</td>
<td>设置成功结果</td>
</tr>
<tr>
<td>setFailure</td>
<td>-</td>
<td>-</td>
<td>设置失败结果</td>
</tr>
</tbody></table>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>同步处理任务成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoop eventExecutors = <span class="keyword">new</span> DefaultEventLoop();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;set success, &#123;&#125;&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    promise.setSuccess(<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,promise.getNow()); <span class="comment">// 还没有结果</span></span><br><span class="line">log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,promise.get());</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class="line">11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10</span><br><span class="line">11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10</span><br></pre></td></tr></table></figure>



<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>异步处理任务成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoop eventExecutors = <span class="keyword">new</span> DefaultEventLoop();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调，异步接收结果</span></span><br><span class="line">promise.addListener(future -&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里的 future 就是上面的 promise</span></span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,future.getNow());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 1000 后设置成功结果</span></span><br><span class="line">eventExecutors.execute(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;set success, &#123;&#125;&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    promise.setSuccess(<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10</span><br><span class="line">11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10</span><br></pre></td></tr></table></figure>



<h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p>同步处理任务失败 - sync &amp; get</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoop eventExecutors = <span class="keyword">new</span> DefaultEventLoop();</span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">        eventExecutors.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">            promise.setFailure(e);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, promise.getNow());</span><br><span class="line">        promise.get(); <span class="comment">// sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class="line">12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...</span><br><span class="line">	at io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)</span><br><span class="line">	at com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)</span><br><span class="line">Caused by: java.lang.RuntimeException: error...</span><br><span class="line">	at com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)</span><br><span class="line">	at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>



<h4 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h4><p>同步处理任务失败 - await</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoop eventExecutors = <span class="keyword">new</span> DefaultEventLoop();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    RuntimeException e = <span class="keyword">new</span> RuntimeException(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">    promise.setFailure(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, promise.getNow());</span><br><span class="line">promise.await(); <span class="comment">// 与 sync 和 get 区别在于，不会抛异常</span></span><br><span class="line">log.debug(<span class="string">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class="line">12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line">12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></table></figure>



<h4 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h4><p>异步处理任务失败</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoop eventExecutors = <span class="keyword">new</span> DefaultEventLoop();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">promise.addListener(future -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    RuntimeException e = <span class="keyword">new</span> RuntimeException(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">    promise.setFailure(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line">12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></table></figure>



<h4 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h4><p>await 死锁检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultEventLoop eventExecutors = <span class="keyword">new</span> DefaultEventLoop();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">eventExecutors.submit(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        promise.await();</span><br><span class="line">        <span class="comment">// 注意不能仅捕获 InterruptedException 异常</span></span><br><span class="line">        <span class="comment">// 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播</span></span><br><span class="line">        <span class="comment">// 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">eventExecutors.submit(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        promise.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)</span><br><span class="line">	at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)</span><br><span class="line">	at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)</span><br><span class="line">	at com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)</span><br><span class="line">	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)</span><br><span class="line">	at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)</span><br><span class="line">	at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)</span><br><span class="line">	at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)</span><br><span class="line">	at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)</span><br><span class="line">	at com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)</span><br><span class="line">	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)</span><br><span class="line">	at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)</span><br><span class="line">	at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="3-4-Handler-amp-Pipeline"><a href="#3-4-Handler-amp-Pipeline" class="headerlink" title="3.4 Handler &amp; Pipeline"></a>3.4 Handler &amp; Pipeline</h3><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</p>
<ul>
<li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li>
<li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工</li>
</ul>
<p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p>
<p>先搞清楚顺序，服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">1</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">2</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">3</span>);</span><br><span class="line">                    ctx.channel().write(msg); <span class="comment">// 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span></span><br><span class="line"><span class="params"><span class="function">                                  ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">4</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span></span><br><span class="line"><span class="params"><span class="function">                                  ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">5</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span></span><br><span class="line"><span class="params"><span class="function">                                  ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="number">6</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 6</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">        future.channel().writeAndFlush(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>服务器端打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</p>
<img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0008.png" class>

<ul>
<li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul>
<li>如果注释掉 1 处代码，则仅会打印 1</li>
<li>如果注释掉 2 处代码，则仅会打印 1 2</li>
</ul>
</li>
<li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul>
<li>如果注释掉 3 处代码，则仅会打印 1 2 3</li>
</ul>
</li>
<li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul>
<li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li>
</ul>
</li>
<li>ctx.channel().write(msg) vs ctx.write(msg)<ul>
<li>都是触发出站处理器的执行</li>
<li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li>
<li>ctx.write(msg) 是从当前节点找上一个出站处理器</li>
<li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li>
<li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己</li>
</ul>
</li>
</ul>
<p>图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p>
<img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0009.png" class>



<h3 id="3-5-ByteBuf"><a href="#3-5-ByteBuf" class="headerlink" title="3.5 ByteBuf"></a>3.5 ByteBuf</h3><p>是对字节数据的封装</p>
<h4 id="1）创建"><a href="#1）创建" class="headerlink" title="1）创建"></a>1）创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10</p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:0 capacity:10</span><br></pre></td></tr></table></figure>

<p>其中 log 方法参考如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = buffer.readableBytes();</span><br><span class="line">    <span class="keyword">int</span> rows = length / <span class="number">16</span> + (length % <span class="number">15</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">    StringBuilder buf = <span class="keyword">new</span> StringBuilder(rows * <span class="number">80</span> * <span class="number">2</span>)</span><br><span class="line">        .append(<span class="string">&quot;read index:&quot;</span>).append(buffer.readerIndex())</span><br><span class="line">        .append(<span class="string">&quot; write index:&quot;</span>).append(buffer.writerIndex())</span><br><span class="line">        .append(<span class="string">&quot; capacity:&quot;</span>).append(buffer.capacity())</span><br><span class="line">        .append(NEWLINE);</span><br><span class="line">    appendPrettyHexDump(buf, buffer);</span><br><span class="line">    System.out.println(buf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2）直接内存-vs-堆内存"><a href="#2）直接内存-vs-堆内存" class="headerlink" title="2）直接内存 vs 堆内存"></a>2）直接内存 vs 堆内存</h4><p>堆内存分配效率高，但是读写效率低。直接内存则反之。</p>
<p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>
<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>
</ul>
<h4 id="3）池化-vs-非池化"><a href="#3）池化-vs-非池化" class="headerlink" title="3）池化 vs 非池化"></a>3）池化 vs 非池化</h4><p>池化的最大意义在于可以重用 ByteBuf，优点有</p>
<ul>
<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>
<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>
<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>
</ul>
<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li>
<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>
</ul>
<h4 id="4）组成"><a href="#4）组成" class="headerlink" title="4）组成"></a>4）组成</h4><p>ByteBuf 由四部分组成</p>
<img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0010.png" class>

<p>最开始读写指针都在 0 位置</p>
<h4 id="5）写入"><a href="#5）写入" class="headerlink" title="5）写入"></a>5）写入</h4><p>方法列表，省略一些不重要的方法</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>writeBoolean(boolean value)</td>
<td>写入 boolean 值</td>
<td>用一字节 01|00 代表 true|false</td>
</tr>
<tr>
<td>writeByte(int value)</td>
<td>写入 byte 值</td>
<td></td>
</tr>
<tr>
<td>writeShort(int value)</td>
<td>写入 short 值</td>
<td></td>
</tr>
<tr>
<td>writeInt(int value)</td>
<td>写入 int 值</td>
<td>Big Endian，即 0x250，写入后 00 00 02 50</td>
</tr>
<tr>
<td>writeIntLE(int value)</td>
<td>写入 int 值</td>
<td>Little Endian，即 0x250，写入后 50 02 00 00</td>
</tr>
<tr>
<td>writeLong(long value)</td>
<td>写入 long 值</td>
<td></td>
</tr>
<tr>
<td>writeChar(int value)</td>
<td>写入 char 值</td>
<td></td>
</tr>
<tr>
<td>writeFloat(float value)</td>
<td>写入 float 值</td>
<td></td>
</tr>
<tr>
<td>writeDouble(double value)</td>
<td>写入 double 值</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuf src)</td>
<td>写入 netty 的 ByteBuf</td>
<td></td>
</tr>
<tr>
<td>writeBytes(byte[] src)</td>
<td>写入 byte[]</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuffer src)</td>
<td>写入 nio 的 ByteBuffer</td>
<td></td>
</tr>
<tr>
<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>
<td>写入字符串</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>注意</p>
<ul>
<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li>
<li>网络传输，默认习惯是 Big Endian</li>
</ul>
</blockquote>
<p>先写入 4 个字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:4 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>再写入一个 int 整数，也是 4 个字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">5</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:8 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<p>还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置</p>
<h4 id="6）扩容"><a href="#6）扩容" class="headerlink" title="6）扩容"></a>6）扩容</h4><p>再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">6</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>扩容规则是</p>
<ul>
<li>如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>
<li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10=1024（2^9=512 已经不够了）</li>
<li>扩容不能超过 max capacity 会报错</li>
</ul>
<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<h4 id="7）读取"><a href="#7）读取" class="headerlink" title="7）读取"></a>7）读取</h4><p>例如读了 4 次，每次一个字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>如果需要重复读取 int 整数 5，怎么办？</p>
<p>可以在 read 前先做个标记 mark</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.markReaderIndex();</span><br><span class="line">System.out.println(buffer.readInt());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">read index:8 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 06                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这时要重复读取的话，重置到标记位置 reset</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.resetReaderIndex();</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>这时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</p>
<h4 id="8）retain-amp-release"><a href="#8）retain-amp-release" class="headerlink" title="8）retain &amp; release"></a>8）retain &amp; release</h4><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p>
<ul>
<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>
<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>
<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
<blockquote>
<p>回收内存的源码实现，请关注下面方法的不同实现</p>
<p><code>protected abstract void deallocate()</code></p>
</blockquote>
<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>
<ul>
<li>每个 ByteBuf 对象的初始计数为 1</li>
<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>
<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>
<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>
</ul>
<p>谁来负责 release 呢？</p>
<p>不是我们想象的（一般情况下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buf = ...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    buf.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>
<p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong>，详细分析如下</p>
<ul>
<li>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</li>
<li>入站 ByteBuf 处理原则<ul>
<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>
<li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li>
<li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li>
<li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li>
<li>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>
</ul>
</li>
<li>出站 ByteBuf 处理原则<ul>
<li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li>
</ul>
</li>
<li>异常处理原则<ul>
<li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li>
</ul>
</li>
</ul>
<p>TailContext 释放未处理消息逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.debug(</span><br><span class="line">            <span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class="line">            <span class="string">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ReferenceCounted) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ReferenceCounted) msg).release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9）slice"><a href="#9）slice" class="headerlink" title="9）slice"></a>9）slice</h4><p>【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</p>
<img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0011.png" class>

<p>例，原始 ByteBuf 进行一些初始操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf origin = ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">origin.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf slice = origin.slice();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br><span class="line"><span class="comment">// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 04                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这时的 slice 不受影响，因为它有独立的读写指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>如果 slice 的内容发生了更改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">slice.setByte(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 05                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 05                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<h4 id="10）duplicate"><a href="#10）duplicate" class="headerlink" title="10）duplicate"></a>10）duplicate</h4><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p>
<img src="/2021/09/25/Netty02-%E5%85%A5%E9%97%A8/0012.png" class>



<h4 id="11）copy"><a href="#11）copy" class="headerlink" title="11）copy"></a>11）copy</h4><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p>
<h4 id="12）CompositeByteBuf"><a href="#12）CompositeByteBuf" class="headerlink" title="12）CompositeByteBuf"></a>12）CompositeByteBuf</h4><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p>
<p>有两个 ByteBuf 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf1));</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf2));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p>
<p>方法1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buf3 = ByteBufAllocator.DEFAULT</span><br><span class="line">    .buffer(buf1.readableBytes()+buf2.readableBytes());</span><br><span class="line">buf3.writeBytes(buf1);</span><br><span class="line">buf3.writeBytes(buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这种方法好不好？回答是不太好，因为进行了数据的内存复制操作</p>
<p>方法2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line"><span class="comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class="line">buf3.addComponents(<span class="keyword">true</span>, buf1, buf2);</span><br></pre></td></tr></table></figure>

<p>结果是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p>
<ul>
<li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>
<li>缺点，复杂了很多，多次操作会带来性能的损耗</li>
</ul>
<h4 id="13）Unpooled"><a href="#13）Unpooled" class="headerlink" title="13）Unpooled"></a>13）Unpooled</h4><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p>
<p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span></span><br><span class="line">ByteBuf buf3 = Unpooled.wrappedBuffer(buf1, buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buf4 = Unpooled.wrappedBuffer(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;);</span><br><span class="line">System.out.println(buf4.getClass());</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf4));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class io.netty.buffer.CompositeByteBuf</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<h4 id="💡-ByteBuf-优势"><a href="#💡-ByteBuf-优势" class="headerlink" title="💡 ByteBuf 优势"></a>💡 ByteBuf 优势</h4><ul>
<li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>
<li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li>
<li>可以自动扩容</li>
<li>支持链式调用，使用更流畅</li>
<li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li>
</ul>
<h2 id="4-双向通信"><a href="#4-双向通信" class="headerlink" title="4. 双向通信"></a>4. 双向通信</h2><h3 id="4-1-练习"><a href="#4-1-练习" class="headerlink" title="4.1 练习"></a>4.1 练习</h3><p>实现一个 echo server</p>
<p>编写 server</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">    .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">                    ByteBuf buffer = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 建议使用 ctx.alloc() 创建 ByteBuf</span></span><br><span class="line">                    ByteBuf response = ctx.alloc().buffer();</span><br><span class="line">                    response.writeBytes(buffer);</span><br><span class="line">                    ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                    <span class="comment">// 思考：需要释放 response 吗</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>编写 client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">Channel channel = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">    .group(group)</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">                    ByteBuf buffer = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line"></span><br><span class="line">channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String line = scanner.nextLine();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.writeAndFlush(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>



<h3 id="💡-读和写的误解"><a href="#💡-读和写的误解" class="headerlink" title="💡 读和写的误解"></a>💡 读和写的误解</h3><p>我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在<code>A 到 B</code> 和 <code>B 到 A</code> 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket s = ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(reader.readLine());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line">                <span class="comment">// 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    writer.write(String.valueOf(i));</span><br><span class="line">                    writer.newLine();</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    System.out.println(reader.readLine());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    writer.write(String.valueOf(i));</span><br><span class="line">                    writer.newLine();</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL/TLS协议</title>
    <url>/2022/09/25/https/</url>
    <content><![CDATA[<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>图片来源于： <a href="https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.788&amp;vd_source=4542f58f83b32442d5604ba46f2aa229">https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.788&amp;vd_source=4542f58f83b32442d5604ba46f2aa229</a></p>
<p>图解：</p>
<img src="/2022/09/25/https/1664081948786.png" class width="1664081948786">



<p>交换后：同样会被中间人知道交换了什么颜色</p>
<img src="/2022/09/25/https/1664082027997.png" class width="1664082027997">

<p>蓝色的私钥+对方的（私+公）= 咖啡色</p>
<p>红色的私钥+ 蓝色的（私+公） = 咖啡色</p>
<img src="/2022/09/25/https/client.png" class width="1664113823517">

<p>这个“咖啡色”就是他们之间的密钥了，重点是，这个“咖啡色”只能由他们自己私有的颜色才可以调制而成，其他人是无法得知的，包括这个中间人。</p>
<p>这便是非对称加密的核心所在，使用两个密钥来进行加密和解密。</p>
<p>公开密钥是所有人都拥有的，而私有密钥只有持有方才有的秘钥。</p>
<p>一般来说，私钥是放在服务器中，数据经过公钥加密就只能使用私钥解密，数据使用私钥加密就只能使用公钥解密。</p>
<img src="/2022/09/25/https/1664114094235.png" class width="1664114094235">

<p>服务端具有成对的秘钥，把自己的公钥公开出去，客户端使用公钥加密，就只能使用服务端的私有进行解密。</p>
<h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><img src="/2022/09/25/https/1664114193249.png" class width="1664114193249">

<p>证书里面包含的内容：域名、所属公司、时间日期、特定的公钥和私钥等</p>
<p>服务器安装了SSL证书后，客户端才可以使用https来访问服务器了，并将默认的80端口改为443端口。</p>
<h2 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h2><ol>
<li><p>客户端访问服务端</p>
<img src="/2022/09/25/https/TLS.png" class width="1664114368348"></li>
</ol>
<ol start="2">
<li><p>服务端响应客户端</p>
<img src="/2022/09/25/https/1664114429035.png" class width="1664114368348"></li>
</ol>
<ol start="3">
<li><p>服务器接着向客户端发送自己的证书，客户端可以根据自己的证书新人列表来确认这个服务器是否是可信的。</p>
<img src="/2022/09/25/https/1664114518013.png" class width="1664114518013"></li>
<li><p>服务器把自己的公钥发送给了客户端，这里不会傻傻地把自己的私钥发送出去</p>
<p>如果是双向SSL通信的话，</p>
<img src="/2022/09/25/https/1664114561487.png" class width="1664114561487"></li>
</ol>
<ol start="5">
<li><p>告诉客户端自己发送完毕，Server Hello Done</p>
<img src="/2022/09/25/https/ChangeCipherSpec.png" class width="1664114677987">

<p>以上步骤的通讯还没有加密，接下来客户端将进行响应了。</p>
<ol start="6">
<li>Client Key Exchange，客户端生成第三个随机数，称之为“预主密钥”。</li>
</ol>
<img src="/2022/09/25/https/1664114786783.png" class width="1664114786783">

<p>第三个随机数会使用刚刚收到的<strong>公钥进行加密</strong>，并发送给服务器。</p>
<p>告诉服务器往后的数据就用商议好的算法和密钥来加密了</p>
<p><img src="/2022/09/25/https/Users/ZHLAS/AppData/Roaming/Typora/typora-user-images/1664115068643.png" alt="1664115068643"></p>
<p>8 服务器这边的TLS握手已经成功</p>
<img src="/2022/09/25/https/1664114429035.png" class width="1664114368348">







<p>握手总结：</p>
<img src="/2022/09/25/https/TLS.png" class width="1664114368348">



<p>前面握手的部分使用的是非对称加密，后面得到会话密钥后就使用对称加密来通信了。</p>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ol>
<li><a href="https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.788&amp;vd_source=4542f58f83b32442d5604ba46f2aa229">https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.788&amp;vd_source=4542f58f83b32442d5604ba46f2aa229</a></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>网络</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2022/10/17/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p> 简单工厂（Simple factory）理解：</p>
<blockquote>
<p>According to definition from wikipedia, Factory Pattern is “A factory is an object for creating other objects”. Simple Factory Pattern is a Factory class in its simplest form (In comparison to Factory Method Pattern or Abstract Factory Pattern). In another way, we can say: In simple factory pattern, <strong>we have a factory class which has a method that returns different types of object based on given input.</strong> </p>
</blockquote>
<p>有一个工厂类，根据不同的输入返回不同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(SimpleFactory.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IExcelExport <span class="title">createExcelExport</span><span class="params">(FileType fileType)</span></span>&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;简单工厂&quot;</span>);</span><br><span class="line">        IExcelExport excelExport=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (fileType)&#123;</span><br><span class="line">            <span class="keyword">case</span> EXCEL_2003:</span><br><span class="line">                excelExport=<span class="keyword">new</span> Excel2003Export();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EXCEL_2007:</span><br><span class="line">                excelExport=<span class="keyword">new</span> Excel2007Export();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> excelExport;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>三个关键词：方法、入参、返回值</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>负责创建对象的方法，可以叫做工厂方法</p>
<ol>
<li>在加简单工厂模式中，为了简单，往往将这个方法定义成static，方便使用</li>
<li>一个工厂类中可以包含多个这样的方法，建议一个模块使用一个工厂类即可。</li>
</ol>
<h2 id="入参"><a href="#入参" class="headerlink" title="入参"></a>入参</h2><p>根据这个入参决定创建哪种类型的对象</p>
<ol>
<li>入参的一般是常量或者枚举，便于方法里面的seich语句或者其他分支的语句进行判断</li>
<li>也有人喜欢直接传递一个Class类（需要实例化的对象），但是不推荐，因为违反了工厂模式的宗旨。</li>
</ol>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>工厂方法创建的是一类对象，所以返回值类型常常是一个接口，也可以是抽象的父类，而不会是一个具体的类。</p>
<h1 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h1><p>不符合开闭原则，同样的，如果需要增加一个，需要修改工厂类的代码</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2022/10/18/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>定义一个用于创建对象的<strong>接口</strong>，让<strong>子类</strong>决定实例化哪个类，Factory Method 使一个<strong>类</strong>的实例化延迟到其子类。</p>
<p>工厂方法模式包含五种角色</p>
<ul>
<li>抽象工厂</li>
<li>具体工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
<li>客户方角色</li>
</ul>
<p>宗旨： 在抽象工厂的接口和抽象类李面定义工厂方法，创建抽象产品。而将创建具体产品的操作延迟在具体的工厂和工厂方法中</p>
<p>目的： 解除框架在创建对象时，对具体类的依赖，实现两者的解耦。</p>
<h2 id="和简单工厂模式的区别"><a href="#和简单工厂模式的区别" class="headerlink" title="和简单工厂模式的区别"></a>和简单工厂模式的区别</h2><p>简单工厂模式决定创建的对象是根据工厂类中的静态工厂方法的入参来决定的，而工厂方法模式决定创建具体的对象是由具体的工厂类，也就是抽象工厂的子类来确定的。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>这里的接口是用于创建对象的，往往会创建相应的抽象了，这里统称为抽象工厂。</p>
<h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><p>指的是抽象工厂的子类，子类的任务时实现工厂接口中定义的工厂方法。抽象工厂的子类称之为工厂模式里面的具体工厂。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>让<strong>子类</strong>决定实例化哪个类，这个类指的就是具体的产品，返回的是一个真正的类</p>
<h2 id="工厂方法模式示例代码"><a href="#工厂方法模式示例代码" class="headerlink" title="工厂方法模式示例代码"></a>工厂方法模式示例代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileExportService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(FileExportService.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportExcel</span><span class="params">(List&lt;SKU&gt; skuList, FileType fileType)</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;文件导出服务&quot;</span>);</span><br><span class="line">        IExcelExportFactory excelExportFactory = <span class="keyword">null</span>;</span><br><span class="line">        IExcelExport excelExport = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (fileType) &#123;</span><br><span class="line">            <span class="keyword">case</span> EXCEL_2003:</span><br><span class="line">                excelExportFactory = <span class="keyword">new</span> Excel2003ExportFactory();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EXCEL_2007:</span><br><span class="line">                excelExportFactory = <span class="keyword">new</span> Excel2007ExportFactory();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != excelExportFactory) &#123;</span><br><span class="line">            excelExport = excelExportFactory.createExcelExport();</span><br><span class="line">            excelExport.exportExcel(skuList);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;不支持的文件类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类图：</p>
<img src="/2022/10/18/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/1666022902680.png" class width="1666022902680">

<p>这段代码和下面的代码是否类似？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileExportService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(FileExportService.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportFile</span><span class="params">(List&lt;SKU&gt; skuList,FileType fileType)</span></span>&#123;</span><br><span class="line">        IExcelExport excelExport=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (fileType)&#123;</span><br><span class="line">            <span class="keyword">case</span> EXCEL_2003:</span><br><span class="line">                LOG.info(<span class="string">&quot;文件导出服务:excel2003&quot;</span>);</span><br><span class="line">                excelExport=<span class="keyword">new</span> Excel2003Export();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EXCEL_2007:</span><br><span class="line">                LOG.info(<span class="string">&quot;文件导出服务:excel2007&quot;</span>);</span><br><span class="line">                excelExport=<span class="keyword">new</span> Excel2003Export();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> !=excelExport)&#123;</span><br><span class="line">            excelExport.exportExcel(skuList);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;不支持的文件类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Excel2003Export/Excel2003Export都是具体的产品了，上面的工厂方法模式实际上是创建了具体的工厂。两者逻辑以相似，但是灵魂却相似、</p>
<p>客户方角色使用Service服务，创建工厂比创建具体某个产品简单许多，因为具体的产品往往比较复杂，依赖较多，考虑的东西比较多，这里工厂方法模式将创建具体的产品的细节延迟到具体的工厂方法里面了。</p>
<h2 id="工厂方法模式的另一种“形态”"><a href="#工厂方法模式的另一种“形态”" class="headerlink" title="工厂方法模式的另一种“形态”"></a>工厂方法模式的另一种“形态”</h2><p>工厂方法模式常常和模板方法模式联合使用。抽象产品+抽象工厂 = 框架</p>
<p>规则： 抽象工厂里面定义的工厂方法里面去定义规则</p>
<p>流程：在抽象工厂的抽象类中定义模板方法</p>
<p>规则和流程定义得好不好，符不符合业务需求，扩展性强不强，就是体现架构师功力的地方。</p>
<p>何为架构师：</p>
<blockquote>
<p>当你开始定义规则，当你开始关注接口和抽象类，当你开发的代码是给其他程序员提供支持和服务的时候，你就踏上了架构师之路！</p>
</blockquote>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IExcelExportFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">IExcelFile <span class="title">createExcel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">IFileTitleRow <span class="title">createFileTitleRow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ITableTitleRow <span class="title">createTableTitleRow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">IDataRow <span class="title">createDataRow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ITotalRow <span class="title">createTotalRow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法模式：模板方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exportExcel</span><span class="params">(List&lt;SKU&gt; skuList)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExcelExportFactory</span> <span class="keyword">implements</span> <span class="title">IExcelExportFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(AbstractExcelExportFactory.class);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *Excel文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> IExcelFile excelFile = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法模式：个性化方法，同时也是钩子方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IFileTitleRow <span class="title">createFileTitleRow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以提供一个默认实现,创建文件标题行对象，并添加到excel文件中。。。</span></span><br><span class="line">        LOG.info(<span class="string">&quot;抽象工厂:创建文件标题行对象&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法模式：个性化方法，同时也是钩子方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IExcelFile <span class="title">createExcel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以提供一个默认实现,比如创建一个excel2003对应的workbook。</span></span><br><span class="line">        LOG.info(<span class="string">&quot;抽象工厂:创建Excel文件对象，默认为2003版本&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IExcelFile() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFileTitleRow</span><span class="params">(IFileTitleRow fileTitleRow)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTableTitleRow</span><span class="params">(ITableTitleRow tableTitleRow)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDataRow</span><span class="params">(IDataRow dataRow)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTotalRow</span><span class="params">(ITotalRow totalRow)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法模式：模板方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">exportExcel</span><span class="params">(List&lt;SKU&gt; skuList)</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;抽象工厂-模板方法:导出Excel文件&quot;</span>);</span><br><span class="line">        excelFile = createExcel();</span><br><span class="line">        IFileTitleRow fileTitleRow = createFileTitleRow();</span><br><span class="line">        ITableTitleRow tableTitleRow = createTableTitleRow();</span><br><span class="line">        IDataRow dataRow = createDataRow();</span><br><span class="line">        ITotalRow totalRow = createTotalRow();</span><br><span class="line">        excelFile.addFileTitleRow(fileTitleRow);</span><br><span class="line">        excelFile.addTableTitleRow(tableTitleRow);</span><br><span class="line">        excelFile.addDataRow(dataRow);</span><br><span class="line">        excelFile.addTotalRow(totalRow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，客户方角色相当于此模板方法，使用了抽象工厂的工厂方法去创建对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2022/10/18/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>和工厂方法模式相似，包含五种角色：</p>
<ul>
<li>抽象工厂</li>
<li>具体工厂</li>
<li>抽象产品</li>
<li>具体产品</li>
<li>客户方角色</li>
</ul>
<p>其通过抽象工厂定义的一系列的工厂方法，每个工厂方法生成一类抽象产品。</p>
<p>宗旨： 通过每一个具体的工厂，负责生产一系列相关或者相互依赖的产品。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>提供一个创建一系列相关或者相互依赖<strong>对象</strong>的<strong>接口</strong>，而无需指定他们的<strong>具体类</strong></p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>工厂模式里面的产品，注意，产品有两类，抽象产品和具体产品，抽象工厂创建的都是抽象产品，具体工厂创建的都是具体产品的对象。</p>
<p>产品是有特点的，“一系列相关或者相互依赖的对象”，这里面包含了产品族的概念。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>创建对象的接口，就是工厂模式的抽象工厂</p>
<h3 id="具体类"><a href="#具体类" class="headerlink" title="具体类"></a>具体类</h3><p>指的就是具体产品</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>N个工厂方法相加，是否等于抽象工厂</p>
<p>产品族出现之时，抽象工厂开工之际</p>
<p>产品族 VS 产品分类</p>
<h2 id="N个工厂方法相加，是否等于抽象工厂"><a href="#N个工厂方法相加，是否等于抽象工厂" class="headerlink" title="N个工厂方法相加，是否等于抽象工厂"></a>N个工厂方法相加，是否等于抽象工厂</h2><p>一个导出模块，只支持Excel文件格式，远远不够没需要支持其他格式，比如SQL。CSV、甚至word、pdf等。</p>
<p>由原来的单一文件格式增加到三种、四种甚至更多的时候，如果多个工厂方法模式的相加，量变会不会引起质变？如果需求没变化的话，只是新增一种文件格式，并不会引起质的变化，只需要增加一套工厂方法模式即可。</p>
<p>只有产品族出现了，才需要使用更加复杂的更加强大的抽象工厂设计模式、</p>
<h2 id="产品族出现之时，抽象工厂开工之际"><a href="#产品族出现之时，抽象工厂开工之际" class="headerlink" title="产品族出现之时，抽象工厂开工之际"></a>产品族出现之时，抽象工厂开工之际</h2><p>何为产品族？</p>
<img src="/2022/10/18/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1666101869212.png" class width="1666101869212">

<p>比如，我们的系统现在西药支持中国和俄罗斯两个国家的文件导出</p>
<p>中国： Excel文件（Excel2003， Excel2007）， SQL文件（Mysql、oracle）</p>
<p>俄罗斯：Excel文件（Excel2003， Excel2007）， SQL文件（Mysql、oracle）</p>
<p>中国就是一个产品族了。</p>
<h2 id="产品族和产品分类"><a href="#产品族和产品分类" class="headerlink" title="产品族和产品分类"></a>产品族和产品分类</h2><p>两个概念很重要</p>
<p>按照上面的说法，Excel文件、SQL文件或者Word文件、PDF文件这些都属于产品分类。</p>
<p>一个抽象工厂模式，支持生产多个产品分类，而且产品分类下面，还可以再分类，也就是二级分类、三级分类等，比如Excel分类，可以分为Excel2003， Excel2007等</p>
<p>而导出的文件，如果要区分中国和俄罗斯，以及其他地区的国家，产品族就出现了。</p>
<p>族的本质也是分类，只是给分配换了一个名字而已，但是在抽象工厂模式里面，产品族有特殊的约定。</p>
<ol>
<li>一个产品族，往往需要包含所有的产品分类（并不是必须的），比如俄罗斯地区的导出文件，也需要支持Excel、SQL、Word、PDF等各种文件。</li>
<li>一个系统，同一时刻，往往只能选择一个产品族，但是可以使用多个产品分类。比如，中国地区的商家，往往只会选择中国地区的文件导出。不会两个都需要，总之，不同产品族的产品一般不会同时使用，对于一个商家，可以选择多个产品分类，但是往往同一时刻，只需要选择一个产品族。</li>
<li>同一个产品族里面的产品，往往有依赖关系。同一个产品族，里面的不同的产品之间，可以有依赖性。而不同的产品族，里面的产品，则一般不会有依赖关系。比如中国地区的PDF文件格式不会依赖其他地区的文件格式，但是可以依赖中国地区其他分类的文件格式。</li>
</ol>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>需要支持中国、俄罗斯的Excel和SQL文件格式的导出。Excel支持Excel2003和Excel2007，Sql文件支持mysql和oracle两种格式。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><img src="/2022/10/18/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1666106109538.png" class width="1666106109538">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFileExportFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">IExcelExport <span class="title">createExcelExport</span><span class="params">(FileType fileType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ISqlExport <span class="title">createSqlExport</span><span class="params">(FileType fileType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>具体工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinaFileExportFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFileExportFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(ChinaFileExportFactory.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IExcelExport <span class="title">createExcelExport</span><span class="params">(FileType fileType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (fileType) &#123;</span><br><span class="line">            <span class="keyword">case</span> CHINA_EXCEL_2003:</span><br><span class="line">                LOG.info(<span class="string">&quot;创建中国-excel2003文件导出对象&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ChinaExcel2003Export();</span><br><span class="line">            <span class="keyword">case</span> CHINA_EXCEL_2007:</span><br><span class="line">                LOG.info(<span class="string">&quot;创建中国-excel2007文件导出对象&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ChinaExcel2007Export();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISqlExport <span class="title">createSqlExport</span><span class="params">(FileType fileType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (fileType) &#123;</span><br><span class="line">            <span class="keyword">case</span> CHINA_MYSQL:</span><br><span class="line">                LOG.info(<span class="string">&quot;创建中国-mysql文件导出对象&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ChinaMysqlExport();</span><br><span class="line">            <span class="keyword">case</span> CHINA_ORACLE:</span><br><span class="line">                LOG.info(<span class="string">&quot;创建中国-oracle文件导出对象&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ChinaOracleExport();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抽象产品和具体产品"><a href="#抽象产品和具体产品" class="headerlink" title="抽象产品和具体产品"></a>抽象产品和具体产品</h3><img src="/2022/10/18/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1666106137402.png" class width="1666106137402">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IExcelExport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exportExcel</span><span class="params">(List&lt;SKU&gt; skuList)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinaExcel2003Export</span> <span class="keyword">implements</span> <span class="title">IExcelExport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(ChinaExcel2003Export.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportExcel</span><span class="params">(List&lt;SKU&gt; skuList)</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;导出中国-excel2003文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinaExcel2007Export</span> <span class="keyword">implements</span> <span class="title">IExcelExport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportExcel</span><span class="params">(List&lt;SKU&gt; skuList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RussiaExcel2003Export</span> <span class="keyword">implements</span> <span class="title">IExcelExport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportExcel</span><span class="params">(List&lt;SKU&gt; skuList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RussiaExcel2007Export</span> <span class="keyword">implements</span> <span class="title">IExcelExport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportExcel</span><span class="params">(List&lt;SKU&gt; skuList)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户方"><a href="#客户方" class="headerlink" title="客户方"></a>客户方</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileExportService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(FileExportService.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportFile</span><span class="params">(List&lt;SKU&gt; skuList)</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;文件导出服务&quot;</span>);</span><br><span class="line">        IFileExportFactory fileExportFactory = <span class="keyword">new</span> ChinaFileExportFactory();</span><br><span class="line">        IExcelExport excelExport = fileExportFactory.createExcelExport(FileType.CHINA_EXCEL_2003);</span><br><span class="line">        ISqlExport sqlExport = fileExportFactory.createSqlExport(FileType.CHINA_MYSQL);</span><br><span class="line">        excelExport.exportExcel(skuList);</span><br><span class="line">        sqlExport.exportSql(skuList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="抽象工厂模式如何扩展"><a href="#抽象工厂模式如何扩展" class="headerlink" title="抽象工厂模式如何扩展"></a>抽象工厂模式如何扩展</h2><p>需求增加：文件格式增加PDF格式，国家增加对法国的支持</p>
<p>分析：</p>
<p>新增pdf文件格式，增加产品分类，需要进行以下操作：</p>
<ol>
<li><p>增加pdf相关的抽象产品和具体产品，注意，具体产品的个数，一般等于产品族的数量。因为要支持中国、俄罗斯、法国 的pdf文件的导出，所以需要3个pdf的具体产品。</p>
<img src="/2022/10/18/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1666106721894.png" class width="1666106721894"></li>
<li><p>工厂方法里面需要增加响应的工厂方法，每一个工厂方法生产一类产品</p>
</li>
</ol>
<img src="/2022/10/18/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1666106801934.png" class width="1666106801934">

<p>以新增法国为例，增加产品族，需要增加以下操作</p>
<ol>
<li><p>所有的产品分类，都需要增加对新的产品族的支持</p>
<img src="/2022/10/18/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1666106979825.png" class width="1666106979825"></li>
<li><p>增加产品族对应的具体工厂</p>
<img src="/2022/10/18/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1666107030003.png" class width="1666107030003">



<p>看起来扩展一下还是比较复杂的。。。</p>
</li>
</ol>
<h2 id="使用场景（Scene）"><a href="#使用场景（Scene）" class="headerlink" title="使用场景（Scene）"></a>使用场景（Scene）</h2><p>什么情况下使用抽象工厂模式？</p>
<blockquote>
<p>当一个系统中，需要创建的对象或者产品有多个类别，而且也有产品族出现时，就可以使用抽象工厂模式</p>
</blockquote>
<h2 id="开源代码搜索工厂模式的应用"><a href="#开源代码搜索工厂模式的应用" class="headerlink" title="开源代码搜索工厂模式的应用"></a>开源代码搜索工厂模式的应用</h2><p>地址： <a href="https://sourcegraph.com/search">https://sourcegraph.com/search</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo:^github\.com/spring-projects/spring-framework$ file:^spring-beans/src/main/java/org/springframework/beans/factory/BeanFactory\.java</span><br></pre></td></tr></table></figure>



<p>doubble框架里面使用了非常经典的工厂方法模式+ 模板模式的案例</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者设计模式</title>
    <url>/2022/10/19/%E5%BB%BA%E9%80%A0%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="建造者设计模式"><a href="#建造者设计模式" class="headerlink" title="建造者设计模式"></a>建造者设计模式</h1><p>将一个复杂对象的构建和它的表示分离，使得同样的构建过程，可以创建不同的表示</p>
<h2 id="流行实践"><a href="#流行实践" class="headerlink" title="流行实践"></a>流行实践</h2><p><strong>Joshua Bloch改进的建造者模式（主流方式）</strong></p>
<p>下面这个实现了建造者模式的类，注意以下6点：</p>
<p>1，它里面的静态内部类MyCacheBuilder才是神来之笔。（主类是产品，静态内部类是工厂，工厂生产产品）</p>
<p>2，它的构造函数是private的（有点像单例模式，防止用户绕开工厂，自己直接建立对象）</p>
<p>3，它的参数，没有提供set方法（主类（产品）是只读的，绝对的线程安全）</p>
<p>4，它里面必须（不能为空）的参数，添加了final关键字</p>
<p>5，静态内部类MyCacheBuilder的set方法，不同于常规的set方法，注意它的返回值</p>
<p>6，静态内部类MyCacheBuilder的build方法，非常重要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化容量,必须</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> initialCapacity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大数量，必须</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maximumSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并行等级。决定segment数量的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> concurrencyLevel = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maximumWeight = -<span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写操作后失效时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireAfterWriteNanos = -<span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问操作后失效时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireAfterAccessNanos = -<span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyCache</span><span class="params">(MyCacheBuilder myCacheBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initialCapacity = myCacheBuilder.initialCapacity;</span><br><span class="line">        <span class="keyword">this</span>.maximumSize = myCacheBuilder.maximumSize;</span><br><span class="line">        <span class="keyword">this</span>.concurrencyLevel = myCacheBuilder.concurrencyLevel;</span><br><span class="line">        <span class="keyword">this</span>.maximumWeight = myCacheBuilder.maximumWeight;</span><br><span class="line">        <span class="keyword">this</span>.expireAfterWriteNanos = myCacheBuilder.expireAfterWriteNanos;</span><br><span class="line">        <span class="keyword">this</span>.expireAfterAccessNanos = myCacheBuilder.expireAfterAccessNanos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyCache&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;initialCapacity=&quot;</span> + initialCapacity +</span><br><span class="line">                <span class="string">&quot;, maximumSize=&quot;</span> + maximumSize +</span><br><span class="line">                <span class="string">&quot;, concurrencyLevel=&quot;</span> + concurrencyLevel +</span><br><span class="line">                <span class="string">&quot;, maximumWeight=&quot;</span> + maximumWeight +</span><br><span class="line">                <span class="string">&quot;, expireAfterWriteNanos=&quot;</span> + expireAfterWriteNanos +</span><br><span class="line">                <span class="string">&quot;, expireAfterAccessNanos=&quot;</span> + expireAfterAccessNanos +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheBuilder</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化容量,必须</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> initialCapacity;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最大数量，必须</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maximumSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; cacheMap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 并行等级。决定segment数量的参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> concurrencyLevel = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最大权重</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> maximumWeight = -<span class="number">1L</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 写操作后失效时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> expireAfterWriteNanos = -<span class="number">1L</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 访问操作后失效时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> expireAfterAccessNanos = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyCacheBuilder</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">long</span> maximumSize)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.initialCapacity = initialCapacity;</span><br><span class="line">            <span class="keyword">this</span>.maximumSize = maximumSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyCacheBuilder <span class="title">setConcurrencyLevel</span><span class="params">(<span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.concurrencyLevel = concurrencyLevel;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyCacheBuilder <span class="title">setMaximumWeight</span><span class="params">(<span class="keyword">long</span> maximumWeight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.maximumWeight = maximumWeight;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyCacheBuilder <span class="title">setExpireAfterWriteNanos</span><span class="params">(<span class="keyword">long</span> expireAfterWriteNanos)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.expireAfterWriteNanos = expireAfterWriteNanos;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyCacheBuilder <span class="title">setExpireAfterAccessNanos</span><span class="params">(<span class="keyword">long</span> expireAfterAccessNanos)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.expireAfterAccessNanos = expireAfterAccessNanos;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyCache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyCache&lt;K, V&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="源码中的建造者模式"><a href="#源码中的建造者模式" class="headerlink" title="源码中的建造者模式"></a>源码中的建造者模式</h2><ul>
<li>JDK：</li>
</ul>
<p>查询条件：</p>
<p>repo:^github.com/openjdk/jdk$ file:^src/java.base -file:test lang:Java file:builder.java count:all</p>
<p>StringBuilder类</p>
<p>Calendar类</p>
<ul>
<li>Spring框架中的建造者模式 ：</li>
</ul>
<p>repo:^github.com/spring-projects/spring-framework$ -file:test lang:Java file:builder.java count:all</p>
<p>UriComponentsBuilder</p>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>1.<a href="https://www.bilibili.com/read/cv17885668?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv17885668?spm_id_from=333.999.0.0</a> </p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>VM虚拟机ping通外网check</title>
    <url>/2022/11/20/VM%E8%99%9A%E6%8B%9F%E6%9C%BAping%E9%80%9A%E5%A4%96%E7%BD%91check/</url>
    <content><![CDATA[<h1 id="VM虚拟机ping通外网check"><a href="#VM虚拟机ping通外网check" class="headerlink" title="VM虚拟机ping通外网check"></a>VM虚拟机ping通外网check</h1><p>每隔一段时间，家里的虚拟机就无法ping外网了，先做一个记录，方便后续设置：</p>
<img src="/2022/11/20/VM%E8%99%9A%E6%8B%9F%E6%9C%BAping%E9%80%9A%E5%A4%96%E7%BD%91check/1668924703763.png" class width="1668924703763">



<p>出现此问题大概率是因为网关设置错误</p>
<p>保持vm8网卡中的网关、vmware网络编辑器中的NAT模式中网关、具体虚拟机中网络配置中的GATEWAY一致</p>
<img src="/2022/11/20/VM%E8%99%9A%E6%8B%9F%E6%9C%BAping%E9%80%9A%E5%A4%96%E7%BD%91check/1668924831629.png" class width="1668924831629">



<img src="/2022/11/20/VM%E8%99%9A%E6%8B%9F%E6%9C%BAping%E9%80%9A%E5%A4%96%E7%BD%91check/1668924885392.png" class width="1668924885392">

<img src="/2022/11/20/VM%E8%99%9A%E6%8B%9F%E6%9C%BAping%E9%80%9A%E5%A4%96%E7%BD%91check/1668924904556.png" class width="1668924904556">

<img src="/2022/11/20/VM%E8%99%9A%E6%8B%9F%E6%9C%BAping%E9%80%9A%E5%A4%96%E7%BD%91check/1668924928032.png" class width="1668924928032">



<p>附上一个配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=94566983-eb19-4cae-a2f1-29c4a308bc2f</span><br><span class="line">IPADDR=192.168.160.200</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.160.2</span><br><span class="line">DNS=114.114.114.114</span><br><span class="line">HWADDR=00:0C:29:55:5C:E4</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPV6_PRIVACY=no</span><br><span class="line">PREFIX=24</span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>blog操作步骤</title>
    <url>/2022/11/20/blog%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h1 id="创建博客的操作"><a href="#创建博客的操作" class="headerlink" title="创建博客的操作"></a>创建博客的操作</h1><ol>
<li><p>新建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo n 文章名称</span><br></pre></td></tr></table></figure>

<p>此时文章在source/_drafts/ 目录下</p>
</li>
<li><p>发布到post</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo p 文章名称</span><br></pre></td></tr></table></figure></li>
<li><p>生成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li>
<li><p>部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>docker文档</title>
    <url>/2022/11/20/docker%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul>
<li><p>官方文档地址:<a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></p>
</li>
<li><p>中文参考手册:<a href="https://docker_practice.gitee.io/zh-cn/">https://docker_practice.gitee.io/zh-cn/</a></p>
</li>
</ul>
<hr>
<h2 id="1-什么是-Docker"><a href="#1-什么是-Docker" class="headerlink" title="1.什么是 Docker"></a>1.什么是 Docker</h2><h3 id="1-1-官方定义"><a href="#1-1-官方定义" class="headerlink" title="1.1 官方定义"></a>1.1 官方定义</h3><ul>
<li>最新官网首页</li>
</ul>
<img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20201220213306128.png" class title="image-20201220213306128">

<img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20201220214210994.png" class title="image-20201220214210994">

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.官方介绍</span></span><br><span class="line"><span class="bullet">-</span> We have a complete container solution for you - no matter who you are and where you are on your containerization journey.</span><br><span class="line"><span class="bullet">-</span> 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。</span><br><span class="line"><span class="bullet">-</span> 官方定义: docker是一个容器技术。</span><br></pre></td></tr></table></figure>

<h3 id="1-2-Docker的起源"><a href="#1-2-Docker的起源" class="headerlink" title="1.2 Docker的起源"></a>1.2 Docker的起源</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。</span><br><span class="line"></span><br><span class="line">Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</span><br><span class="line"></span><br><span class="line">Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</span><br></pre></td></tr></table></figure>

<h2 id="2-为什么是Docker"><a href="#2-为什么是Docker" class="headerlink" title="2.为什么是Docker"></a>2.为什么是Docker</h2><ul>
<li><p><code>在开发的时候，在本机测试环境可以跑，生产环境跑不起来</code></p>
<p>这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p>
<p><strong>优势1:  一致的运行环境,更轻松的迁移</strong></p>
</li>
<li><p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了</code></p>
<p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p>
<p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p>
</li>
<li><p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器</code></p>
<p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p>
<p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p>
</li>
</ul>
<hr>
<h2 id="3-Docker和虚拟机区别"><a href="#3-Docker和虚拟机区别" class="headerlink" title="3.Docker和虚拟机区别"></a>3.Docker和虚拟机区别</h2><blockquote>
<p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p>
</blockquote>
<img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20201220222456675.png" class title="image-20201220222456675">

<p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p>
<table>
<thead>
<tr>
<th></th>
<th>传统虚拟机</th>
<th>Docker容器</th>
</tr>
</thead>
<tbody><tr>
<td>磁盘占用</td>
<td>几个GB到几十个GB左右</td>
<td>几十MB到几百MB左右</td>
</tr>
<tr>
<td>CPU内存占用</td>
<td>虚拟操作系统非常占用CPU和内存</td>
<td>Docker引擎占用极低</td>
</tr>
<tr>
<td>启动速度</td>
<td>（从开机到运行项目）几分钟</td>
<td>（从开启容器到运行项目）几秒</td>
</tr>
<tr>
<td>安装管理</td>
<td>需要专门的运维技术</td>
<td>安装、管理方便</td>
</tr>
<tr>
<td>应用部署</td>
<td>每次部署都费时费力</td>
<td>从第二次部署开始轻松简捷</td>
</tr>
<tr>
<td>耦合性</td>
<td>多个应用服务安装到一起，容易互相影响</td>
<td>每个应用服务一个容器，达成隔离</td>
</tr>
<tr>
<td>系统依赖</td>
<td>无</td>
<td>需求相同或相似的内核，目前推荐是Linux</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-Docker的安装"><a href="#4-Docker的安装" class="headerlink" title="4.Docker的安装"></a>4.Docker的安装</h2><h3 id="4-1-安装docker-centos7-x"><a href="#4-1-安装docker-centos7-x" class="headerlink" title="4.1 安装docker(centos7.x)"></a>4.1 安装docker(centos7.x)</h3><ul>
<li><p>卸载原始docker</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></li>
<li><p>安装docker依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils \</span></span><br><span class="line"><span class="bash">  device-mapper-persistent-data \</span></span><br><span class="line"><span class="bash">  lvm2</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置docker的yum源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li><p>安装最新版的docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li>
<li><p>指定版本安装docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br><span class="line">$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br><span class="line">$ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io</span><br></pre></td></tr></table></figure></li>
<li><p>启动docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li><p>关闭docker</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl stop docker</span><br></pre></td></tr></table></figure></li>
<li><p>测试docker安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-bash安装-通用所有平台"><a href="#4-2-bash安装-通用所有平台" class="headerlink" title="4.2 bash安装(通用所有平台)"></a>4.2 bash安装(通用所有平台)</h3><ul>
<li><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure></li>
<li><p>启动docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li><p>创建docker用户组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure></li>
<li><p>将当前用户加入docker组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试docker安装是否正确</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run hello-world</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-Docker-的核心架构"><a href="#5-Docker-的核心架构" class="headerlink" title="5.Docker 的核心架构"></a>5.Docker 的核心架构</h2><img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20200404111908085-0291323.png" class title="image-20200404111908085">

<ul>
<li><code>镜像:</code> 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li>
<li><code>容器:</code> 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li>
<li><code>仓库:</code>用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li>
<li><code>dockerFile:</code>docker生成镜像配置文件,用来书写自定义镜像的一些配置</li>
<li><code>tar:</code>一个对镜像打包的文件,日后可以还原成镜像</li>
</ul>
<h2 id="6-Docker-配置阿里镜像加速服务"><a href="#6-Docker-配置阿里镜像加速服务" class="headerlink" title="6. Docker 配置阿里镜像加速服务"></a>6. Docker 配置阿里镜像加速服务</h2><h3 id="6-1-docker-运行流程"><a href="#6-1-docker-运行流程" class="headerlink" title="6.1 docker 运行流程"></a>6.1 docker 运行流程</h3><img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20200404120356784.png" class title="image-20200404120356784">

<h3 id="6-2-docker配置阿里云镜像加速"><a href="#6-2-docker配置阿里云镜像加速" class="headerlink" title="6.2 docker配置阿里云镜像加速"></a>6.2 docker配置阿里云镜像加速</h3><ul>
<li><code>访问阿里云登录自己账号查看docker镜像加速服务</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://1sbuq3iu.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<ul>
<li><code>验证docker的镜像加速是否生效</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker info</span><br><span class="line">		..........</span><br><span class="line">    127.0.0.0/8</span><br><span class="line">   Registry Mirrors:</span><br><span class="line">    &#x27;https://lz2nib3q.mirror.aliyuncs.com/&#x27;</span><br><span class="line">   Live Restore Enabled: false</span><br><span class="line">   Product License: Community Engine</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-Docker的入门应用"><a href="#7-Docker的入门应用" class="headerlink" title="7.Docker的入门应用"></a>7.Docker的入门应用</h2><h3 id="7-1-docker-的第一个程序"><a href="#7-1-docker-的第一个程序" class="headerlink" title="7.1 docker 的第一个程序"></a>7.1 docker 的第一个程序</h3><blockquote>
<p>docker  run hello-world</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-常用命令"><a href="#8-常用命令" class="headerlink" title="8.常用命令"></a>8.常用命令</h2><h3 id="6-1-辅助命令"><a href="#6-1-辅助命令" class="headerlink" title="6.1 辅助命令"></a>6.1 辅助命令</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.安装完成辅助命令</span></span><br><span class="line"><span class="code">		docker version	--------------------------	查看docker的信息</span></span><br><span class="line"><span class="code">		docker info		--------------------------	查看更详细的信息</span></span><br><span class="line"><span class="code">		docker --help	--------------------------	帮助命令</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-Images-镜像命令"><a href="#6-2-Images-镜像命令" class="headerlink" title="6.2 Images 镜像命令"></a>6.2 Images 镜像命令</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.查看本机中所有镜像</span></span><br><span class="line"><span class="code">	docker images	--------------------------	列出本地所有镜像</span></span><br><span class="line"><span class="code">		-a			列出所有镜像（包含中间映像层）</span></span><br><span class="line"><span class="code">  	-q			只显示镜像id</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.搜索镜像</span></span><br><span class="line"><span class="code">	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像</span></span><br><span class="line"><span class="code">		-s 指定值		列出收藏数不少于指定值的镜像</span></span><br><span class="line"><span class="code">  	--no-trunc	  显示完整的镜像信息</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.从仓库下载镜像</span></span><br><span class="line"><span class="code">	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.删除镜像</span></span><br><span class="line"><span class="code">	docker rmi 镜像名	--------------------------  删除镜像</span></span><br><span class="line"><span class="code">		-f		强制删除</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-Contrainer-容器命令"><a href="#6-3-Contrainer-容器命令" class="headerlink" title="6.3 Contrainer 容器命令"></a>6.3 Contrainer 容器命令</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.运行容器</span></span><br><span class="line"><span class="code">	docker run 镜像名	--------------------------	镜像名新建并启动容器</span></span><br><span class="line"><span class="code">    --name 					别名为容器起一个名字</span></span><br><span class="line"><span class="code">    -d							启动守护式容器（在后台启动容器）</span></span><br><span class="line"><span class="code">    -p 							映射端口号：原始端口号		 指定端口号启动</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">	例：docker run -it --name myTomcat -p 8888:8080 tomcat</span></span><br><span class="line"><span class="code">   	 docker run -d --name myTomcat -P tomcat</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.查看运行的容器</span></span><br><span class="line"><span class="code">	docker ps					--------------------------	列出所有正在运行的容器</span></span><br><span class="line"><span class="code">	-a			正在运行的和历史运行过的容器</span></span><br><span class="line"><span class="code">	-q			静默模式，只显示容器编号</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.停止|关闭|重启容器</span></span><br><span class="line"><span class="code">	docker start   容器名字或者容器id  --------------- 开启容器</span></span><br><span class="line"><span class="code">	docker restart 容器名或者容器id    --------------- 重启容器</span></span><br><span class="line"><span class="code">	docker stop  容器名或者容器id 	    ------------------ 正常停止容器运行</span></span><br><span class="line"><span class="code">	docker kill  容器名或者容器id      ------------------ 立即停止容器运行</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.删除容器</span></span><br><span class="line"><span class="code">	docker rm -f 容器id和容器名     </span></span><br><span class="line"><span class="code">	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.查看容器内进程</span></span><br><span class="line"><span class="code">	docker top 容器id或者容器名 ------------------ 查看容器内的进程</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.查看查看容器内部细节</span></span><br><span class="line"><span class="code">	docker inspect 容器id 		------------------ 查看容器内部细节</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 7.查看容器的运行日志</span></span><br><span class="line"><span class="code">	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志</span></span><br><span class="line"><span class="code">    -t			 加入时间戳</span></span><br><span class="line"><span class="code">    -f			 跟随最新的日志打印 实时监听日志</span></span><br><span class="line"><span class="code">    --tail 	 数字	显示最后多少条</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 8.进入容器内部</span></span><br><span class="line"><span class="code">	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令</span></span><br><span class="line"><span class="code">		-i		以交互模式运行容器，通常与-t一起使用</span></span><br><span class="line"><span class="code">    -t		分配一个伪终端    shell窗口   bash </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 9.容器和宿主机之间复制文件</span></span><br><span class="line"><span class="code">	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部</span></span><br><span class="line"><span class="code">	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 10.数据卷(volum)实现与宿主机共享目录</span></span><br><span class="line"><span class="code">	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名</span></span><br><span class="line"><span class="code">		注意: </span></span><br><span class="line"><span class="code">				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容</span></span><br><span class="line"><span class="code">				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 11.打包镜像</span></span><br><span class="line"><span class="code">		docker save 镜像名 -o  名称.tar</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 12.载入镜像</span></span><br><span class="line"><span class="code">		docker load -i   名称.tar</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 13.容器打包成新的镜像</span></span><br><span class="line"><span class="code">	  docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-docker的镜像原理"><a href="#7-docker的镜像原理" class="headerlink" title="7.docker的镜像原理"></a>7.docker的镜像原理</h2><h3 id="7-1-镜像是什么？"><a href="#7-1-镜像是什么？" class="headerlink" title="7.1 镜像是什么？"></a>7.1 镜像是什么？</h3><blockquote>
<p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p>
</blockquote>
<h3 id="7-2-为什么一个镜像会那么大？"><a href="#7-2-为什么一个镜像会那么大？" class="headerlink" title="7.2 为什么一个镜像会那么大？"></a>7.2 为什么一个镜像会那么大？</h3><img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20200404142950068.png" class title="image-20200404142950068">

<p><code>镜像就是花卷</code></p>
<ul>
<li><p>UnionFS（联合文件系统）:</p>
<p>Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。    </p>
</li>
</ul>
<h3 id="7-3-Docker镜像原理"><a href="#7-3-Docker镜像原理" class="headerlink" title="7.3 Docker镜像原理"></a>7.3 Docker镜像原理</h3><blockquote>
<p><code>docker的镜像实际是由一层一层的文件系统组成。</code></p>
</blockquote>
<ul>
<li><p>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux/Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</p>
</li>
<li><p>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的/dev，/proc，/bin，/etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu/CentOS等等。</p>
</li>
<li><p>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</p>
</li>
</ul>
.jpg)

<h3 id="7-4-为什么docker镜像要采用这种分层结构呢"><a href="#7-4-为什么docker镜像要采用这种分层结构呢" class="headerlink" title="7.4 为什么docker镜像要采用这种分层结构呢?"></a>7.4 为什么docker镜像要采用这种分层结构呢?</h3><blockquote>
<p><code>最大的一个好处就是资源共享</code></p>
</blockquote>
<ul>
<li>比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</li>
</ul>
<hr>
<h2 id="8-Docker安装常用服务"><a href="#8-Docker安装常用服务" class="headerlink" title="8.Docker安装常用服务"></a>8.Docker安装常用服务</h2><h3 id="8-1-安装mysql"><a href="#8-1-安装mysql" class="headerlink" title="8.1 安装mysql"></a>8.1 安装mysql</h3><p>可以参考这个进行进一步的设置，比如设置远程连接： <a href="https://blog.csdn.net/qq_42971035/article/details/127831101">https://blog.csdn.net/qq_42971035/article/details/127831101</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.拉取mysql镜像到本地</span></span><br><span class="line"><span class="code">	docker pull mysql:tag (tag不加默认最新版本)</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code"># 2.运行mysql服务</span></span><br><span class="line"><span class="code">	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接</span></span><br><span class="line"><span class="code">	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.进入mysql容器</span></span><br><span class="line"><span class="code">	docker exec -it 容器名称|容器id bash</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.外部查看mysql日志</span></span><br><span class="line"><span class="code">	docker logs 容器名称|容器id</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.使用自定义配置参数</span></span><br><span class="line"><span class="code">	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.将容器数据位置与宿主机位置挂载保证数据安全</span></span><br><span class="line"><span class="code">	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code"># 8.将mysql数据库备份为sql文件</span></span><br><span class="line"><span class="code">	docker exec mysql|容器id sh -c &#x27;exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &gt; /root/all-databases.sql  --导出全部数据</span></span><br><span class="line"><span class="code">	docker exec mysql sh -c &#x27;exec mysqldump --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &gt; /root/all-databases.sql  --导出指定库数据</span></span><br><span class="line"><span class="code">	docker exec mysql sh -c &#x27;exec mysqldump --no-data --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &gt; /root/all-databases.sql  --导出指定库数据不要数据</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 9.执行sql文件到mysql中</span></span><br><span class="line"><span class="code">	docker exec -i mysql sh -c &#x27;exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &lt; /root/xxx.sql</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-安装Redis服务"><a href="#8-2-安装Redis服务" class="headerlink" title="8.2 安装Redis服务"></a>8.2 安装Redis服务</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在docker hub搜索redis镜像</span></span><br><span class="line"><span class="code">	docker search redis</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.拉取redis镜像到本地</span></span><br><span class="line"><span class="code">	docker pull redis</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.启动redis服务运行容器</span></span><br><span class="line"><span class="code">	docker run --name redis -d redis:tag (没有暴露外部端口)</span></span><br><span class="line"><span class="code">	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.查看启动日志</span></span><br><span class="line"><span class="code">	docker logs -t -f 容器id|容器名称</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.进入容器内部查看</span></span><br><span class="line"><span class="code">	docker exec -it 容器id|名称 bash  </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.加载外部自定义配置启动redis容器</span></span><br><span class="line"><span class="code">	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件</span></span><br><span class="line"><span class="code">	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包</span></span><br><span class="line"><span class="code">	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件</span></span><br><span class="line"><span class="code">	3. 修改需要自定义的配置</span></span><br><span class="line"><span class="code">		 bind 0.0.0.0 开启远程权限</span></span><br><span class="line"><span class="code">		 appenonly yes 开启aof持久化</span></span><br><span class="line"><span class="code">	4. 加载配置启动</span></span><br><span class="line"><span class="code">	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 7.将数据目录挂在到本地保证数据安全</span></span><br><span class="line"><span class="code">	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  </span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-安装Nginx"><a href="#8-3-安装Nginx" class="headerlink" title="8.3 安装Nginx"></a>8.3 安装Nginx</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在docker hub搜索nginx</span></span><br><span class="line"><span class="code">	docker search nginx</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.拉取nginx镜像到本地</span></span><br><span class="line"><span class="code">	[root@localhost ~]# docker pull nginx</span></span><br><span class="line"><span class="code">    Using default tag: latest</span></span><br><span class="line"><span class="code">    latest: Pulling from library/nginx</span></span><br><span class="line"><span class="code">    afb6ec6fdc1c: Pull complete </span></span><br><span class="line"><span class="code">    b90c53a0b692: Pull complete </span></span><br><span class="line"><span class="code">    11fa52a0fdc0: Pull complete </span></span><br><span class="line"><span class="code">    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097</span></span><br><span class="line"><span class="code">    Status: Downloaded newer image for nginx:latest</span></span><br><span class="line"><span class="code">    docker.io/library/nginx:latest</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.启动nginx容器</span></span><br><span class="line"><span class="code">		docker run -p 80:80 --name nginx01 -d nginx</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.进入容器</span></span><br><span class="line"><span class="code">		docker exec -it nginx01 /bin/bash</span></span><br><span class="line"><span class="code">		查找目录:  whereis nginx</span></span><br><span class="line"><span class="code">		配置文件:  /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.复制配置文件到宿主机</span></span><br><span class="line"><span class="code">		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.挂在nginx配置以及html到宿主机外部</span></span><br><span class="line"><span class="code">		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-4-安装Tomcat"><a href="#8-4-安装Tomcat" class="headerlink" title="8.4 安装Tomcat"></a>8.4 安装Tomcat</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在docker hub搜索tomcat</span></span><br><span class="line"><span class="code">	docker search tomcat</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.下载tomcat镜像</span></span><br><span class="line"><span class="code">	docker pull tomcat</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.运行tomcat镜像</span></span><br><span class="line"><span class="code">	docker run -p 8080:8080 -d --name mytomcat tomcat</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.进入tomcat容器</span></span><br><span class="line"><span class="code">	docker exec -it mytomcat /bin/bash</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.将webapps目录挂载在外部</span></span><br><span class="line"><span class="code">	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-5-安装MongoDB数据库"><a href="#8-5-安装MongoDB数据库" class="headerlink" title="8.5 安装MongoDB数据库"></a>8.5 安装MongoDB数据库</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.运行mongDB</span></span><br><span class="line"><span class="code">	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限</span></span><br><span class="line"><span class="code">	docker logs -f mymongo --查看mongo运行日志</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.进入mongodb容器</span></span><br><span class="line"><span class="code">	docker exec -it mymongo /bin/bash</span></span><br><span class="line"><span class="code">		直接执行mongo命令进行操作</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.常见具有权限的容器</span></span><br><span class="line"><span class="code">	docker run --name  mymongo  -p 27017:27017  -d mongo --auth</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.进入容器配置用户名密码</span></span><br><span class="line"><span class="code">	mongo</span></span><br><span class="line"><span class="code">	use admin 选择admin库</span></span><br><span class="line"><span class="code">	db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[&#123;role:&#x27;root&#x27;,db:&#x27;admin&#x27;&#125;]&#125;)   //创建用户,此用户创建成功,则后续操作都需要用户认证</span></span><br><span class="line"><span class="code">	exit</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.将mongoDB中数据目录映射到宿主机中</span></span><br><span class="line"><span class="code">	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo </span></span><br></pre></td></tr></table></figure>

<h3 id="8-6-安装ElasticSearch"><a href="#8-6-安装ElasticSearch" class="headerlink" title="8.6 安装ElasticSearch"></a>8.6 安装ElasticSearch</h3><ul>
<li><code>注意:</code><strong>调高JVM线程数限制数量</strong></li>
</ul>
<h4 id="0-拉取镜像运行elasticsearch"><a href="#0-拉取镜像运行elasticsearch" class="headerlink" title="0.拉取镜像运行elasticsearch"></a>0.拉取镜像运行elasticsearch</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.dockerhub 拉取镜像</span></span><br><span class="line"><span class="code">	docker pull elasticsearch:6.4.2</span></span><br><span class="line"><span class="code"># 2.查看docker镜像</span></span><br><span class="line"><span class="code">	docker images</span></span><br><span class="line"><span class="code"># 3.运行docker镜像</span></span><br><span class="line"><span class="code">	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动出现如下错误</li>
<li><img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20200602184321790.png" class title="image-20200602184321790"></li>
</ul>
<h4 id="1-预先配置"><a href="#1-预先配置" class="headerlink" title="1. 预先配置"></a>1. 预先配置</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.在centos虚拟机中，修改配置sysctl.conf</span></span><br><span class="line"><span class="code">	vim /etc/sysctl.conf</span></span><br><span class="line"><span class="code"># 2.加入如下配置</span></span><br><span class="line"><span class="code">	vm.max_map_count=262144 </span></span><br><span class="line"><span class="code"># 3.启用配置</span></span><br><span class="line"><span class="code">	sysctl -p</span></span><br><span class="line"><span class="code">	注：这一步是为了防止启动容器时，报出如下错误：</span></span><br><span class="line"><span class="code">	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>

<h4 id="2-启动EleasticSearch容器"><a href="#2-启动EleasticSearch容器" class="headerlink" title="2.启动EleasticSearch容器"></a>2.启动EleasticSearch容器</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 0.复制容器中data目录到宿主机中</span></span><br><span class="line"><span class="code">	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es</span></span><br><span class="line"><span class="code"># 1.运行ES容器 指定jvm内存大小并指定ik分词器位置</span></span><br><span class="line"><span class="code">	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx128m&quot; -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2</span></span><br></pre></td></tr></table></figure>

<h4 id="3-安装IK分词器"><a href="#3-安装IK分词器" class="headerlink" title="3.安装IK分词器"></a>3.安装IK分词器</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.下载对应版本的IK分词器</span></span><br><span class="line"><span class="code">	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.解压到plugins文件夹中</span></span><br><span class="line"><span class="code">	yum install -y unzip</span></span><br><span class="line"><span class="code">	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.添加自定义扩展词和停用词</span></span><br><span class="line"><span class="code">	cd plugins/elasticsearch/config</span></span><br><span class="line"><span class="code">	vim IKAnalyzer.cfg.xml</span></span><br><span class="line"><span class="code">	&lt;properties&gt;</span></span><br><span class="line"><span class="code">		&lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;</span></span><br><span class="line"><span class="code">		&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line"><span class="code">		&lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt;</span></span><br><span class="line"><span class="code">		&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line"><span class="code">		&lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopwords.dic&lt;/entry&gt;</span></span><br><span class="line"><span class="code">	&lt;/properties&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.在ik分词器目录下config目录中创建ext<span class="emphasis">_dict.dic文件   编码一定要为UTF-8才能生效</span></span></span><br><span class="line"><span class="emphasis"><span class="section">	vim ext_</span>dict.dic 加入扩展词即可</span></span><br><span class="line"><span class="section"># 5. 在ik分词器目录下config目录中创建ext<span class="emphasis">_stopword.dic文件 </span></span></span><br><span class="line"><span class="emphasis"><span class="section">	vim ext_</span>stopwords.dic 加入停用词即可</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 6.重启容器生效</span></span><br><span class="line"><span class="code">	docker restart 容器id</span></span><br><span class="line"><span class="code"># 7.将此容器提交成为一个新的镜像</span></span><br><span class="line"><span class="code">	docker commit -a=&quot;xiaochen&quot; -m=&quot;es with IKAnalyzer&quot; 容器id xiaochen/elasticsearch:6.4.2</span></span><br></pre></td></tr></table></figure>

<h4 id="4-安装Kibana"><a href="#4-安装Kibana" class="headerlink" title="4. 安装Kibana"></a>4. 安装Kibana</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.下载kibana镜像到本地</span></span><br><span class="line"><span class="code">	docker pull kibana:6.4.2</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.启动kibana容器</span></span><br><span class="line"><span class="code">	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-7-安装rabbitmq"><a href="#8-7-安装rabbitmq" class="headerlink" title="8.7 安装rabbitmq"></a>8.7 安装rabbitmq</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 下载镜像</span></span><br><span class="line">docker pull rabbitmq</span><br><span class="line"></span><br><span class="line"><span class="section"># 创建并运行rabbotmq容器</span></span><br><span class="line">docker run -d -p 15672:15672 -p 5672:5672 \</span><br><span class="line"><span class="code">	-e RABBITMQ_DEFAULT_VHOST=my_vhost  \</span></span><br><span class="line"><span class="code">	-e RABBITMQ_DEFAULT_USER=admin \</span></span><br><span class="line"><span class="code">	-e RABBITMQ_DEFAULT_PASS=admin \</span></span><br><span class="line"><span class="code">	--hostname myRabbit \</span></span><br><span class="line"><span class="code">	--name rabbitmq \</span></span><br><span class="line"><span class="code">	rabbitmq:3.8.16</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">-d：表示在后台运行容器；</span></span><br><span class="line"><span class="code">-p：将容器的端口 5672（应用访问端口）和 15672 （控制台Web端口号）映射到主机中；</span></span><br><span class="line"><span class="code">-e：指定环境变量：</span></span><br><span class="line"><span class="code">RABBITMQ_DEFAULT_VHOST：默认虚拟机名；</span></span><br><span class="line"><span class="code">RABBITMQ_DEFAULT_USER：默认的用户名；</span></span><br><span class="line"><span class="code">RABBITMQ_DEFAULT_PASS：默认的用户密码；</span></span><br><span class="line"><span class="code">--hostname：指定主机名（RabbitMQ 的一个重要注意事项是它根据所谓的 节点名称 存储数据，默认为主机名）；</span></span><br><span class="line"><span class="code">--name rabbitmq：设置容器名称；</span></span><br><span class="line"><span class="code">rabbitmq：容器使用的镜像名称；</span></span><br></pre></td></tr></table></figure>

<h3 id="启动-rabbitmq-management"><a href="#启动-rabbitmq-management" class="headerlink" title="启动 rabbitmq_management"></a>启动 <code>rabbitmq_management</code></h3><p>docker exec -it rabbitmq rabbitmq-plugins enable rabbitmq_management</p>
<p>访问ip:15672即可打开管理页面：</p>
<img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/1668926575569.png" class width="1668926575569">

<h2 id="10-Docker中出现如下错误解决方案"><a href="#10-Docker中出现如下错误解决方案" class="headerlink" title="10.Docker中出现如下错误解决方案"></a>10.Docker中出现如下错误解决方案</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># docker search mysql 或者 docker pull 这些命令无法使用</span></span><br><span class="line">Error response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=<span class="number">25</span>: x509: certificate has expired or is not yet valid</span><br></pre></td></tr></table></figure>

<img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20200602183429286.png" class title="image-20200602183429286">

<ul>
<li>注意:<strong>这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步</strong></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.安装时间同步</span></span><br><span class="line"><span class="code">	sudo yum -y install ntp ntpdate</span></span><br><span class="line"><span class="code"># 2.同步时间</span></span><br><span class="line"><span class="code">	sudo ntpdate cn.pool.ntp.org</span></span><br><span class="line"><span class="code"># 3.查看本机时间</span></span><br><span class="line"><span class="code">	date</span></span><br><span class="line"><span class="code"># 4.从新测试</span></span><br></pre></td></tr></table></figure>

<img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20200602183718623.png" class title="image-20200602183718623">

<h2 id="9-Dockerfile"><a href="#9-Dockerfile" class="headerlink" title="9.Dockerfile"></a>9.Dockerfile</h2><h3 id="9-1-什么是Dockerfile"><a href="#9-1-什么是Dockerfile" class="headerlink" title="9.1 什么是Dockerfile"></a>9.1 什么是Dockerfile</h3><p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p>
<img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20200404111908085.png" class title="image-20200404111908085">

<ul>
<li><strong>通过架构图可以看出通过DockerFile可以直接构建镜像</strong></li>
</ul>
<h3 id="9-2-Dockerfile解析过程"><a href="#9-2-Dockerfile解析过程" class="headerlink" title="9.2 Dockerfile解析过程"></a>9.2 Dockerfile解析过程</h3><img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20200603181253804.png" class title="image-20200603181253804">

<h3 id="9-3-Dockerfile的保留命令"><a href="#9-3-Dockerfile的保留命令" class="headerlink" title="9.3 Dockerfile的保留命令"></a>9.3 Dockerfile的保留命令</h3><p>官方说明:<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
<table>
<thead>
<tr>
<th>保留字</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FROM</strong></td>
<td><strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code></td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像维护者的姓名和邮箱地址</td>
</tr>
<tr>
<td><strong>RUN</strong></td>
<td><strong>构建镜像时需要运行的指令</strong></td>
</tr>
<tr>
<td><strong>EXPOSE</strong></td>
<td><strong>当前容器对外暴露出的端口号</strong></td>
</tr>
<tr>
<td><strong>WORKDIR</strong></td>
<td><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td>
</tr>
<tr>
<td><strong>ENV</strong></td>
<td><strong>用来在构建镜像过程中设置环境变量</strong></td>
</tr>
<tr>
<td><strong>ADD</strong></td>
<td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td>
</tr>
<tr>
<td><strong>COPY</strong></td>
<td><strong>类似于ADD，拷贝文件和目录到镜像中<br>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong></td>
</tr>
<tr>
<td><strong>VOLUME</strong></td>
<td><strong>容器数据卷，用于数据保存和持久化工作</strong></td>
</tr>
<tr>
<td><strong>CMD</strong></td>
<td><strong>指定一个容器启动时要运行的命令<br>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong></td>
</tr>
<tr>
<td><strong>ENTRYPOINT</strong></td>
<td><strong>指定一个容器启动时要运行的命令<br>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></td>
</tr>
</tbody></table>
<h4 id="9-3-1-FROM-命令"><a href="#9-3-1-FROM-命令" class="headerlink" title="9.3.1 FROM 命令"></a>9.3.1 FROM 命令</h4><ul>
<li><p>基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  &lt;image&gt;</span><br><span class="line"><span class="keyword">FROM</span>  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest</span><br><span class="line"><span class="keyword">FROM</span>  &lt;image&gt;[@&lt;digest&gt;]  使用摘要</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-3-2-MAINTAINER-命令"><a href="#9-3-2-MAINTAINER-命令" class="headerlink" title="9.3.2 MAINTAINER  命令"></a>9.3.2 MAINTAINER  命令</h4><ul>
<li><p>镜像维护者的姓名和邮箱地址[废弃]</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MAINTAINER</span> &lt;name&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-3-3-RUN-命令"><a href="#9-3-3-RUN-命令" class="headerlink" title="9.3.3 RUN 命令"></a>9.3.3 RUN 命令</h4><ul>
<li><p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> &lt;<span class="built_in">command</span>&gt; (shell form, the <span class="built_in">command</span> is run <span class="keyword">in</span> a shell, <span class="built_in">which</span> by default is /bin/sh -c on Linux or cmd /S /C on Windows)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>] (<span class="built_in">exec</span> form)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo hello&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-3-4-EXPOSE-命令"><a href="#9-3-4-EXPOSE-命令" class="headerlink" title="9.3.4 EXPOSE 命令"></a>9.3.4 EXPOSE 命令</h4><ul>
<li><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/tcp  如果没有显示指定则默认暴露都是tcp</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-3-5-CMD-命令"><a href="#9-3-5-CMD-命令" class="headerlink" title="9.3.5 CMD 命令"></a>9.3.5 CMD 命令</h4><ul>
<li><p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p>
</li>
<li><p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>] (<span class="built_in">exec</span> form, this is the preferred form)</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>] (as default parameters to ENTRYPOINT)</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">command</span> param1 param2 (shell form)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-3-6-WORKDIR-命令"><a href="#9-3-6-WORKDIR-命令" class="headerlink" title="9.3.6 WORKDIR 命令"></a>9.3.6 WORKDIR 命令</h4><ul>
<li><p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br><span class="line">`注意:<span class="keyword">WORKDIR</span><span class="bash">指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-3-7-ENV-命令"><a href="#9-3-7-ENV-命令" class="headerlink" title="9.3.7 ENV 命令"></a>9.3.7 ENV 命令</h4><ul>
<li><p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p>
</li>
<li><p>语法：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-3-8-ADD-命令"><a href="#9-3-8-ADD-命令" class="headerlink" title="9.3.8 ADD 命令"></a>9.3.8 ADD 命令</h4><ul>
<li><p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> hom* /mydir/       通配符添加多个文件</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> hom?.txt /mydir/   通配符添加</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> test.txt relativeDir/  可以指定相对路径</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> test.txt /absoluteDir/ 也可以指定绝对路径</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> url </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-3-9-COPY-命令"><a href="#9-3-9-COPY-命令" class="headerlink" title="9.3.9 COPY 命令"></a>9.3.9 COPY 命令</h4><ul>
<li><p>用来将context目录中指定文件复制到镜像的指定目录中</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> src dest</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-3-10-VOLUME-命令"><a href="#9-3-10-VOLUME-命令" class="headerlink" title="9.3.10 VOLUME 命令"></a>9.3.10 VOLUME 命令</h4><ul>
<li><p>用来定义容器运行时可以挂在到宿主机的目录</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;/data&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-3-11-ENTRYPOINT命令"><a href="#9-3-11-ENTRYPOINT命令" class="headerlink" title="9.3.11 ENTRYPOINT命令"></a>9.3.11 ENTRYPOINT命令</h4><ul>
<li><p>用来指定容器启动时执行命令和CMD类似</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">  [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure>

<p>ENTRYPOINT指令，往往用于设置容器启动后的<strong>第一个命令</strong>，这对一个容器来说往往是固定的。<br>CMD指令，往往用于设置容器启动的第一个命令的<strong>默认参数</strong>，这对一个容器来说可以是变化的。</p>
</li>
</ul>
<h4 id="9-3-11-ENTRYPOINT命令-1"><a href="#9-3-11-ENTRYPOINT命令-1" class="headerlink" title="9.3.11 ENTRYPOINT命令"></a>9.3.11 ENTRYPOINT命令</h4><h3 id="9-4-Dockerfile构建springboot项目部署"><a href="#9-4-Dockerfile构建springboot项目部署" class="headerlink" title="9.4 Dockerfile构建springboot项目部署"></a>9.4 Dockerfile构建springboot项目部署</h3><h5 id="1-准备springboot可运行项目"><a href="#1-准备springboot可运行项目" class="headerlink" title="1.准备springboot可运行项目"></a>1.准备springboot可运行项目</h5><img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20200605172151266.png" class title="image-20200605172151266">

<h5 id="2-将可运行项目放入linux虚拟机中"><a href="#2-将可运行项目放入linux虚拟机中" class="headerlink" title="2.将可运行项目放入linux虚拟机中"></a>2.将可运行项目放入linux虚拟机中</h5><img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20200605172340380.png" class title="image-20200605172340380">

<h5 id="3-编写Dockerfile"><a href="#3-编写Dockerfile" class="headerlink" title="3.编写Dockerfile"></a>3.编写Dockerfile</h5><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /ems</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ems.jar /ems</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8989</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;ems.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h5 id="4-构建镜像"><a href="#4-构建镜像" class="headerlink" title="4.构建镜像"></a>4.构建镜像</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ems]# docker build -t ems .</span><br></pre></td></tr></table></figure>

<h5 id="5-运行镜像"><a href="#5-运行镜像" class="headerlink" title="5.运行镜像"></a>5.运行镜像</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ems]# docker run -p 8989:8989 ems</span><br></pre></td></tr></table></figure>

<h5 id="6-访问项目"><a href="#6-访问项目" class="headerlink" title="6.访问项目"></a>6.访问项目</h5><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://10.15.0.8:8989/ems/login.html</span><br></pre></td></tr></table></figure>

<img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20200605173141636.png" class title="image-20200605173141636">

<hr>
<h2 id="10-高级网络配置"><a href="#10-高级网络配置" class="headerlink" title="10.高级网络配置"></a>10.高级网络配置</h2><h3 id="10-1-说明"><a href="#10-1-说明" class="headerlink" title="10.1 说明"></a>10.1 说明</h3><p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href="https://tools.ietf.org/html/rfc1918">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>
<img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20201125105847896.png" class title="image-20201125105847896">

<h3 id="10-2-查看网络信息"><a href="#10-2-查看网络信息" class="headerlink" title="10.2 查看网络信息"></a>10.2 查看网络信息</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># docker network ls</span></span><br></pre></td></tr></table></figure>

<h3 id="10-3-创建一个网桥"><a href="#10-3-创建一个网桥" class="headerlink" title="10.3 创建一个网桥"></a>10.3 创建一个网桥</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># docker network create -d bridge 网桥名称</span></span><br></pre></td></tr></table></figure>

<h3 id="10-4-删除一个网桥"><a href="#10-4-删除一个网桥" class="headerlink" title="10.4 删除一个网桥"></a>10.4 删除一个网桥</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># docker network rm 网桥名称</span></span><br></pre></td></tr></table></figure>

<h3 id="10-5-容器之前使用网络通信"><a href="#10-5-容器之前使用网络通信" class="headerlink" title="10.5 容器之前使用网络通信"></a>10.5 容器之前使用网络通信</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.查询当前网络配置</span></span><br><span class="line"><span class="bullet">-</span> docker network ls</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">8e424e5936b7        bridge              bridge              local</span><br><span class="line">17d974db02da        docker_gwbridge     bridge              local</span><br><span class="line">d6c326e433f7        host                host                local</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.创建桥接网络</span></span><br><span class="line"><span class="bullet">-</span> docker network create -d bridge info</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@centos ~]# docker network create -d bridge info</span><br><span class="line">6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f</span><br><span class="line">[root@centos ~]# docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">8e424e5936b7        bridge              bridge              local</span><br><span class="line">17d974db02da        docker_gwbridge     bridge              local</span><br><span class="line">d6c326e433f7        host                host                local</span><br><span class="line">6e4aaebff79b        info                bridge              local</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.启动容器指定使用网桥</span></span><br><span class="line"><span class="bullet">-</span> docker run -d -p 8890:80 --name nginx001 --network info nginx </span><br><span class="line"><span class="bullet">-</span> docker run -d -p 8891:80 --name nginx002 --network info nginx </span><br><span class="line"><span class="code">	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx </span><br><span class="line">c315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe</span><br><span class="line">[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx</span><br><span class="line">f8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5</span><br><span class="line">[root@centos ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">f8682db35dd7        nginx               &quot;/docker-entrypoint.…&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8891-&gt;80/tcp   nginx002</span><br><span class="line">c315bcc94e9d        nginx               &quot;/docker-entrypoint.…&quot;   7 minutes ago       Up 7 minutes        0.0.0.0:8890-&gt;80/tcp   nginx001</span><br><span class="line">b63169d43792        mysql:5.7.19        &quot;docker-entrypoint.s…&quot;   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda</span><br><span class="line">[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash</span><br><span class="line">root@f8682db35dd7:/# curl http://nginx001</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="11-高级数据卷配置"><a href="#11-高级数据卷配置" class="headerlink" title="11.高级数据卷配置"></a>11.高级数据卷配置</h2><h3 id="11-1-说明"><a href="#11-1-说明" class="headerlink" title="11.1 说明"></a>11.1 说明</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
</blockquote>
<h3 id="11-2-创建数据卷"><a href="#11-2-创建数据卷" class="headerlink" title="11.2 创建数据卷"></a>11.2 创建数据卷</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@centos ~]# docker volume create my-vol</span><br><span class="line">my-vol</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-3-查看数据卷"><a href="#11-3-查看数据卷" class="headerlink" title="11.3 查看数据卷"></a>11.3 查看数据卷</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ro </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-4-挂载数据卷"><a href="#11-4-挂载数据卷" class="headerlink" title="11.4 挂载数据卷"></a>11.4 挂载数据卷</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx</span><br><span class="line">[root@centos ~]# docker inspect web</span><br><span class="line">				&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-5-删除数据卷"><a href="#11-5-删除数据卷" class="headerlink" title="11.5 删除数据卷"></a>11.5 删除数据卷</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume rm my-vol</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="12-Docker-Compose"><a href="#12-Docker-Compose" class="headerlink" title="12.Docker Compose"></a>12.Docker Compose</h2><h3 id="12-1-简介"><a href="#12-1-简介" class="headerlink" title="12.1 简介"></a>12.1 简介</h3><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>
<p>其代码目前在 <a href="https://github.com/docker/compose">https://github.com/docker/compose</a> 上开源。</p>
<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>
<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<h3 id="12-2-安装与卸载"><a href="#12-2-安装与卸载" class="headerlink" title="12.2 安装与卸载"></a>12.2 安装与卸载</h3><h6 id="1-linux"><a href="#1-linux" class="headerlink" title="1.linux"></a>1.linux</h6><ul>
<li>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">$ sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-macos、window"><a href="#2-macos、window" class="headerlink" title="2.macos、window"></a>2.macos、window</h6><ul>
<li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li>
</ul>
<h6 id="3-bash命令补全"><a href="#3-bash命令补全" class="headerlink" title="3.bash命令补全"></a>3.bash命令补全</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="4-卸载"><a href="#4-卸载" class="headerlink" title="4.卸载"></a>4.卸载</h6><ul>
<li>如果是二进制包方式安装的，删除二进制文件即可。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo rm /usr/<span class="built_in">local</span>/bin/docker-compose</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="5-测试安装成功"><a href="#5-测试安装成功" class="headerlink" title="5.测试安装成功"></a>5.测试安装成功</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose --version</span></span><br><span class="line"> docker-compose version 1.25.5, build 4667896b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="12-3-docker-compose使用"><a href="#12-3-docker-compose使用" class="headerlink" title="12.3 docker compose使用"></a>12.3 docker compose使用</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 1.相关概念</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先介绍几个术语。</p>
<ul>
<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 2.场景</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<ul>
<li>springboot应用</li>
<li>mysql服务</li>
<li>redis服务</li>
<li>elasticsearch服务</li>
<li>…….</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 3.docker-compose模板</span></span><br><span class="line"><span class="bullet">-</span> 参考文档:https://docker<span class="emphasis">_practice.gitee.io/zh-cn/compose/compose_</span>file.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.0&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysqldb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.19</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/mysql/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/mysql/logs:/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/mysql/data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ems</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:4.0.14</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ems</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/redis/data:/data</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">ems:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 4.通过docker-compose运行一组容器</span></span><br><span class="line"><span class="bullet">-</span> 参考文档:https://docker<span class="emphasis">_practice.gitee.io/zh-cn/compose/commands.html</span></span><br><span class="line"><span class="emphasis"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos ~]<span class="comment"># docker-compose up    							//前台启动一组服务</span></span><br><span class="line">[root@centos ~]<span class="comment"># docker-compose up -d 							//后台启动一组服务</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="12-4-docker-compose-模板文件"><a href="#12-4-docker-compose-模板文件" class="headerlink" title="12.4 docker-compose 模板文件"></a>12.4 docker-compose 模板文件</h3><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>
<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">examples/web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/data&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>
<p>下面分别介绍各个指令的用法。</p>
<h4 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h4><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./dir</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>
<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>
<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">buildno:</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="command"><a href="#command" class="headerlink" title="command"></a><code>command</code></h4><p>覆盖容器启动后默认执行的命令。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">echo</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a><code>container_name</code></h4><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">docker-web-container</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>
</blockquote>
<h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a><code>depends_on</code></h4><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>
</blockquote>
<h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a><code>env_file</code></h4><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>
<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a><code>environment</code></h4><p>设置环境变量。你可以使用数组或字典两种格式。</p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SESSION_SECRET</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="https://yaml.org/type/bool.html">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|<span class="literal">true</span>|True|TRUE|<span class="literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a><code>healthcheck</code></h4><p>通过命令检查容器是否健康运行。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">orchardup/postgresql</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">a4bc65fd</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a><code>networks</code></h4><p>配置容器连接的网络。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">some-service:</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">some-network</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">other-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">some-network:</span></span><br><span class="line">  <span class="attr">other-network:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a><code>ports</code></h4><p>暴露端口信息。</p>
<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;49100:22&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:8001:8001&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>
<h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a><code>sysctls</code></h4><p>配置容器内核参数。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="attr">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">  <span class="attr">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a><code>ulimits</code></h4><p>指定容器的 ulimits 限制值。</p>
<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line">  <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">nofile:</span></span><br><span class="line">    <span class="attr">soft:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">hard:</span> <span class="number">40000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a><code>volumes</code></h4><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>
<p>该指令中路径支持相对路径。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my_src:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="12-5-docker-compose-常用命令"><a href="#12-5-docker-compose-常用命令" class="headerlink" title="12.5 docker-compose 常用命令"></a>12.5 docker-compose 常用命令</h3><h5 id="1-命令对象与格式"><a href="#1-命令对象与格式" class="headerlink" title="1. 命令对象与格式"></a>1. 命令对象与格式</h5><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>
<p><code>docker-compose</code> 命令的基本的使用格式是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-命令选项"><a href="#2-命令选项" class="headerlink" title="2. 命令选项"></a>2. 命令选项</h5><ul>
<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>
<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>
<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>
<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>
<li><code>--verbose</code> 输出更多调试信息。</li>
<li><code>-v, --version</code> 打印版本并退出。</li>
</ul>
<h5 id="3-命令使用说明"><a href="#3-命令使用说明" class="headerlink" title="3.命令使用说明"></a>3.命令使用说明</h5><h5 id="up"><a href="#up" class="headerlink" title="up"></a><code>up</code></h5><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>
<ul>
<li><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
</li>
<li><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
</li>
<li><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
</li>
<li><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
</li>
<li><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>
</li>
<li><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
</li>
<li><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</p>
</li>
</ul>
<hr>
<h5 id="down"><a href="#down" class="headerlink" title="down"></a><code>down</code></h5><ul>
<li>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</li>
</ul>
<hr>
<h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h5><ul>
<li>进入指定的容器。</li>
</ul>
<hr>
<h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h5><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<hr>
<h5 id="restart"><a href="#restart" class="headerlink" title="restart"></a><code>restart</code></h5><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>
</ul>
<hr>
<h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h5><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><code>-v</code> 删除容器所挂载的数据卷。</li>
</ul>
<hr>
<h5 id="start"><a href="#start" class="headerlink" title="start"></a><code>start</code></h5><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>
<p>启动已经存在的服务容器。</p>
<hr>
<h5 id="stop"><a href="#stop" class="headerlink" title="stop"></a><code>stop</code></h5><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<hr>
<h5 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h5><p>查看各个服务容器内运行的进程。</p>
<hr>
<h5 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a><code>unpause</code></h5><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>
<p>恢复处于暂停状态中的服务。</p>
<hr>
<h2 id="13-docker可视化工具"><a href="#13-docker可视化工具" class="headerlink" title="13.docker可视化工具"></a>13.docker可视化工具</h2><h4 id="13-1-安装Portainer"><a href="#13-1-安装Portainer" class="headerlink" title="13.1 安装Portainer"></a>13.1 安装Portainer</h4><p>官方安装说明：<a href="http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=">https://www.portainer.io/installation/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ubuntu1804 ~]#docker pull  portainer/portainer</span><br><span class="line"></span><br><span class="line">[root@ubuntu1804 ~]#docker volume create portainer_data</span><br><span class="line">portainer_data</span><br><span class="line">[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br><span class="line">20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3</span><br><span class="line">[root@ubuntu1804 ~]#docker ps </span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES</span><br><span class="line">20db26b67b79        portainer/portainer   &quot;/portainer&quot;        5 seconds ago       Up 4 seconds        0.0.0.0:8000-&gt;8000/tcp, 0.0.0.0:9000-&gt;9000/tcp   portainer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="13-2-登录和使用Portainer"><a href="#13-2-登录和使用Portainer" class="headerlink" title="13.2 登录和使用Portainer"></a>13.2 登录和使用Portainer</h4><blockquote>
<p>用浏览器访问：<code>http://localhost:9000</code></p>
</blockquote>
<img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/image-20201223231707738.png" class title="image-20201223231707738">

<hr>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="1-WARNING-IPv4-forwarding-is-disabled-Networking-will-not-work-无法访问ipv4"><a href="#1-WARNING-IPv4-forwarding-is-disabled-Networking-will-not-work-无法访问ipv4" class="headerlink" title="1. WARNING: IPv4 forwarding is disabled. Networking will not work. 无法访问ipv4"></a>1. WARNING: IPv4 forwarding is disabled. Networking will not work. 无法访问ipv4</h2><p>[root@castile ~]# docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d –name mytomcat tomcat:8.0.53<br>WARNING: IPv4 forwarding is disabled. Networking will not work.<br>61464b009339e82adf1f81c3dbabea1c4910b037006a2d2666e28b4706f4b3a6</p>
<p>解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line">添加</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/11/20/docker%E6%96%87%E6%A1%A3/1668926163225.png" class width="1668926163225">



<p>重启network和docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart network &amp;&amp; systemctl restart docker</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Flink集群部署</title>
    <url>/2022/11/27/Flink%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="Flink集群部署"><a href="#Flink集群部署" class="headerlink" title="Flink集群部署"></a>Flink集群部署</h1><p>Flink几个关键主件： 客户端（Client）、作业管理器（JobManager）和 任务管理器（TaskManager）。我们的代码，实际上是由客户端获取并做转换，之后提交给 JobManger 的。所以 JobManager 就是 Flink 集群里的“管事人”，对作业进行中央调度管理； 而它获取到要执行的作业后，会进一步处理转换，然后分发任务给众多的 TaskManager。这里 的 TaskManager，就是真正“干活的人”，数据的处理操作都是它们来做的。</p>
<img src="/2022/11/27/Flink%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/1669535535878.png" class width="1669535535878">



<h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h2><p> Flink 是一个分布式的流处理框架，所以实际应用一般都需要搭建集群环境。我们在进行 Flink 安装部署的学习时，需要准备 3 台 Linux 机器 。</p>
<p> 进入 Flink 官网，下载 1.13.0 版本安装包 flink-1.13.0-bin-scala_2.12.tgz，注意此处选用对 应 scala 版本为 scala 2.12 的安装包 </p>
<p><a href="https://archive.apache.org/dist/flink/flink-1.13.0/">https://archive.apache.org/dist/flink/flink-1.13.0/</a></p>
<img src="/2022/11/27/Flink%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/1669536353839.png" class width="1669536353839">



<p>解压：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/</span><br><span class="line">mkdir flink</span><br><span class="line">tar -zxvf flink-1.13.0-bin-scala_2.12.tgz -C /opt/flink/</span><br><span class="line">flink-1.13.0/</span><br><span class="line">flink-1.13.0/log/</span><br><span class="line">flink-1.13.0/LICENSE</span><br><span class="line">flink-1.13.0/lib/</span><br><span class="line">……</span><br></pre></td></tr></table></figure>



<p> Flink 是典型的 Master-Slave 架构的分布式数据处理框架，其中 Master 角色对应着 JobManager，Slave 角色则对应 TaskManager。我们对三台节点服务器的角色分配如</p>
<table>
<thead>
<tr>
<th>节点服务器</th>
<th>castile</th>
<th>castile2</th>
<th>castile3</th>
</tr>
</thead>
<tbody><tr>
<td>角色</td>
<td>JobManager</td>
<td>TaskManager</td>
<td>TaskManager</td>
</tr>
</tbody></table>
<h2 id="2-集群配置"><a href="#2-集群配置" class="headerlink" title="2. 集群配置"></a>2. 集群配置</h2><ol>
<li> 进入 conf 目录下，修改 flink-conf.yaml 文件，修改 jobmanager.rpc.address 参数为 castile，如下所示 </li>
</ol>
<img src="/2022/11/27/Flink%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/1669536841818.png" class width="1669536841818">

<p> 这就指定了 castile(192.168.160.200)节点服务器为 JobManager 节点。 </p>
<ol start="2">
<li><p>修改workers文件，  将另外两台节点服务器添加为本 Flink 集群的 TaskManager 节点 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim workers </span><br><span class="line">castile2</span><br><span class="line">castile3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 这样就指定了 castile2和 castile3为 TaskManager 节点。 </p>
</li>
<li><p> 另外，在 flink-conf.yaml 文件中还可以对集群中的 JobManager 和 TaskManager 组件 进行优化配置，主要配置项如下 :</p>
</li>
</ol>
<ul>
<li>jobmanager.memory.process.size：对 JobManager 进程可使用到的全部内存进行配置， 包括 JVM 元空间和其他开销，默认为 1600M，可以根据集群规模进行适当调整。 </li>
<li>taskmanager.memory.process.size：对 TaskManager 进程可使用到的全部内存进行配置， 包括 JVM 元空间和其他开销，默认为 1600M，可以根据集群规模进行适当调整。 </li>
<li> taskmanager.numberOfTaskSlots：对每个 TaskManager 能够分配的 Slot 数量进行配置， 默认为 1，可根据 TaskManager 所在的机器能够提供给 Flink 的 CPU 数量决定。所谓 Slot 就是 TaskManager 中具体运行一个任务所分配的计算资源。</li>
<li>parallelism.default：Flink 任务执行的默认并行度，优先级低于代码中进行的并行度配 置和任务提交时使用参数指定的并行度数量 </li>
</ul>
<h2 id="3-集群内容分发脚本"><a href="#3-集群内容分发脚本" class="headerlink" title="3. 集群内容分发脚本"></a>3. 集群内容分发脚本</h2><p>配置修改完毕后，将Flink安装目录分发给另外两个节点服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1 获取输入参数个数，如果没有参数，直接退出</span></span><br><span class="line">pcount=$#</span><br><span class="line">if [ $pcount -lt 1 ]</span><br><span class="line">then</span><br><span class="line">    echo No Enough Arguement!</span><br><span class="line">    exit;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">2. 遍历集群所有机器</span></span><br><span class="line">for host in castile2 castile3</span><br><span class="line">do</span><br><span class="line">    echo ====================    $host    ====================</span><br><span class="line">    #3. 递归遍历所有目录</span><br><span class="line">    for file in $@</span><br><span class="line">    do</span><br><span class="line">        #4 判断文件是否存在</span><br><span class="line">        if [ -e $file ]</span><br><span class="line">        then</span><br><span class="line">            #5. 获取全路径</span><br><span class="line">            pdir=$(cd -P $(dirname $file); pwd)</span><br><span class="line">            echo pdir=$pdir</span><br><span class="line"></span><br><span class="line">            #6. 获取当前文件的名称</span><br><span class="line">            fname=$(basename $file)</span><br><span class="line">            echo fname=$fname</span><br><span class="line"></span><br><span class="line">            #7. 通过ssh执行命令：在$host主机上递归创建文件夹（如果存在该文件夹）</span><br><span class="line">            ssh $host &quot;source /etc/profile;mkdir -p $pdir&quot;</span><br><span class="line"></span><br><span class="line">            #8. 远程同步文件至$host主机的$USER用户的$pdir文件夹下</span><br><span class="line">            rsync -av $pdir/$fname $USER@$host:$pdir</span><br><span class="line">        else</span><br><span class="line">            echo $file Does Not Exists!</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>分发：</p>
<img src="/2022/11/27/Flink%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/1669537196294.png" class width="1669537196294">

<p>可以看到其他两个节点服务器已经收到：</p>
<img src="/2022/11/27/Flink%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/1669537281400.png" class width="1669537281400">

<img src="/2022/11/27/Flink%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/1669537304323.png" class width="1669537304323">

<h2 id="4-启动集群"><a href="#4-启动集群" class="headerlink" title="4. 启动集群"></a>4. 启动集群</h2><p> （1）在 castile节点服务器上执行 start-cluster.sh 启动 Flink 集群： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@castile bin]# ./start-cluster.sh</span><br><span class="line">Starting cluster.</span><br><span class="line">Starting standalonesession daemon on host castile.</span><br><span class="line">Starting taskexecutor daemon on host castile2.</span><br><span class="line">Starting taskexecutor daemon on host castile3.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>查看进程情况</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[root@castile bin]# jps</span><br><span class="line">82890 StandaloneSessionClusterEntrypoint</span><br><span class="line">83038 Jps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@castile2 conf]# jps</span><br><span class="line">3426 TaskManagerRunner</span><br><span class="line">3478 Jps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@castile3 flink-1.13.0]# jps</span><br><span class="line">3459 TaskManagerRunner</span><br><span class="line">3530 Jps</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-访问WebUI"><a href="#5-访问WebUI" class="headerlink" title="5. 访问WebUI"></a>5. 访问WebUI</h2><p> 启动成功后，同样可以访问  <a href="http://192.168.160.200:8081/#/overview">Apache Flink Web Dashboard</a>  对 flink 集群和任务进行监控管理，如图 所示。 </p>
<img src="/2022/11/27/Flink%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/1669537600942.png" class width="1669537600942">

<p> 这里可以明显看到，当前集群的 TaskManager 数量为 2；由于默认每个 TaskManager 的 Slot 数量为 1，所以总 Slot 数和可用 Slot 数都为 2。 还可以查看TaskManager节点的资源情况：</p>
<img src="/2022/11/27/Flink%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/1669537745617.png" class width="1669537745617">

<p>至此，我们Flink的一个集群就搭建起来了，我们可以使用web界面进行作业的提交。</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件-RabbitMQ</title>
    <url>/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/</url>
    <content><![CDATA[<h1 id="消息中间件-RabbitMQ"><a href="#消息中间件-RabbitMQ" class="headerlink" title="消息中间件-RabbitMQ"></a>消息中间件-RabbitMQ</h1><h2 id="一、-介绍"><a href="#一、-介绍" class="headerlink" title="一、 介绍"></a>一、 介绍</h2><h3 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1. 消息队列"></a>1. 消息队列</h3><p> MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。  </p>
<h3 id="2-为什么要使用MQ"><a href="#2-为什么要使用MQ" class="headerlink" title="2. 为什么要使用MQ"></a>2. 为什么要使用MQ</h3><ol>
<li><p>流量削峰</p>
</li>
<li><p>应用解耦： 子系统间通过消息队列来通信，提升系统可用性</p>
<img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1669995845244.png" class width="1669995845244"></li>
<li><p>异步处理</p>
<img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1669995869164.png" class width="1669995869164"></li>
</ol>
<h3 id="3-分类"><a href="#3-分类" class="headerlink" title="3. 分类"></a>3. 分类</h3><ol>
<li>ActiveMQ： 优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据 缺点:官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。 </li>
<li>Kafka：大数据场景常用，百万级TPS、吞吐量高</li>
<li>RocketMQ： 出自阿里巴巴， 单机吞吐量十万级,可用性非常高，分布式架构,消息可以做到 0 丢失,MQ 功能较为完善，还是分 布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ 。</li>
<li> RabbitMQ  ： 2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最 主流的消息中间件之一 。 吞吐量到万级 ，支持多语言，社区活跃度高。</li>
</ol>
<h2 id="二、-RabbitMQ"><a href="#二、-RabbitMQ" class="headerlink" title="二、 RabbitMQ"></a>二、 RabbitMQ</h2><p> RabbitMQ 是一个消息中间件 </p>
<p> 它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包 裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。  </p>
<h3 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h3><img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1669996408130.png" class width="1669996408130">

<ol>
<li>生产者： 产生数据发送消息的程序 </li>
<li>交换机： 交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推 送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定。</li>
<li>队列： 队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式 。</li>
<li>消费者： 消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</li>
<li> Broker：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker。</li>
<li> Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</li>
<li> Connection：publisher／consumer 和 broker 之间的 TCP 连接。</li>
<li> Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</strong> </li>
<li> Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。</li>
<li> Queue：消息最终被送到这里等待 consumer 取 走。</li>
<li> Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据 。</li>
</ol>
<h3 id="2-工作模式"><a href="#2-工作模式" class="headerlink" title="2. 工作模式"></a>2. 工作模式</h3><p>有7种工作模式：  <a href="https://www.rabbitmq.com/getstarted.html">RabbitMQ Tutorials — RabbitMQ</a> </p>
<img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1669996563784.png" class width="1669996563784">

<img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1669996575608.png" class width="1669996575608">



<img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1669996588314.png" class width="1669996588314">

<h3 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello World"></a>2. Hello World</h3><p>最简单工作方式，生产者消费者模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, <span class="string">&quot;hello rabbitMq&quot;</span>.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息.........&quot;</span>);</span><br><span class="line">        <span class="comment">//推送的消息如何进行消费的接口回调</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class="line">        CancelCallback cancelCallback = (consumerTag) -&gt; System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(Producer.QUEUE_NAME, deliverCallback, cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-Work-Queues"><a href="#3-Work-Queues" class="headerlink" title="3. Work Queues"></a>3. Work Queues</h3><p> 工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p>
<p>多个消费者，轮询分发消息。</p>
<h3 id="4-消息应答"><a href="#4-消息应答" class="headerlink" title="4. 消息应答"></a>4. 消息应答</h3><p> 消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成 了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消 息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续 发送给该消费这的消息，因为它无法接收到。 </p>
<p>为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是:<strong>消费者在接收 到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong> </p>
<h4 id="1-自动应答"><a href="#1-自动应答" class="headerlink" title="1. 自动应答"></a>1. 自动应答</h4><p> 消息发送后立即被认为已经传送成功，这种模式需要在**高吞吐量和数据传输安全性方面做权 衡,**因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当 然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使 得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用 </p>
<ul>
<li>Channel.basicAck(用于肯定确认)  RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了 、</li>
<li>Channel.basicNack(用于否定确认)  </li>
<li>Channel.basicReject(用于否定确认)  与 Channel.basicNack 相比少一个参数 不处理该消息了直接拒绝，可以将其丢弃了 </li>
</ul>
<h4 id="2-手动应答"><a href="#2-手动应答" class="headerlink" title="2.  手动应答"></a>2.  手动应答</h4><img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1670069711106.png" class width="1670069711106">



<h3 id="5-RabbitMQ持久化"><a href="#5-RabbitMQ持久化" class="headerlink" title="5. RabbitMQ持久化"></a>5. RabbitMQ持久化</h3><p>队列持久化： 要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化。 但是需要注意的就是如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新 创建一个持久化的队列，不然就会出现错误。</p>
<p>消息持久化： 要想让消息实现持久化需要在消息生产者修改代码MessageProperties.PERSISTENT_TEXT_PLAIN 添 加这个属性。 </p>
<p> 将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是 这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。 </p>
<h3 id="6-多劳多得，不公平分发"><a href="#6-多劳多得，不公平分发" class="headerlink" title="6. 多劳多得，不公平分发"></a>6. 多劳多得，不公平分发</h3><p> RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是 很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间 处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好。</p>
<p> 为了避免这种情况，我们可以设置参数 channel.basicQos(1) .</p>
<img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1670070012710.png" class width="1670070012710">

<p>消费者代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QoSConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;qos_queue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次消费一条数据</span></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自动ack关闭</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;qos_queue&quot;</span>,<span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;receive a message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 手动ack</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QosProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;qos_queue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;qos_queue&quot;</span>, <span class="keyword">null</span>, (<span class="string">&quot;message&quot;</span> + i).getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。 </p>
<h3 id="8-发布确认机制"><a href="#8-发布确认机制" class="headerlink" title="8. 发布确认机制"></a>8. 发布确认机制</h3><p> 生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消 息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会 发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了， 如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产 者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。 </p>
<p> confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道 返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方 法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息 </p>
<h4 id="单个确认机制"><a href="#单个确认机制" class="headerlink" title="单个确认机制"></a>单个确认机制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hlz.rabbit.mq.confirm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hlz.rabbit.mq.util.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单个确认发布缺点： 发布速度特别的慢，因为如果没有确认发布的消息就会</span></span><br><span class="line"><span class="comment"> * 阻塞所有后续消息的发布</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-28 23:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PubModConfirmProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开启发布确认</span></span><br><span class="line">            channel.confirmSelect();</span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;queue-pub-confirm&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;confirm&quot;</span> + i;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;queue-pub-confirm&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">                <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息：&quot;</span> + message + <span class="string">&quot;发送成功..&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;发布200个单独确认消息,耗时&quot;</span> + (end - start) +</span><br><span class="line">                    <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> waitForConfirmsOrDie(long)这个方法只有在消息被确认 的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p>
<p> 缺点就是: 发布速度特别的慢，因为如果没有确认发布的消息就会 阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某 些应用程序来说这可能已经足够了。 </p>
<h4 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hlz.rabbit.mq.confirm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hlz.rabbit.mq.util.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量确认发布</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-28 23:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PubModConfirmBatchProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 开启发布确认</span></span><br><span class="line">            channel.confirmSelect();</span><br><span class="line">            <span class="comment">//批量确认消息大小</span></span><br><span class="line">            <span class="keyword">int</span> batchSize = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">//未确认消息个数</span></span><br><span class="line">            <span class="keyword">int</span> outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;queue-pub-confirm&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;confirm&quot;</span> + i;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;queue-pub-confirm&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">                outstandingMessageCount++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">                    channel.waitForConfirms();</span><br><span class="line">                    outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line">            <span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                channel.waitForConfirms();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;发布 200个批量确认消息,耗时&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="异步发布确认"><a href="#异步发布确认" class="headerlink" title="异步发布确认"></a>异步发布确认</h4><img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1670070275111.png" class width="1670070275111">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hlz.rabbit.mq.confirm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hlz.rabbit.mq.util.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConfirmCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentNavigableMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步确认发布</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-28 23:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PubModConfirmAsyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 开启发布确认</span></span><br><span class="line">            channel.confirmSelect();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 线程安全有序的一个哈希表，适用于高并发的情况</span></span><br><span class="line"><span class="comment">             * 1.轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">             * 2.轻松批量删除条目 只要给到序列号</span></span><br><span class="line"><span class="comment">             * 3.支持并发访问</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ConcurrentSkipListMap&lt;Long, String&gt; outStandingConfirm = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            确认收到消息的一个回调</span></span><br><span class="line"><span class="comment">            1. 消息序列号</span></span><br><span class="line"><span class="comment">            2. true可以确认小于等于当前序列号的消息</span></span><br><span class="line"><span class="comment">            false表示确认当前序列号</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ConfirmCallback confirmCallback = <span class="keyword">new</span> ConfirmCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                        <span class="comment">//返回的是小于等于当前序列号的未确认消息，是一个 map</span></span><br><span class="line">                        ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outStandingConfirm.headMap(deliveryTag, <span class="keyword">true</span>);</span><br><span class="line">                        <span class="comment">// 清除该部分</span></span><br><span class="line">                        confirmed.clear();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 只清除当前序列号的消息</span></span><br><span class="line">                        outStandingConfirm.remove(deliveryTag);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            ConfirmCallback nackCallBack = <span class="keyword">new</span> ConfirmCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    String message = outStandingConfirm.get(deliveryTag);</span><br><span class="line">                    System.out.println(<span class="string">&quot;发布的消息&quot;</span> + message + <span class="string">&quot;未被确认， 序列号为：&quot;</span> + deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加异步确认的监听器</span></span><br><span class="line">            channel.addConfirmListener(confirmCallback, nackCallBack);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;queue-pub-confirm&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;confirm-async&quot;</span> + i;</span><br><span class="line">                outStandingConfirm.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;queue-pub-confirm&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//异步发布确认的方式：发布 200个消息,耗时15ms ，性能最好！</span></span><br><span class="line">            System.out.println(<span class="string">&quot;异步发布确认的方式：发布 200个消息,耗时&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="9-交换机"><a href="#9-交换机" class="headerlink" title="9. 交换机"></a>9. 交换机</h3><p> RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。 </p>
<p> 生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来 自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消 息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。 </p>
<img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1670070563948.png" class width="1670070563948">

<h4 id="1-交换机的类型"><a href="#1-交换机的类型" class="headerlink" title="1. 交换机的类型"></a>1. 交换机的类型</h4><p> 直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout) </p>
<h4 id="2-无名交换机"><a href="#2-无名交换机" class="headerlink" title="2. 无名交换机"></a>2. 无名交换机</h4><p> 空字符串表示默认或无名称交换机：消息能路由发送到队列中其实 是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话 。</p>
<h4 id="3-队列绑定bindings"><a href="#3-队列绑定bindings" class="headerlink" title="3. 队列绑定bindings"></a>3. 队列绑定bindings</h4><p> 什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队 列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定。</p>
<img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1670071444693.png" class width="1670071444693">

<p> 队列只对它绑定的交换机的消息感兴趣。绑定用参数：routingKey 来表示，也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);绑定之后的 意义由其交换类型决定。 </p>
<h4 id="4-fanout"><a href="#4-fanout" class="headerlink" title="4. fanout"></a>4. fanout</h4><p> Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些 exchange 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  定义交换机</span></span><br><span class="line">            channel.exchangeDeclare(<span class="string">&quot;test-fanout&quot;</span>, BuiltinExchangeType.FANOUT);</span><br><span class="line">            <span class="comment">// 定义队列</span></span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;test-fanout-queue1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;test-fanout-queue2&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 队列绑定交换机</span></span><br><span class="line">            channel.queueBind(<span class="string">&quot;test-fanout-queue1&quot;</span>, <span class="string">&quot;test-fanout&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            channel.queueBind(<span class="string">&quot;test-fanout-queue2&quot;</span>, <span class="string">&quot;test-fanout&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            RabbitMqUtils.console(channel, <span class="string">&quot;test-fanout&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-Direct-exchange"><a href="#5-Direct-exchange" class="headerlink" title="5. Direct exchange"></a>5. Direct exchange</h4><img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1670071654723.png" class width="1670071654723">

<p> 在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green. 在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 black和green 的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。 </p>
<img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1670071706465.png" class width="1670071706465">

<p>如上图，如果 exchange 的绑定类型是direct，但是它绑定的多个队列的 key 如果都相同，在这种情 况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了 </p>
<h4 id="6-Topics"><a href="#6-Topics" class="headerlink" title="6.  Topics"></a>6.  Topics</h4><p> 发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单 词列表，以点号分隔开。这些单词可以是任意单词，比如说：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。</p>
<ul>
<li><p>*(星号)可以代替一个单词 </p>
</li>
<li><p>#(井号)可以替代零个或多个单词  </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hlz.rabbit.mq.topic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hlz.rabbit.mq.util.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *(星号)可以代替一个单词</span></span><br><span class="line"><span class="comment"> #(井号)可以替代零个或多个单词</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了</span></span><br><span class="line"><span class="comment"> * 如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-21 20:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义交换机</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;my-topic&quot;</span>, BuiltinExchangeType.TOPIC, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test-queue1&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test-queue2&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test-queue3&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列绑定</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;test-queue1&quot;</span>, <span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;#.order.error&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;test-queue2&quot;</span>, <span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;#.error&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;test-queue3&quot;</span>, <span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;*.info.*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;test.order.error&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;test.order.error == &gt;order订单日志，级别为error&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;hi.test.order.error&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;hi.test.order.error == &gt; order订单日志，级别为error&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;test.info.apple&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;test.info.apple == &gt;info日志&quot;</span>.getBytes());</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;test.error&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;test.info.apple == &gt;info日志&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        RabbitMqUtils.console(channel, <span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;test.order.error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了 </li>
<li>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了 </li>
</ol>
<h3 id="10-死信队列"><a href="#10-死信队列" class="headerlink" title="10. 死信队列"></a>10. 死信队列</h3><p> 死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有 后续的处理，就变成了死信，有死信自然就有了死信队列。 </p>
<h4 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h4><p> 为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说: 用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p>
<h4 id="2-死信来源"><a href="#2-死信来源" class="headerlink" title="2. 死信来源"></a>2. 死信来源</h4><ul>
<li>消息 TTL 过期 </li>
<li>队列达到最大长度(队列满了，无法再添加数据到 mq 中) </li>
<li>消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false </li>
</ul>
<h4 id="3-死信实战"><a href="#3-死信实战" class="headerlink" title="3. 死信实战"></a>3. 死信实战</h4><img src="/2022/12/03/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-RabbitMQ/1670071942516.png" class width="1670071942516">

<p>生产者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hlz.rabbit.mq.dead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hlz.rabbit.mq.util.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列生产者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-21 22:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Channel channel = RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">            channel.exchangeDeclare(<span class="string">&quot;normal_exchange&quot;</span>, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 死信交换机</span></span><br><span class="line">            channel.exchangeDeclare(<span class="string">&quot;dead-exchange&quot;</span>, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明死信队列</span></span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;dead-queue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 死信队列绑定死信交换机</span></span><br><span class="line">            channel.queueBind(<span class="string">&quot;dead-queue&quot;</span>, <span class="string">&quot;dead-exchange&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常队列绑定死信队列信息</span></span><br><span class="line">            Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// 正常队列设置死信交换机</span></span><br><span class="line">            params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dead-exchange&quot;</span>);</span><br><span class="line">            <span class="comment">//正常队列设置死信 routing-key</span></span><br><span class="line">            params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置队列长度限制</span></span><br><span class="line">            params.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明正常队列</span></span><br><span class="line">            String normalQueue = <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">            channel.queueDeclare(normalQueue, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, params);</span><br><span class="line">            channel.queueBind(normalQueue, <span class="string">&quot;normal_exchange&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置消息的ttl时间</span></span><br><span class="line"><span class="comment">//            AMQP.BasicProperties basicProperties = new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                String message = <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;normal_exchange&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hlz.rabbit.mq.dead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hlz.rabbit.mq.util.RabbitMqUtils;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死信队列生产者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-21 22:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadConsumer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Channel channel = RabbitMqUtils.getChannel();</span><br><span class="line">            channel.exchangeDeclare(<span class="string">&quot;dead-exchange&quot;</span>, BuiltinExchangeType.DIRECT);</span><br><span class="line">            System.out.println(<span class="string">&quot;等待接收死信队列消息........... &quot;</span>);</span><br><span class="line">            channel.basicConsume(<span class="string">&quot;dead-queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DeliverCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String consumerTag, Delivery message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    String data = <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    System.out.println(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> CancelCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String consumerTag)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="11-延时队列"><a href="#11-延时队列" class="headerlink" title="11. 延时队列"></a>11. 延时队列</h3><p> 延时队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。</p>
<h4 id="1-应用场景-1"><a href="#1-应用场景-1" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h4><ol>
<li>订单在十分钟之内未支付则自动取消 </li>
<li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。 </li>
<li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li>
<li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li>
<li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议 。</li>
</ol>
<h4 id="2-TTL"><a href="#2-TTL" class="headerlink" title="2. TTL"></a>2. TTL</h4><p> TTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有 消息的最大存活时间。 Time To Live。 单位是毫秒。换句话说，如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这 条消息如果在TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。  </p>
<p>消息设置TTL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message, message1 -&gt; &#123;</span><br><span class="line">           message1.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">           <span class="keyword">return</span> message1;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<p>队列设置TTL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line"> QueueBuilder.durable(Queue_B).withArguments(args).build();</span><br></pre></td></tr></table></figure>

<p> 如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队 列中)，而消息设置TTL方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者 之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，还需 要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以 直接投递该消息到消费者，否则该消息将会被丢弃。 </p>
<h4 id="3-延时队列实现"><a href="#3-延时队列实现" class="headerlink" title="3. 延时队列实现"></a>3. 延时队列实现</h4><p><a href="https://gitee.com/hongliangzhu/mid-mq/tree/master/springboot-rabbitmq-producer/src/main/java/com/hlz/mid/mq/producer/ttl">https://gitee.com/hongliangzhu/mid-mq/tree/master/springboot-rabbitmq-producer/src/main/java/com/hlz/mid/mq/producer/ttl</a></p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>mq</tag>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty-优化与源码分析</title>
    <url>/2022/12/03/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="四-优化与源码"><a href="#四-优化与源码" class="headerlink" title="四. 优化与源码"></a>四. 优化与源码</h1><h2 id="1-优化"><a href="#1-优化" class="headerlink" title="1. 优化"></a>1. 优化</h2><h3 id="1-1-扩展序列化算法"><a href="#1-1-扩展序列化算法" class="headerlink" title="1.1 扩展序列化算法"></a>1.1 扩展序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上</p>
<ul>
<li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li>
<li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li>
</ul>
<p>目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">byte</span>[] body = <span class="keyword">new</span> <span class="keyword">byte</span>[bodyLength];</span><br><span class="line">byteByf.readBytes(body);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(body));</span><br><span class="line">Message message = (Message) in.readObject();</span><br><span class="line">message.setSequenceId(sequenceId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="keyword">new</span> ObjectOutputStream(out).writeObject(message);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = out.toByteArray();</span><br></pre></td></tr></table></figure>

<p>为了支持更多序列化算法，抽象一个 Serializer 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SerializerAlgorithm</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Java 实现</span></span><br><span class="line">    Java &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ObjectInputStream in = </span><br><span class="line">                    <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">                Object object = in.readObject();</span><br><span class="line">                <span class="keyword">return</span> (T) object;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;SerializerAlgorithm.Java 反序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                <span class="keyword">new</span> ObjectOutputStream(out).writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;SerializerAlgorithm.Java 序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// Json 实现(引入了 Gson 依赖)</span></span><br><span class="line">    Json &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(<span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8), clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Gson().toJson(object).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要从协议的字节中得到是哪种序列化算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SerializerAlgorithm <span class="title">getByInt</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        SerializerAlgorithm[] array = SerializerAlgorithm.values();</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;超过 SerializerAlgorithm 范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[type];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>增加配置类和配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream in = Config.class.getResourceAsStream(<span class="string">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class="line">            properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getServerPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = properties.getProperty(<span class="string">&quot;server.port&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">8080</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Serializer.<span class="function">Algorithm <span class="title">getSerializerAlgorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = properties.getProperty(<span class="string">&quot;serializer.algorithm&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.Java;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.valueOf(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">serializer.algorithm</span>=<span class="string">Json</span></span><br></pre></td></tr></table></figure>



<p>修改编解码器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>, <span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf out = ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(Config.getSerializerAlgorithm().ordinal());</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Config.getSerializerAlgorithm().serialize(msg);</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magicNum = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span> version = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializerAlgorithm = in.readByte(); <span class="comment">// 0 或 1</span></span><br><span class="line">        <span class="keyword">byte</span> messageType = in.readByte(); <span class="comment">// 0,1,2...</span></span><br><span class="line">        <span class="keyword">int</span> sequenceId = in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到反序列化算法</span></span><br><span class="line">        Serializer.Algorithm algorithm = Serializer.Algorithm.values()[serializerAlgorithm];</span><br><span class="line">        <span class="comment">// 确定具体消息类型</span></span><br><span class="line">        Class&lt;? extends Message&gt; messageClass = Message.getMessageClass(messageType);</span><br><span class="line">        Message message = algorithm.deserialize(messageClass, bytes);</span><br><span class="line"><span class="comment">//        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);</span></span><br><span class="line"><span class="comment">//        log.debug(&quot;&#123;&#125;&quot;, message);</span></span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中确定具体消息类型，可以根据 <code>消息类型字节</code> 获取到对应的 <code>消息 class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据消息类型字节，获得对应的消息 class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageType 消息类型字节</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 消息 class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;? extends Message&gt; getMessageClass(<span class="keyword">int</span> messageType) &#123;</span><br><span class="line">        <span class="keyword">return</span> messageClasses.get(messageType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sequenceId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> messageType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LoginRequestMessage = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LoginResponseMessage = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ChatRequestMessage = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ChatResponseMessage = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupCreateRequestMessage = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupCreateResponseMessage = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupJoinRequestMessage = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupJoinResponseMessage = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupQuitRequestMessage = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupQuitResponseMessage = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupChatRequestMessage = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupChatResponseMessage = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupMembersRequestMessage = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupMembersResponseMessage = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PingMessage = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PongMessage = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Class&lt;? extends Message&gt;&gt; messageClasses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);</span><br><span class="line">        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);</span><br><span class="line">        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);</span><br><span class="line">        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-参数调优"><a href="#1-2-参数调优" class="headerlink" title="1.2 参数调优"></a>1.2 参数调优</h3><h4 id="1）CONNECT-TIMEOUT-MILLIS"><a href="#1）CONNECT-TIMEOUT-MILLIS" class="headerlink" title="1）CONNECT_TIMEOUT_MILLIS"></a>1）CONNECT_TIMEOUT_MILLIS</h4><ul>
<li><p>属于 SocketChannal 参数</p>
</li>
<li><p>用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</p>
</li>
<li><p>SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConnectionTimeout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">300</span>)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line">            ChannelFuture future = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            future.sync().channel().closeFuture().sync(); <span class="comment">// 断点1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.debug(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外源码部分 <code>io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Schedule connect timeout.</span></span><br><span class="line">    <span class="keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();</span><br><span class="line">    <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">                ChannelPromise connectPromise = AbstractNioChannel.<span class="keyword">this</span>.connectPromise;</span><br><span class="line">                ConnectTimeoutException cause =</span><br><span class="line">                    <span class="keyword">new</span> ConnectTimeoutException(<span class="string">&quot;connection timed out: &quot;</span> + remoteAddress); <span class="comment">// 断点2</span></span><br><span class="line">                <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                    close(voidPromise());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2）SO-BACKLOG"><a href="#2）SO-BACKLOG" class="headerlink" title="2）SO_BACKLOG"></a>2）SO_BACKLOG</h4><ul>
<li>属于 ServerSocketChannal 参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">participant c as client</span><br><span class="line">participant s as server</span><br><span class="line">participant sq as syns queue</span><br><span class="line">participant aq as accept queue</span><br><span class="line"></span><br><span class="line">s -&gt;&gt; s : bind()</span><br><span class="line">s -&gt;&gt; s : listen()</span><br><span class="line">c -&gt;&gt; c : connect()</span><br><span class="line">c -&gt;&gt; s : 1. SYN</span><br><span class="line">Note left of c : SYN_SEND</span><br><span class="line">s -&gt;&gt; sq : put</span><br><span class="line">Note right of s : SYN_RCVD</span><br><span class="line">s -&gt;&gt; c : 2. SYN + ACK</span><br><span class="line">Note left of c : ESTABLISHED</span><br><span class="line">c -&gt;&gt; s : 3. ACK</span><br><span class="line">sq -&gt;&gt; aq : put</span><br><span class="line">Note right of s : ESTABLISHED</span><br><span class="line">aq --&gt;&gt; s : </span><br><span class="line">s -&gt;&gt; s : accept()</span><br></pre></td></tr></table></figure>

<ol>
<li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li>
<li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li>
<li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue</li>
</ol>
<p>其中</p>
<ul>
<li><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p>
</li>
<li><p>sync queue - 半连接队列</p>
<ul>
<li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li>
</ul>
</li>
<li><p>accept queue - 全连接队列</p>
<ul>
<li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值</li>
<li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li>
</ul>
</li>
</ul>
<p>netty 中</p>
<p>可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置大小</p>
<p>可以通过下面源码查看默认大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServerSocketChannelConfig</span> <span class="keyword">extends</span> <span class="title">DefaultChannelConfig</span></span></span><br><span class="line"><span class="class">                                              <span class="keyword">implements</span> <span class="title">ServerSocketChannelConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> backlog = NetUtil.SOMAXCONN;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>课堂调试关键断点为：<code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>
<p>oio 中更容易说明，不用 debug 模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>, <span class="number">2</span>);</span><br><span class="line">        Socket accept = ss.accept();</span><br><span class="line">        System.out.println(accept);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端启动 4 个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket s = <span class="keyword">new</span> Socket();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date()+<span class="string">&quot; connecting...&quot;</span>);</span><br><span class="line">            s.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>),<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date()+<span class="string">&quot; connected...&quot;</span>);</span><br><span class="line">            s.getOutputStream().write(<span class="number">1</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date()+<span class="string">&quot; connecting timeout...&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tue Apr <span class="number">21</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">28</span> CST <span class="number">2020</span> connecting...</span><br><span class="line">Tue Apr <span class="number">21</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">28</span> CST <span class="number">2020</span> connected...</span><br></pre></td></tr></table></figure>

<p>第 4 个客户端连接时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tue Apr 21 20:53:58 CST 2020 connecting...</span><br><span class="line">Tue Apr 21 20:53:59 CST 2020 connecting timeout...</span><br><span class="line">java.net.SocketTimeoutException: connect timed out</span><br></pre></td></tr></table></figure>





<h4 id="3）ulimit-n"><a href="#3）ulimit-n" class="headerlink" title="3）ulimit -n"></a>3）ulimit -n</h4><ul>
<li>属于操作系统参数</li>
</ul>
<h4 id="4）TCP-NODELAY"><a href="#4）TCP-NODELAY" class="headerlink" title="4）TCP_NODELAY"></a>4）TCP_NODELAY</h4><ul>
<li>属于 SocketChannal 参数</li>
</ul>
<h4 id="5）SO-SNDBUF-amp-SO-RCVBUF"><a href="#5）SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="5）SO_SNDBUF &amp; SO_RCVBUF"></a>5）SO_SNDBUF &amp; SO_RCVBUF</h4><ul>
<li>SO_SNDBUF 属于 SocketChannal 参数</li>
<li>SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）</li>
</ul>
<h4 id="6）ALLOCATOR"><a href="#6）ALLOCATOR" class="headerlink" title="6）ALLOCATOR"></a>6）ALLOCATOR</h4><ul>
<li>属于 SocketChannal 参数</li>
<li>用来分配 ByteBuf， ctx.alloc()</li>
</ul>
<h4 id="7）RCVBUF-ALLOCATOR"><a href="#7）RCVBUF-ALLOCATOR" class="headerlink" title="7）RCVBUF_ALLOCATOR"></a>7）RCVBUF_ALLOCATOR</h4><ul>
<li>属于 SocketChannal 参数</li>
<li>控制 netty 接收缓冲区大小</li>
<li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li>
</ul>
<h3 id="1-3-RPC-框架"><a href="#1-3-RPC-框架" class="headerlink" title="1.3 RPC 框架"></a>1.3 RPC 框架</h3><h4 id="1）准备工作"><a href="#1）准备工作" class="headerlink" title="1）准备工作"></a>1）准备工作</h4><p>这些代码可以认为是现成的，无需从头编写练习</p>
<p>为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略旧的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RPC_MESSAGE_TYPE_REQUEST = <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RPC_MESSAGE_TYPE_RESPONSE = <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);</span><br><span class="line">        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequestMessage</span> <span class="keyword">extends</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用的接口全限定名，服务端根据它找到实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用接口中的方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; returnType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数类型数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class[] parameterTypes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数值数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameterValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcRequestMessage</span><span class="params">(<span class="keyword">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setSequenceId(sequenceId);</span><br><span class="line">        <span class="keyword">this</span>.interfaceName = interfaceName;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">        <span class="keyword">this</span>.returnType = returnType;</span><br><span class="line">        <span class="keyword">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">        <span class="keyword">this</span>.parameterValue = parameterValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RPC_MESSAGE_TYPE_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseMessage</span> <span class="keyword">extends</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object returnValue;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Exception exceptionValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RPC_MESSAGE_TYPE_RESPONSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器架子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// rpc 请求消息处理器，待实现</span></span><br><span class="line">        RpcRequestMessageHandler RPC_HANDLER = <span class="keyword">new</span> RpcRequestMessageHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = serverBootstrap.bind(<span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端架子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// rpc 响应消息处理器，待实现</span></span><br><span class="line">        RpcResponseMessageHandler RPC_HANDLER = <span class="keyword">new</span> RpcResponseMessageHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端的 service 获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServicesFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Object&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream in = Config.class.getResourceAsStream(<span class="string">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class="line">            properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(in);</span><br><span class="line">            Set&lt;String&gt; names = properties.stringPropertyNames();</span><br><span class="line">            <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">                <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;Service&quot;</span>)) &#123;</span><br><span class="line">                    Class&lt;?&gt; interfaceClass = Class.forName(name);</span><br><span class="line">                    Class&lt;?&gt; instanceClass = Class.forName(properties.getProperty(name));</span><br><span class="line">                    map.put(interfaceClass, instanceClass.newInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getService</span><span class="params">(Class&lt;T&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) map.get(interfaceClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关配置 application.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">serializer.algorithm=Json</span><br><span class="line">cn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl</span><br></pre></td></tr></table></figure>



<h4 id="2）服务器-handler"><a href="#2）服务器-handler" class="headerlink" title="2）服务器 handler"></a>2）服务器 handler</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequestMessage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequestMessage message)</span> </span>&#123;</span><br><span class="line">        RpcResponseMessage response = <span class="keyword">new</span> RpcResponseMessage();</span><br><span class="line">        response.setSequenceId(message.getSequenceId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取真正的实现对象</span></span><br><span class="line">            HelloService service = (HelloService)</span><br><span class="line">                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取要调用的方法</span></span><br><span class="line">            Method method = service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用方法</span></span><br><span class="line">            Object invoke = method.invoke(service, message.getParameterValue());</span><br><span class="line">            <span class="comment">// 调用成功</span></span><br><span class="line">            response.setReturnValue(invoke);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 调用异常</span></span><br><span class="line">            response.setExceptionValue(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="3）客户端代码第一版"><a href="#3）客户端代码第一版" class="headerlink" title="3）客户端代码第一版"></a>3）客户端代码第一版</h4><p>只发消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        RpcResponseMessageHandler RPC_HANDLER = <span class="keyword">new</span> RpcResponseMessageHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = channel.writeAndFlush(<span class="keyword">new</span> RpcRequestMessage(</span><br><span class="line">                    <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&quot;cn.itcast.server.service.HelloService&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;sayHello&quot;</span>,</span><br><span class="line">                    String.class,</span><br><span class="line">                    <span class="keyword">new</span> Class[]&#123;String.class&#125;,</span><br><span class="line">                    <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;张三&quot;</span>&#125;</span><br><span class="line">            )).addListener(promise -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (!promise.isSuccess()) &#123;</span><br><span class="line">                    Throwable cause = promise.cause();</span><br><span class="line">                    log.error(<span class="string">&quot;error&quot;</span>, cause);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4）客户端-handler-第一版"><a href="#4）客户端-handler-第一版" class="headerlink" title="4）客户端 handler 第一版"></a>4）客户端 handler 第一版</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponseMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="5）客户端代码-第二版"><a href="#5）客户端代码-第二版" class="headerlink" title="5）客户端代码 第二版"></a>5）客户端代码 第二版</h4><p>包括 channel 管理，代理，接收结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService service = getProxyService(HelloService.class);</span><br><span class="line">        System.out.println(service.sayHello(<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line"><span class="comment">//        System.out.println(service.sayHello(&quot;lisi&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(service.sayHello(&quot;wangwu&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxyService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = serviceClass.getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = <span class="keyword">new</span> Class[]&#123;serviceClass&#125;;</span><br><span class="line">        <span class="comment">//                                                            sayHello  &quot;张三&quot;</span></span><br><span class="line">        Object o = Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1. 将方法调用转换为 消息对象</span></span><br><span class="line">            <span class="keyword">int</span> sequenceId = SequenceIdGenerator.nextId();</span><br><span class="line">            RpcRequestMessage msg = <span class="keyword">new</span> RpcRequestMessage(</span><br><span class="line">                    sequenceId,</span><br><span class="line">                    serviceClass.getName(),</span><br><span class="line">                    method.getName(),</span><br><span class="line">                    method.getReturnType(),</span><br><span class="line">                    method.getParameterTypes(),</span><br><span class="line">                    args</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// 2. 将消息对象发送出去</span></span><br><span class="line">            getChannel().writeAndFlush(msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 准备一个空 Promise 对象，来接收结果             指定 promise 对象异步接收结果线程</span></span><br><span class="line">            DefaultPromise&lt;Object&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(getChannel().eventLoop());</span><br><span class="line">            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            promise.addListener(future -&gt; &#123;</span></span><br><span class="line"><span class="comment">//                // 线程</span></span><br><span class="line"><span class="comment">//            &#125;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 等待 promise 结果</span></span><br><span class="line">            promise.await();</span><br><span class="line">            <span class="keyword">if</span>(promise.isSuccess()) &#123;</span><br><span class="line">                <span class="comment">// 调用正常</span></span><br><span class="line">                <span class="keyword">return</span> promise.getNow();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 调用失败</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(promise.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (T) o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取唯一的 channel 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123; <span class="comment">//  t2</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125;</span><br><span class="line">            initChannel();</span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 channel 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        RpcResponseMessageHandler RPC_HANDLER = <span class="keyword">new</span> RpcResponseMessageHandler();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">        bootstrap.group(group);</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line">                ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6）客户端-handler-第二版"><a href="#6）客户端-handler-第二版" class="headerlink" title="6）客户端 handler 第二版"></a>6）客户端 handler 第二版</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponseMessage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//                       序号      用来接收结果的 promise 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; PROMISES = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        <span class="comment">// 拿到空的 promise</span></span><br><span class="line">        Promise&lt;Object&gt; promise = PROMISES.remove(msg.getSequenceId());</span><br><span class="line">        <span class="keyword">if</span> (promise != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object returnValue = msg.getReturnValue();</span><br><span class="line">            Exception exceptionValue = msg.getExceptionValue();</span><br><span class="line">            <span class="keyword">if</span>(exceptionValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                promise.setFailure(exceptionValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setSuccess(returnValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><h3 id="2-1-启动剖析"><a href="#2-1-启动剖析" class="headerlink" title="2.1 启动剖析"></a>2.1 启动剖析</h3><p>我们就来看看 netty 中对下面的代码是怎样进行处理的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span></span><br><span class="line">Selector selector = Selector.open(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span></span><br><span class="line">NioServerSocketChannel attachment = <span class="keyword">new</span> NioServerSocketChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); </span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 启动 nio boss 线程执行接下来的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span></span><br><span class="line">SelectionKey selectionKey = serverSocketChannel.register(selector, <span class="number">0</span>, attachment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6 head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7 绑定端口</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//8 触发 channel active 事件，在 head 中关注 op_accept 事件</span></span><br><span class="line">selectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>







<p>入口 <code>io.netty.bootstrap.ServerBootstrap#bind</code></p>
<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分</span></span><br><span class="line">    <span class="comment">// 2.1 如果已经完成</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        <span class="comment">// 3.1 立刻调用 doBind0</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 2.2 还没有完成</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        <span class="comment">// 3.2 回调 doBind0</span></span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 处理异常...</span></span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">					<span class="comment">// 3. 由注册线程去执行 doBind0</span></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#initAndRegister</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 处理异常...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理异常...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap#init</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里 channel 实际上是 NioServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 为 NioServerSocketChannel 添加初始化器</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一些检查，略...</span></span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行</span></span><br><span class="line">            <span class="comment">// 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程</span></span><br><span class="line">            <span class="comment">// 这行代码完成的事实是 main -&gt; nio boss 线程的切换</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 日志记录...</span></span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        <span class="comment">// 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel</span></span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对应 server socket channel 还未绑定，isActive 为 false</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Close the channel directly to avoid FD leak.</span></span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码 <code>io.netty.channel.ChannelInitializer#initChannel</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.add(ctx)) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2.2.1 执行初始化</span></span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2.2.2 移除初始化器</span></span><br><span class="line">            ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.1 或 3.2 执行 doBind0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</span><br><span class="line">        localAddress <span class="keyword">instanceof</span> InetSocketAddress &amp;&amp;</span><br><span class="line">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</span><br><span class="line">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</span><br><span class="line">        <span class="comment">// 记录日志...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3.3 执行端口绑定</span></span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 3.4 触发 active 事件</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.3 关键代码 <code>io.netty.channel.socket.nio.NioServerSocketChannel#doBind</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.4 关键代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">	<span class="comment">// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码 <code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="comment">// readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-NioEventLoop-剖析"><a href="#2-2-NioEventLoop-剖析" class="headerlink" title="2.2 NioEventLoop 剖析"></a>2.2 NioEventLoop 剖析</h3><p>NioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），</p>
<p>提交任务代码 <code>io.netty.util.concurrent.SingleThreadEventExecutor#execute</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="comment">// 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        <span class="comment">// inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread</span></span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">            <span class="comment">// 如果已经 shutdown，做拒绝逻辑，代码略...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        <span class="comment">// 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程</span></span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>唤醒 select 阻塞线程<code>io.netty.channel.nio.NioEventLoop#wakeup</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">(<span class="keyword">boolean</span> inEventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>启动 EventLoop 主循环 <code>io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 将线程池的当前线程保存在成员变量中，以便后续使用</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// 清理工作，代码略...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>io.netty.channel.nio.NioEventLoop#run</code> 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// calculateStrategy 的逻辑如下：</span></span><br><span class="line">                <span class="comment">// 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch</span></span><br><span class="line">                <span class="comment">// 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞</span></span><br><span class="line">                <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                        <span class="comment">// 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒</span></span><br><span class="line">                        <span class="comment">// 进行 select 阻塞，并设置唤醒状态为 false</span></span><br><span class="line">                        <span class="keyword">boolean</span> oldWakenUp = wakenUp.getAndSet(<span class="keyword">false</span>);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup</span></span><br><span class="line">                        <span class="comment">// 下面的 select 方法不会阻塞</span></span><br><span class="line">                        <span class="comment">// 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?</span></span><br><span class="line">                        <span class="comment">// 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时</span></span><br><span class="line">                        <span class="comment">// 才能执行，让 select 方法无谓阻塞</span></span><br><span class="line">                        select(oldWakenUp);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                            selector.wakeup();</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                rebuildSelector0();</span><br><span class="line">                handleLoopException(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// ioRatio 默认是 50</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// ioRatio 为 100 时，总是运行完所有非 IO 任务</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                </span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 记录 io 事件处理耗时</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                    <span class="comment">// 运行非 IO 任务，一旦超时会退出 runAllTasks</span></span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="⚠️-注意"><a href="#⚠️-注意" class="headerlink" title="⚠️ 注意"></a>⚠️ 注意</h4><blockquote>
<p>这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：</p>
<ul>
<li>由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程</li>
<li>由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作</li>
</ul>
</blockquote>
<p>参考下图</p>
<img src="/2022/12/03/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/0032.png" class>



<p><code>io.netty.channel.nio.NioEventLoop#select</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">        <span class="comment">// 计算等待时间</span></span><br><span class="line">        <span class="comment">// * 没有 scheduledTask，超时时间为 1s</span></span><br><span class="line">        <span class="comment">// * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`</span></span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="comment">// 如果超时，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行</span></span><br><span class="line">            <span class="comment">// wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup</span></span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// select 有限时阻塞</span></span><br><span class="line">            <span class="comment">// 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%</span></span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            <span class="comment">// 计数加 1</span></span><br><span class="line">            selectCnt ++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">               	<span class="comment">// 线程被打断，退出循环</span></span><br><span class="line">                <span class="comment">// 记录日志</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                <span class="comment">// 如果超时，计数重置为 1，下次循环就会 break</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512</span></span><br><span class="line">            <span class="comment">// 这是为了解决 nio 空轮询 bug</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                <span class="comment">// 重建 selector</span></span><br><span class="line">                selector = selectRebuildSelector(selectCnt);</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>处理 keys <code>io.netty.channel.nio.NioEventLoop#processSelectedKeys</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet </span></span><br><span class="line">        <span class="comment">// SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）</span></span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="comment">// 当 key 取消或关闭时会导致这个 key 无效</span></span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">        <span class="comment">// 无效时处理...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        <span class="comment">// 连接事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可写事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可读或可接入事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</span></span><br><span class="line">            <span class="comment">// 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</span></span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-accept-剖析"><a href="#2-3-accept-剖析" class="headerlink" title="2.3 accept 剖析"></a>2.3 accept 剖析</h3><p>nio 中如下代码，在 netty 中的流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 阻塞直到事件发生</span></span><br><span class="line">selector.select();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;    </span><br><span class="line">    <span class="comment">//2 拿到一个事件</span></span><br><span class="line">    SelectionKey key = iter.next();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3 如果是 accept 事件</span></span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4 执行 accept</span></span><br><span class="line">        SocketChannel channel = serverSocketChannel.accept();</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5 关注 read 事件</span></span><br><span class="line">        channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>先来看可接入事件处理（accept）</p>
<p><code>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();    </span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">				<span class="comment">// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf</span></span><br><span class="line">                <span class="comment">// readBuf 是一个 ArrayList 用来缓存消息</span></span><br><span class="line">                <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">                <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    closed = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// localRead 为 1，就一条消息，即接收一个客户端连接</span></span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            exception = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理</span></span><br><span class="line">            <span class="comment">// io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</span></span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        readBuf.clear();</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closed = closeOnReadError(exception);</span><br><span class="line"></span><br><span class="line">            pipeline.fireExceptionCaught(exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">                close(voidPromise());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这时的 msg 是 NioSocketChannel</span></span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NioSocketChannel 添加  childHandler 即初始化器</span></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置选项</span></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程</span></span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>又回到了熟悉的 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code>  方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一些检查，略...</span></span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这行代码完成的事实是 nio boss -&gt; nio worker 线程的切换</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 日志记录...</span></span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        <span class="comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span></span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                <span class="comment">// 触发 pipeline 上 active 事件</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>回到了熟悉的代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">	<span class="comment">// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line">	<span class="comment">// 这时候 interestOps 是 0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 关注 read 事件</span></span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-read-剖析"><a href="#2-4-read-剖析" class="headerlink" title="2.4 read 剖析"></a>2.4 read 剖析</h3><p>再来看可读事件 <code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class="line">        clearReadPending();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="comment">// io.netty.allocator.type 决定 allocator 的实现</span></span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="comment">// 用来分配 byteBuf，确定单次读取大小</span></span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            <span class="comment">// 读取</span></span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">            <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuf.release();</span><br><span class="line">                byteBuf = <span class="keyword">null</span>;</span><br><span class="line">                close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                    readPending = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler</span></span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = <span class="keyword">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 是否要继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        <span class="comment">// 触发 read complete 事件</span></span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">continueReading</span><span class="params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">           <span class="comment">// 一般为 true</span></span><br><span class="line">           config.isAutoRead() &amp;&amp;</span><br><span class="line">           <span class="comment">// respectMaybeMoreData 默认为 true</span></span><br><span class="line">           <span class="comment">// maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true</span></span><br><span class="line">           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;</span><br><span class="line">           <span class="comment">// 小于最大次数，maxMessagePerRead 默认 16</span></span><br><span class="line">           totalMessages &lt; maxMessagePerRead &amp;&amp;</span><br><span class="line">           <span class="comment">// 实际读到了数据</span></span><br><span class="line">           totalBytesRead &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty 进阶</title>
    <url>/2022/12/03/Netty03-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="三-Netty-进阶"><a href="#三-Netty-进阶" class="headerlink" title="三. Netty 进阶"></a>三. Netty 进阶</h1><h2 id="1-粘包与半包"><a href="#1-粘包与半包" class="headerlink" title="1. 粘包与半包"></a>1. 粘包与半包</h2><h3 id="1-1-粘包现象"><a href="#1-1-粘包现象" class="headerlink" title="1.1 粘包现象"></a>1.1 粘包现象</h3><p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldServer.class);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            log.debug(<span class="string">&quot;stoped&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HelloWorldServer().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码希望发送 10 个消息，每个消息是 16 字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">                            <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">                                buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                                ctx.writeAndFlush(buffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...</span><br><span class="line">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE</span><br></pre></td></tr></table></figure>



<h3 id="1-2-半包现象"><a href="#1-2-半包现象" class="headerlink" title="1.2 半包现象"></a>1.2 半包现象</h3><p>客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ctx.writeAndFlush(buffer);</span><br></pre></td></tr></table></figure>

<p>为现象明显，服务端修改一下接收缓冲区，其它代码不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...</span><br><span class="line">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000010| 00 01 02 03                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍</p>
</blockquote>
<h3 id="1-3-现象分析"><a href="#1-3-现象分析" class="headerlink" title="1.3 现象分析"></a>1.3 现象分析</h3><p>粘包</p>
<ul>
<li>现象，发送 abc def，接收 abcdef</li>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包</li>
</ul>
</li>
</ul>
<p>半包</p>
<ul>
<li>现象，发送 abcdef，接收 abc def</li>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 小于实际发送数据量</li>
<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>
<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
<p>本质是因为 TCP 是流式协议，消息无边界</p>
<blockquote>
<p>滑动窗口</p>
<ul>
<li><p>TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</p>
<img src="/2022/12/03/Netty03-%E8%BF%9B%E9%98%B6/0049.png" class></li>
</ul>
<ul>
<li><p>为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</p>
<img src="/2022/12/03/Netty03-%E8%BF%9B%E9%98%B6/0051.png" class></li>
<li><p>窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用</p>
<ul>
<li>图中深色的部分即要发送的数据，高亮的部分即窗口</li>
<li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li>
<li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li>
<li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p> MSS 限制</p>
<ul>
<li><p>链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如</p>
</li>
<li><p>以太网的 MTU 是 1500</p>
</li>
<li><p>FDDI（光纤分布式数据接口）的 MTU 是 4352</p>
</li>
<li><p>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</p>
</li>
<li><p>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</p>
</li>
<li><p>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460</p>
</li>
<li><p>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</p>
</li>
<li><p>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS</p>
</li>
</ul>
</blockquote>
<img src="/2022/12/03/Netty03-%E8%BF%9B%E9%98%B6/0031.jpg" class>

<blockquote>
<p>Nagle 算法</p>
<ul>
<li>即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由</li>
<li>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送<ul>
<li>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</li>
<li>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</li>
<li>如果 TCP_NODELAY = true，则需要发送</li>
<li>已发送的数据都收到 ack 时，则需要发送</li>
<li>上述条件不满足，但发生超时（一般为 200ms）则需要发送</li>
<li>除上述情况，延迟发送</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="1-4-解决方案"><a href="#1-4-解决方案" class="headerlink" title="1.4 解决方案"></a>1.4 解决方案</h3><ol>
<li>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</li>
<li>每一条消息采用固定长度，缺点浪费空间</li>
<li>每一条消息采用分隔符，例如 \n，缺点需要转义</li>
<li>每一条消息分为 head 和 body，head 中包含 body 的长度</li>
</ol>
<h4 id="方法1，短链接"><a href="#方法1，短链接" class="headerlink" title="方法1，短链接"></a>方法1，短链接</h4><p>以解决粘包为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;conneted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">                            buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                            <span class="comment">// 发完即关</span></span><br><span class="line">                            ctx.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出，略</p>
<blockquote>
<p>半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的</p>
</blockquote>
<h4 id="方法2，固定长度"><a href="#方法2，固定长度" class="headerlink" title="方法2，固定长度"></a>方法2，固定长度</h4><p>让所有数据包长度固定（假设长度为 8 字节），服务器端加入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<p>客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="comment">// 发送内容随机的数据包</span></span><br><span class="line">                            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">                            <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r.nextInt(<span class="number">8</span>); j++) &#123;</span><br><span class="line">                                    bytes[j] = (<span class="keyword">byte</span>) c;</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                                buffer.writeBytes(bytes);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|</span><br><span class="line">|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|</span><br><span class="line">|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|</span><br><span class="line">|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|</span><br><span class="line">|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>

<p>服务端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...</span><br><span class="line">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 00 00 00 00 00 00 00                         |b.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 00 00 00 00 00 00                         |cc......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 00 00 00 00 00 00 00                         |d.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 00 00 00 00 00                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 00 00 00 00 00 00 00                         |h.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE</span><br></pre></td></tr></table></figure>

<p>缺点是，数据包的大小不好把握</p>
<ul>
<li>长度定的太大，浪费</li>
<li>长度定的太小，对某些数据包又显得不够</li>
</ul>
<h4 id="方法3，固定分隔符"><a href="#方法3，固定分隔符" class="headerlink" title="方法3，固定分隔符"></a>方法3，固定分隔符</h4><p>服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LineBasedFrameDecoder(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure>

<p>客户端在每条消息之后，加入 \n 分隔符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">                            <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= r.nextInt(<span class="number">16</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="keyword">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                buffer.writeByte(<span class="number">10</span>);</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|</span><br><span class="line">|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|</span><br><span class="line">|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|</span><br><span class="line">|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>



<p>服务端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61                                              |a               |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 62 62                                        |bbb             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 63                                        |ccc             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 64                                           |dd              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66                                           |ff              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67 67 67 67 67 67                            |ggggggg         |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 68 68 68                                     |hhhh            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE</span><br></pre></td></tr></table></figure>

<p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p>
<h4 id="方法4，预设长度"><a href="#方法4，预设长度" class="headerlink" title="方法4，预设长度"></a>方法4，预设长度</h4><p>在发送消息前，先约定用定长字节表示接下来数据的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">                            <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="keyword">byte</span> length = (<span class="keyword">byte</span>) (r.nextInt(<span class="number">16</span>) + <span class="number">1</span>);</span><br><span class="line">                                <span class="comment">// 先写入长度</span></span><br><span class="line">                                buffer.writeByte(length);</span><br><span class="line">                                <span class="comment">// 再</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= length; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="keyword">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>客户端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|</span><br><span class="line">|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|</span><br><span class="line">|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|</span><br><span class="line">|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|</span><br><span class="line">|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|</span><br><span class="line">|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|</span><br><span class="line">|00000060| 6a                                              |j               |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>



<p>服务端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...</span><br><span class="line">14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 63 63 63 63                               |cccccc          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67                                           |gg              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 68                                           |hh              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-协议设计与解析"><a href="#2-协议设计与解析" class="headerlink" title="2. 协议设计与解析"></a>2. 协议设计与解析</h2><h3 id="2-1-为什么需要协议？"><a href="#2-1-为什么需要协议？" class="headerlink" title="2.1 为什么需要协议？"></a>2.1 为什么需要协议？</h3><p>TCP/IP 中消息传输基于流的方式，没有边界。</p>
<p>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</p>
<p>例如：在网络上传输</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下雨天留客天留我不留</span><br></pre></td></tr></table></figure>

<p>是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性</p>
<p>一种解读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下雨天留客，天留，我不留</span><br></pre></td></tr></table></figure>

<p>另一种解读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下雨天，留客天，留我不？留</span><br></pre></td></tr></table></figure>



<p>如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定长字节表示内容长度 + 实际内容</span><br></pre></td></tr></table></figure>

<p>例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0f下雨天留客06天留09我不留</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小故事</p>
<p>很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。</p>
<p>年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”</p>
<p>私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”</p>
<p>双方唇枪舌战，你来我往，真个是不亦乐乎！</p>
<p>这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬</p>
</blockquote>
<h3 id="2-2-redis-协议举例"><a href="#2-2-redis-协议举例" class="headerlink" title="2.2 redis 协议举例"></a>2.2 redis 协议举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">byte</span>[] LINE = &#123;<span class="number">13</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">    bootstrap.group(worker);</span><br><span class="line">    bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                <span class="comment">// 会在连接 channel 建立成功后，会触发 active 事件</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">                    set(ctx);</span><br><span class="line">                    get(ctx);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">                    ByteBuf buf = ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;*2&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;get&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">                    ByteBuf buf = ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;*3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;set&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;bbb&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>).sync();</span><br><span class="line">    channelFuture.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    worker.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-http-协议举例"><a href="#2-3-http-协议举例" class="headerlink" title="2.3 http 协议举例"></a>2.3 http 协议举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">    serverBootstrap.group(boss, worker);</span><br><span class="line">    serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 获取请求</span></span><br><span class="line">                    log.debug(msg.uri());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 返回响应</span></span><br><span class="line">                    DefaultFullHttpResponse response =</span><br><span class="line">                            <span class="keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">                    response.headers().setInt(CONTENT_LENGTH, bytes.length);</span><br><span class="line">                    response.content().writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 写回响应</span></span><br><span class="line">                    ctx.writeAndFlush(response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">/*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;</span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">                    log.debug(&quot;&#123;&#125;&quot;, msg.getClass());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    if (msg instanceof HttpRequest) &#123; // 请求行，请求头</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &#125; else if (msg instanceof HttpContent) &#123; //请求体</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;);*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">    channelFuture.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    boss.shutdownGracefully();</span><br><span class="line">    worker.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-自定义协议要素"><a href="#2-4-自定义协议要素" class="headerlink" title="2.4 自定义协议要素"></a>2.4 自定义协议要素</h3><ul>
<li>魔数，用来在第一时间判定是否是无效数据包</li>
<li>版本号，可以支持协议的升级</li>
<li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li>
<li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li>
<li>请求序号，为了双工通信，提供异步能力</li>
<li>正文长度</li>
<li>消息正文</li>
</ul>
<h4 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h4><p>根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span> <span class="keyword">extends</span> <span class="title">ByteToMessageCodec</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magicNum = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span> version = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializerType = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> messageType = in.readByte();</span><br><span class="line">        <span class="keyword">int</span> sequenceId = in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">        Message message = (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">    <span class="keyword">new</span> LoggingHandler(),</span><br><span class="line">    <span class="keyword">new</span> LengthFieldBasedFrameDecoder(</span><br><span class="line">        <span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> MessageCodec()</span><br><span class="line">);</span><br><span class="line"><span class="comment">// encode</span></span><br><span class="line">LoginRequestMessage message = <span class="keyword">new</span> LoginRequestMessage(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//        channel.writeOutbound(message);</span></span><br><span class="line"><span class="comment">// decode</span></span><br><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line"><span class="keyword">new</span> MessageCodec().encode(<span class="keyword">null</span>, message, buf);</span><br><span class="line"></span><br><span class="line">ByteBuf s1 = buf.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">ByteBuf s2 = buf.slice(<span class="number">100</span>, buf.readableBytes() - <span class="number">100</span>);</span><br><span class="line">s1.retain(); <span class="comment">// 引用计数 2</span></span><br><span class="line">channel.writeInbound(s1); <span class="comment">// release 1</span></span><br><span class="line">channel.writeInbound(s2);</span><br></pre></td></tr></table></figure>



<p>解读</p>




<h4 id="💡-什么时候可以加-Sharable"><a href="#💡-什么时候可以加-Sharable" class="headerlink" title="💡 什么时候可以加 @Sharable"></a>💡 什么时候可以加 @Sharable</h4><ul>
<li>当 handler 不保存状态时，就可以安全地在多线程下被共享</li>
<li>但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制</li>
<li>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>, <span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf out = ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magicNum = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span> version = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializerType = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> messageType = in.readByte();</span><br><span class="line">        <span class="keyword">int</span> sequenceId = in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">        Message message = (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-聊天室案例"><a href="#3-聊天室案例" class="headerlink" title="3. 聊天室案例"></a>3. 聊天室案例</h2><h3 id="3-1-聊天室业务介绍"><a href="#3-1-聊天室业务介绍" class="headerlink" title="3.1 聊天室业务介绍"></a>3.1 聊天室业务介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 登录成功返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username, String password)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 会话管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 会话绑定用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(Channel channel, String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解绑会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要解绑会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unbind</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getAttribute</span><span class="params">(Channel channel, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(Channel channel, String name, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名获取 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Channel <span class="title">getChannel</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天组会话管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroupSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> members 成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功时返回组对象, 失败返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">createGroup</span><span class="params">(String name, Set&lt;String&gt; members)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">joinMember</span><span class="params">(String name, String member)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">removeMember</span><span class="params">(String name, String member)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">removeGroup</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员集合, 没有成员会返回 empty set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">getMembers</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员 channel 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Channel&gt; <span class="title">getMembersChannel</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-聊天室业务-登录"><a href="#3-2-聊天室业务-登录" class="headerlink" title="3.2 聊天室业务-登录"></a>3.2 聊天室业务-登录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;LoginRequestMessage&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            String username = msg.getUsername();</span><br><span class="line">                            String password = msg.getPassword();</span><br><span class="line">                            <span class="keyword">boolean</span> login = UserServiceFactory.getUserService().login(username, password);</span><br><span class="line">                            LoginResponseMessage message;</span><br><span class="line">                            <span class="keyword">if</span>(login) &#123;</span><br><span class="line">                                message = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                message = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;用户名或密码不正确&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(message);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = serverBootstrap.bind(<span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        CountDownLatch WAIT_FOR_LOGIN = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        AtomicBoolean LOGIN = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(LOGGING_HANDLER);</span></span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(<span class="string">&quot;client handler&quot;</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="comment">// 接收响应消息</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;msg: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">                            <span class="keyword">if</span> ((msg <span class="keyword">instanceof</span> LoginResponseMessage)) &#123;</span><br><span class="line">                                LoginResponseMessage response = (LoginResponseMessage) msg;</span><br><span class="line">                                <span class="keyword">if</span> (response.isSuccess()) &#123;</span><br><span class="line">                                    <span class="comment">// 如果登录成功</span></span><br><span class="line">                                    LOGIN.set(<span class="keyword">true</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 唤醒 system in 线程</span></span><br><span class="line">                                WAIT_FOR_LOGIN.countDown();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 在连接建立后触发 active 事件</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 负责接收用户在控制台的输入，负责向服务器发送各种消息</span></span><br><span class="line">                            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                                Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                                System.out.println(<span class="string">&quot;请输入用户名:&quot;</span>);</span><br><span class="line">                                String username = scanner.nextLine();</span><br><span class="line">                                System.out.println(<span class="string">&quot;请输入密码:&quot;</span>);</span><br><span class="line">                                String password = scanner.nextLine();</span><br><span class="line">                                <span class="comment">// 构造消息对象</span></span><br><span class="line">                                LoginRequestMessage message = <span class="keyword">new</span> LoginRequestMessage(username, password);</span><br><span class="line">                                <span class="comment">// 发送消息</span></span><br><span class="line">                                ctx.writeAndFlush(message);</span><br><span class="line">                                System.out.println(<span class="string">&quot;等待后续操作...&quot;</span>);</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    WAIT_FOR_LOGIN.await();</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 如果登录失败</span></span><br><span class="line">                                <span class="keyword">if</span> (!LOGIN.get()) &#123;</span><br><span class="line">                                    ctx.channel().close();</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;send [username] [content]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gsend [group name] [content]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gmembers [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gjoin [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gquit [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;quit&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">                                    String command = scanner.nextLine();</span><br><span class="line">                                    String[] s = command.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                                    <span class="keyword">switch</span> (s[<span class="number">0</span>])&#123;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;send&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> ChatRequestMessage(username, s[<span class="number">1</span>], s[<span class="number">2</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gsend&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupChatRequestMessage(username, s[<span class="number">1</span>], s[<span class="number">2</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gcreate&quot;</span>:</span><br><span class="line">                                            Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(s[<span class="number">2</span>].split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">                                            set.add(username); <span class="comment">// 加入自己</span></span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupCreateRequestMessage(s[<span class="number">1</span>], set));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gmembers&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupMembersRequestMessage(s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gjoin&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinRequestMessage(username, s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gquit&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupQuitRequestMessage(username, s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">                                            ctx.channel().close();</span><br><span class="line">                                            <span class="keyword">return</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;, <span class="string">&quot;system in&quot;</span>).start();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-聊天室业务-单聊"><a href="#3-3-聊天室业务-单聊" class="headerlink" title="3.3 聊天室业务-单聊"></a>3.3 聊天室业务-单聊</h3><p>服务器端将 handler 独立出来</p>
<p>登录 handler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LoginRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String username = msg.getUsername();</span><br><span class="line">        String password = msg.getPassword();</span><br><span class="line">        <span class="keyword">boolean</span> login = UserServiceFactory.getUserService().login(username, password);</span><br><span class="line">        LoginResponseMessage message;</span><br><span class="line">        <span class="keyword">if</span>(login) &#123;</span><br><span class="line">            SessionFactory.getSession().bind(ctx.channel(), username);</span><br><span class="line">            message = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            message = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;用户名或密码不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单聊 handler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ChatRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String to = msg.getTo();</span><br><span class="line">        Channel channel = SessionFactory.getSession().getChannel(to);</span><br><span class="line">        <span class="comment">// 在线</span></span><br><span class="line">        <span class="keyword">if</span>(channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> ChatResponseMessage(msg.getFrom(), msg.getContent()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不在线</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> ChatResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;对方用户不存在或者不在线&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-聊天室业务-群聊"><a href="#3-4-聊天室业务-群聊" class="headerlink" title="3.4 聊天室业务-群聊"></a>3.4 聊天室业务-群聊</h3><p>创建群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupCreateRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupCreateRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String groupName = msg.getGroupName();</span><br><span class="line">        Set&lt;String&gt; members = msg.getMembers();</span><br><span class="line">        <span class="comment">// 群管理器</span></span><br><span class="line">        GroupSession groupSession = GroupSessionFactory.getGroupSession();</span><br><span class="line">        Group group = groupSession.createGroup(groupName, members);</span><br><span class="line">        <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 发生成功消息</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupCreateResponseMessage(<span class="keyword">true</span>, groupName + <span class="string">&quot;创建成功&quot;</span>));</span><br><span class="line">            <span class="comment">// 发送拉群消息</span></span><br><span class="line">            List&lt;Channel&gt; channels = groupSession.getMembersChannel(groupName);</span><br><span class="line">            <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">                channel.writeAndFlush(<span class="keyword">new</span> GroupCreateResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;您已被拉入&quot;</span> + groupName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupCreateResponseMessage(<span class="keyword">false</span>, groupName + <span class="string">&quot;已经存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupChatRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Channel&gt; channels = GroupSessionFactory.getGroupSession()</span><br><span class="line">                .getMembersChannel(msg.getGroupName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> GroupChatResponseMessage(msg.getFrom(), msg.getContent()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupJoinRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupJoinRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Group group = GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>, msg.getGroupName() + <span class="string">&quot;群加入成功&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>, msg.getGroupName() + <span class="string">&quot;群不存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>退出群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupQuitRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupQuitRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Group group = GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;已退出群&quot;</span> + msg.getGroupName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>, msg.getGroupName() + <span class="string">&quot;群不存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupMembersRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupMembersRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Set&lt;String&gt; members = GroupSessionFactory.getGroupSession()</span><br><span class="line">                .getMembers(msg.getGroupName());</span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> GroupMembersResponseMessage(members));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-聊天室业务-退出"><a href="#3-5-聊天室业务-退出" class="headerlink" title="3.5 聊天室业务-退出"></a>3.5 聊天室业务-退出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class QuitHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    // 当连接断开时触发 inactive 事件</span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">        log.debug(&quot;&#123;&#125; 已经断开&quot;, ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 当出现异常时触发</span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">        log.debug(&quot;&#123;&#125; 已经异常断开 异常是&#123;&#125;&quot;, ctx.channel(), cause.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-聊天室业务-空闲检测"><a href="#3-6-聊天室业务-空闲检测" class="headerlink" title="3.6 聊天室业务-空闲检测"></a>3.6 聊天室业务-空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p>原因</p>
<ul>
<li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li>
<li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li>
<li>应用程序线程阻塞，无法进行数据读写</li>
</ul>
<p>问题</p>
<ul>
<li>假死的连接占用的资源不能自动释放</li>
<li>向假死的连接发送数据，得到的反馈是发送超时</li>
</ul>
<p>服务器端解决</p>
<ul>
<li>怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ChannelDuplexHandler() &#123;</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了读空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;已经 5s 没有读到数据了&quot;</span>);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>客户端定时心跳</p>
<ul>
<li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ChannelDuplexHandler() &#123;</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了写空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            <span class="comment">//                                log.debug(&quot;3s 没有写数据了，发送一个心跳包&quot;);</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> PingMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-batch核心概念</title>
    <url>/2023/02/26/spring-batch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="批处理领域语言"><a href="#批处理领域语言" class="headerlink" title="批处理领域语言"></a>批处理领域语言</h1><p>下图是批处理整体框架， spring Batch提供了层、组件和技术服务的物理实现，这些层、组件和技术服务通常存在于健壮的、可维护的系统中，用于创建从简单到复杂的批处理应用程序，其基础设施和扩展用于处理非常复杂的处理需求。 </p>
<img src="/2023/02/26/spring-batch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/1677378333315.png" class width="1677378333315">

<p>黄色部分代表了Spring-batch的核心组件，每一个Job有一或者多个步骤（Step），每个Step都有一个ItemReader、ItemWriter和一个ItemProcessor。而启动一个Job需要一个Job执行器（JobLauncher），并且需要存储有关当前Job进程中的一些元数据（JobRepository）。</p>
<h2 id="1-Job"><a href="#1-Job" class="headerlink" title="1. Job"></a>1. Job</h2><p> Job是封装整个批处理过程的实体。在Spring-Batch中，一个Job可以简单看做多个Step的容器。 它将逻辑上属于一个流的多个步骤组合在一起，并允许配置所有步骤的全局属性，例如可重新启动性。 </p>
<img src="/2023/02/26/spring-batch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/1677378628530.png" class width="1677378628530">

<p>一个Job可以通过XMl、或者java配置的方式进行配置。主要包含：</p>
<ul>
<li>job的名称</li>
<li>Step的定义和顺序</li>
<li>Job是否可以restart</li>
</ul>
<p>Job接口的默认实现有SimpleJob，提供了一些默认实现。使用Java 的配置方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Job <span class="title">footballJob</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleJob simpleJob = <span class="keyword">new</span> SimpleJob();</span><br><span class="line">        <span class="keyword">return</span> simpleJob;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-JobInstance"><a href="#2-JobInstance" class="headerlink" title="2. JobInstance"></a>2. JobInstance</h2><p>代表是一个Job真正运行的实例。每个Job可以执行多次，每个JobInstance都与一个JobParameter绑定。</p>
<p> JobInstance的定义与要加载的数据完全无关。完全由ItemReader实现决定如何加载数据。 </p>
<p> 使用相同的JobInstance决定是否使用以前执行的“状态”(即ExecutionContext，)。使用一个新的JobInstance意味着“从头开始”，而使用一个现有的实例通常意味着“从你离开的地方开始”。 </p>
<h2 id="3-JobParameters"><a href="#3-JobParameters" class="headerlink" title="3. JobParameters"></a>3. JobParameters</h2><p>那么如何区分JobInstance之间的不同呢？答案就是JobParameters。JobParameters作为一系列的启动参数用于启动一个批处理任务。</p>
<img src="/2023/02/26/spring-batch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/1677380836783.png" class width="1677380836783">

<p>假如一个Job启动了两个实例： 一个在1月1号启动，一个在1月2号启动，他们各自有自己的JobParameters。那么约定：JobInstance = Job+identifying JobParameters 。这允许开发人员有效地控制JobInstance的定义方式，因为他们可以控制传入的参数。 </p>
<h2 id="4-JobExecution"><a href="#4-JobExecution" class="headerlink" title="4. JobExecution"></a>4. JobExecution</h2><p>JobExecution表示一个Job运行中的技术概念。 执行可能以失败或成功结束，但与给定执行对应的JobInstance不被认为是完成的，除非执行成功完成 。</p>
<p> 以前面描述的EndOfDay 的Job为例，考虑在第一次运行时失败的JobInstance。如果使用与第一次运行(01-01-2017)相同的标识作业参数再次运行它，则会创建一个新的JobExecution。但是，仍然只有一个JobInstance。</p>
<p>一个Job定义了任务是怎么样的以及是怎么被执行的， 然而，jobeexecution是运行期间实际发生情况的主要存储机制，它包含许多必须控制和持久化的属性。</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Definition</th>
</tr>
</thead>
<tbody><tr>
<td>Status</td>
<td>A <code>BatchStatus</code> object that indicates the status of the execution. While running, it is <code>BatchStatus#STARTED</code>. If it fails, it is <code>BatchStatus#FAILED</code>. If it finishes successfully, it is <code>BatchStatus#COMPLETED</code></td>
</tr>
<tr>
<td>startTime</td>
<td>A <code>java.util.Date</code> representing the current system time when the execution was started. This field is empty if the job has yet to start.</td>
</tr>
<tr>
<td>endTime</td>
<td>A <code>java.util.Date</code> representing the current system time when the execution finished, regardless of whether or not it was successful. The field is empty if the job has yet to finish.</td>
</tr>
<tr>
<td>exitStatus</td>
<td>The <code>ExitStatus</code>, indicating the result of the run. It is most important, because it contains an exit code that is returned to the caller. See chapter 5 for more details. The field is empty if the job has yet to finish.</td>
</tr>
<tr>
<td>createTime</td>
<td>A <code>java.util.Date</code> representing the current system time when the <code>JobExecution</code> was first persisted. The job may not have been started yet (and thus has no start time), but it always has a createTime, which is required by the framework for managing job level <code>ExecutionContexts</code>.</td>
</tr>
<tr>
<td>lastUpdated</td>
<td>A <code>java.util.Date</code> representing the last time a <code>JobExecution</code> was persisted. This field is empty if the job has yet to start.</td>
</tr>
<tr>
<td>executionContext</td>
<td>The “property bag” containing any user data that needs to be persisted between executions.</td>
</tr>
<tr>
<td>failureExceptions</td>
<td>The list of exceptions encountered during the execution of a <code>Job</code>. These can be useful if more than one exception is encountered during the failure of a <code>Job</code>.</td>
</tr>
</tbody></table>
<p>这些属性是<strong>持久化</strong>的，因此可以完全确定一个execution的执行状态。</p>
<h2 id="5-Step"><a href="#5-Step" class="headerlink" title="5. Step"></a>5. Step</h2><p> 它封装了批处理作业的一个独立的顺序阶段。 每个Job都完全由一个或多个步骤（Step）组成。一个步骤包含定义和控制实际批处理所需的所有信息。 </p>
<h2 id="6-StepExecution"><a href="#6-StepExecution" class="headerlink" title="6. StepExecution"></a>6. StepExecution</h2><p> 每次运行Step时都会创建一个新的StepExecution，类似于jobeexecution。但是，如果一个步骤执行失败是因为它之前的步骤失败，则不会为它持久执行。  只有当其Step实际启动时，才会创建StepExecution。 </p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Definition</th>
</tr>
</thead>
<tbody><tr>
<td>Status</td>
<td>A <code>BatchStatus</code> object that indicates the status of the execution. While running, the status is <code>BatchStatus.STARTED</code>. If it fails, the status is <code>BatchStatus.FAILED</code>. If it finishes successfully, the status is <code>BatchStatus.COMPLETED</code>.</td>
</tr>
<tr>
<td>startTime</td>
<td>A <code>java.util.Date</code> representing the current system time when the execution was started. This field is empty if the step has yet to start.</td>
</tr>
<tr>
<td>endTime</td>
<td>A <code>java.util.Date</code> representing the current system time when the execution finished, regardless of whether or not it was successful. This field is empty if the step has yet to exit.</td>
</tr>
<tr>
<td>exitStatus</td>
<td>The <code>ExitStatus</code> indicating the result of the execution. It is most important, because it contains an exit code that is returned to the caller. See chapter 5 for more details. This field is empty if the job has yet to exit.</td>
</tr>
<tr>
<td>executionContext</td>
<td>The “property bag” containing any user data that needs to be persisted between executions.</td>
</tr>
<tr>
<td>readCount</td>
<td>The number of items that have been successfully read.</td>
</tr>
<tr>
<td>writeCount</td>
<td>The number of items that have been successfully written.</td>
</tr>
<tr>
<td>commitCount</td>
<td>The number of transactions that have been committed for this execution.</td>
</tr>
<tr>
<td>rollbackCount</td>
<td>The number of times the business transaction controlled by the <code>Step</code> has been rolled back.</td>
</tr>
<tr>
<td>readSkipCount</td>
<td>The number of times <code>read</code> has failed, resulting in a skipped item.</td>
</tr>
<tr>
<td>processSkipCount</td>
<td>The number of times <code>process</code> has failed, resulting in a skipped item.</td>
</tr>
<tr>
<td>filterCount</td>
<td>The number of items that have been ‘filtered’ by the <code>ItemProcessor</code>.</td>
</tr>
<tr>
<td>writeSkipCount</td>
<td>The number of times <code>write</code> has failed, resulting in a skipped item.</td>
</tr>
</tbody></table>
<h2 id="7-ExecutionContext"><a href="#7-ExecutionContext" class="headerlink" title="7. ExecutionContext"></a>7. ExecutionContext</h2><p>ExecutionContext代表一系列key-value的数据map。 好的使用例子是方便重新启动。以平面文件输入为例，在处理单个行时，框架定期在提交点持久化ExecutionContext。 </p>
<h2 id="8-JobRepository"><a href="#8-JobRepository" class="headerlink" title="8. JobRepository"></a>8. JobRepository</h2><p> JobRepository是上述概念的持久化机制。提供了一些CRUD的操作、 当Job第一次启动时，从存储库中获得jobeexecution，并且在执行过程中，通过将StepExecution和jobeexecution实现传递给存储库来持久化它们。 </p>
<h2 id="9-JobLauncher"><a href="#9-JobLauncher" class="headerlink" title="9. JobLauncher"></a>9. JobLauncher</h2><p>Job 执行器、</p>
<h2 id="10-Item-Reader"><a href="#10-Item-Reader" class="headerlink" title="10.  Item Reader"></a>10.  Item Reader</h2><p> ItemReader是一种抽象，表示对Step的输入的检索，每次一项。当ItemReader耗尽了它所能提供的项时，它将通过返回null来表示。关于ItemReader接口及其各种实现的更多细节可以在Readers和writer中找到。 </p>
<h2 id="11-Item-Writer"><a href="#11-Item-Writer" class="headerlink" title="11. Item Writer"></a>11. Item Writer</h2><p> 它表示一个步骤的输出，一次一批或一组项目。通常，ItemWriter不知道它接下来应该接收的输入，只知道在当前调用中传递的项。</p>
<h2 id="12-Item-Processor"><a href="#12-Item-Processor" class="headerlink" title="12. Item Processor"></a>12. Item Processor</h2><p>每一条数据的处理逻辑。 如果在处理该项时确定该项无效，则返回null表示不应写入该项。 </p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>执行批处理作业时的一个关键问题是重新启动作业时的行为。如果特定JobInstance的jobeexecute已经存在，则启动Job被认为是“重新启动” </p>
<h4 id="Restartability属性"><a href="#Restartability属性" class="headerlink" title="Restartability属性"></a>Restartability属性</h4><p> 将restarttable设置为false意味着此Job不支持再次启动。重新启动不可重新启动的作业将引发JobRestartException异常 </p>
<h2 id="EnableBatchProcessing"><a href="#EnableBatchProcessing" class="headerlink" title="EnableBatchProcessing"></a>EnableBatchProcessing</h2><p> @EnableBatchProcessing提供了用于构建批处理任务的基本配置。在这个基本配置中，除了许多可用于自动连接的bean之外，还创建了一个StepScope实例 </p>
<ul>
<li><code>JobRepository</code>: bean name “jobRepository”</li>
<li><code>JobLauncher</code>: bean name “jobLauncher”</li>
<li><code>JobRegistry</code>: bean name “jobRegistry”</li>
<li><code>PlatformTransactionManager</code>: bean name “transactionManager”</li>
<li><code>JobBuilderFactory</code>: bean name “jobBuilders”</li>
<li><code>StepBuilderFactory</code>: bean name “stepBuilders”</li>
</ul>
<h2 id="改变存储机制"><a href="#改变存储机制" class="headerlink" title="改变存储机制"></a>改变存储机制</h2><p>可能不需要将Job的状态存储在数据库中， 出于这个原因，Spring批处理提供了作业存储库的内存中的Map版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This would reside in your BatchConfigurer implementation</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> JobRepository <span class="title">createJobRepository</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MapJobRepositoryFactoryBean factory = <span class="keyword">new</span> MapJobRepositoryFactoryBean();</span><br><span class="line">    factory.setTransactionManager(transactionManager);</span><br><span class="line">    <span class="keyword">return</span> factory.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，内存中的存储库是不稳定的，因此不允许在JVM实例之间重新启动。它也不能保证同时启动两个具有相同参数的作业实例，并且不适合在多线程作业或本地分区Step中使用。因此，只要需要这些特性，就使用存储库的数据库版本。<br>  确实需要定义事务管理器，因为存储库中存在回滚语义，而且业务逻辑可能仍然是事务性的(例如RDBMS访问)。出于测试目的，许多人发现ResourcelessTransactionManager很有用。 </p>
<p>但是MapJobRepositoryFactoryBean已经过时了，将会在Spring-Batch 5.x版本中移除。因此如果想要基于内存的操作，那么可以配置一个本地的数据库，如H2， Apache Derby or HSQLDB 等，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">            .addScript(<span class="string">&quot;/org/springframework/batch/core/schema-drop-h2.sql&quot;</span>)</span><br><span class="line">            .addScript(<span class="string">&quot;/org/springframework/batch/core/schema-h2.sql&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置数据源后需要结合createJobRepository来设置。</p>
<h2 id="配置Configuring-a-JobLauncher"><a href="#配置Configuring-a-JobLauncher" class="headerlink" title="配置Configuring a JobLauncher"></a>配置Configuring a JobLauncher</h2><p> 获得jobeexecution后，将它传递给Job的execute方法，最终将jobeexecution返回给调用者，如下图所示 </p>
<img src="/2023/02/26/spring-batch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/1677424458876.png" class width="1677424458876">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobLauncher <span class="title">jobLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SimpleJobLauncher jobLauncher = <span class="keyword">new</span> SimpleJobLauncher();</span><br><span class="line">	jobLauncher.setJobRepository(jobRepository());</span><br><span class="line">	jobLauncher.setTaskExecutor(<span class="keyword">new</span> SimpleAsyncTaskExecutor());</span><br><span class="line">	jobLauncher.afterPropertiesSet();</span><br><span class="line">	<span class="keyword">return</span> jobLauncher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-batch</tag>
      </tags>
  </entry>
  <entry>
    <title>cstile-seckill项目云端部署</title>
    <url>/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="本地打包"><a href="#本地打包" class="headerlink" title="本地打包"></a>本地打包</h2><p>我们使用jar包与配置文件分离的方式进行打包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--不打入jar包的文件类型或者路径--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 执行的主程序路径 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.castile.secondkill.CastileSeckillApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--是否要把第三方jar放到manifest的classpath中--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--生成的manifest中classpath的前缀，因为要把第三方jar放到lib目录下，所以classpath的前缀是lib/--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 打包时 MANIFEST.MF 文件不记录的时间戳版本 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">useUniqueVersions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">useUniqueVersions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 在 Class-Path 下添加配置文件的路径 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Class-Path</span>&gt;</span>config/<span class="tag">&lt;/<span class="name">Class-Path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib/<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--把配置文件打包到指定路径--&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/config<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679752855016.png" class width="1679752855016">

<p>配置文件放在config目录下，项目依赖的jar包放在lib目录下。</p>
<h2 id="docker远程访问"><a href="#docker远程访问" class="headerlink" title="docker远程访问"></a>docker远程访问</h2><p> 修改 /usr/lib/systemd/system/docker.service 文件，ExecStart中加入如下内容 </p>
<p> -H tcp://0.0.0.0:2375  -H unix:///var/run/docker.sock </p>
<img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679753201017.png" class width="1679753201017">

<p>重启docker让它生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload    </span><br><span class="line">systemctl restart docker </span><br></pre></td></tr></table></figure>

<h2 id="idea测试docker连接"><a href="#idea测试docker连接" class="headerlink" title="idea测试docker连接"></a>idea测试docker连接</h2><img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679753357352.png" class width="1679753357352">

<p>可以看到连接成功：</p>
<img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679753392186.png" class width="1679753392186">



<h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p> 项目中引入docker-maven-plugin插件，在pom.xml引入插件并做相应的配置： </p>
<h3 id="1、打包的时候忽略resource配置"><a href="#1、打包的时候忽略resource配置" class="headerlink" title="1、打包的时候忽略resource配置"></a>1、打包的时候忽略resource配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-lib、config目录的构建"><a href="#2-lib、config目录的构建" class="headerlink" title="2. lib、config目录的构建"></a>2. lib、config目录的构建</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib/<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--把配置文件打包到指定路径--&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/config<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、启动类-boot-jar"><a href="#3、启动类-boot-jar" class="headerlink" title="3、启动类-boot-jar"></a>3、启动类-boot-jar</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>none-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span>&gt;</span>ZIP<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attach</span>&gt;</span>true<span class="tag">&lt;/<span class="name">attach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>boot<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 执行的主程序路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.castile.secondkill.CastileSeckillApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span></span><br><span class="line">                    repackage</span><br><span class="line">                <span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4、镜像构建"><a href="#4、镜像构建" class="headerlink" title="4、镜像构建"></a>4、镜像构建</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.spotify/docker-maven-plugin --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 当mvn执行install操作的时候，执行docker的build和push --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>buildAndPush<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                            &lt;goal&gt;build&lt;/goal&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                            &lt;goal&gt;push&lt;/goal&gt;--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>build-docker<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 连接到 带docker环境的linux服务器 编译image --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>$&#123;docker.host&#125;<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- push到 docker hub 开始 --&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- serverId 这个是配置在maven的setting.xml中私服的登录账户信息--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">retryPushCount</span>&gt;</span>1<span class="tag">&lt;/<span class="name">retryPushCount</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">retryPushTimeout</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">retryPushTimeout</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">registryUrl</span>&gt;</span>$&#123;docker.registry&#125;<span class="tag">&lt;/<span class="name">registryUrl</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 格式：私有仓库/镜像名称:版本号, 如果要执行push操作， 那么镜像名称必须为私有仓库为前缀，不然无效。--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;docker.registry&#125;/$&#123;project.artifactId&#125;:$&#123;imageVersion&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- push到 docker hub 结束 --&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--指定dockerfile文件路径--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/docker<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- optionally overwrite tags every time image is built with docker:build --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">forceTags</span>&gt;</span>true<span class="tag">&lt;/<span class="name">forceTags</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">SERVICE_PACKAGE</span>&gt;</span>$&#123;project.basedir&#125;/../../target/$&#123;finalName&#125;.tar.gz<span class="tag">&lt;/<span class="name">SERVICE_PACKAGE</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/opt/castile/app<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">include</span>&gt;</span>lib/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">include</span>&gt;</span>config/**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">include</span>&gt;</span>*-boot.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                       <span class="comment">&lt;!-- &lt;resource&gt;</span></span><br><span class="line"><span class="comment">                            &lt;targetPath&gt;/&lt;/targetPath&gt;</span></span><br><span class="line"><span class="comment">                            &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span></span><br><span class="line"><span class="comment">                            &lt;includes&gt;</span></span><br><span class="line"><span class="comment">                                &lt;include&gt;$&#123;finalName&#125;.tar.gz&lt;/include&gt;</span></span><br><span class="line"><span class="comment">                            &lt;/includes&gt;</span></span><br><span class="line"><span class="comment">                        &lt;/resource&gt;--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、Dockerfile"><a href="#5、Dockerfile" class="headerlink" title="5、Dockerfile"></a>5、Dockerfile</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line">ARG SERVICE_PACKAGE</span><br><span class="line">MAINTAINER zhuhongliang &#x27;castile.github.io&#x27;</span><br><span class="line">ENV APP_HOME=/opt/castile/app</span><br><span class="line"></span><br><span class="line">ADD opt/castile/app /opt/castile/app/</span><br><span class="line">EXPOSE 9090</span><br><span class="line">WORKDIR /opt/castile/app</span><br><span class="line"><span class="meta">#</span><span class="bash">CMD  /bin/bash <span class="variable">$&#123;APP_HOME&#125;</span>/config/docker-start.sh</span></span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-Xbootclasspath/a:/opt/castile/app/config&quot;, &quot;-Djava.ext.dirs=/opt/castile/app/lib:$JAVA_HOME/jre/lib/ext&quot;,&quot;-jar&quot;,&quot;/opt/castile/app/castile-seckill-0.0.1-SNAPSHOT-boot.jar&quot;]</span><br></pre></td></tr></table></figure>

<p>推送至docker私服：</p>
<img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679824979208.png" class width="1679824979208">

<img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679825019113.png" class width="1679825019113">

<h2 id="启动部署"><a href="#启动部署" class="headerlink" title="启动部署"></a>启动部署</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name castile -p 9090:9090 -v /opt/applications/castile-seckill/config/:/opt/castile/app/config  192.168.160.140:5000/castile-seckill:0.0.1-SNAPSHOT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里设置宿主机的opt/applications/castile-seckill/config/目录和容器内/opt/castile/app/config目录映射，为了修改配置方便些。</p>
<p>执行的java命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Xbootclasspath/a:/opt/castile/app/config -Djava.ext.dirs=/opt/castile/app/lib:$JAVA_HOME/jre/lib/ext -jar /opt/castile/app/castile-seckill-0.0.1-SNAPSHOT-boot.jar</span><br></pre></td></tr></table></figure>



<img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679825557145.png" class width="1679825557145">

<h2 id="部署msql"><a href="#部署msql" class="headerlink" title="部署msql"></a>部署msql</h2><p>因为项目依赖mysql，因此需要把mysql容器先启动，再启动项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name mysql8 -v /var/mysql/data:/var/lib/mysql -v /var/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -p 3306:                                      3306 -d mysql:8.0.32</span><br></pre></td></tr></table></figure>

<p>设置远程访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select host, user, plugin,  authentication_string, password_expired from user;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679825319954.png" class width="1679825319954">

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> root@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> root@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line">刷新权限</span><br><span class="line"> FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679825359041.png" class width="1679825359041">

<img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679825476826.png" class width="1679825476826">

<h2 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h2><p>浏览器输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://192.168.160.140:9090/login.html</span><br></pre></td></tr></table></figure>

<img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679825153890.png" class width="1679825153890">

<p>已经可以成功访问啦，可以验证基本功能都正常。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
        <category>秒杀项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>castile-seckill项目jmeter性能压测</title>
    <url>/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="Jmeter下载"><a href="#Jmeter下载" class="headerlink" title="Jmeter下载"></a>Jmeter下载</h2><p><a href="https://jmeter.apache.org/download_jmeter.cgi#binaries">https://jmeter.apache.org/download_jmeter.cgi#binaries</a></p>
<img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679830977726.png" class width="1679830977726">



<h2 id="jmeter使用简介"><a href="#jmeter使用简介" class="headerlink" title="jmeter使用简介"></a>jmeter使用简介</h2><h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>我们先小测一把，模拟20个请求去访问商品详情页的接口</p>
<img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679831046375.png" class width="1679831046375">

<img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679831057429.png" class width="1679831057429">

<p>结果：</p>
<p>1、平均值接口响应为13ms</p>
<p>2、90线：表示有90%的请求的响应在26ms</p>
<p>3、95线：表示有95%的请求响应在33ms</p>
<p>4、吞吐量：2.1/s</p>
<h2 id="发现容量问题"><a href="#发现容量问题" class="headerlink" title="发现容量问题"></a>发现容量问题</h2><p>server端并发线程数上不去</p>
<p>我们使用的是springboot内嵌的tomcat</p>
<p>查看当前java进行开启的线程数量：pstree</p>
<img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679831526854.png" class width="1679831526854">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost config]# pstree -p 20919 | wc -l</span><br><span class="line">29</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目前有29个线程</p>
<h3 id="100个线程、循环10次"><a href="#100个线程、循环10次" class="headerlink" title="100个线程、循环10次"></a>100个线程、循环10次</h3><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/111" class width="1679831898788">

<img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679831918221.png" class width="1679831918221">



<h3 id="500个线程、循环10次"><a href="#500个线程、循环10次" class="headerlink" title="500个线程、循环10次"></a>500个线程、循环10次</h3><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/111" class width="1679831898788">



<h3 id="5000个线程，循环100"><a href="#5000个线程，循环100" class="headerlink" title="5000个线程，循环100"></a>5000个线程，循环100</h3><p>服务已经出现拒绝连接了：</p>
<img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679836900586.png" class width="1679836900586">

<p>线程数量一直在219个：</p>
<img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679836949848.png" class width="1679836949848">

<img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679837001322.png" class width="1679837001322">



<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>spring-configuration-metadata.json</p>
<img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679837237188.png" class width="1679837237188">

<p>项目使用的是springboot内嵌的tomcat容器，并且没有对参数进行特定设置；查看springboot的默认配置：</p>
<p>server.tomcat.accept-count： 等待队列的长度，默认100</p>
<p>server.tomcat.max-connections： 最大可被连接数，默认8192</p>
<p>server.tomcat.threads.min-spare：最小工作线程数，默认10</p>
<p>server.tomcat.threads.max： 最大工作线程数， 默认200</p>
<p>默认配置下，连接超过8192后出现拒绝连接情况</p>
<p>默认配置项啊，触发的请求超过200+100后拒绝处理。 </p>
<p>更改tomcat服务端参数：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据源</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/castile-seckill?characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 404问题的处理, 非通用异常的返回设置</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapping/*.xml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">accept-count:</span> <span class="number">1000</span></span><br><span class="line">    <span class="attr">threads:</span></span><br><span class="line">      <span class="attr">max:</span> <span class="number">800</span></span><br><span class="line">      <span class="attr">min-spare:</span> <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>容器重新启动后，可以看到还没有开始压测的时候，启动后的线程数量为119：</p>
<img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679841203406.png" class width="1679841203406">

<h3 id="优化后：-2000个线程，循环100"><a href="#优化后：-2000个线程，循环100" class="headerlink" title="优化后： 2000个线程，循环100"></a>优化后： 2000个线程，循环100</h3><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679841277.png" class width="1679841277106">

<img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679841486748.png" class width="1679841486748">

<p>最大开启线程数819个</p>
<img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679841277.png" class width="1679841277106">



<h3 id="定制内嵌tomcat开发"><a href="#定制内嵌tomcat开发" class="headerlink" title="定制内嵌tomcat开发"></a>定制内嵌tomcat开发</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.castile.secondkill.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Connector;</span><br><span class="line"><span class="keyword">import</span> org.apache.coyote.http11.Http11NioProtocol;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.embedded.tomcat.TomcatConnectorCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.ConfigurableWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当Spring容器内没有TomcatEmbeddedServletContainerFactory这个bean时，会把此bean加载到Spring容器中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-3-27 23:01:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServerConfiguration</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用对应工厂类提供给我们的接口定制化我们的tomcat onnector</span></span><br><span class="line">        ((TomcatServletWebServerFactory) factory).addConnectorCustomizers(<span class="keyword">new</span> TomcatConnectorCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">                Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line">                <span class="comment">// 设置30秒内没有请求则断开keepalive连接</span></span><br><span class="line">                protocol.setKeepAliveTimeout(<span class="number">30000</span>);</span><br><span class="line">                <span class="comment">// 当客户端发送超过10000个请求则自动断开keepalive连接</span></span><br><span class="line">                protocol.setMaxKeepAliveRequests(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KeepAliveTimeout: 多少毫秒后不响应就断开keepalive</p>
<p>MaxKeepAliveRequests： 多少次请求后keepalive断开</p>
<p>设置这两个参数是为了保证我们的系统不受客户端请求的拖累，在满足需求的同时提升性能</p>
<h2 id="单web容量上限"><a href="#单web容量上限" class="headerlink" title="单web容量上限"></a>单web容量上限</h2><p>线程数量：4U8G内存单进程调度线程数量800-1000以上后就花费巨大的时间在cpu的调度上</p>
<p>等待队列长度： 对列做缓冲池使用，但不能无限长，消耗内存，出队入队也耗cpu</p>
<h2 id="mysql数据库QPS容量问题"><a href="#mysql数据库QPS容量问题" class="headerlink" title="mysql数据库QPS容量问题"></a>mysql数据库QPS容量问题</h2><p><strong>经验</strong></p>
<ul>
<li><p>主键查询：千万级别数据= 1-10ms</p>
</li>
<li><p>唯一索引查询：千万级别数据 = 10-100ms</p>
</li>
<li><p>非唯一索引查询： 千万级别数据=100-1000ms</p>
</li>
<li><p>无索引： 百万条数据=1000ms+</p>
</li>
<li><p>非插入更新删除操作： 同查询</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
        <category>秒杀项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink之聚合算子</title>
    <url>/2023/05/06/Flink%E4%B9%8B%E8%81%9A%E5%90%88%E7%AE%97%E5%AD%90/</url>
    <content><![CDATA[<h2 id="聚合算子"><a href="#聚合算子" class="headerlink" title="聚合算子"></a>聚合算子</h2><p> 我们往往需要对大量的数据进行统计或整合，从而提炼出更有用的 信息。比如要对每个词出现的频次进行叠加统计。这种操作，计算的结果不仅依赖当前数据，还跟之前的数据有关，相当于要把所有数据聚在一起进行汇总合并 ——这就是所谓的“聚合”（Aggregation），也对应着 MapReduce 中的 reduce 操作。  </p>
<h2 id="KeyBy"><a href="#KeyBy" class="headerlink" title="KeyBy"></a>KeyBy</h2><p> DataStream 是没有直接进行聚合的 API 的。因为我们对海量数据做聚合 肯定要进行分区并行处理，这样才能提高效率。所以在 Flink 中，要做聚合，需要先进行分区； 这个操作就是通过 keyBy 来完成的。</p>
<img src="/2023/05/06/Flink%E4%B9%8B%E8%81%9A%E5%90%88%E7%AE%97%E5%AD%90/1683215484651.png" class width="1683215484651">

<p> 基于不同的 key，流中的数据将被分配到不同的分区中去，这样一来，所 有具有相同的 key 的数据，都将被发往同一个分区，那么下一步算子操作就将会在同一个 slot 中进行处理了。</p>
<img src="/2023/05/06/Flink%E4%B9%8B%E8%81%9A%E5%90%88%E7%AE%97%E5%AD%90/1683215525749.png" class width="1683215525749">



<h2 id="简单聚合"><a href="#简单聚合" class="headerlink" title="简单聚合"></a>简单聚合</h2><p> 有了按键分区的数据流 KeyedStream，我们就可以基于它进行聚合操作了。Flink 为我们 内置实现了一些最基本、最简单的聚合 API，主要有以下几种： </p>
<p>⚫ sum()：在输入流上，对指定的字段做叠加求和的操作。 </p>
<p>⚫ min()：在输入流上，对指定的字段求最小值。 </p>
<p>⚫ max()：在输入流上，对指定的字段求最大值。 </p>
<p>⚫ minBy()：与 min()类似，在输入流上针对指定字段求最小值。不同的是，min()只计 算指定字段的最小值，其他字段会保留最初第一个数据的值；而 minBy()则会返回包 含字段最小值的整条数据。 </p>
<p>⚫ maxBy()：与 max()类似，在输入流上针对指定字段求最大值。两者区别与 min()/minBy()完全一致。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hlz.flink.chapter05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.functions.KeySelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单聚合操作2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-05-04 23:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAggregation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        DataStreamSource&lt;Event&gt; streamSource = env.fromElements(</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=100&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=9&quot;</span>, <span class="number">5000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>, <span class="number">6000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">7000L</span>)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按键分组后聚合,提取当</span></span><br><span class="line"></span><br><span class="line">        streamSource.keyBy(<span class="keyword">new</span> KeySelector&lt;Event, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value.user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).max(<span class="string">&quot;timeStamp&quot;</span>)</span><br><span class="line">                .print(<span class="string">&quot;max: &quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>max: &gt; Event{user=’Mary’, url=’./home’, timeStamp=1970-01-01 08:00:01.0}<br>max: &gt; Event{user=’Bob’, url=’./cart’, timeStamp=1970-01-01 08:00:02.0}<br>max: &gt; Event{user=’Alice’, url=’./prod?id=100’, timeStamp=1970-01-01 08:00:03.0}<br><font color="red">max: &gt; Event{user=’Bob’, url=’./cart’, timeStamp=1970-01-01 08:00:04.0}</font><br>max: &gt; Event{user=’Bob’, url=’./cart’, timeStamp=1970-01-01 08:00:05.0}<br>max: &gt; Event{user=’Bob’, url=’./cart’, timeStamp=1970-01-01 08:00:06.0}<br>max: &gt; Event{user=’Mary’, url=’./home’, timeStamp=1970-01-01 08:00:07.0}</p>
<p>看红色这一条数据，第四条数据中的路径应该是/home，但是这里却是原来的/cart，说明max()只计 算指定字段的最小值，其他字段会保留最初第一个数据的。</p>
<p>把max()换成maxBy(), 结果输出如下：</p>
<p>maxBy: &gt; Event{user=’Mary’, url=’./home’, timeStamp=1970-01-01 08:00:01.0}<br>maxBy: &gt; Event{user=’Bob’, url=’./cart’, timeStamp=1970-01-01 08:00:02.0}<br>maxBy: &gt; Event{user=’Alice’, url=’./prod?id=100’, timeStamp=1970-01-01 08:00:03.0}<br><font color="red">maxBy: &gt; Event{user=’Bob’, url=’./home’, timeStamp=1970-01-01 08:00:04.0}</font><br>maxBy: &gt; Event{user=’Bob’, url=’./prod?id=9’, timeStamp=1970-01-01 08:00:05.0}<br>maxBy: &gt; Event{user=’Bob’, url=’./prod?id=2’, timeStamp=1970-01-01 08:00:06.0}<br>maxBy: &gt; Event{user=’Mary’, url=’./prod?id=3’, timeStamp=1970-01-01 08:00:07.0}</p>
<p>第四条数据已经中url变成了本身的数据了。</p>
<h2 id="规约聚合"><a href="#规约聚合" class="headerlink" title="规约聚合"></a>规约聚合</h2><p> 与简单聚合类似，reduce 操作也会将 KeyedStream 转换为 DataStream。它不会改变流的元 素数据类型，所以输出类型和输入类型是一样的。  </p>
<p> 调用 KeyedStream 的 reduce 方法时，需要传入一个参数，实现 ReduceFunction 接口， ReduceFunction 接口里需要实现 reduce()方法，这个方法接收两个输入事件，经过转换处 理之后输出一个相同类型的事件；所以，对于一组数据，我们可以先取两个进行合并，然后再 将合并的结果看作一个数据、再跟后面的数据合并，最终会将它“简化”成唯一的一个数据， 这也就是 reduce“归约”的含义。</p>
<p> 我们将数据流按照用户 id 进行分区，然后用一个 reduce 算子实现 sum 的功能，统计每个 用户访问的频次；进而将所有统计结果分到一组，用另一个 reduce 算子实现 maxBy 的功能， 记录所有用户中访问频次最高的那个，也就是当前访问量最大的用户是谁。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hlz.flink.chapter05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.ReduceFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.TypeHint;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reduce操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-02-16 23:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransReduceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        DataStreamSource&lt;Event&gt; source = env.addSource(new ClickSource());</span></span><br><span class="line"></span><br><span class="line">        DataStreamSource&lt;Event&gt; source = env.fromElements(</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./mary&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./hello&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod&quot;</span>, <span class="number">5000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod1&quot;</span>, <span class="number">6000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">7000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod3&quot;</span>, <span class="number">8000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">        <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">4000L</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将Event类型转换成Tuple元组类型</span></span><br><span class="line"><span class="comment">//        SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Long&gt;&gt; tupleStream = source.map(e -&gt; Tuple3.of(e.getUser(), e.getUrl(), 1L)).returns(new TypeHint&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Long&gt;&gt; reduceStream = source</span><br><span class="line">                .map(e -&gt; Tuple3.of(e.getUser(), e.getUrl(), <span class="number">1L</span>))</span><br><span class="line">                .returns(<span class="keyword">new</span> TypeHint&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                &#125;)</span><br><span class="line">                .keyBy(t -&gt; t.f0)</span><br><span class="line">                .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple3&lt;String, String, Long&gt; <span class="title">reduce</span><span class="params">(Tuple3&lt;String, String, Long&gt; value1, Tuple3&lt;String, String, Long&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 每到一条数据，pv加1</span></span><br><span class="line">                        <span class="keyword">return</span> Tuple3.of(value1.f0, value2.f1, value1.f2 + value2.f2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).keyBy(r -&gt; <span class="string">&quot;hello&quot;</span>).reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找最大值</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple3&lt;String, String, Long&gt; <span class="title">reduce</span><span class="params">(Tuple3&lt;String, String, Long&gt; value1, Tuple3&lt;String, String, Long&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> value1.f2 &gt; value2.f2 ? value1 : value2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        reduceStream.print(<span class="string">&quot;reduceStream&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出:</p>
<p>reduceStream&gt; (Mary,./mary,1)<br>reduceStream&gt; (Bob,./hello,1)<br>reduceStream&gt; (Alice,./prod,1)<br>reduceStream&gt; (Alice,./prod2,2)<br>reduceStream&gt; (Bob,./prod,2)<br>reduceStream&gt; (Bob,./prod1,3)<br>reduceStream&gt; (Bob,./prod2,4)<br>reduceStream&gt; (Bob,./prod3,5)<br>reduceStream&gt; (Bob,./prod3,5)<br>reduceStream&gt; (Bob,./prod3,5)<br>reduceStream&gt; (Alice,./prod2,5)<br>reduceStream&gt; (Alice,./prod2,6)<br>reduceStream&gt; (Alice,./prod2,7)</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>在使用max操作的时候，报错Cannot reference field by field expression on GenericType&lt;com.hlz.flink.chapter05.Event&gt;Field expressions are only supported on POJO types, tuples, and case classes. (See the Flink documentation on what is considered a POJO.)</p>
<img src="/2023/05/06/Flink%E4%B9%8B%E8%81%9A%E5%90%88%E7%AE%97%E5%AD%90/1683215675470.png" class width="1683215675470">

<p>这是因为我们定义的Event对象不是标准的POJO对象，</p>
<h4 id="标准的POJO类的要求："><a href="#标准的POJO类的要求：" class="headerlink" title="标准的POJO类的要求："></a>标准的POJO类的要求：</h4><ol>
<li><p>所有成员变量都是私有的，用private修饰</p>
</li>
<li><p>每个成员变量都有对应的getter和setter</p>
</li>
<li><p>有一个无参的构造方法</p>
</li>
</ol>
<p>我们Event没有无参构造，因此需要加上</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
        <tag>聚合</tag>
        <tag>聚合算子</tag>
        <tag>算子</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计01-概览</title>
    <url>/2023/05/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A101-%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h1 id="领域驱动设计概览"><a href="#领域驱动设计概览" class="headerlink" title="领域驱动设计概览"></a>领域驱动设计概览</h1><p>领域驱动设计是一种面向对象的建模方法。</p>
<p> <strong>将要解决的业务概念和业务规则转换为软件系统中的类型以及类型的属性与行为，通过合理运用面向对象的封装、继承和多态等设计要素</strong>，降低或隐藏整个系统的业务复杂性，并使得系统具有更好的扩展性，应对纷繁多变的现实业务问题。 </p>
<p> 领域驱动设计的提出，是<strong>设计观念的转变，蕴含了全新的设计思想、设计原则与设计过程</strong>。 </p>
<h2 id="领域驱动设计过程"><a href="#领域驱动设计过程" class="headerlink" title="领域驱动设计过程"></a>领域驱动设计过程</h2><p> 领域驱动设计强调<strong>领域模型</strong>的重要性，并通过模型驱动设计来保障领域模型与程序设计的一致。从业务需求中提炼出统一语言（Ubiquitous Language），再基于统一语言建立领域模型；这个领域模型会指导着程序设计以及编码实现；最后，又通过重构来发现隐式概念，并运用设计模式改进设计与开发质量 </p>
<img src="/2023/05/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A101-%E6%A6%82%E8%A7%88/1684334923286.png" class width="1684334923286">

<p> 这个过程是一个覆盖<strong>软件全生命周期</strong>的设计闭环，每个环节的输出都可以作为下一个环节的输入，而在其中扮演重要指导作用的则是“领域模型” 。这是一个 螺旋式的迭代设计过程。</p>
<p> 在为问题域寻求解决方案时，需要从<strong>宏观层次</strong>划分不同业务关注点的<strong>子领域</strong>，然后再深入到子领域中从微观层次对领域进行建模。<strong>宏观层次是战略的层面，微观层次是战术的层面</strong>，只有将战略设计与战术设计结合起来，才是完整的领域驱动设计。 </p>
<h3 id="战略设计阶段"><a href="#战略设计阶段" class="headerlink" title="战略设计阶段"></a>战略设计阶段</h3><p> 领域驱动设计的战略设计阶段是从下面两个方面来考量的 ：</p>
<ul>
<li><p>问题域方面：针对问题域，引入<strong>限界上下文（Bounded Context）和上下文映射（Context Map）对问题域进行合理的分解，识别出核心领域（Core Domain）与子领域（SubDomain）</strong>，并确定领域的边界以及它们之间的关系，维持模型的完整性。</p>
</li>
<li><p>架构方面：通过<strong>分层架构</strong>来隔离关注点，尤其是将领域实现独立出来，能够更利于领域模型的单一性与稳定性；引入<strong>六边形架构</strong>可以清晰地表达领域与技术基础设施的边界；CQRS 模式则分离了查询场景和命令场景，针对不同场景选择使用同步或异步操作，来提高架构的低延迟性与高并发能力。</p>
</li>
</ul>
<h3 id="战术设计阶段"><a href="#战术设计阶段" class="headerlink" title="战术设计阶段"></a>战术设计阶段</h3><p> 整个软件系统被分解为多个限界上下文（或领域）后，就可以分而治之，对每个限界上下文进行战术设计。领域驱动设计并不牵涉到技术层面的实现细节，在战术层面，它主要应对的是领域的复杂性。领域驱动设计用以表示模型的主要要素包括：</p>
<ul>
<li>值对象（Value Object）</li>
<li>实体（Entity）</li>
<li>领域服务（Domain Service）</li>
<li>领域事件（Domain Event）</li>
<li>资源库（Repository）</li>
<li>工厂（Factory）</li>
<li>聚合（Aggregate）</li>
<li>应用服务（Application Service）</li>
</ul>
<img src="/2023/05/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A101-%E6%A6%82%E8%A7%88/1684335677898.png" class width="1684335677898">

<p> 领域驱动设计围绕着领域模型进行设计，通过<strong>分层架构（Layered Architecture）将领域独立出来。表示领域模型的对象包括：实体、值对象和领域服务</strong>，<strong>领域逻辑都应该封装在这些对象中</strong>。这一严格的设计原则可以避免业务逻辑渗透到领域层之外，导致技术实现与业务逻辑的混淆。在领域驱动设计的演进中，又引入了<strong>领域事件</strong>来丰富领域模型。 </p>
<p> <strong>聚合</strong>是一种边界，它可以封装一到多个<strong>实体</strong>与<strong>值对象</strong>，并维持该边界范围之内的业务完整性。在聚合中，至少包含一个实体，且只有实体才能作为<strong>聚合根（Aggregate Root）</strong>。注意，在领域驱动设计中，没有任何一个类是单独的聚合，因为聚合代表的是边界概念，而非领域概念。在极端情况下，一个聚合可能有且只有一个实体。 </p>
<p> <strong>工厂</strong>和<strong>资源库</strong>都是对领域对象生命周期的管理。前者负责领域对象的创建，往往用于封装复杂或者可能变化的创建逻辑；后者则负责从存放资源的位置（数据库、内存或者其他 Web 资源）获取、添加、删除或者修改领域对象。领域模型中的资源库不应该暴露访问领域对象的技术实现细节。 </p>
<img src="/2023/05/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A101-%E6%A6%82%E8%A7%88/1684335927676.png" class width="1684335927676">]]></content>
      <categories>
        <category>领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>领域驱动设计</tag>
        <tag>战略设计</tag>
        <tag>战术设计</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计02-应对软件的复杂性</title>
    <url>/2023/05/18/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A102-%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7/</url>
    <content><![CDATA[<h1 id="应对软件的复杂性"><a href="#应对软件的复杂性" class="headerlink" title="应对软件的复杂性"></a>应对软件的复杂性</h1><p>需求引起的软件复杂度包含了业务复杂度和技术复杂度：</p>
<p><strong>技术复杂度来自需求的质量属性</strong>，诸如安全、高性能、高并发、高可用性等需求，为软件设计带来了极大的挑战，让人痛苦的是这些因素彼此之间可能又互相矛盾、互相影响。</p>
<p> <strong>业务复杂度对应了客户的业务需求</strong>，因而这种复杂度往往会随着需求规模的增大而增加。由于需求不可能做到完全独立，一旦规模扩大到一定程度，不仅产生了功能数量的增加，还会因为功能互相之间的依赖与影响使得这种复杂度产生叠加，进而影响到整个系统的质量属性，比如系统的可维护性与可扩展性。 </p>
<p> <strong>技术复杂度与业务复杂度并非完全独立，二者混合在一起产生的化合作用更让系统的复杂度变得不可预期，难以掌控</strong>。 </p>
<h2 id="1、隔离业务复杂度与技术复杂度"><a href="#1、隔离业务复杂度与技术复杂度" class="headerlink" title="1、隔离业务复杂度与技术复杂度"></a>1、隔离业务复杂度与技术复杂度</h2><p> 要避免业务逻辑的复杂度与技术实现的复杂度混淆在一起，<strong>首要任务就是确定业务逻辑与技术实现的边界，从而隔离各自的复杂度</strong>。</p>
<p> 例如，在电商的领域逻辑中，订单业务关注的业务规则包括验证订单有效性、计算订单总额、提交和审核订单的流程等；技术关注点则从实现层面保障这些业务能够正确地完成，包括确保分布式系统之间的数据一致性，确保服务之间通信的正确性等。</p>
<p> 业务逻辑并不关心技术是如何实现的，无论采用何种技术，只要业务需求不变，业务规则就不会发生变化。换言之，<strong>在理想状态下，我们应该保证业务规则与技术实现是正交的</strong>。 </p>
<p> 领域驱动设计通过<strong>分层架构</strong>与<strong>六边形架构</strong>来确保业务逻辑与技术实现的隔离 </p>
<h2 id="2、分层架构的关注点分离"><a href="#2、分层架构的关注点分离" class="headerlink" title="2、分层架构的关注点分离"></a>2、分层架构的关注点分离</h2><p> 分层架构遵循了“关注点分离”原则，将属于业务逻辑的关注点放到领域层（Domain Layer）中，而将支撑业务逻辑的技术实现放到基础设施层（Infrastructure Layer）中。同时，领域驱动设计又颇具创见的引入了应用层（Application Layer），应用层扮演了双重角色。一方面它作为业务逻辑的外观（Facade），暴露了能够体现业务用例的应用服务接口；另一方面它又是业务逻辑与技术实现的粘合剂，实现二者之间的协作。 </p>
<p>下图展现的就是一个典型的领域驱动设计分层架构，蓝色区域的内容与业务逻辑有关，灰色区域的内容与技术实现有关，二者泾渭分明，然后汇合在应用层。应用层确定了业务逻辑与技术实现的边界，通过直接依赖或者依赖注入（DI，Dependency Injection）的方式将二者结合起来： </p>
<img src="/2023/05/18/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A102-%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7/1684339034063.png" class width="1684339034063">



<h2 id="3、六边形架构的内外分离"><a href="#3、六边形架构的内外分离" class="headerlink" title="3、六边形架构的内外分离"></a>3、六边形架构的内外分离</h2><p> 由 Cockburn 提出的六边形架构则以“内外分离”的方式，更加清晰地勾勒出了业务逻辑与技术实现的边界，且将业务逻辑放在了架构的核心位置。这种架构模式改变了我们观察系统架构的视角：</p>
<img src="/2023/05/18/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A102-%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7/1684339190795.png" class width="1684339190795">

<p> 体现业务逻辑的应用层与领域层处于六边形架构的<strong>内核</strong>，并通过内部的六边形边界与基础设施的模块隔离开。当我们在进行软件开发时，只要恪守架构上的六边形边界，则不会让技术实现的复杂度污染到业务逻辑，保证了领域的整洁。边界还隔离了变化产生的影响。如果我们在领域层或应用层抽象了技术实现的接口，再通过依赖注入将控制的方向倒转，业务内核就会变得更加的稳定，不会因为技术选型或其他决策的变化而导致领域代码的修改。 </p>
<h2 id="4、限界上下文的分而治之"><a href="#4、限界上下文的分而治之" class="headerlink" title="4、限界上下文的分而治之"></a>4、限界上下文的分而治之</h2><p>面对一个庞大的问题域，可以划分一些子系统，这些子系统内部也可以进行分层架构。不同子系统之间的抽象层次是一致的，这种概念在DDD中称之为“限界上下文（Bounded Context）”。</p>
<p>通过限界上下文“分而治之”的思想对问题域进行分解，有效地控制了问题域的规模，进而控制了整个系统的规模。</p>
<p> 限界上下文对整个系统进行了划分，在将一个大系统拆分为一个个小系统后，我们再利用分层架构与六边形架构思想对其进行逻辑分层，以确保业务逻辑与技术实现的隔离，其设计会变得更易于把控，系统的架构也会变得更加清晰。 </p>
<p>在一个复杂系统中，可以将识别出来的限界上下文定义为微服务，并对外公开REST服务接口。</p>
<img src="/2023/05/18/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A102-%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7/1684635011835.png" class width="1684635011835">

<p> UI Applications 是一个薄薄的展现层，它会调用后端的 RESTful 服务，也使得服务在保证接口不变的前提下能够单独演化。每个服务都是独立的，可以单独部署，因而可以针对服务建立单独的代码库和对应的特性团队（Feature Team）。服务的重用性和可扩展性也有了更好的保障，服务与 UI 之间的集成变得更简单，整个架构会更加清晰。 </p>
<h2 id="5、领域模型对领域知识的抽象"><a href="#5、领域模型对领域知识的抽象" class="headerlink" title="5、领域模型对领域知识的抽象"></a>5、领域模型对领域知识的抽象</h2><p>以一个软件项目管理流程来举例子。在一个团队中，使用的软件开发流程大致有如下几类：</p>
<p>瀑布式开发： 需求、分析、设计、编码、测试、验收 </p>
<p>RUP（ Rational Unified Process 统一软件开发过程）： 先启阶段（Inception）、细化阶段（Elaboration）、构造阶段（Construction）与交付阶段（Transition）。 每个阶段可以包含一到多个迭代，每个迭代有不同的工作，如业务建模、分析设计、配置与变更管理 </p>
<p> XP（ Extreme Programming ）： 极限编程作为一种敏捷方法，迭代的增量式开发。先做预研（ Architectual Spike，又被译为架构穿刺 ），初始方案确定后就可以进入每次小版本的交付（Release Planning）。 每个小版本交付又被划分为多个周期相同的迭代。在迭代过程中，要求执行一些必须的活动，如编写用户故事、故事点估算、验收测试等。</p>
<p> Scrum：确定系统待办项（Product Backlog）、指定发布计划和组件团队、Sprint迭代。 Sprint 迭代过程是一个固定时长的项目过程，在这个过程中，整个团队需要召开计划会议、每日站会（Daliy Scrum）、评审会议（Sprint Review）和回顾会议（Sprint Retrospective）。</p>
<h3 id="领域分析"><a href="#领域分析" class="headerlink" title="领域分析"></a>领域分析</h3><p> 领域建模就是要从这些纷繁复杂的领域逻辑中寻找到能够表示项目管理领域的概念，并利用面向对象建模范式或其他范式对概念进行抽象，并确定它们之间的关系。</p>
<p>上面说的几种开发流程在概念上会有差别，比如瀑布模式有六个节阶段，但是没有发布、迭代这些概念。RUP有阶段，有迭代，但是没有发布。Scrum又为迭代引入了Sprint概念。</p>
<p>除了业务概念外，他们的业务规则也会有不一样的地方。</p>
<ul>
<li>首先，从项目管理系统的角度看，无论针对何种项目管理流程，我们的主题需求是不变的，就是要为这些管理流程制定软件开发计划（Plan）</li>
<li> 计划可以由多个阶段（Phase）组成 </li>
<li> 阶段（Phase）包含了发布（Release）</li>
<li> 每个发布又包含了一到多个迭代（Iteration）</li>
<li> 每个迭代可以开展多种不同的活动（Activity）</li>
<li> 对于计划而言，我们还需要跟踪任务（Task） </li>
</ul>
<p>所以我们可以根据上述分析提炼出统一的领域模型：</p>
<img src="/2023/05/18/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A102-%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7/1684637274676.png" class width="1684637274676">

<p> 项目管理者更加方便地制定项目计划，产品经理提出了计划模板功能。当管理者选择对应的项目管理生命周期类型后，系统会自动创建满足其规则的初始计划。 在模型中，LifeCycle Specification 是一个隐含的概念，遵循领域驱动设计提出的规格（Specification）模式，封装了项目开发生命周期的约束规则。</p>
<p>领域模型以可视化的方式清晰地表达了业务含义， 我们可以根据这个模型来指导后面的程序设计与编码实现，当需求有变更的时候可以根据模型进行更新。同时，领域建模可以很好在团队之间传递知识， 有利于让开发人员从纷繁复杂的业务中解脱出来，从而可以在一定程度上控制业务的复杂度对我们软件交付的影响。</p>
]]></content>
      <categories>
        <category>领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>领域驱动设计</tag>
        <tag>软件复杂性</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计04-限界上下文</title>
    <url>/2023/06/06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A104-%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="1、-限界上下文的含义"><a href="#1、-限界上下文的含义" class="headerlink" title="1、 限界上下文的含义"></a>1、 限界上下文的含义</h2><p>限界上下文(Bounded Context)， <strong>Context</strong> 表现了业务流程的场景片段。整个业务流程由诸多具有时序的活动组成，随着流程的进行，不同的活动需要不同的角色参与，并导致上下文因为某个活动的产生随之发生切换。因而，<strong>上下文（Context）其实是动态的业务流程被边界（Bounded）静态切分的产物</strong>。 </p>
<p> 一个复杂系统的领域驱动设计，就是以子域为中心进行领域建模，绘制出一张一张的领域模型设计，然后以此作为基础指导程序设计。这一张一张的领域模型设计，称为“<strong>限界上下文</strong>”（Context Bounds，CB）。  根据<strong>业务相关性</strong>、<strong>耦合的强弱程度</strong>、<strong>分离的关注点</strong>对这些活动进行归类，找到不同类别之间存在的边界，这就是<strong>限界上下文</strong>的含义。<strong>上下文（Context）是业务目标，限界（Bounded）则是保护和隔离上下文的边界，避免业务目标的不单一而带来的混乱与概念的不一致。</strong> </p>
<h2 id="2、限界上下文的价值"><a href="#2、限界上下文的价值" class="headerlink" title="2、限界上下文的价值"></a>2、限界上下文的价值</h2><p>观察角度的不同，限界上下文划定的边界也有所不同。大体可以分为如下三个方面：</p>
<ul>
<li><strong>领域逻辑层面</strong>：限界上下文确定了领域模型的业务边界，维护了模型的完整性与一致性，从而降低系统的业务复杂度。</li>
<li><strong>团队合作层面</strong>：限界上下文确定了开发团队的工作边界，建立了团队之间的合作模式，避免团队之间的沟通变得混乱，从而降低系统的管理复杂度。</li>
<li><strong>技术实现层面</strong>：限界上下文确定了系统架构的应用边界，保证了系统层和上下文领域层各自的一致性，建立了上下文之间的集成方式，从而降低系统的技术复杂度。</li>
</ul>
<p>这三种边界体现了<strong>限界上下文对不同边界的控制力</strong>。业务边界是对领域模型的控制，工作边界是对开发协作的控制，应用边界是对技术风险的控制。引入限界上下文的目的，其实<strong>不在于如何划分边界，而在于如何控制边界</strong>。 </p>
<p>  EventStorming 创始人 Alberto Brandolini  对限界上下文的理解： bounded context are a mean of safety（限界上下文意味着安全），如何理解安全呢？</p>
<p>他的意思是：  being in control and no surprise。</p>
<blockquote>
<p> Surprise leads to stress and stress leads to no learning, just hard work. （出乎意料的惊讶会导致压力，而压力就会使得团队疲于加班，缺少学习。） </p>
</blockquote>
<p>其实限界上下文并不是大多数人理解的那样，是模块、服务、组件或者子系统，而是你对领域模型、团队合作以及技术风险的<strong>控制</strong>。大领域的模型切割成一个一个小的领域模型是很重要的， <strong>更小的模型为我们的软件设计和开发带来了更多的好处，它使得团队能够根据自己的设计和开发职责确定更为明确的</strong>工作边界 。</p>
<p>小的模型也为项目带来了更好的可维护性：由于上下文由边界确定，因此对其的修改也不会给整个模型的其他部分造成影响。显然，通过限界上下文对领域模型进行分解，就能保证在其边界内创建的模型<strong>内聚性更高</strong>，在<strong>边界隔离</strong>下，受到变化的影响也更小，反映为团队合作的工作边界，就更容易保证团队之间的沟通与协作。 </p>
<p>限界上下文是“<strong>分而治之</strong>”架构原则的体现，我们引入它的目的其实为了控制（应对）软件的复杂度，它并非某种固定的设计单元，我们不能说它就是模块、服务或组件，而是通过它来帮助我们做出高内聚低耦合的设计。</p>
<p>可以把限界上下文看成是一个“自治”的单元。 所谓“自治”就是满足四个特征：最小完备、稳定空间、自我履行、独立进化。如下图所示的自治单元就是限界上下文，映射到编码实现，则<strong>可能</strong>是模块、组件或服务： </p>
<img src="/2023/06/06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A104-%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/1685462880155.png" class width="1685462880155">

<p> <strong>最小完备</strong>是实现“自治”的基本条件。自治单元的职责是完整的，不需要依赖别的单元的功能。最小完备是指不要将不必要的职责被错误地添加到该自治单元内。</p>
<p><strong>自我履行</strong>表示自治单元自身决定需要做什么， 从拟人的角度来思考，就是这些自治单元能够对外部请求做出符合自身利益的明智判断，是否应该履行该职责，由限界上下文拥有的信息来决定。 例如，在当订单上下文履行了验证订单的职责之后，需要执行支付活动时，由于与支付相关的业务行为要操作的信息已经超出了订单上下文的范畴，就应该将该职责转移到支付上下文。自我履行其实意味着对知识的掌握，为避免风险，你要履行的职责一定是你掌握的知识范畴之内。 </p>
<p><strong>稳定空间</strong>指的是减少外界变化对限界上下文内部的影响。  稳定空间符合<strong>开放封闭原则（OCP）</strong>，即对修改是封闭的，对扩展是开放的，该原则其实体现了一个单元的封闭空间与开放空间。封闭空间体现为对细节的封装与隐藏，开放空间体现为对共性特征的抽象与统一，二者共同确保了整个空间的稳定。</p>
<p><strong>独立进化</strong>与稳定空间刚好相反，指的是减少限界上下文的变化对外界的影响。 如果借用限界上下文的上下游关系来阐释，则<strong>稳定空间</strong>寓意下游限界上下文，无论上游怎么变，我自岿然不动；<strong>独立进化</strong>寓意上游限界上下文，无论下游有多少，我凌寒独自开。实现上看，要做到独立进化，就必须保证对外公开接口的稳定性，因为这些接口往往被众多消费者使用，一旦修改，就会牵一发而动全身。一个独立进化的限界上下文，需要接口设计良好，符合标准规范，并在版本上考虑了兼容与演化。 </p>
<p>这四个要素是<strong>高内聚低耦合</strong>思想的体现。我们需要根据业务关注点和技术关注点，尽可能将强相关性的内容放到同一个限界上下文中，同时降低限界上下文之间的耦合。对于整个系统架构而言，不同的限界上下文可以采用不同的架构风格与技术决策，而在每个限界上下文内部保持自己的技术独立性与一致性。由于限界上下文边界对技术实现的隔离，不同限界上下文内部实现的多样性并不会影响整体架构的一致性。</p>
<h2 id="3、-限界上下文分离了业务边界"><a href="#3、-限界上下文分离了业务边界" class="headerlink" title="3、 限界上下文分离了业务边界"></a>3、 限界上下文分离了业务边界</h2><p>引入限界上下文的目的，不在于如何划分，而在于如何控制边界。  可以说，<strong>限界上下文是连接问题域与解决方案域的重要桥梁</strong>。 </p>
<p>限界上下文用于区分领域边界，我们在理解领域模型时，是基于当前所在的上下文作为概念语境的， 这样的设计既保证了限界上下文之间的松散耦合，又能够维持限界上下文各自领域模型的一致性，此时的限界上下文成为了保障领域模型不受污染的边界屏障。 </p>
<h2 id="4、-限界上下文明确了工作边界"><a href="#4、-限界上下文明确了工作边界" class="headerlink" title="4、 限界上下文明确了工作边界"></a>4、 限界上下文明确了工作边界</h2><p> 一个理想的开发团队规模最好能符合亚马逊公司提出的“Two-Pizza Teams”，即 <strong>2PTs</strong> 规则，该规则认为“让团队保持在两个披萨能让成员吃饱的小规模”，大体而言，就是将团队成员人数控制在 7~10 人左右。为何要保证这样的规模呢？因为小团队能够更有效保证有效的沟通。</p>
<p> 传统的“组件团队”强调的是专业技能与功能重用，例如，熟练掌握数据库开发技能的成员组建一个数据库团队，深谙前端框架的成员组建一个前端开发团队。这种遵循“专业的事情交给专业的人去做”原则的团队组建模式，可以更好地发挥每个人的技能特长，然而牺牲的却是团队成员业务知识的缺失，客户价值的漠视。这种团队组建模式也加大了团队之间的沟通成本，导致系统的整体功能无法持续和频繁的集成。</p>
<p>特性团队， 是一个<strong>端对端的开发垂直细分领域的跨职能团队</strong>，它将需求分析、架构设计、开发测试等多个角色糅合在一起，专注于领域逻辑，实现该领域特性的完整的端对端开发。 </p>
<img src="/2023/06/06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A104-%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/1686065089311.png" class width="1686065089311">

<p>特性团队专注的领域特性，是与领域驱动设计中限界上下文对应的领域是相对应的。当我们确定了限界上下文时，其实也就等同于确定了特性团队的工作边界，确定了限界上下文之间的关系，也就意味着确定了特性团队之间的合作模式；反之亦然。之所以如此，则是因为<strong>康威定律（Conway’s Law）</strong>为我们提供了理论支持 </p>
<p><strong>康威定律</strong>认为：“任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。” <strong>在康威定律中起到关键杠杆作用的是沟通成本</strong>。如果同一个限界上下文的工作交给了两个不同的团队分工完成，为了合力解决问题，就必然需要这两个团队进行密切的沟通。然而，团队间的沟通成本显然要高于团队内的沟通成本，为了降低日趋增高的成本，就需要重新划分团队。反过来，如果让同一个团队分头做两个限界上下文的工作，则会因为工作的弱相关性带来自然而然的团队隔离。 </p>
<h2 id="5、-限界上下文封装了应用边界"><a href="#5、-限界上下文封装了应用边界" class="headerlink" title="5、 限界上下文封装了应用边界"></a>5、 限界上下文封装了应用边界</h2><p>在划分上下文的时候，不能值满足于业务边界的确立，还需要从控制技术复杂度的角度来考虑技术实现。高并发系统，功能重用，实时性，第三服务集成，遗留系统等案例从技术层面为系统划分边界，这种边界也是由限界上下文完成的，以形成对技术实现的隔离，避免不同的技术方案选择互相干扰导致架构混乱。</p>
]]></content>
      <categories>
        <category>领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>领域驱动设计</tag>
        <tag>限界上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计03-应用领域场景分析提炼领域知识</title>
    <url>/2023/05/25/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A103-%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%E6%8F%90%E7%82%BC%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="领域场景分析的-6W-模型"><a href="#领域场景分析的-6W-模型" class="headerlink" title="领域场景分析的 6W 模型"></a>领域场景分析的 6W 模型</h2><p> 组成场景的要素常常被称之为 <strong>6W 模型</strong>，即描写场景的过程必须包含 <strong>W</strong>ho、<strong>W</strong>hat、<strong>W</strong>hy、<strong>W</strong>here、<strong>W</strong>hen 与 ho<strong>W</strong> 这六个要素。</p>
<p> 在 6W 模型中，可以将领域功能划分为三个层次，即业务价值、业务功能和业务实现。</p>
<p><img src="/2023/05/25/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A103-%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%E6%8F%90%E7%82%BC%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/1685026515876.png" alt="1685026515876"></p>
<p>在分析一个需求的时候，要建立场景，识别该场景中的用户角色（Who），通过分析改用户的特征与属性 来辨别该角色在整个场景中参与的活动。这意味着我们需要明确业务功能（What），思考这一功能给该角色能够带来什么样的业务价值（Why）。在不同场景中同一个用户可能代表不同的角色，比如在订单系统中，角色就是买家；在评论系统中，角色变成了评论者。</p>
<p> 在利用场景进行建模时，还要充分考虑场景的边界，即 6W 模型中的 Where。例如，在“下订单”的案例中，验证商品库存量的业务实现需要调用库存提供的接口，该功能属于下订单场景的边界之外。领域驱动设计引入了<strong>限界上下文（Bounded Context）</strong>来解决这一问题。 </p>
<p> 业务场景分析的 6W 模型给出了具有指导意义的约束，要求我们提炼的领域知识必须具备模型的六个要素。 6W 模型也是对领域逻辑的一种检验，如果提炼出来的领域逻辑缺乏部分要素，就有可能忽略一些重要的领域概念、规则与约束。这种缺失会对后续的领域建模直接产生影响。</p>
<h2 id="领域场景分析的方法"><a href="#领域场景分析的方法" class="headerlink" title="领域场景分析的方法"></a>领域场景分析的方法</h2><p> 如果将 6W 模型看做是领域分析的抽象，那么这些领域分析方法就是对 6W 模型各种不同的实现。 这些模式主要有：</p>
<ul>
<li>用例（Use Case）</li>
<li>用户故事（User Story）</li>
<li>测试驱动开发（TDD）</li>
</ul>
<p>用例尤其是用例图的抽象能力更强，更擅长于对系统整体需求进行场景分析；用户故事提供了场景分析的固定模式，善于表达具体场景的业务细节；测试驱动开发则强调对业务的分解，利用编写测试用例的形式驱动领域建模，即使不采用测试先行，让开发者转换为调用者角度去思考领域对象及行为，也是一种很好的建模思想与方法。 </p>
<p>在提炼领域知识的过程中，我们可以将这三种领域场景分析方法结合起来运用，在不同层次的领域场景中选择不同的场景分析方法，才不至于好高骛远，缺乏对细节的把控，也不至于一叶障目，只见树木不见森林。 </p>
]]></content>
      <categories>
        <category>领域驱动设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>领域驱动设计</tag>
      </tags>
  </entry>
  <entry>
    <title>任务和任务槽Slot</title>
    <url>/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/</url>
    <content><![CDATA[<h1 id="任务槽-（Task-Slots）"><a href="#任务槽-（Task-Slots）" class="headerlink" title="任务槽 （Task Slots）"></a>任务槽 （Task Slots）</h1><p>Flink 中每一个 worker(也就是 TaskManager)都是一个 JVM 进程，它可 6以启动多个独立的线程，来并行执行多个子任务（subtask）。</p>
<p>任务槽（task slot）其实表示了 TaskManager 拥有计算资源的一个固定大小的子集。 这些资源就是用来独立执行一个子任务的 </p>
<img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720134334.png" class width="1693720134334">

<p>假如一个 TaskManager 有三个 slot，那么它会将管理的内存平均分成三份，每个 slot 独自 占据一份。这样一来，我们在 slot 上执行一个子任务时，相当于划定了一块内存“专款专用”，   就不需要跟来自其他作业的任务去竞争内存资源了。所以现在我们只要 2 个 TaskManager，就 可以并行处理分配好的 5 个任务了。</p>
<p>slot 目前仅仅用来<strong>隔离内存</strong>，不会涉及 CPU 的隔离。在具体应用时，可 以将 slot 数量配置为机器的 CPU 核心数，尽量避免不同任务之间对 CPU 的竞争。这也是开发 环境默认并行度设为机器 CPU 数量的原因 。</p>
<h3 id="任务对任务槽的共享"><a href="#任务对任务槽的共享" class="headerlink" title="任务对任务槽的共享"></a>任务对任务槽的共享</h3><img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720264738.png" class width="1693720264738">

<p>默认情况下，Flink 是允许子任务共享 slot 的。 只要属于同一个作业，那么对于不同任务节点的并行子任务，就可以放到同一个 slot 上执行。</p>
<p>每个任务节点的并行子任务一字排开，占据不同的 slot；而不同 的任务节点的子任务可以共享 slot。一个 slot 中，可以将程序处理的所有任务都放在这里执行， 我们把它叫作保存了整个作业的运行管道（pipeline）。 </p>
<p> 我们知道，一个 slot 对应了一组独立的计算资源。在之前不做共享的时候，每个任务都平 等地占据了一个 slot，但其实不同的任务对资源的占用是不同的。例如这里的前两个任务， source/map 尽管是两个算子合并算子链得到的，但它只是基本的数据读取和简单转换，计算耗 时极短，一般也不需要太大的内存空间；而 window 算子所做的窗口操作，往往会涉及大量的 数据、状态存储和计算，我们一般把这类任务叫作“资源密集型”（intensive）任务。当它们 被平等地分配到独立的 slot 上时，实际运行我们就会发现，大量数据到来时 source/map 和 sink 任务很快就可以完成，但 window 任务却耗时很久；于是下游的 sink 任务占据的 slot 就会等待 闲置，而上游的 source/map 任务受限于下游的处理能力，也会在快速处理完一部分数据后阻 塞对应的资源开始等待（相当于处理<strong>背压</strong>）。这样资源的利用就出现了极大的不平衡，“忙的忙 死，闲的闲死”。 解决这一问题的思路就是允许 slot 共享。当我们将资源密集型和非密集型的任务同时放到 一个 slot 中，它们就可以自行分配对资源占用的比例，从而保证最重的活平均分配给所有的 TaskManager。 </p>
<p>同一个任务节点的并行子任务是不能共享 slot 的，所以允许 slot 共享之后，运行作业所需的 slot 数量正好就是作业中所有算子并行度的最大值。这样一来，我们考虑当前集群需 要配置多少 slot 资源时，就不需要再去详细计算一个作业总共包含多少个并行子任务了，只看 最大的并行度就够了。  </p>
<h3 id="任务槽和并行度的关系"><a href="#任务槽和并行度的关系" class="headerlink" title="任务槽和并行度的关系"></a>任务槽和并行度的关系</h3><p>假设一共有 3 个 TaskManager，每一个 TaskManager 中的 slot 数量设置为 3 个，那么一共有 9 个 task slot，表示集群最多能并行执行 9 个任务 </p>
<img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720541867.png" class width="1693720541867">

<p>而我们定义 WordCount 程序的处理操作是四个转换算子： </p>
<blockquote>
<p>source→ flatMap→ reduce→ sink</p>
</blockquote>
<p>当所有算子并行度相同时，容易看出 source 和 flatMap 可以合并算子链，于是最终有三个任务节点.。如果我们没有任何并行度设置，而配置文件中默认 parallelism.default=1，那么程序运行的 默认并行度为 1，总共有 3 个任务。由于不同算子的任务可以共享任务槽，所以最终占用的 slot 只有 1 个。9 个 slot 只用了 1 个，有 8 个空闲。</p>
<img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720650260.png" class width="1693720650260">

<p>设置并行度为 2，那么总共有 6 个任务，共享任 务槽之后会占用 2 个 slot：</p>
<img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720782089.png" class width="1693720782089">

<p>把并行度设置为 9，这样所有 27 个任务就会完全占用 9 个 slot。 这是当前集群资源下能执行的最大并行度，计算资源得到了充分的利用</p>
<img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720792252.png" class width="1693720792252">

<p> 再考虑对于某个算子单独设置并行度的场景。 考虑到输出可能是写入 文件，那会希望不要并行写入多个文件，就需要设置 sink 算子的并行度为 1。这时其他的算子 并行度依然为 9，所以总共会有 19 个子任务。根据 slot 共享的原则，它们最终还是会占用全 部的 9 个 slot，而 sink 任务只在其中一个 slot 上执行</p>
<img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720801175.png" class width="1693720801175">

<p>整个流处理程序的并行度，就应该是所有算子并行度中最大的那个， 这代表了运行程序需要的 slot 数量。</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
        <tag>Slots</tag>
      </tags>
  </entry>
  <entry>
    <title>算子链</title>
    <url>/2023/09/03/%E7%AE%97%E5%AD%90%E9%93%BE/</url>
    <content><![CDATA[<h2 id="并行子任务和并行度"><a href="#并行子任务和并行度" class="headerlink" title="并行子任务和并行度"></a>并行子任务和并行度</h2><p>在 Flink 执行过程中，每一个算子（operator）可以包含一个或多个子任务（operator subtask）， 这些子任务在不同的线程、不同的物理机或不同的容器中完全独立地执行 </p>
<p> <strong>一个特定算子的子任务（subtask）的个数被称之为其并行度（parallelism）。</strong> </p>
<p>包含并行子任务的数据流，就是<strong>并行数据流</strong>，它需要多个分区（stream partition）来分配并行任 </p>
<h2 id="算子间的数据传输"><a href="#算子间的数据传输" class="headerlink" title="算子间的数据传输"></a>算子间的数据传输</h2><img src="/2023/09/03/%E7%AE%97%E5%AD%90%E9%93%BE/1693722079994.png" class width="1693722079994">

<p>一个数据流在算子之间传输数据的形式可以是一对一（one-to-one）的直 通 (forwarding)模式，也可以是打乱的重分区（redistributing）模式，具体是哪一种形式，取决 于算子的种类。</p>
<p> （1）一对一（One-to-one，forwarding） </p>
<p>数据流维护着分区以及元素的顺序。比如图中的 source 和 map 算子，source 算子读取数据之后，可以直接发送给 map 算子做处理，它们之间不需要重新分区，也不需要 调整数据的顺序。这就意味着 map 算子的子任务，看到的元素个数和顺序跟 source 算子的子 任务产生的完全一样，保证着“一对一”的关系。map、filter、flatMap 等算子都是这种 one-to-one 的对应关系 </p>
<p> （2）重分区（Redistributing） </p>
<p>在这种模式下，数据流的分区会发生改变。比图中的 map 和后面的 keyBy/window 算子之 间（这里的 keyBy 是数据传输算子，后面的 window、apply 方法共同构成了 window 算子）, 以及 keyBy/window 算子和 Sink 算子之间，都是这样的关系。</p>
<h2 id="合并算子链"><a href="#合并算子链" class="headerlink" title="合并算子链"></a>合并算子链</h2><p>在 Flink 中，并行度相同的一对一（one to one）算子操作，可以直接链接在一起形成一个 “大”的任务（task），这样原来的算子就成为了真正任务里的一部分 </p>
<p>每个 task  会被一个线程执行。这样的技术被称为“算子链”（Operator Chain）。 </p>
<img src="/2023/09/03/%E7%AE%97%E5%AD%90%E9%93%BE/1693722193555.png" class width="1693722193555">

<p>Source 和 map 之间满足了算子链的要求，所以可以直接合并 在一起，形成了一个任务；因为并行度为 2，所以合并后的任务也有两个并行子任务。这样， 这个数据流图所表示的作业最终会有 5 个任务，由 5 个线程并行执行 </p>
<p> <strong>将算子链接成 task 是非常有效的优 化：可以减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量。</strong> </p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
      <tags>
        <tag>Flink</tag>
        <tag>Operator Chain</tag>
      </tags>
  </entry>
  <entry>
    <title>castile-rpc框架</title>
    <url>/2023/09/03/castile-rpc%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="RPC服务框架架构"><a href="#RPC服务框架架构" class="headerlink" title="RPC服务框架架构"></a>RPC服务框架架构</h1><img src="/2023/09/03/castile-rpc%E6%A1%86%E6%9E%B6/1693723330951.png" class width="1693723330951">

<p>RPC又称远程过程调用（Remote Procedure Call），用于解决分布式系统中服务之间的调用问题。他可以实现开发者能够像调用本地的方法一样去调用远程的服务。包含了三个重要的组成部分，分别是注册中心、服务提供者、服务消费者，其中，服务消费者也称之为客户端。</p>
<p>在一次RPC调用的时候，这三个组成部分的交互过程大致如下：</p>
<p>1、 服务提供者（微服务）启动的时候，会将自己的对外开发的服务列表（接口信息）注册到服务中心中，消费者想注册中心去订阅服务提供者的地址。</p>
<p>2、 消费者会通过一个本地的代理模块区调用服务提供者，这个代理Proxy模块会将调用的方法。参数等数据封装成网络字节流的形式去传输</p>
<p>3、在传输之前需要确定发给哪一个服务端，因此会先从服务列表中选取一个服务地址（可以做负载均衡），并将数据通过网络发送给服务端。</p>
<p>4、 服务提供者接受到消息后，进行解码，拿到要调用的方法和参数。</p>
<p>5、服务提供者根据解码后的请求去调用对应的服务，然后将返回结果封装成字节流发送给服务消费者。</p>
<h1 id="服务的注册和发现"><a href="#服务的注册和发现" class="headerlink" title="服务的注册和发现"></a>服务的注册和发现</h1><p>首先最重要的是服务提供者可以去注册到注册中心，消费者可以去注册中心订阅服务。</p>
<p>为什么要有注册中心呢？传统的分布式系统一般是通过http去调用远端服务，这往往需要知道具体的服务端地址、调用信息等，系统之间的耦合比较严重，为了更好的去洁癖客户端和服务端，引入了注册中心，可以优雅地处理服务的上线和下线。</p>
<p>注册中心实现服务的注册和发现功能。服务端自行注册服务列表，服务下线的时候需要将自己的服务列表元数据移除，并可通知对应的客户端。客户端发起调用的时候，自己去订阅获取注册中心的服务列表，并通过一些负载均衡算法选择其中的一个实例进行调用，</p>
<p>那么，如何处理服务下线的问题，服务下线是需要移除注册中心该服务的一些信息的，最能想到的办法就是，服务端主动发送清理消息给注册中心，但是如果服务节点异常退出，比如节点断点了，断网等，还来不及发送消息给注册中心，那么注册中心就一直存在异常服务节点的元数据了，从而可能会造成服务调用失败的问题。</p>
<p>为了避免上述问题，实现服务优雅下线比较好的方式是采用<strong>主动通知 + 心跳检测</strong>的方案。除了主动通知注册中心下线外，还需要增加节点与注册中心的心跳检测功能，这个过程也叫作探活。心跳检测可以由节点或者注册中心负责，例如注册中心可以向服务节点每 60s 发送一次心跳包，如果 3 次心跳包都没有收到请求结果，可以任务该服务节点已经下线 </p>
<h1 id="通信协议和序列化"><a href="#通信协议和序列化" class="headerlink" title="通信协议和序列化"></a>通信协议和序列化</h1><p>RPC 是远程调用，必然离不开网络通信协议。客户端在向服务端发起调用之前，需要考虑采用何种方式将调用信息进行编码，并传输到服务端。因为 RPC 框架对性能有非常高的要求，所以通信协议应该越简单越好，这样可以减少编解码的性能损耗。</p>
<p>RPC 框架可以基于不同的协议实现，大部分主流 RPC 框架会选择 TCP、HTTP 协议，出名的 gRPC 框架使用的则是 HTTP2。TCP、HTTP、HTTP2 都是稳定可靠的，但其实使用 UDP 协议也是可以的，具体看业务使用的场景 。</p>
<p>客户端和服务端在通信过程中要传输的数据主要有：</p>
<blockquote>
<ol>
<li>调用的接口名称</li>
<li>方法</li>
<li>请求参数</li>
<li>调用属性等信息</li>
</ol>
</blockquote>
<p>这些数据需要在客户端序列化成二进制，通过网络传输到服务端。服务端需要通过反序列化得到调用的信息，然后利用反射调用对应的方法，最后将结果、状态码、异常等信息返回。</p>
<h1 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h1><h2 id="1、-同步调用"><a href="#1、-同步调用" class="headerlink" title="1、 同步调用"></a>1、 同步调用</h2><p>客户端线程发起RPC调用后会一直阻塞，知道拿到返回的结果。</p>
<h2 id="2、-异步调用"><a href="#2、-异步调用" class="headerlink" title="2、 异步调用"></a>2、 异步调用</h2><p>客户端发起调用后不会再阻塞等待，而是拿到 RPC 框架返回的 Future 对象，调用结果会被服务端缓存，客户端自行决定后续何时获取返回结果 </p>
<h2 id="3、-回调调用"><a href="#3、-回调调用" class="headerlink" title="3、 回调调用"></a>3、 回调调用</h2><p>客户端发起调用的时候，将callback对象传给rpc框架，无需等待结果。当得到服务端响应结果或者超时的时候，会执行用户注册的回调函数。callback一般包含onResponse 和 onException 两个方法，分别对应成功返回和异常返回两种情况。</p>
<h2 id="4、-OneWay单向调用"><a href="#4、-OneWay单向调用" class="headerlink" title="4、 OneWay单向调用"></a>4、 OneWay单向调用</h2><p> 客户端发起请求之后直接返回 ，忽略他的返回结果。</p>
<h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>线程模型是RPC框架重要关注的部分，首先需要知道IO线程和业务线程的区别。</p>
<p>以Dubbo框架为例， Dubbo 使用 Netty 作为底层的网络通信框架，采用了我们熟悉的主从 Reactor 线程模型，其中 Boss 和 Worker 线程池就可以看作 I/O 线程。I/O 线程可以理解为主要负责处理网络数据，例如事件轮询、编解码、数据传输等。</p>
<p>业务逻辑如果能够立即完成，也可以使用 I/O 线程进行处理，这样可以省去线程上下文切换的开销。如果业务逻辑耗时较多，例如包含查询数据库、复杂规则计算等耗时逻辑，那么 I/O 必须将这些请求分发到业务线程池中进行处理，以免阻塞 I/O 线程 </p>
<p> 那么哪些请求需要在 I/O 线程中执行，哪些又需要在业务线程池中执行呢？Dubbo 框架的做法值得借鉴，它给用户提供了多种选择，它一共提供了 5 种分发策略，如下表格所示 </p>
<table>
<thead>
<tr>
<th>策略类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>所有的请求、事件、心跳等都发送到业务线程池，也就是说Worker线程接收到事件后，会将事件提交到业务线程池中</td>
</tr>
<tr>
<td>connection</td>
<td>连接建立、断开事件放入队列排队执行，其他所有的消息都分发到业务线程池执行</td>
</tr>
<tr>
<td>direct</td>
<td>所有事件都在IO线程池中执行</td>
</tr>
<tr>
<td>execution</td>
<td>只有请求类的消息分发到业务线程池中执行，响应和其他事件消息直接在IO线程池中处理</td>
</tr>
<tr>
<td>message</td>
<td>只有请求响应消息被分发到业务线程池中执行，其他事件消息都在IO线程池中执行</td>
</tr>
</tbody></table>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>服务提供者和服务消费者多实例的，如何保证服务提供者的所有节点的负载均衡呢。主流的方法有以下几种：</p>
<p> <strong>Round-Robin 轮询</strong>。 </p>
<p> <strong>Weighted Round-Robin 权重轮询</strong> </p>
<p> <strong>Least Connections 最少连接数</strong> </p>
<p> <strong>Consistent Hash 一致性 Hash</strong>。 </p>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>castile-rpc框架：服务的注册与发现</title>
    <url>/2023/09/24/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="先考虑用户应该如何使用"><a href="#先考虑用户应该如何使用" class="headerlink" title="先考虑用户应该如何使用"></a>先考虑用户应该如何使用</h1><h2 id="1、-服务端"><a href="#1、-服务端" class="headerlink" title="1、 服务端"></a>1、 服务端</h2><p>服务端定义一个服务接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-03 15:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打招呼</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 姓名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现服务接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-03 15:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RpcService(serviceInterface = HelloService.class, serviceVersion = &quot;1.0.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在服务端启动的时候会向注册中心注册这个服务。</p>
<h2 id="2、-消费端"><a href="#2、-消费端" class="headerlink" title="2、 消费端"></a>2、 消费端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RpcReference(serviceVersion = &quot;1.0.0&quot;, timeout = 3000)</span></span><br><span class="line">    <span class="keyword">private</span> HelloFacade helloFacade;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloFacade.hello(<span class="string">&quot;mini rpc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="服务提供者提供服务"><a href="#服务提供者提供服务" class="headerlink" title="服务提供者提供服务"></a>服务提供者提供服务</h1><h2 id="1、RPC服务端"><a href="#1、RPC服务端" class="headerlink" title="1、RPC服务端"></a>1、RPC服务端</h2><p>服务提供者采用的是主从 Reactor 线程模型，启动过程包括配置线程池、Channel 初始化、端口绑定三个步骤 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.castile.rpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.castile.rpc.provider.autoconfig.RpcProperties;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动RPC服务端，</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务启动的时候进行服务发现与注册</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-03 22:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServerRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RpcProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String address = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap().group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line">                            <span class="comment">// TODO 添加其他处理器， 如：编解码，消息请求处理</span></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(address, <span class="keyword">this</span>.properties.getPort()).sync();</span><br><span class="line">            log.info(<span class="string">&quot;连接信息：server addr &#123;&#125; started on port &#123;&#125;&quot;</span>, address, <span class="keyword">this</span>.properties.getPort());</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2、发布服务"><a href="#2、发布服务" class="headerlink" title="2、发布服务"></a>2、发布服务</h2><p>定义一个注解，用于标识一个服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.castile.rpc.provider;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * rpc服务注解</span><br><span class="line"> *</span><br><span class="line"> * @author Hongliang Zhu</span><br><span class="line"> * @create 2023-09-03 15:51</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Component</span><br><span class="line">public @interface RpcService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 服务所在的接口</span><br><span class="line">     *</span><br><span class="line">     * @return 服务接口</span><br><span class="line">     */</span><br><span class="line">    Class&lt;?&gt; serviceInterface() default Object.class;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 服务版本</span><br><span class="line">     *</span><br><span class="line">     * @return 版本</span><br><span class="line">     */</span><br><span class="line">    String version() default &quot;1.0.0&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有两个重要的属性，serviceInterface表示服务类型接口，version表示服务版本。 服务消费者必须指定完全一样的属性才能正确调用。有了 @RpcService 注解之后，我们就可以在服务实现类上使用它。</p>
<p>@RpcService 注解本质上就是 @Component，可以将服务实现类注册成 Spring 容器所管理的 Bean。这里需要了解Spring中Bean的生命周期了。</p>
<img src="/2023/09/24/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/1693753942141.png" class width="1693753942141">

<p>Spring的BeanPostProcessor接口提供了对Bean进行再加工的扩展点。 BeanPostProcessor 常用于处理自定义注解。自定义的 Bean 可以通过实现 BeanPostProcessor 接口，在 Bean 实例化的前后加入自定义的逻辑处理。如下所示，我们通过 RpcProvider 实现 BeanPostProcessor 接口，来实现对 声明 @RpcService 注解服务的自定义处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.castile.rpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.castile.rpc.provider.autoconfig.RpcProperties;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描<span class="doctag">@RpcService</span>注解，注册到注册中心中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-03 23:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcProviderProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; rpcServices = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RpcProperties properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        RpcService rpcService = bean.getClass().getAnnotation(RpcService.class);</span><br><span class="line">        <span class="keyword">if</span> (rpcService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String serviceName = rpcService.serviceInterface().getName();</span><br><span class="line">            String serviceVersion = rpcService.version();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String address = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                ServiceMetaData serviceMetaData = <span class="keyword">new</span> ServiceMetaData();</span><br><span class="line">                serviceMetaData.setPort(properties.getPort());</span><br><span class="line">                serviceMetaData.setServiceAddr(address);</span><br><span class="line">                serviceMetaData.setServiceName(serviceName);</span><br><span class="line">                serviceMetaData.setServiceVersion(serviceVersion);</span><br><span class="line">                <span class="comment">// TODO 封装注册信息，注册到注册中心</span></span><br><span class="line"></span><br><span class="line">                rpcServices.put(serviceName + <span class="string">&quot;#&quot;</span> + serviceVersion, bean);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;failed to register service &#123;&#125;#&#123;&#125;&quot;</span>, serviceName, serviceVersion, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="服务消费者订阅服务"><a href="#服务消费者订阅服务" class="headerlink" title="服务消费者订阅服务"></a>服务消费者订阅服务</h1><p>消费者不属于常驻服务， 每次发起 RPC 调用时它才会去选择向哪个远端服务发送数据。 对于声明 @RpcReference 注解的成员变量，我们需要构造出一个可以真正进行 RPC 调用的 Bean，然后将它注册到 Spring 的容器中。</p>
<p> @RpcReference 注解的定义 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcReference &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用的服务版本</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">serviceVersion</span><span class="params">()</span> <span class="keyword">default</span> &quot;1.0.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rpc调用的超时时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 3000</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要为使用了@RpcReference注解的成员变量构造成一个自定义的bean对象，并且对该bean对象执行的所有方法进行拦截。</p>
<p>Spring 的 FactoryBean 接口可以帮助我们实现自定义的 Bean，FactoryBean 是一种特种的工厂 Bean，通过 getObject() 方法返回对象，而并不是 FactoryBean 本身。 </p>
<p>有了 @RpcReference 注解和 RpcReferenceBean 之后，我们可以使用 Spring 的扩展点 BeanFactoryPostProcessor 对 Bean 的定义进行修改。上文中服务提供者使用的是 BeanPostProcessor，BeanFactoryPostProcessor 和 BeanPostProcessor 都是 Spring 的核心扩展点，它们之间有什么区别呢？BeanFactoryPostProcessor 是 Spring 容器加载 Bean 的定义之后以及 Bean 实例化之前执行，所以 BeanFactoryPostProcessor 可以在 Bean 实例化之前获取 Bean 的配置元数据，并允许用户对其修改。而 BeanPostProcessor 是在 Bean 初始化前后执行，它并不能修改 Bean 的配置信息。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcConsumerPostProcessor</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INIT_METHOD_NAME = <span class="string">&quot;init&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; rpcRefBeanDefinitions = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        String[] beanDefinitionNames = configurableListableBeanFactory.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String beanDefName : beanDefinitionNames) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = configurableListableBeanFactory.getBeanDefinition(beanDefName);</span><br><span class="line">            <span class="keyword">final</span> String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">            <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = ClassUtils.resolveClassName(beanClassName, <span class="keyword">this</span>.classLoader);</span><br><span class="line">                ReflectionUtils.doWithFields(clazz, <span class="keyword">this</span>::parseRpcReference);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// beanClassName = null</span></span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) configurableListableBeanFactory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.rpcRefBeanDefinitions.forEach((beanName, definition) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.containsBean(beanName)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;application  context already has a bean named &quot;</span> + beanName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注册到spring中</span></span><br><span class="line">                registry.registerBeanDefinition(beanName, rpcRefBeanDefinitions.get(beanName));</span><br><span class="line">                log.info(<span class="string">&quot;registered RpcReferenceBean &#123;&#125; success.&quot;</span>, beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = applicationContext;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseRpcReference</span><span class="params">(Field field)</span> </span>&#123;</span><br><span class="line">        RpcReference annotation = AnnotationUtils.getAnnotation(field, RpcReference.class);</span><br><span class="line">        <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(RpcReferenceBean.class);</span><br><span class="line">            builder.setInitMethodName(INIT_METHOD_NAME);</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;interfaceClass&quot;</span>, field.getType());</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;serviceVersion&quot;</span>, annotation.serviceVersion());</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;timeout&quot;</span>, annotation.timeout());</span><br><span class="line">            AbstractBeanDefinition definition = builder.getBeanDefinition();</span><br><span class="line">            rpcRefBeanDefinitions.put(field.getName(), definition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>castile-rpc框架：服务治理-服务发现和负载均衡</title>
    <url>/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p>在一个分布式系统中，每个服务都有多个实例，如果服务实例节点出现负载比较高，那么可能会导致该节点上面的请求处理超时，影响可用性。so，一个良好的rpc框架需要 实现合理的负载均衡算法。</p>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>服务消费者在发起请求之前都需要根据需要调用的服务去服务中心去找那些服务端实例，而且每个服务都有上线和下线的概念，因此消费端还需要感知服务提供者的实例变化，在rpc框架中，一般使用注册中心来实现服务的发现和注册。</p>
<p>主流的注册中心有zookeeper、Eureka、Etcd？Consul、Nacos等， 高可用的注册中心对 RPC 框架至关重要。说到高可用自然离不开 CAP 理论，一致性 Consistency、可用性 Availability 和分区容忍性 Partition tolerance 是无法同时满足的，注册中心一般分为 <strong>CP 类型注册中心</strong>和 <strong>AP 类型注册中心</strong> 。</p>
<p>● 一致性：指所有节点在同一时刻的数据完全一致。</p>
<p>● 可用性：指服务一直可用，而且响应时间正常。例如，不管什么时候访问X节点和Y节点都可以正常获取数据值，而不会出现问题。</p>
<p>● 分区容错性：指在遇到某节点或网络分区故障时，仍然能够对外提供满足一致性和可用性的服务。例如X节点和Y节点出现故障，但是依然可以很好地对外提供服务 </p>
<p><strong>CAP的取舍</strong>:</p>
<p>1、 满足CA舍弃P，也就是满足一致性和可用性，舍弃分区容错性。这也就意味着你的系统不是分布式的了，因为分布式就是把功能分开部署到不同的机器上。</p>
<p>2、满足CP舍弃A，也就是满足一致性和分区容错性，舍弃可用性。这也就意味着你的系统允许有一段时间访问失效等，不会出现数据不一致的情况。</p>
<p>3、满足AP舍弃C，也就是满足可用性和分区容错性，舍弃一致性。这也就意味着你的系统在并发访问的时候可能会出现数据不一致的情况。</p>
<p>在分布式系统中，为了避免单点故障，分区容错是不可避免的，所以对于注册中心来说只能从CP（优先保证数据一致性）、AP（优先保证数据可用性）中根据你的业务场景选择一种。</p>
<p> 使用最为广泛的 Zookeeper 就是 CP 类型的注册中心，集群中会有一个节点作为 Leader，如果 Leader 节点挂了，会重新进行 Leader 选举，ZooKeeper 保证了所有节点的强一致性，但是在 Leader 选举的过程中是无法对外提供服务的，牺牲了部分可用性。Eureka 是典型的 AP 类型注册中心，在实现服务发现的场景下有很大的优势，整个集群是不存在 Leader、Flower 概念的，如果其中一个节点挂了，请求会立刻转移到其他节点上。可能会存在的问题是如果不同分区无法进行节点通信，那么可能会造成节点之间的数据是有差异的，所以 AP 类型的注册中心通过牺牲强一致性来保证高可用性 。 </p>
<p>对于 RPC 框架而言，即使注册中心出现问题，也不应该影响服务的正常调用，所以 AP 类型的注册中心在该场景下相比于 CP 类型的注册中心更有优势。 对于成熟的 RPC 框架而言，会提供多种注册中心的选择，接下来我们便设计一个通用的注册中心接口，然后每种注册中心的实现都按该接口规范行扩展。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册微服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceMetaData 服务元数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(ServiceMetaData serviceMetaData)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(ServiceMetaData serviceMetaData)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServiceMetaData <span class="title">discovery</span><span class="params">(String serviceName, <span class="keyword">int</span> invokerHashCode)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> RegistryService 接口包含注册中心四个基本操作：<strong>服务注册 register</strong>、<strong>服务注销 unRegister</strong>、<strong>服务发现 discovery</strong>、<strong>注册中心销毁 destroy</strong>。 </p>
<h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>服务消费者在发起 RPC 调用之前，需要感知有多少服务端节点可用，然后从中选取一个进行调用。之前我们提到了几种常用的负载均衡策略：Round-Robin 轮询、Weighted Round-Robin 权重轮询、Least Connections 最少连接数、Consistent Hash 一致性 Hash 等。  一致性 Hash 算法可以保证每个服务节点分摊的流量尽可能均匀，而且能够把服务节点扩缩容带来的影响降到最低。下面我们一起看下一致性 Hash 算法的设计思路。 </p>
<p>在服务端节点扩缩容时，一致性 Hash 算法会尽可能保证客户端发起的 RPC 调用还是固定分配到相同的服务节点上。一致性 Hash 算法是采用<strong>哈希环</strong>来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash。</p>
<p>关于一致性hash算法可参考： <a href="https://zhuanlan.zhihu.com/p/482549860?utm_medium=social&amp;utm_oi=919687111576289280">https://zhuanlan.zhihu.com/p/482549860?utm_medium=social&amp;utm_oi=919687111576289280</a></p>
<p>负载均衡接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceLoadBalancer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">select</span><span class="params">(List&lt;T&gt; servers, <span class="keyword">int</span> hashCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于zk实现的一致性hash算法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConsistentHashLoadBalancer</span> <span class="keyword">implements</span> <span class="title">ServiceLoadBalancer</span>&lt;<span class="title">ServiceInstance</span>&lt;<span class="title">ServiceMetaData</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 虚拟节点数，默认是10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildServiceInstanceKey</span><span class="params">(ServiceInstance&lt;ServiceMetaData&gt; instance)</span> </span>&#123;</span><br><span class="line">        ServiceMetaData payload = instance.getPayload();</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot;:&quot;</span>, payload.getServiceAddr(), String.valueOf(payload.getPort()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance&lt;ServiceMetaData&gt; <span class="title">select</span><span class="params">(List&lt;ServiceInstance&lt;ServiceMetaData&gt;&gt; servers, <span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, ServiceInstance&lt;ServiceMetaData&gt;&gt; ring = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ServiceInstance&lt;ServiceMetaData&gt; instance : servers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE; i++) &#123;</span><br><span class="line">                ring.put((buildServiceInstanceKey(instance) + VIRTUAL_NODE_SIZE + i).hashCode(), instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ceilingEntry() 方法找出大于或等于客户端 hashCode 的第一个节点，即为客户端对应要调用的服务节点</span></span><br><span class="line">        Map.Entry&lt;Integer, ServiceInstance&lt;ServiceMetaData&gt;&gt; entry = ring.ceilingEntry(hashCode);</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            entry = ring.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>服务发现的实现思路比较简单，首先找出被调用服务所有的节点列表，然后通过 ZKConsistentHashLoadBalancer 提供的一致性 Hash 算法找出相应的服务节点。具体代码实现如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ServiceMetaData <span class="title">discovery</span><span class="params">(String serviceName, <span class="keyword">int</span> invokerHashCode)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Collection&lt;ServiceInstance&lt;ServiceMetaData&gt;&gt; serviceInstances = serviceDiscovery.queryForInstances(serviceName);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 通过一些负载均衡算法，选择一个服务实例</span></span><br><span class="line">       ServiceInstance&lt;ServiceMetaData&gt; instance = <span class="keyword">new</span> ZKConsistentHashLoadBalancer().select((List&lt;ServiceInstance&lt;ServiceMetaData&gt;&gt;) serviceInstances, invokerHashCode);</span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance.getPayload();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>castile-rpc框架：通信协议的设计和编解码器的实现</title>
    <url>/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>现在需要建立客户端和服务端之间的通信机制了，主要内容有：</p>
<ul>
<li>服务消费者实现协议编码，向服务提供者发送调用数据。</li>
<li>服务提供者收到数据后解码，然后向服务消费者发送响应数据，暂时忽略 RPC 请求是如何被调用的。</li>
<li>服务消费者收到响应数据后成功返回。</li>
</ul>
<h2 id="1、RPC-通信方案设计"><a href="#1、RPC-通信方案设计" class="headerlink" title="1、RPC 通信方案设计"></a>1、RPC 通信方案设计</h2><img src="/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/1695565921880.png" class width="1695565921880">





<h2 id="2、自定义RPC通信协议"><a href="#2、自定义RPC通信协议" class="headerlink" title="2、自定义RPC通信协议"></a>2、自定义RPC通信协议</h2><p>协议是服务消费者和服务提供者之间通信的基础，主流的 RPC 框架都会自定义通信协议，相比于 HTTP、HTTPS、JSON 等通用的协议，自定义协议可以实现更好的性能、扩展性以及安全性。 </p>
<h3 id="自定义协议要素"><a href="#自定义协议要素" class="headerlink" title="自定义协议要素"></a>自定义协议要素</h3><ul>
<li>魔数，用来在第一时间判定是否是无效数据包</li>
<li>版本号，可以支持协议的升级</li>
<li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li>
<li>状态： 失败还是成功？ 可选</li>
<li>消息类型，是请求、响应？这个 跟业务相关</li>
<li>请求序号，为了双工通信，提供异步能力</li>
<li>正文长度</li>
<li>消息正文</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">+---------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">| 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">| 状态 1byte |        消息 ID 8byte     |      数据长度 4byte     |</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">|                   数据内容 （长度不定）                          |</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>我们把协议分为协议头 Header 和协议体 Body 两个部分。协议头 Header 包含魔数、协议版本号、序列化算法、报文类型、状态、消息 ID、数据长度，协议体 Body 只包含数据内容部分，数据内容的长度是不固定的。RPC 请求和响应都可以使用该协议进行通信，对应协议实体类的定义如下所示： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CastileRpcProtocol</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> MessageHeader messageHeader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageHeader</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">short</span> magic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> version;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> serialization;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> msgType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> status;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> requestId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> msgLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3、序列化算法选型"><a href="#3、序列化算法选型" class="headerlink" title="3、序列化算法选型"></a>3、序列化算法选型</h2><p>目前比较常用的序列化算法包括 Json、Kryo、Hessian、Protobuf 等，这些第三方序列化算法都比 Java 原生的序列化操作都更加高效。 我们设计了一个 RPC 序列化顶层接口， 所有的序列化算法都需要实现这个接口；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcSerialization</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 待序列化数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 序列化数据的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 序列化后的字节流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="keyword">byte</span>[] serialize(T obj) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf   数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;   类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] buf, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 我们为 RpcSerialization 提供了 HessianSerialization 和 JsonSerialization 两种类型的实现，为此，可以提供一个序列化工厂来切换不同的序列化算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RpcSerialization <span class="title">getRpcSerialization</span><span class="params">(<span class="keyword">byte</span> type)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        SerializationTypeEnum typeEnum = SerializationTypeEnum.findSerializationType(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (typeEnum)&#123;</span><br><span class="line">            <span class="keyword">case</span> HESSIAN:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HessianSerialization();</span><br><span class="line">            <span class="keyword">case</span> JSON:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JsonSerialization();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;serialization type is illegal, &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4、通信协议的编码器"><a href="#4、通信协议的编码器" class="headerlink" title="4、通信协议的编码器"></a>4、通信协议的编码器</h2><p>Netty 提供了两个最为常用的编解码抽象基类 MessageToByteEncoder 和 ByteToMessageDecoder，帮助我们很方便地扩展实现自定义协议。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">CastileRpcProtocol</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">   | 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |</span></span><br><span class="line"><span class="comment">   +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">   | 状态 1byte |        消息 ID 8byte     |      数据长度 4byte     |</span></span><br><span class="line"><span class="comment">   +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">   |                   数据内容 （长度不定）                          |</span></span><br><span class="line"><span class="comment">   +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, CastileRpcProtocol message, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessageHeader messageHeader = message.getMessageHeader();</span><br><span class="line">        <span class="comment">// 魔数</span></span><br><span class="line">        byteBuf.writeShort(messageHeader.getMagic());</span><br><span class="line">        <span class="comment">// 协议版本号</span></span><br><span class="line">        byteBuf.writeByte(messageHeader.getVersion());</span><br><span class="line">        <span class="comment">// 序列化算法</span></span><br><span class="line">        byteBuf.writeByte(messageHeader.getSerialization());</span><br><span class="line">        <span class="comment">// 报文类型</span></span><br><span class="line">        byteBuf.writeByte(messageHeader.getMsgType());</span><br><span class="line">        <span class="comment">// 状态</span></span><br><span class="line">        byteBuf.writeByte(messageHeader.getStatus());</span><br><span class="line">        <span class="comment">// 消息id</span></span><br><span class="line">        byteBuf.writeLong(messageHeader.getRequestId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        RpcSerialization rpcSerialization = SerializationFactory.getRpcSerialization(messageHeader.getSerialization());</span><br><span class="line">        <span class="keyword">byte</span>[] body = rpcSerialization.serialize(message.getBody());</span><br><span class="line">        <span class="comment">// 数据长度</span></span><br><span class="line">        byteBuf.writeInt(body.length);</span><br><span class="line">        byteBuf.writeBytes(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在服务消费者或者服务提供者调用 writeAndFlush() 将数据写给对方前，都已经封装成 RpcRequest 或者 RpcResponse，所以可以采用 CastileRpcProtocol作为 RPC Encoder 编码器能够支持的编码类型。 </p>
<h2 id="5、-通信协议的解码器"><a href="#5、-通信协议的解码器" class="headerlink" title="5、 通信协议的解码器"></a>5、 通信协议的解码器</h2><p> 解码器 相比于编码器 要复杂很多，解码器的目标是将字节流数据解码为消息对象，并传递给下一个 Inbound 处理器。整个解码过程有几个要点要特别注意： </p>
<ul>
<li><p>只有当 ByteBuf 中内容大于协议头 Header 的固定的 18 字节时，才开始读取数据。</p>
</li>
<li><p>即使已经可以完整读取出协议头 Header，但是协议体 Body 有可能还未就绪。所以在刚开始读取数据时，需要使用 markReaderIndex() 方法标记读指针位置，当 ByteBuf 中可读字节长度小于协议体 Body 的长度时，再使用 resetReaderIndex() 还原读指针位置，说明现在 ByteBuf 中可读字节还不够一个完整的数据包。</p>
<blockquote>
<p>这个其实也可以使用<strong>LengthFieldBasedFrameDecoder</strong>来处理粘包和半包问题</p>
</blockquote>
</li>
<li><p>根据不同的报文类型 MsgType，需要反序列化出不同的协议体对象。在 RPC 请求调用的场景下，服务提供者需要将协议体内容反序列化成 MiniRpcRequest 对象；在 RPC 结果响应的场景下，服务消费者需要将协议体内容反序列化成 MiniRpcResponse 对象。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 消息小于头长度，不完整数据</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &lt; ProtocolConstants.HEADER_TOTAL_LEN) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;message length valid failed! please check request data&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        byteBuf.markReaderIndex();</span><br><span class="line">        <span class="comment">// 魔数</span></span><br><span class="line">        <span class="keyword">short</span> magic = byteBuf.readShort();</span><br><span class="line">        <span class="comment">// 魔数不匹配，不是本系统消息</span></span><br><span class="line">        <span class="keyword">if</span> (magic != ProtocolConstants.MAGIC) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;magic number is illegal, &quot;</span> + magic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span> version = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializeType = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> msgType = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> status = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">long</span> requestId = byteBuf.readLong();</span><br><span class="line">        <span class="keyword">int</span> dataLength = byteBuf.readInt();</span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &lt; dataLength) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;data readableBytes less than data length!&quot;</span>);</span><br><span class="line">            byteBuf.resetReaderIndex();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[dataLength];</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line">        <span class="comment">// 获取消息类型</span></span><br><span class="line">        MsgType byTpye = MsgType.findByType(msgType);</span><br><span class="line">        <span class="keyword">if</span> (byTpye == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;msgType number is illegal, &quot;</span> + msgType);</span><br><span class="line">        &#125;</span><br><span class="line">        MessageHeader header = <span class="keyword">new</span> MessageHeader();</span><br><span class="line">        header.setMagic(magic);</span><br><span class="line">        header.setVersion(version);</span><br><span class="line">        header.setSerialization(serializeType);</span><br><span class="line">        header.setStatus(status);</span><br><span class="line">        header.setRequestId(requestId);</span><br><span class="line">        header.setMsgType(msgType);</span><br><span class="line">        header.setMsgLen(dataLength);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        RpcSerialization rpcSerialization = SerializationFactory.getRpcSerialization(serializeType);</span><br><span class="line">        <span class="keyword">switch</span> (byTpye) &#123;</span><br><span class="line">            <span class="keyword">case</span> REQUEST:</span><br><span class="line">                RpcRequest rpcRequest = rpcSerialization.deserialize(data, RpcRequest.class);</span><br><span class="line">                <span class="keyword">if</span> (rpcRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    CastileRpcProtocol&lt;RpcRequest&gt; castileRpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">                    castileRpcProtocol.setMessageHeader(header);</span><br><span class="line">                    castileRpcProtocol.setBody(rpcRequest);</span><br><span class="line">                    list.add(castileRpcProtocol);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RESPONSE:</span><br><span class="line">                RpcResponse rpcResponse = rpcSerialization.deserialize(data, RpcResponse.class);</span><br><span class="line">                <span class="keyword">if</span> (rpcResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    CastileRpcProtocol&lt;RpcResponse&gt; castileRpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">                    castileRpcProtocol.setMessageHeader(header);</span><br><span class="line">                    castileRpcProtocol.setBody(rpcResponse);</span><br><span class="line">                    list.add(castileRpcProtocol);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> HEARTBEAT:</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6、请求和响应处理"><a href="#6、请求和响应处理" class="headerlink" title="6、请求和响应处理"></a>6、请求和响应处理</h2><p>消费者调用RPC请求后，服务端通过解码器将二进制的数据解码成CastileRpcProtocol<RpcRequest>对象，再传递给RpcRequestHandler处理器执行rpc调用。 RpcRequestHandler 也是一个 Inbound 处理器，它并不需要承担解码工作，所以 RpcRequestHandler 直接继承 SimpleChannelInboundHandler 即可，然后重写 channelRead0() 方法，具体实现如下： </RpcRequest></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">CastileRpcProtocol</span>&lt;<span class="title">RpcRequest</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; rpcServiceMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcRequestHandler</span><span class="params">(Map&lt;String, Object&gt; rpcServiceMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rpcServiceMap = rpcServiceMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, CastileRpcProtocol&lt;RpcRequest&gt; msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 执行rpc调用比较耗时，因此放在业务线程池中去处理</span></span><br><span class="line">        RpcRequestProcessor.submitRequest(() -&gt; &#123;</span><br><span class="line">            CastileRpcProtocol&lt;RpcResponse&gt; rpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">            RpcResponse rpcResponse = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">            MessageHeader messageHeader = msg.getMessageHeader();</span><br><span class="line">            messageHeader.setMsgType((<span class="keyword">byte</span>) MsgType.RESPONSE.getType());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                RpcRequest request = msg.getBody();</span><br><span class="line">                String serviceKey = RpcServiceHelper.buildServiceKey(request.getClassName(), request.getServiceVersion());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取bean对象</span></span><br><span class="line">                Object serviceBean = rpcServiceMap.get(serviceKey);</span><br><span class="line">                <span class="keyword">if</span> (serviceBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 不存在</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;service not exist: %s:%s&quot;</span>, request.getClassName(), request.getMethodName()));</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; serviceClazz = serviceBean.getClass();</span><br><span class="line">                String methodName = request.getMethodName();</span><br><span class="line">                Object[] params = request.getParams();</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">                FastClass fastClass = FastClass.create(serviceClazz);</span><br><span class="line">                <span class="keyword">int</span> index = fastClass.getIndex(methodName, parameterTypes);</span><br><span class="line">                Object result = fastClass.invoke(index, serviceBean, params);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写回到response中</span></span><br><span class="line">                rpcResponse.setData(result);</span><br><span class="line">                messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.SUCCESS.getCode());</span><br><span class="line">                rpcProtocol.setBody(rpcResponse);</span><br><span class="line">                rpcProtocol.setMessageHeader(messageHeader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.FAIL.getCode());</span><br><span class="line">                rpcResponse.setMessage(throwable.toString());</span><br><span class="line">                log.error(<span class="string">&quot;process request &#123;&#125; error&quot;</span>, messageHeader.getRequestId(), throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ctx.writeAndFlush(rpcProtocol);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 服务消费者在发起调用时，维护了请求 requestId 和 RpcFuture的映射关系，RpcResponseHandler 会根据请求的 requestId 找到对应发起调用的 RpcFuture，然后为 RpcFuture 设置响应结果。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">CastileRpcProtocol</span>&lt;<span class="title">RpcResponse</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, CastileRpcProtocol&lt;RpcResponse&gt; msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> requestId = msg.getMessageHeader().getRequestId();</span><br><span class="line">        RpcFuture&lt;RpcResponse&gt; responseRpcFuture = RpcRequestHolder.REQUEST_MAP.remove(requestId);</span><br><span class="line">        responseRpcFuture.getPromise().setSuccess(msg.getBody());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcFuture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Promise&lt;T&gt; promise;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcFuture</span><span class="params">(Promise&lt;T&gt; promise, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.promise = promise;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

























]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>castile-rpc框架：动态代理实现RPC的调用和处理</title>
    <url>/2023/10/08/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0RPC%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在一个RPC框架中，动态代理可以屏蔽rpc调用时低层的网络通讯、服务发现、负载均衡等具体细节。 使用 RPC 框架的时候，只需要调用接口方法，然后就拿到了返回结果。这些都是通过动态代理去实现的。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的优势是可以很好地遵循设计模式中的开闭原则，对扩展开发，对修改关闭。不需要关注目标类的实现细节，通过代理模式可以在不修改目标类的情况下，增强目标类功能的行为。 </p>
<p>动态代理是一种代理模式，它提供了一种能够在运行时动态构建代理类以及动态调用目标方法的机制。为什么称为动态是因为代理类和被代理对象的关系是在运行时决定的，代理类可以看作是对被代理对象的包装，对目标方法的调用是通过代理类来完成的。所以通过代理模式可以有效地将服务提供者和服务消费者进行解耦，隐藏了 RPC 调用的具体细节。</p>
<h2 id="服务消费者动态代理实现"><a href="#服务消费者动态代理实现" class="headerlink" title="服务消费者动态代理实现"></a>服务消费者动态代理实现</h2><p>我们使用@RPCReference注解来标注一个服务端接口，通过一个自定义的RpcReferenceBean完成了所有执行方法的拦截。 RpcReferenceBean 中 init() 方法是代理对象的创建入口，代理对象创建如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化bean，返回代理对象</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       RegistryService registryService = RegistryFactory.getInstance(registryAddr, RegistryType.valueOf(registryType));</span><br><span class="line">       <span class="keyword">this</span>.object = Proxy.newProxyInstance(</span><br><span class="line">               interfaceClass.getClassLoader(),</span><br><span class="line">               <span class="keyword">new</span> Class&lt;?&gt;[]&#123;interfaceClass&#125;,</span><br><span class="line">               <span class="keyword">new</span> RpcInvokerProxy(serviceVersion, timeout, registryService)</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>RpcInvokerProxy 处理器是实现动态代理逻辑的核心所在，其中包含 RPC 调用时底层网络通信、服务发现、负载均衡等具体细节 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcInvokerProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceVersion;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RegistryService registryService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcInvokerProxy</span><span class="params">(String serviceVersion, <span class="keyword">long</span> timeout, RegistryService registryService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceVersion = serviceVersion;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.registryService = registryService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        CastileRpcProtocol&lt;RpcRequest&gt; rpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">        <span class="comment">// 消息头</span></span><br><span class="line">        MessageHeader messageHeader = <span class="keyword">new</span> MessageHeader();</span><br><span class="line">        <span class="comment">// 消息id</span></span><br><span class="line">        <span class="keyword">long</span> requestId = RpcRequestHolder.REQUEST_ID_GEN.incrementAndGet();</span><br><span class="line">        <span class="comment">// 魔数</span></span><br><span class="line">        messageHeader.setMagic(ProtocolConstants.MAGIC);</span><br><span class="line">        <span class="comment">// 版本</span></span><br><span class="line">        messageHeader.setVersion(ProtocolConstants.VERSION);</span><br><span class="line">        <span class="comment">// 序列化算法</span></span><br><span class="line">        messageHeader.setSerialization((<span class="keyword">byte</span>) SerializationTypeEnum.HESSIAN.getType());</span><br><span class="line">        <span class="comment">// 消息类型</span></span><br><span class="line">        messageHeader.setMsgType((<span class="keyword">byte</span>) MsgType.REQUEST.getType());</span><br><span class="line">        messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.SUCCESS.getCode());</span><br><span class="line"></span><br><span class="line">        rpcProtocol.setMessageHeader(messageHeader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息正文</span></span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">        rpcRequest.setServiceVersion(serviceVersion);</span><br><span class="line">        rpcRequest.setClassName(method.getDeclaringClass().getName());</span><br><span class="line">        rpcRequest.setMethodName(method.getName());</span><br><span class="line">        rpcRequest.setParameterTypes(method.getParameterTypes());</span><br><span class="line">        rpcRequest.setParams(args);</span><br><span class="line"></span><br><span class="line">        rpcProtocol.setBody(rpcRequest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建rpc客户端，发送消息进行rpc调用</span></span><br><span class="line">        RpcConsumer consumer = <span class="keyword">new</span> RpcConsumer();</span><br><span class="line"></span><br><span class="line">        RpcFuture&lt;RpcResponse&gt; rpcFuture = <span class="keyword">new</span> RpcFuture&lt;&gt;(<span class="keyword">new</span> DefaultPromise&lt;&gt;(<span class="keyword">new</span> DefaultEventLoop()), timeout);</span><br><span class="line">        RpcRequestHolder.REQUEST_MAP.put(requestId, rpcFuture);</span><br><span class="line">        consumer.sendMessage(rpcProtocol, registryService);</span><br><span class="line">        <span class="keyword">return</span> rpcFuture.getPromise().get(rpcFuture.getTimeout(), TimeUnit.MILLISECONDS).getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invoke() 方法的核心流程主要分为三步：构造 RPC 协议对象、发起 RPC 远程调用、等待 RPC 调用执行结果。 </p>
<p>发起 RPC 调用之前，我们需要找到最合适的服务节点，直接调用注册中心服务 RegistryService 的 discovery() 方法即可，默认是采用一致性 Hash 算法实现的服务发现 。为了尽可能使所有服务节点收到的请求流量更加均匀，需要为 discovery() 提供一个 invokerHashCode，一般可以采用 RPC 服务接口参数列表中第一个参数的 hashCode 作为参考依据。找到服务节点地址后，接下来通过 Netty 建立 TCP 连接，然后调用 writeAndFlush() 方法将数据发送到远端服务节点。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(CastileRpcProtocol&lt;RpcRequest&gt; protocolRequest, RegistryService registryService)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RpcRequest request = protocolRequest.getBody();</span><br><span class="line">        Object[] params = request.getParams();</span><br><span class="line">        String serviceKey = RpcServiceHelper.buildServiceKey(request.getMethodName(), request.getServiceVersion());</span><br><span class="line">        <span class="keyword">int</span> invokeHashCode = params.length &gt; <span class="number">0</span> ? params[<span class="number">0</span>].hashCode() : serviceKey.hashCode();</span><br><span class="line">        <span class="comment">// 找到需要发送到哪个服务实例</span></span><br><span class="line">        ServiceMetaData serviceMetaData = registryService.discovery(serviceKey, invokeHashCode);</span><br><span class="line">        <span class="keyword">if</span> (serviceMetaData != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(serviceMetaData.getServiceAddr(), serviceMetaData.getPort()).sync();</span><br><span class="line">            channelFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;connect rpc service &#123;&#125; om port &#123;&#125; success!&quot;</span>, serviceMetaData.getServiceAddr(), serviceMetaData.getPort());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;connect rpc server &#123;&#125; on port &#123;&#125; failed.&quot;</span>, serviceMetaData.getServiceAddr(), serviceMetaData.getPort());</span><br><span class="line">                        channelFuture.cause().printStackTrace();</span><br><span class="line">                        eventLoopGroup.shutdownGracefully();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            channelFuture.channel().writeAndFlush(protocolRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 发送RPC远程调用后，使用Promise机制等待拿到结果。</p>
<p>Promise 模式本质是一种异步编程模型，我们可以先拿到一个查看任务执行结果的凭证，不必等待任务执行完毕，当我们需要获取任务执行结果时，再使用凭证提供的相关接口进行获取。 </p>
<h2 id="服务提供者反射调用实现"><a href="#服务提供者反射调用实现" class="headerlink" title="服务提供者反射调用实现"></a>服务提供者反射调用实现</h2><p>消费者通过netty发送消息给服务端后，rpc的请求数据经过解码器解码成CastileRpcProtocol对象后，再交由RpcRequestHandler执行rpcx请求调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, CastileRpcProtocol&lt;RpcRequest&gt; msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 执行rpc调用比较耗时，因此放在业务线程池中去处理</span></span><br><span class="line">        RpcRequestProcessor.submitRequest(() -&gt; &#123;</span><br><span class="line">            CastileRpcProtocol&lt;RpcResponse&gt; rpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">            RpcResponse rpcResponse = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">            MessageHeader messageHeader = msg.getMessageHeader();</span><br><span class="line">            messageHeader.setMsgType((<span class="keyword">byte</span>) MsgType.RESPONSE.getType());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                RpcRequest request = msg.getBody();</span><br><span class="line">                String serviceKey = RpcServiceHelper.buildServiceKey(request.getClassName(), request.getServiceVersion());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取bean对象</span></span><br><span class="line">                Object serviceBean = rpcServiceMap.get(serviceKey);</span><br><span class="line">                <span class="keyword">if</span> (serviceBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 不存在</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;service not exist: %s:%s&quot;</span>, request.getClassName(), request.getMethodName()));</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; serviceClazz = serviceBean.getClass();</span><br><span class="line">                String methodName = request.getMethodName();</span><br><span class="line">                Object[] params = request.getParams();</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">                FastClass fastClass = FastClass.create(serviceClazz);</span><br><span class="line">                <span class="keyword">int</span> index = fastClass.getIndex(methodName, parameterTypes);</span><br><span class="line">                Object result = fastClass.invoke(index, serviceBean, params);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写回到response中</span></span><br><span class="line">                rpcResponse.setData(result);</span><br><span class="line">                messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.SUCCESS.getCode());</span><br><span class="line">                rpcProtocol.setBody(rpcResponse);</span><br><span class="line">                rpcProtocol.setMessageHeader(messageHeader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.FAIL.getCode());</span><br><span class="line">                rpcResponse.setMessage(throwable.toString());</span><br><span class="line">                log.error(<span class="string">&quot;process request &#123;&#125; error&quot;</span>, messageHeader.getRequestId(), throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ctx.writeAndFlush(rpcProtocol);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>rpcServiceMap 中存放着服务提供者所有对外发布的服务接口，我们可以通过服务名和服务版本找到对应的服务接口。通过服务接口、方法名、方法参数列表、参数类型列表，我们一般可以使用反射的方式执行方法调用。为了加速服务接口调用的性能，我们采用 Cglib 提供的 FastClass 机制直接调用方法，Cglib 中 MethodProxy 对象就是采用了 FastClass 机制，它可以和 Method 对象完成同样的事情，但是相比于反射性能更高。 </p>
<p>FastClass 机制并没有采用反射的方式调用被代理的方法，而是运行时动态生成一个新的 FastClass 子类，向子类中写入直接调用目标方法的逻辑。同时该子类会为代理类分配一个 int 类型的 index 索引，FastClass 即可通过 index 索引定位到需要调用的方法。 </p>
<h1 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h1><p><a href="https://gitee.com/hongliangzhu/castile-rpc">https://gitee.com/hongliangzhu/castile-rpc</a></p>
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>NiFi身份验证与授权验证（2）</title>
    <url>/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="授权验证（Authorization）概述"><a href="#授权验证（Authorization）概述" class="headerlink" title="授权验证（Authorization）概述"></a>授权验证（Authorization）概述</h2><p>访问Nifi界面相当于你想进入一个商业写字楼，门口保安可能会拦住你要查看你的身份证（身份验证）。现在保安从身份证上知道了我们的名字（身份验证成功），但是他依然需要确定你是在这个写字楼工作才能让你进去。为此他查找大楼员工花名册（授权验证）。只有当你的名字出现在名册上时你才会被放行。</p>
<img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697299271277.png" class width="1697299271277">



<p>Nifi授权验证模块与两个数据库有关：一个是授权用户身份数据库（<code>UserGroupProvider</code>），另一个是用户权限数据库（<code>AccessPolicyProvider</code>） </p>
<p>其中，<code>UserGroupProvider</code>里面列出了所有被授权用户的用户名。只有在这个数据库里面的用户名才真正有权限使用Nifi。而<code>AccessPolicyProvider</code>里面列出了这些被授权用户以及他们所获得的权限之间的一一对应关系。</p>
<p>因此，Nifi的授权验证模块需要做的，就是先拿从身份验证模块得来的用户名与<code>UserGroupProvider</code>里的用户名做核对，看是否能找到对应的条目。如果有，再到<code>AccessPolicyProvider</code>里查看该用户有哪些权限。</p>
<p> 接下来，我们就看看，在Nifi当中是怎么对<code>UserGroupProvider</code>和<code>AccessPolicyProvider</code>进行设置的。 </p>
<h2 id="授权验证设置"><a href="#授权验证设置" class="headerlink" title="授权验证设置"></a>授权验证设置</h2><p>Nifi 会在<code>./conf/authorizers.xml</code>这个文件中寻找<code>UserGroupProvider</code>和<code>AccessPolicyProvider</code>的设置。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authorizers</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">userGroupProvider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileUserGroupProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Users File&quot;</span>&gt;</span>./conf/users.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial User Identity 1&quot;</span>&gt;</span>CN=castile-nifi, OU=nifi<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userGroupProvider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileAccessPolicyProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;User Group Provider&quot;</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Authorizations File&quot;</span>&gt;</span>./conf/authorizations.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial Admin Identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Identity 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Group&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">authorizer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>managed-authorizer<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.StandardManagedAuthorizer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Access Policy Provider&quot;</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">authorizer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorizers</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="1、-UserGroupProvider-设置"><a href="#1、-UserGroupProvider-设置" class="headerlink" title="1、 UserGroupProvider 设置"></a>1、 UserGroupProvider 设置</h3><p><code>FileUserGroupProvider</code>的使用最为简单，其本质是把所有授权用户名都存在一个文件里面。在<code>./conf/authorizers.xml</code>文件中与<code>FileUserGroupProvider</code>相关的有以下条目：</p>
<p> 这个文件储存用户名的文件默认是<code>./conf/users.xml</code>。它可以有类似以下内容 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tenants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groups</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;66fa993d-f882-396e-bc79-3ff4b6994470&quot;</span> <span class="attr">identity</span>=<span class="string">&quot;CN=castile-nifi, OU=nifi&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tenants</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>里面配置一些用户的信息</p>
<h3 id="2、-AccessPolicyProvider-设置"><a href="#2、-AccessPolicyProvider-设置" class="headerlink" title="2、 AccessPolicyProvider 设置"></a>2、 AccessPolicyProvider 设置</h3><p> Nifi自带<code>AccessPolicyProvider</code>是<code>FileAccessPolicyProvider</code>。在<code>authorizers.xml</code>中相关的设置有以下的条目： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileAccessPolicyProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;User Group Provider&quot;</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Authorizations File&quot;</span>&gt;</span>./conf/authorizations.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial Admin Identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Identity 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Group&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">accessPolicyProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在属性<code>User Group Provider</code>中我们指定了使用哪一个<code>UserGroupProvider</code>。而<code>Authorizations File</code>指定了权限数据都存在哪个文件，默认是<code>./conf/authorizations.xml</code>。这个文件中有类似以下的内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authorizations</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;f99bccd1-a30e-3e4a-98a2-dbc708edc67f&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/flow&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;3fbc23d1-30d2-3068-ba89-9066202e13d7&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;b8775bd4-704a-34c6-987b-84f2daf7a515&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/restricted-components&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;3fbc23d1-30d2-3068-ba89-9066202e13d7&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;ff96062a-fa99-36dc-9942-0f6442ae7212&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/policies&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;3fbc23d1-30d2-3068-ba89-9066202e13d7&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorizations</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 在这个文件中列出了每一条的权限（Policy），而每条权限都对应一个用户，这样形成了一一对应的关系，而Nifi也能够因此确定每个用户拥有什么权限。 </p>
<h3 id="3、-Authorizer设置"><a href="#3、-Authorizer设置" class="headerlink" title="3、 Authorizer设置"></a>3、 Authorizer设置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authorizer</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>managed-authorizer<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.StandardManagedAuthorizer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Access Policy Provider&quot;</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">authorizer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Nifi自带有managed-authorizer和single-user-authorizer，注意我们要在这里指定<code>AccessPolicyProvider</code>。然后，在<code>nifi.properties</code>中，我们要在以下属性指定我们需要用的<code>authorizer</code>:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">nifi.security.user.authorizer</span>=<span class="string">managed-authorizer </span></span><br><span class="line"><span class="attr">或者：</span></span><br><span class="line"><span class="meta">nifi.security.user.authorizer</span>=<span class="string">single-user-authorizer</span></span><br></pre></td></tr></table></figure>

<p>这样，我们就告诉了Nifi我们使用的是<code>managed-authorizer</code>，然后<code>managed-authorizer</code>又指定了使用的<code>AccessPolicyProvider</code>，而<code>AccessPolicyProvider</code>又指定了所使用的<code>UserGroupProvider</code>。整个权限验证模块的设置就是这样子被串了起来。</p>
<h2 id="多用户授权"><a href="#多用户授权" class="headerlink" title="多用户授权"></a>多用户授权</h2><p>在生产环境中推荐使用<code>nifi.security.user.authorizer=managed-authorizer </code>, 这样可以为多个用户登录nifi并设置相应的权限。</p>
<p>在user.xml添加一个用户，并不设置任何权限</p>
<img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697359958358.png" class width="1697359958358">

<img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697359986486.png" class width="1697359986486">

<p>我们是要手动添加条目到<code>./conf/users.xml</code>和<code>./conf/authorizations.xml</code>吗？并不需要，我们可以通过在Nifi的UI界面操作来添加。不过，首先你得有一个管理员账号来登录进Nifi界面才行。无论你采用哪种身份验证方法，对于一个新的加密Nifi，你必须在<code>authorizers.xml</code>的<code>AccessPolicyProvider</code>中找到这一项：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial Admin Identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 把你的用户名添加进去即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileAccessPolicyProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;User Group Provider&quot;</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Authorizations File&quot;</span>&gt;</span>./conf/authorizations.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial Admin Identity&quot;</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Identity 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Group&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置Initial User Identity 1： admin</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">userGroupProvider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileUserGroupProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Users File&quot;</span>&gt;</span>./conf/users.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial User Identity 1&quot;</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name=&quot;Initial User Identity 1&quot;&gt;CN=admin, OU=nifi&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userGroupProvider</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>保存，重启Nifi。当你再次访问UI时就发现，关于权限的错误已经消除，主界面也可以进去了。实际上，当你添加了<code>Initial Admin Identity</code>并重启后，Nifi在后台把这名用户添加到了<code>users.xml</code>中，并且在<code>authorizations.xml</code>中添加了一些基础的权限。</p>
<p>user.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tenants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groups</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">identity</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;user identifier=&quot;6743d555-1f60-343a-9038-0be6fdcbf33b&quot; identity=&quot;CN=admin, OU=nifi&quot;/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tenants</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 当你使用初始管理员账号进入Nifi以后，你会发现大部分的地方都是灰色的，你基本没法做任何操作（下图） </p>
<img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697364885070.png" class width="1697364885070">



<p>authorizations.xml中的配置湖自动生成：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authorizations</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;f99bccd1-a30e-3e4a-98a2-dbc708edc67f&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/flow&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;87dce6d5-be9f-3392-a4ef-dd58a553a6a0&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/data/process-groups/2ba3a086-018b-1000-6247-3dcbfaf4602f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;2cb459c4-151d-3671-9d9b-7fa7f1448886&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/data/process-groups/2ba3a086-018b-1000-6247-3dcbfaf4602f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;f5e329a9-16eb-3aaf-a969-3778d17ad1e4&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/process-groups/2ba3a086-018b-1000-6247-3dcbfaf4602f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;3be25fe5-3d07-302c-9bf9-0b03fa9fb77d&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/process-groups/2ba3a086-018b-1000-6247-3dcbfaf4602f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;b8775bd4-704a-34c6-987b-84f2daf7a515&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/restricted-components&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;627410be-1717-35b4-a06f-e9362b89e0b7&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/tenants&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;15e4e0bd-cb28-34fd-8587-f8d15162cba5&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/tenants&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;ff96062a-fa99-36dc-9942-0f6442ae7212&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/policies&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;ad99ea98-3af6-3561-ae27-5bf09e1d969d&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/policies&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;2e1015cb-0fed-3005-8e0d-722311f21a03&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/controller&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;c6322e6c-4cc1-3bcc-91b3-2ed2111674cf&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/controller&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorizations</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以 通过点击右上侧的菜单栏并选择 user创建用户、Policies可以为用户进行权限管理</p>
<img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697365023394.png" class width="1697365023394">

<p>创建用户后，自动会写入到user.xml中</p>
<img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697365187598.png" class width="1697365187598">



<h2 id="TroubleShooting"><a href="#TroubleShooting" class="headerlink" title="TroubleShooting"></a>TroubleShooting</h2><p>1、 </p>
<img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697359326101.png" class width="1697359326101">

<p>更改user.xml文件，user部分的identity不能有相同的</p>
<img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697359835216.png" class width="1697359835216">

<p>2、</p>
<img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697360312489.png" class width="1697360312489">

<p>严格匹配，不能有“”，区分大小写</p>
<p>3、 当你在配置的是CN=admin, OU=nifi这种格式，那么会会从中解析出admin 作为用户名</p>
]]></content>
      <categories>
        <category>NiFi</category>
      </categories>
      <tags>
        <tag>NiFi</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>NiFi身份验证与授权验证（1）</title>
    <url>/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="NiFi身份验证和授权验证介绍"><a href="#NiFi身份验证和授权验证介绍" class="headerlink" title="NiFi身份验证和授权验证介绍"></a>NiFi身份验证和授权验证介绍</h2><p>身份验证（Authentication）以及授权验证（Authorization）在Nifi里面是两个相当独立的模块。其中身份验证主要的任务是确认当前操作用户<strong>是否真的是声称的身份</strong>。当用户的身份被证实以后，它的用户名会被传递到授权验证模块，而授权验证模块会在它的数据库里面查找该用户名，并确认该用户<strong>有什么权限</strong>。打个比喻，如果你想进入一个商业写字楼，门口保安可能会拦住你要查看你的身份证（身份验证）。然后他会从一个员工名册上查找你的名字（授权验证）。只有当你的名字出现在名册上时你才会被放行。</p>
<p>下图表明了Nifi中这两个系统间的关系。当用户试图访问Nifi时，他必须首先通过身份验证。身份验证的时候Nifi可能需要参考一个外部的身份数据库（Identity Provider），如LDAP，Kerberos，OpenID Connect等。当确认你的身份后，你的用户名会被送到授权验证模块进一步核对。授权模块在确认你的权限时也需要参考一个身份数据库（可以是一个文档，或者是LDAP服务器）以及一个记录着用户身份与权限对应关系的数据库。</p>
<img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697214104415.png" class width="1697214104415">、

<p>身份验证和权限验证是完全可以采用不同的身份数据库的。所以我们说这两个系统相当独立，唯一把他们连接在一起的就是用户名的传递。 </p>
<h2 id="NiFi-基本配置"><a href="#NiFi-基本配置" class="headerlink" title="NiFi 基本配置"></a>NiFi 基本配置</h2><p>Nifi支持好几种用户验证方式：<code>TLS</code>, <code>LDAP</code>, <code>Kerberos</code>, <code>OpenID Connect</code>, <code>Apache Knox</code>等。我们主要介绍<code>TLS</code>以及<code>LDAP</code>两种方式。只要弄明白这两种，其余方式的设置都很类似。<br> 要开启用户验证功能，我们首先必须设置Nifi，使之只接受<code>https</code>安全连接。要达到这个目的，我们需要更改位于<code>./conf</code> 目录下的<code>nifi.properties</code>设置文件里的以下几项属性</p>
<p><code>nifi.web.http.port</code>：去除原来的<code>8080</code>，使该行变为<code>nifi.web.http.port=</code>，防止用户从非加密的http端口访问</p>
<p> <code>nifi.web.https.host</code>：设为运行Nifi的主机名字，例如<code>host-01</code> </p>
<p> <code>nifi.web.https.port</code>：我们用<code>8443</code>作为<code>https</code>端口</p>
<p> <code>nifi.security.keystore</code>：keystore的路径，例如<code>/opt/nifi/secrets/keystore.jks</code> </p>
<p> <code>nifi.security.keystoreType</code>：设为<code>JKS</code> </p>
<p> <code>nifi.security.keystorePasswd</code>：keystore的密码。</p>
<p> <code>nifi.security.truststore</code>：truststore的路径，例如<code>/opt/nifi/secrets/truststore.jks</code> </p>
<p> <code>nifi.security.truststoreType</code>：设为<code>JKS</code> </p>
<p> <code>nifi.security.truststorePasswd</code>：truststore的密码。</p>
<p> <code>nifi.remote.input.secure</code>：设为<code>true</code>，使得Nifi之间的Site-to-Site通信也用加密的方式。</p>
<h2 id="生成keystroe和truststore"><a href="#生成keystroe和truststore" class="headerlink" title="生成keystroe和truststore"></a>生成keystroe和truststore</h2><p>当我们要把Nifi设置成加密模式时，我们需要为其提供keystore和truststore。如果我们想通过TLS身份验证访问Nifi的UI时，我们还需要生成一个客户端的PKCS12文件来导入浏览器中。以下简单介绍怎么用Java自带的keytool来生成以上所提及的文件。</p>
<h3 id="1、生成KeyStore"><a href="#1、生成KeyStore" class="headerlink" title="1、生成KeyStore"></a>1、生成KeyStore</h3><p> 以下命令生成一个包含自签证书（self-signed certificate）的Java keystore： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -genkey -keyalg RSA -alias nifi -keystore keystore.jks -keypass [password] -storepass [password] -validity 365 -keysize 4096 -dname &quot;CN=[hostname], OU=nifi&quot;</span><br></pre></td></tr></table></figure>

<p> <code>[password]</code>为你想设置的密码，替换<code>[hostname]</code>为你运行Nifi的机器的hostname </p>
<img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697214411384.png" class width="1697214411384">



<h3 id="2、-生成PKCS12文件以及对应的truststore"><a href="#2、-生成PKCS12文件以及对应的truststore" class="headerlink" title="2、 生成PKCS12文件以及对应的truststore"></a>2、 生成PKCS12文件以及对应的truststore</h3><p><code>PKCS12</code>文件是一种加密文件，一般用于存放证书以及对应的私钥。由于使用keytool无法直接生成<code>PKCS12</code>文件，我们首先生成一个包含自签证书的keystore（与上文生成Keystore的命令很相似）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -genkey -keyalg RSA -alias client -keystore client_keystore.jks -keypass password -storepass password -validity 365 -keysize 4096 -dname &quot;CN=castile, OU=nifi&quot;</span><br></pre></td></tr></table></figure>

<p>这里，我们只是随便设置了一个密码<code>password</code>，因为这个Keystore只是一个过渡的产物，我们最后不会用到，所以随便设置一个就好。</p>
<p>接着我们把这个keystore转化成PKCS12文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore client_keystore.jks -destkeystore client.p12 -srcstoretype JKS -deststoretype PKCS12 -srcstorepass password -deststorepass as1234567890 -destkeypass as1234567890 -srcalias client -destalias client</span><br></pre></td></tr></table></figure>

<p> 除了生成PKCS12文件外，我们还需要生成一个信任PKCS12密匙文件中的证书的truststore。为此，我们先从之前的keystore中输出密匙的证书： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -export -keystore client_keystore.jks -alias client -file client.der -storepass password</span><br></pre></td></tr></table></figure>

<p> 当我们得到证书以后，我们把这个证书引入到<code>truststore.jks</code>当中： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">keytool -import -file client.der -alias client -keystore truststore.jks -storepass as1234567890 -noprompt</span><br></pre></td></tr></table></figure>

<p>这是执行上述命令生成的文件：</p>
<img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697215015715.png" class width="1697215015715">



<h2 id="访问nifi-UI界面"><a href="#访问nifi-UI界面" class="headerlink" title="访问nifi UI界面"></a>访问nifi UI界面</h2><p>在浏览器输入：<a href="https://192.168.160.140:9443/nifi">https://192.168.160.140:9443/nifi</a></p>
<img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697215948784.png" class width="1697215948784">

<p>现在要求你输入用户名和密码，但是这个用户名和密码到底是啥呢？查找官网文档得知，有一个 <em>login-identity-providers.xml</em> 默认配置了用户名和密码</p>
<img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697216106597.png" class width="1697216106597">

<img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697216146697.png" class width="1697216146697">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>single-user-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authentication.single.user.SingleUserLoginIdentityProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Username&quot;</span>&gt;</span>3df4e52a-ab76-477c-9af4-513494f21110<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Password&quot;</span>&gt;</span>$2b$12$NFheiU47xu8ezCrkt0Yz7Oxph/WRhmJaNwMPlDEPkynGSwxEPEibu<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是，貌似没啥作用啊</p>
<img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697216230305.png" class width="1697216230305">



<p>原来，nifi启动的时候会自动生成一个随机用户名和密码，而且在login-single-user=credentials.xml中配置的密码是通过BCryptPasswordEncoder加密后的，</p>
<img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697297856757.png" class width="1697297856757">

<img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697297612867.png" class width="1697297612867">

<p>可以通过以下命令设置一个好记忆的密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nifi.sh set-single-user-credentials USERNAME PASSWORD</span><br></pre></td></tr></table></figure>

<p>设置完后可以登录界面了</p>
<img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697299016832.png" class width="1697299016832">

]]></content>
      <categories>
        <category>NiFi</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>nifi</tag>
        <tag>身份验证</tag>
      </tags>
  </entry>
  <entry>
    <title>无状态的NiFi</title>
    <url>/2023/11/26/Stateless-NiFi/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Apache NiFi应用程序可以被认为是两个独立但相互交织的组件:流作者组件和流引擎。通过将这两个组件集成到一个应用程序中，NiFi允许用户创建数据流并在同一个用户界面中实时运行它。</p>
<p>然而，这两个概念是可以分开的。NiFi可以用来创建流，然后不仅可以由NiFi运行，还可以由其他兼容的数据流引擎运行。Apache NiFi项目提供了几个这样的数据流引擎:Apache NiFi本身、MiNiFi Java (Apache NiFi的一个子项目)、MiNiFi c++ (Apache NiFi的一个子项目)和无状态NiFi</p>
<p>这些数据流引擎中的每一个都有自己的优点和缺点，因此它们有自己最擅长解决的特定用例。本文将介绍无状态NiFi是什么，如何使用它，以及它的优点和缺点</p>
<h2 id="传统的NiFi"><a href="#传统的NiFi" class="headerlink" title="传统的NiFi"></a>传统的NiFi</h2><p>NiFi被设计为作为大型多租户应用程序运行。它努力充分利用提供给它的所有资源，包括磁盘/存储和许多线程。通常，单个NiFi实例跨许多不同的节点集群，形成一个大型的内聚数据流，该数据流可能由许多不同的子流组成。一般来说，NiFi将承担交付给它的数据的所有权。它将数据可靠地存储在磁盘上，直到它被传递到所有必要的目的地。此数据的交付可以在流中的不同位置进行优先级排序，以便将对特定目的地最重要的数据首先交付到该目的地，而相同的数据可以根据优先级以不同的顺序交付到另一个目的地。NiFi在完成所有这些工作的同时，保持非常细粒度的沿袭，并保持流中每个组件所看到的数据缓冲区(数据沿袭和数据滚动缓冲区的组合称为data Provenance)。</p>
<p>这些特性中的每一个都非常重要，可以提供一个非常强大、广泛、全面的视图，了解数据是如何在企业上操作和流经企业的。然而，在一些用例中，更轻量级的应用程序可以更好地服务于这些用例。一个能够与NiFi可以交互的所有不同端点进行交互的应用程序，并执行NiFi可以执行的所有转换、路由、过滤和处理。但是一个应用程序被设计为只运行一个小的子流，而不是一个有许多源和汇的大数据流。</p>
<h2 id="无状态NiFi"><a href="#无状态NiFi" class="headerlink" title="无状态NiFi"></a>无状态NiFi</h2><p>进入无状态NiFi(在本文档中也简称为“无状态”)。无状态NiFi中的许多概念与典型的Apache NiFi引擎中的概念不同。</p>
<p>无状态提供了一个占用空间更小的数据流引擎。它不包括用于编写或监视数据流的用户界面，而是运行使用NiFi应用程序编写的数据流。NiFi在能够访问快速存储(如SSD和NVMe驱动器)时表现最佳，而Stateless则将所有数据存储在内存中。</p>
<p>这意味着如果无状态NiFi停止，它将不再能够直接访问正在运行的数据。因此，无状态应该只用于数据源可靠且可重放的数据流，或者数据丢失不是关键问题的场景。</p>
<p>一个非常常见的用例是让无状态NiFi从Apache Kafka或JMS读取数据，然后执行一些路由/过滤/操作，最后将数据传递到另一个目的地。如果像这样的数据流要在NiFi中运行，那么数据将从源被消耗，写入NiFi的内部存储库，并得到确认，因此NiFi将获得该数据的所有权。然后，它将负责将其传递到所有目的地，即使应用程序重新启动也是如此。</p>
<p>但是，使用无状态NiFi，数据将被使用，然后传输到流中的下一个处理器。数据不会被写入任何类型的内部存储库，也不会被确认。流中的下一个处理器将处理数据，然后将其传递下去。只有当数据到达整个数据流的末端时，才会确认从源接收到的数据。如果在处理完成之前重新启动Stateless，则数据尚未得到确认，因此只是再次使用它。这允许在内存中处理数据，而不必担心数据丢失，但它也让源承担了可靠地存储数据并使数据可重放的责任。</p>
<h2 id="可兼容的数据流"><a href="#可兼容的数据流" class="headerlink" title="可兼容的数据流"></a>可兼容的数据流</h2><p>如上所述，无状态NiFi要求数据源既可靠又可重放。这限制了无状态可以合理交互的源。此外，对于无状态引擎能够运行的数据流，还有一些其他限制。</p>
<h3 id="1、-单一来源、单一目标"><a href="#1、-单一来源、单一目标" class="headerlink" title="1、 单一来源、单一目标"></a>1、 单一来源、单一目标</h3><p>在无状态状态下运行的每个数据流应该保持在单个源和单个接收器或目的地。由于Stateless不存储它正在处理的数据，也不存储元数据，例如数据流中数据排队的位置，因此将单个FlowFile发送到多个目的地可能导致数据重复。</p>
<p>考虑一个流，其中数据从Apache Kafka消费，然后交付到HDFS和S3。如果数据存储在HDFS中，然后存储到S3失败，则整个会话将被回滚，并且必须再次使用数据。因此，数据可能会被第二次消费并交付给HDFS。如果这种情况继续发生，数据将继续从Kafka提取并存储在HDFS中。根据目的地和流配置，这可能不是一个问题(除了浪费资源之外)，但在许多情况下，这是一个重要的问题。</p>
<p>因此，如果要使用无状态引擎运行数据流，那么应该将这样的数据流分解为两个不同的数据流。第一个将数据从Apache Kafka传送到HDFS，另一个将数据从Apache Kafka传送到S3。每个数据流都应该为Kafka使用一个单独的Consumer Group，这将导致每个数据流获得相同数据的副本</p>
<h3 id="2、对合并的支持可能有限"><a href="#2、对合并的支持可能有限" class="headerlink" title="2、对合并的支持可能有限"></a>2、对合并的支持可能有限</h3><p>由于无状态NiFi中的数据从头到尾同步地通过数据流传输，因此使用需要多个flowfile(如MergeContent和MergeRecord)的处理器可能无法接收成功所需的所有数据。如果处理器有数据排队并被触发，但没有取得任何进展，则无状态引擎将再次触发源处理器，以便向处理器提供额外的数据</p>
<p>然而，这可能导致数据不断被引入的情况，这取决于处理器的行为。为了避免这种情况，可以通过配置限制可能带入数据流的单个调用的数据量。如果数据流配置将每次调用的数据量限制为10 MB，但是配置了MergeContent直到至少有100 MB的可用数据才创建bin，则数据流将继续触发MergeContent运行，而不进行任何进展，直到达到最大bin年龄(如果配置)或数据流超时。</p>
<p>此外，根据运行Stateless的上下文，触发源组件可能不会提供额外的数据。例如，如果在数据在输入端口中排队，然后触发数据流的环境中运行无状态，则随后触发输入端口运行将不会产生额外的数据</p>
<p>因此，确保任何包含合并FlowFiles逻辑的数据流都配置了MergeContent和MergeRecord的最大Bin Age是很重要的。</p>
<h3 id="3、故障处理"><a href="#3、故障处理" class="headerlink" title="3、故障处理"></a>3、故障处理</h3><p>在传统的NiFi中，将从给定处理器的“失败”连接循环回同一处理器是很常见的。这导致处理器不断尝试处理FlowFile，直到它成功为止。这可能非常重要，因为通常一个NiFi接收数据，它负责获得该数据的所有权，并且必须能够保存该数据，直到下游服务能够接收它并随后交付该数据。</p>
<p>然而，对于无状态NiFi，假定数据源既可靠又可重放。此外，根据设计，无状态NiFi在重启后不会保存数据。因此，对故障处理的考虑可能会有所不同。使用无状态NiFi，如果无法将数据传递到下游系统，通常最好将FlowFile路由到输出端口，然后将输出端口标记为故障端口(参见下面的[失败端口](#failure- Ports)了解更多信息)。</p>
<h3 id="4、流不应该加载大量文件"><a href="#4、流不应该加载大量文件" class="headerlink" title="4、流不应该加载大量文件"></a>4、流不应该加载大量文件</h3><p>在传统的NiFi中，FlowFile内容存储在磁盘上，而不是内存中。因此，它能够处理任何大小的数据，只要它适合磁盘。然而，在无状态中，FlowFile内容存储在内存中，在JVM堆中。因此，通常不建议尝试将大量文件(例如100 GB数据集)加载到无状态NiFi中。这样做通常会导致OutOfMemoryError，或者至少会导致大量垃圾收集，从而降低性能。</p>
<h2 id="特性对比"><a href="#特性对比" class="headerlink" title="特性对比"></a>特性对比</h2><p>如上所述，无状态NiFi提供了一组不同于传统NiFi的特性和权衡。在这里，我们总结一下关键的区别。这种比较并不详尽，但可以快速了解这两个运行时是如何运行的。<br>| Feature | Traditional NiFi | Stateless NiFi |<br>|———|——————|—————-|<br>| 数据持久性 | 数据可靠地存储在磁盘上的FlowFile和Content Repositories中 | 数据存储在内存中，必须在重新启动时再次从源端使用 |<br>| 数据排序 | 数据在每个连接中根据选择的优先级排序独立排序 | 数据按照接收到的顺序在系统中流动(先进先出/ FIFO) |<br>| Site-to-Site | 支持完整的Site-to-Site功能，包括服务器和客户端角色 | 可以向NiFi实例推送或从NiFi实例拉取，但不能接收传入的站点到站点连接。也就是说，作为客户端而不是服务器工作 |<br>| Form Factor | 旨在利用多个内核和磁盘的优势 | 轻巧的外形因素。很容易嵌入到另一个应用程序。单线程处理 |<br>| Heap Considerations | 通常，许多用户正在使用许多处理器。不应该将FlowFile内容加载到堆中，因为它很容易导致堆耗尽 | 较小的数据流使用较少的堆。Flow一次只对一个或几个FlowFile进行操作，并将FlowFile的内容保存在Java堆的内存中。 |<br>| Data Provenance | 完全存储、索引的数据来源，可以通过UI浏览并通过Reporting Tasks导出 | 有限的数据来源功能，事件存储在内存中。无法查看，但可以使用Reporting Tasks导出。但是，由于它们在内存中，因此它们将在重新启动时丢失，并且可能在导出之前滚出 |<br>| 嵌入性 | 虽然在技术上可以嵌入传统的NiFi，但不建议这样做，因为它会启动一个重量级的用户界面，处理复杂的身份验证和授权，以及几个基于文件的外部依赖项，这可能很难管理 | 具有最小的外部依赖关系(包含扩展的目录和用于临时存储的工作目录)，并且更易于管理。可嵌入性是无状态NiFi的一个重要特性。 |</p>
]]></content>
      <categories>
        <category>NiFi</category>
      </categories>
      <tags>
        <tag>NiFi</tag>
        <tag>Stateless</tag>
      </tags>
  </entry>
  <entry>
    <title>NiFi自定义扩展文档</title>
    <url>/2024/02/24/NiFi%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="一、-NiFi组件"><a href="#一、-NiFi组件" class="headerlink" title="一、 NiFi组件"></a>一、 NiFi组件</h1><p>NiFi提供了几个扩展点，使开发人员能够向应用程序添加功能以满足他们的需求。下面的列表提供了最常见扩展点的高级描述</p>
<h2 id="1-Processor"><a href="#1-Processor" class="headerlink" title="1. Processor"></a>1. Processor</h2><p>处理器接口是NiFi公开对FlowFiles、其属性和内容的访问的机制。处理器是用于组成NiFi数据流的基本元素。该接口用于完成以下所有任务 </p>
<ul>
<li>创建FlowFiles</li>
<li>读取FlowFile内容</li>
<li>写FlowFile内容</li>
<li>读FlowFile属性</li>
<li>更新FlowFile属性</li>
<li>摄取数据</li>
<li>输出数据</li>
<li>路由数据</li>
<li>提取数据</li>
<li>修改数据 </li>
</ul>
<h2 id="2-ReportingTask"><a href="#2-ReportingTask" class="headerlink" title="2. ReportingTask"></a>2. ReportingTask</h2><p> ReportingTask接口允许将指标、监控信息和内部NiFi状态发布到外部端点，如日志文件、电子邮件和远程web服务。 </p>
<h2 id="3-ParameterProvider"><a href="#3-ParameterProvider" class="headerlink" title="3. ParameterProvider"></a>3. ParameterProvider</h2><p>ParameterProvider接口允许外部源提供参数。提供的参数仍然存储在参数上下文中，但是这种机制允许在外部提供和管理它们。 </p>
<h2 id="4-ControllerService"><a href="#4-ControllerService" class="headerlink" title="4.  ControllerService"></a>4.  ControllerService</h2><p> 在单个JVM中，ControllerService提供跨处理器、其他ControllerServices、参数提供者和reportingtask的共享状态和功能。一个示例用例可能包括将非常大的数据集加载到内存中。通过在ControllerService中执行这项工作，数据可以加载一次，并通过该服务向所有处理器公开，而不是要求许多不同的处理器自己加载数据集。 </p>
<h2 id="5-FlowFilePrioritizer"><a href="#5-FlowFilePrioritizer" class="headerlink" title="5.  FlowFilePrioritizer"></a>5.  FlowFilePrioritizer</h2><p>FlowFilePrioritizer接口提供了一种机制，通过该机制可以对队列中的FlowFiles进行优先级排序或排序，以便FlowFiles可以按照最有效的顺序处理特定用例。 </p>
<h2 id="6-AuthorityProvider"><a href="#6-AuthorityProvider" class="headerlink" title="6.  AuthorityProvider"></a>6.  AuthorityProvider</h2><p> AuthorityProvider负责确定应该授予给定用户哪些特权和角色(如果有的话) </p>
<h1 id="二、-Processor-API"><a href="#二、-Processor-API" class="headerlink" title="二、 Processor API"></a>二、 Processor API</h1><p>处理器是NiFi中使用最广泛的组件。处理器是唯一被赋予创建、删除、修改或检查FlowFiles(数据和属性)权限的组件。所有的处理器都是使用Java的ServiceLoader机制加载和实例化的。</p>
<p>虽然Processor是一个可以直接实现的接口，但是这样做是非常罕见的，因为org.apache.nifi.processor.AbstractProcessor是几乎所有Processor实现的基类。 AbstractProcessor类提供了大量的功能，这使得开发Processor的任务变得更加容易和方便。在本文的范围内，我们将主要关注处理Processor API时的AbstractProcessor类。 </p>
<blockquote>
<p> NiFi是一个高度并发的框架。这意味着所有扩展都必须是线程安全的。如果不熟悉用Java编写并发软件，强烈建议您熟悉Java并发原则。 </p>
</blockquote>
<p>为了理解Processor API，我们必须首先理解几个支持类和接口。 </p>
<h2 id="FlowFile"><a href="#FlowFile" class="headerlink" title="FlowFile"></a>FlowFile</h2><p> FlowFile是一个逻辑概念，它将一段数据与一组关于该数据的属性相关联。这些属性包括FlowFile的唯一标识符，以及它的名称、大小和任何其他特定于流的值。虽然FlowFile的内容和属性可以改变，但FlowFile对象是不可变的。对FlowFile的修改可以通过ProcessSession实现。 </p>
<p>FlowFiles的核心属性定义在org.apache.nifi.flowfile.attributes.CoreAttributes enum中。</p>
<ul>
<li> Filename (filename): FlowFile的文件名。文件名不应包含任何目录结构 </li>
<li> UUID (uuid):分配给该FlowFile的通用唯一标识符，用于将该FlowFile与系统中的其他FlowFile区分开来。 </li>
<li> 路径(path): FlowFile的路径是指FlowFile所属的相对目录，不包含文件名。 </li>
<li>绝对路径( absolute.path ): FlowFile的绝对路径是指FlowFile所属的绝对目录，不包含文件名。 </li>
<li> 优先级( priority ):表示FlowFile优先级的数值。 </li>
<li> MIME Type ( mime.type ):这个流文件的MIME类型。 </li>
<li> 丢弃原因( discard.reason ):指定FlowFile被丢弃的原因。  </li>
<li>替代标识符( alternate.identifier ):指示FlowFile的UUID之外的标识符，已知该标识符引用该FlowFile。 </li>
</ul>
<p><strong>其他的公共属性：</strong></p>
<p> 虽然这些属性不是CoreAttributes枚举的成员，但它们实际上是整个系统的标准，并且可以在大多数FlowFiles中找到。 </p>
<ul>
<li>文件大小(fileSize): FlowFile内容的大小，单位为字节。</li>
<li> 输入日期(entryDate): FlowFile进入系统(即创建)的日期和时间。此属性的值是一个数字，表示从1970年1月1日午夜(UTC)开始的毫秒数。 </li>
<li> 血统开始日期(lineageStartDate):任何时候，一个FlowFile被克隆，合并，或者分割，这将导致一个“子”FlowFile被创建。当这些子代被克隆、合并或分裂时，一个祖先链就建立起来了。该值表示最早的祖先进入系统的日期和时间。考虑这个问题的另一种方式是，该属性表示FlowFile通过系统的延迟。取值为数字，表示从1970年1月1日午夜(UTC)开始的毫秒数。 </li>
</ul>
<h2 id="ProcessSession"><a href="#ProcessSession" class="headerlink" title="ProcessSession"></a>ProcessSession</h2><p>ProcessSession(通常简称为“会话”)提供了一种机制，通过该机制可以创建、销毁、检查、克隆FlowFiles，并将其传输到其他处理器。此外，ProcessSession提供了通过添加或删除属性或修改FlowFile的内容来创建修改版本的FlowFiles的机制。ProcessSession还公开了一种发出<strong>出处事件（  <a href="https://nifi.apache.org/docs/nifi-docs/html/developer-guide.html#provenance_events">Provenance Events</a> ）</strong>的机制，该机制提供了跟踪FlowFile沿袭和历史的能力。 在对一个或多个FlowFiles执行操作后，ProcessSession可以提交或回滚。 </p>
<h2 id="ProcessContext"><a href="#ProcessContext" class="headerlink" title="ProcessContext"></a>ProcessContext</h2><p>ProcessContext提供了处理器和框架之间的桥梁。它提供有关处理器当前如何配置的信息，并允许处理器执行特定于框架的任务， 比如释放自己的资源，这样框架就可以在不消耗不必要资源的情况下调度其他处理器运行。 </p>
<h2 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h2><p>PropertyDescriptor定义了一个属性，该属性将被Processor、ReportingTask、ParameterProvider或ControllerService使用。属性的定义包括其名称、属性描述、可选的默认值、验证逻辑和指示说明是否需要该属性才能使Processor有效。PropertyDescriptor是通过实例化PropertyDescriptor的实例来创建的。构造器类，调用适当的方法来填充有关属性的详细信息，最后调用构建方法。 </p>
<h2 id="Validator"><a href="#Validator" class="headerlink" title="Validator"></a>Validator</h2><p>属性描述符必须指定一个或多个验证器，用于确保用户输入的属性值是有效的。如果Validator指示属性值无效，则在该属性变为有效之前，组件将无法运行或使用。如果没有指定Validator，组件将被认为是无效的，NiFi将报告不支持该属性。</p>
<h2 id="ValidationContext"><a href="#ValidationContext" class="headerlink" title="ValidationContext"></a>ValidationContext</h2><p>当验证属性值时，ValidationContext可以用来获取ControllerServices，创建PropertyValue对象，并使用表达式语言编译和计算属性值。</p>
<h2 id="PropertyValue"><a href="#PropertyValue" class="headerlink" title="PropertyValue"></a>PropertyValue</h2><p>返回给Processor的所有属性值都以PropertyValue对象的形式返回。该对象具有将值从String转换为其他形式(如数字和时间段)的方便方法，并提供用于求值Expression Language的API。 </p>
<h2 id="Relationship"><a href="#Relationship" class="headerlink" title="Relationship"></a>Relationship</h2><p>关系定义了FlowFile可以从处理器传输到的路由。通过实例化Relationship的实例来 <code>Relationship.Builder</code>  ，调用适当的方法来填充关系的详细信息，最后调用构建方法。 </p>
<h2 id="StateManager"><a href="#StateManager" class="headerlink" title="StateManager"></a>StateManager</h2><p> StateManager为处理器、报告任务和控制器服务提供了一种容易存储和检索状态的机制， 该API类似于ConcurrentHashMap，但每个操作都需要一个Scope。 这个Scope表示这个state是存在本地还是集群维度的。</p>
<h2 id="ProcessorInitializationContext"><a href="#ProcessorInitializationContext" class="headerlink" title="ProcessorInitializationContext"></a>ProcessorInitializationContext</h2><p>在创建了一个Processor之后，它的initialize方法将被InitializationContext对象调用。该对象向处理器公开在整个处理器生命周期中不会改变的配置，例如处理器的唯一标识符。 </p>
<h2 id="ComponentLog"><a href="#ComponentLog" class="headerlink" title="ComponentLog"></a>ComponentLog</h2><p>建议处理器通过ComponentLog接口执行日志记录，而不是获取第三方日志记录器的直接实例。这是因为通过ComponentLog进行日志记录允许框架将超过可配置严重性级别的日志消息呈现给用户界面，从而允许在发生重要事件时通知监视数据流的人员。此外，它通过在DEBUG模式下记录堆栈跟踪并在日志消息中提供处理器的唯一标识符，为所有处理器提供一致的日志记录格式。 </p>
<h1 id="三、AbstractProcessor-API"><a href="#三、AbstractProcessor-API" class="headerlink" title="三、AbstractProcessor API"></a>三、AbstractProcessor API</h1><p>由于绝大多数处理器将通过扩展AbstractProcessor来创建，因此我们将在本节中研究抽象类。AbstractProcessor提供了几个处理器开发人员会感兴趣的方法。 </p>
<h2 id="1、-处理器初始化"><a href="#1、-处理器初始化" class="headerlink" title="1、 处理器初始化"></a>1、 处理器初始化</h2><p> 在创建Processor之后，在调用任何其他方法之前，将调用AbstractProcessor的init方法。 该方法接受一个参数，类型为ProcessorInitializationContext。 上下文对象向处理器提供一个ComponentLog、处理器的唯一标识符和一个 ControllerServiceLookup  (可用于与已配置的ControllerServices交互)。这些对象中的每一个都由AbstractProcessor存储，并且可以由子类分别通过getLogger、getIdentifier和getControllerservicellookup方法获得。</p>
<h2 id="2、-暴露处理器属性"><a href="#2、-暴露处理器属性" class="headerlink" title="2、 暴露处理器属性"></a>2、 暴露处理器属性</h2><p>大多数处理器在使用之前都需要一定数量的用户配置。  处理器支持的属性通过getSupportedPropertyDescriptors方法公开给框架。 此方法不接受任何参数，并返回PropertyDescriptor对象的列表。<strong>列表中对象的顺序很重要，因为它决定了属性在用户界面中呈现的顺序。</strong> </p>
<h3 id="动态处理器属性"><a href="#动态处理器属性" class="headerlink" title="动态处理器属性"></a>动态处理器属性</h3><p> 除了标准属性之外，有时还希望允许用户配置名称不是预定义的其他属性。  这可以通过覆盖getSupportedDynamicPropertyDescriptor方法来实现。  此方法接受String作为其唯一参数，该参数指示属性的名称。该方法返回一个PropertyDescriptor对象，该对象可用于验证属性的名称和值。  从这个方法返回的任何PropertyDescriptor都应该在PropertyDescriptor中设置isDynamic的值为true。。AbstractProcessor的默认行为是不允许任何动态创建的属性。</p>
<h3 id="敏感动态属性"><a href="#敏感动态属性" class="headerlink" title="敏感动态属性"></a>敏感动态属性</h3><p>动态属性的默认实现不将属性值视为敏感值。在配置FlowFile属性或自定义表达式等特性时，这种方法是足够的，但它不能为密码或密钥等值提供保护。  </p>
<p>NiFi 1.17.0通过一个名为SupportsSensitiveDynamicProperties的注解引入了对敏感动态属性的框架支持。注释可以通过getSupportedDynamicPropertyDescriptor方法应用于支持动态属性的处理器、控制器服务或报告任务。注释表明组件允许将单个动态属性标记为敏感属性，以用于持久化和框架处理。 </p>
<p> getSupportedDynamicPropertyDescriptor必须返回一个 <code>sensitive</code>  设置为false的PropertyDescriptor，以允许自定义敏感状态。在此方法中将敏感字段设置为true将强制将所有动态属性作为敏感属性处理。这种方法允许在受支持的组件中升级敏感状态，但不降级。 </p>
<p>敏感属性值的安全处理是带注释的类的责任。支<strong>持敏感动态属性的组件不能记录属性值或将属性值作为FlowFile属性提供。</strong> </p>
<h2 id="3、-验证处理器属性"><a href="#3、-验证处理器属性" class="headerlink" title="3、 验证处理器属性"></a>3、 验证处理器属性</h2><p>如果处理器的配置无效，则处理器无法启动。 </p>
<p>处理器属性的验证可以通过在PropertyDescriptor上设置Validator或通过PropertyDescriptor限制属性的允许值来实现。Builder的allowableValues方法或identifiesControllerService方法。  此外，如果一个属性依赖于另一个属性( <code>PropertyDescriptor.Builder’s </code>dependsOn` method ），切不满足的话则会被校验住。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertyDescriptor USE_FILE = <span class="keyword">new</span> PropertyDescriptor.Buildler()</span><br><span class="line">    .name(<span class="string">&quot;Use File&quot;</span>)</span><br><span class="line">    .displayName(<span class="string">&quot;Use File&quot;</span>)</span><br><span class="line">    .required(<span class="keyword">true</span>)</span><br><span class="line">    .allowableValues(<span class="string">&quot;true&quot;</span>, <span class="string">&quot;false&quot;</span>)</span><br><span class="line">    .defaultValue(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertyDescriptor FILE = <span class="keyword">new</span> PropertyDescriptor.Builder()</span><br><span class="line">    .name(<span class="string">&quot;File to Use&quot;</span>)</span><br><span class="line">    .displayName(<span class="string">&quot;File to Use&quot;</span>)</span><br><span class="line">    .required(<span class="keyword">true</span>)</span><br><span class="line">    .addValidator(StandardValidators.FILE_EXISTS_VALIDATOR)</span><br><span class="line">    .dependsOn(USE_FILE, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>



<p>有时单独验证一个Processor的属性是不够的。为此，AbstractProcessor公开了一个customValidate方法。该方法接受ValidationContext类型的单个参数。这个方法的返回值是一个ValidationResult对象的集合，它描述了在验证过程中发现的任何问题。只有那些isValid方法返回false的ValidationResult对象才应该被返回。 只有当所有属性根据其关联的验证器和允许值都有效时，才会调用此方法。也就是说，只有当所有属性本身都有效时，这个方法才会被调用，并且这个方法允许将处理器的配置作为一个整体进行验证。 </p>
<h2 id="4、响应配置中的更改"><a href="#4、响应配置中的更改" class="headerlink" title="4、响应配置中的更改"></a>4、响应配置中的更改</h2><p> 有时，当处理器的属性发生变化时，我们希望它立即做出反应。  onPropertyModified方法允许处理器这样做。当用户更改处理器的属性值时，将为每个修改的属性调用onPropertyModified方法。 </p>
<p> 该方法接受三个参数:PropertyDescriptor(表示修改了哪个属性、旧值和新值。  如果属性之前没有值，第二个参数将为空。  如果该属性被删除，则第三个参数将为空。重要的是要注意，无论值是否有效，都会调用此方法。这个方法将只在值被实际修改时调用，而不是在用户更新处理器而不更改其值时调用。在调用此方法时，可以保证调用此方法的线程是当前在处理器中执行代码的唯一线程，除非处理器本身创建了自己的线程。 </p>
<h2 id="5、-执行工作"><a href="#5、-执行工作" class="headerlink" title="5、 执行工作"></a>5、 执行工作</h2><p> 当处理器有工作要做时，它通过框架调用它的onTrigger方法来进行调度。 </p>
<p> 该方法有两个参数:一个ProcessContext和一个ProcessSession。onTrigger方法的第一步通常是通过调用ProcessSession上的get方法来获取要在其上执行工作的FlowFile。 </p>
<p> 对于从外部源摄取数据到NiFi的处理器，跳过此步骤。然后处理器可以自由地检查FlowFile属性;添加、删除或修改属性;读取或修改FlowFile内容;并将FlowFiles传输到适当的关系。 </p>
<h2 id="6、-处理器何时被触发"><a href="#6、-处理器何时被触发" class="headerlink" title="6、  处理器何时被触发"></a>6、  处理器何时被触发</h2><p>处理器的onTrigger方法只有在计划运行时才会被调用，并且处理器有工作要做。如果满足以下任何一个条件，就称处理器存在工作</p>
<ul>
<li> 目标是处理器的连接在其队列中至少有一个FlowFile </li>
<li> 处理器没有传入连接</li>
<li> 处理器用@TriggerWhenEmpty注释 </li>
</ul>
<p>有几个因素会影响处理器的onTrigger方法何时被调用。</p>
<p>首先，除非用户已将Processor配置为运行，否则不会触发Processor。如果处理器被安排运行，框架会定期(周期由用户在用户界面中配置)检查处理器是否有工作要做。如果是，框架将检查处理器的下游目的地。 </p>
<p> <strong>如果处理器的任何出站连接已满，默认情况下，处理器将不会被安排运行。</strong> </p>
<p> 但是，@TriggerWhenAnyDestinationAvailable注释可以添加到Processor的类中。  在这种情况下，需求被更改为只有一个下游目的地必须是“可用的”(如果Connection队列未满，则认为目的地是“可用的”)，而不是要求所有下游目的地都可用。 </p>
<p>与处理器调度相关的还有 @TriggerSerially 注释。使用此注释的处理器永远不会有多个线程同时运行onTrigger方法。但是，需要注意的是，执行代码的线程在调用之间可能会发生变化。因此，仍然必须小心确保处理器是线程安全的</p>
<h2 id="7、组件生命周期"><a href="#7、组件生命周期" class="headerlink" title="7、组件生命周期"></a>7、组件生命周期</h2><h3 id="OnAdded"><a href="#OnAdded" class="headerlink" title="@OnAdded"></a>@OnAdded</h3><p> @OnAdded注释会在创建组件时立即调用一个方法 ， <code>initialize</code>  方法将在组件构造之后被调用，然后是带有@OnAdded注释的方法。 该方法在组件的生命周期中只会被调用一次。带有此注释的方法必须不带参数。 </p>
<h3 id="OnEnabled"><a href="#OnEnabled" class="headerlink" title="@OnEnabled"></a>@OnEnabled</h3><p> @OnEnabled注释可以用来指示一个方法应该在控制器服务被启用时被调用。 任何具有此注释的方法都会在每次用户启用该服务时被调用。此外，每次重启NiFi时，如果将NiFi配置为“ auto-resume state ”并且启用了服务，则将调用该方法。</p>
<p>如果带有此注释的方法抛出Throwable，则将为该组件发出一条日志消息和公告。在这种情况下，服务将保持在“ ENABLING ”状态，并且将不可用。带有此注释的所有方法将在延迟后再次调用。在所有带有此注释的方法都返回而不抛出任何东西之前，该服务将无法使用。 </p>
<h3 id="OnRemoved"><a href="#OnRemoved" class="headerlink" title="@OnRemoved"></a>@OnRemoved</h3><p> @OnRemoved注释导致在组件从流中移除之前调用一个方法。这允许在删除组件之前清理资源。带有此注释的方法必须不带参数。<strong>如果带有此注释的方法抛出异常，该组件仍将被删除。</strong> </p>
<h3 id="OnScheduled"><a href="#OnScheduled" class="headerlink" title="@OnScheduled"></a>@OnScheduled</h3><p> 每次计划运行组件时都应调用该方法。因为ControllerServices没有被调度，所以在ControllerService上使用这个注释是没有意义的。 它应该仅用于处理器和 Reporting Tasks 。如果具有此注释的任何方法抛出Exception，则不会调用具有此注释的其他方法，并将向用户显示通知。 </p>
<p> 在这种情况下，然后触发带有@OnUnscheduled注释的方法，然后触发带有@OnStopped注释的方法(在此状态下，如果这些方法中的任何一个抛出异常，这些异常将被忽略)。  然后，该组件将在一段时间内执行，这段时间称为“Administrative yield Duration”，这是在nifi中配置的一个值。 最后，进程将再次启动，直到所有带@OnScheduled注释的方法都返回而不抛出任何异常。 </p>
<p>带有此注释的方法可以不带参数，也可以只带一个参数。如果使用单个参数变体，如果组件是Processor，则参数必须是ProcessContext类型，如果组件是ReportingTask，则参数必须是ConfigurationContext类型。 </p>
<h3 id="OnUnscheduled"><a href="#OnUnscheduled" class="headerlink" title="@OnUnscheduled"></a>@OnUnscheduled</h3><p>每当处理器或ReportingTask不再调度运行时，将调用带有此注释的方法。此时，在Processor的onTrigger方法中可能仍有许多线程处于活动状态。如果这样的方法抛出异常，将生成一条日志消息，否则将忽略该异常，并且仍将调用带有此注释的其他方法。带有此注释的方法可以不带参数，也可以只带一个参数。如果使用单个参数变体，如果组件是Processor或ConfigurationContext，则参数必须是ProcessContext类型 </p>
<h3 id="OnStopped"><a href="#OnStopped" class="headerlink" title="@OnStopped"></a>@OnStopped</h3><p> 当处理器或ReportingTask不再调度运行并且所有线程都从onTrigger方法返回时，将调用带有此注释的方法。如果这样的方法抛出异常，将生成一条日志消息，否则该异常将被忽略;使用此注释的其他方法仍将被调用。带有此注释的方法允许接受0或1个参数。如果使用了参数，如果组件是ReportingTask，则参数的类型必须是ConfigurationContext;如果组件是Processor，则参数的类型必须是ProcessContext。 </p>
<h3 id="OnShutdown"><a href="#OnShutdown" class="headerlink" title="@OnShutdown"></a>@OnShutdown</h3><p>任何带有@OnShutdown注释的方法都将在NiFi成功关闭时被调用。如果这样的方法抛出异常，将生成一条日志消息，否则将忽略该异常，并且仍将调用带有此注释的其他方法。带有此注释的方法<strong>必须不带参数</strong>。注意:虽然NiFi将尝试在使用它的所有组件上调用带有此注释的方法，但这并不总是可能的。 </p>
<p>例如，进程可能意外终止，在这种情况下，它没有机会调用这些方法。因此，虽然使用此注释的方法可用于清理资源，但不应依赖于关键业务逻辑。 </p>
<h2 id="8、组件通知"><a href="#8、组件通知" class="headerlink" title="8、组件通知"></a>8、组件通知</h2><h3 id="OnPrimaryNodeStateChange"><a href="#OnPrimaryNodeStateChange" class="headerlink" title="@OnPrimaryNodeStateChange"></a>@OnPrimaryNodeStateChange</h3><p> @OnPrimaryNodeStateChange注释会在集群中主节点的状态发生变化时立即调用方法。带有此注释的方法要么不带参数，要么只带一个PrimaryNodeState类型的参数。PrimaryNodeState提供有关更改内容的上下文，以便组件可以采取适当的操作。PrimaryNodeState枚举器有两种可能的值:ELECTED PRIMARY NODE(接收此状态的节点已被选为NiFi集群的主节点)或PRIMARY NODE REVOKED( 接收此状态的节点是主节点，但现在其主节点角色已被撤销)</p>
<h2 id="9-、约束组件"><a href="#9-、约束组件" class="headerlink" title="9.、约束组件"></a>9.、约束组件</h2><p>受限制的组件是可用于执行操作员通过NIFI REST API/UI提供的任意不固定的代码，或者可以使用NIFI OS凭据在NIFI主机系统上获取或更改数据。 </p>
<p>这些组件可以被授权的NiFi用户用于超出应用程序的预期用途，升级特权，或者可能暴露有关NiFi进程或主机系统内部的数据。所有这些功能都应该被认为是特权的，管理员应该知道这些功能，并为一部分受信任的用户显式地启用它们。 </p>
<p>处理器、控制器服务或报告任务可以使用@Restricted注释进行标记。这将导致组件被视为受限组件，并且需要将用户显式地添加到可以访问受限组件的用户列表中。一旦用户被允许访问受限制的组件，他们将被允许创建和修改这些组件，假设所有其他权限都被允许。如果不能访问受限制的组件，用户仍然会知道这些类型的组件的存在，但即使有其他足够的条件，也无法创建或修改它们。</p>
<h2 id="10、状态管理"><a href="#10、状态管理" class="headerlink" title="10、状态管理"></a>10、状态管理</h2><p>从ProcessContext、ReportingContext和ControllerServiceInitializationContext中，组件可以调用getStateManager()方法。这个状态管理器负责提供一个简单的API来存储和检索状态。  该机制旨在使开发人员能够轻松地存储一组密钥/值对，检索这些值并原子更新它们。该状态可以在群集中局部存储在节点上，也可以在所有节点中存储。 </p>
<p>然而，需要注意的是，该机制的目的只是提供一种存储非常“简单”状态的机制。  因此，API只允许存储和检索Map&lt;String, String&gt;，并自动替换整个Map。此外，目前唯一支持存储集群范围状态的实现是由ZooKeeper支持的。  因此，在序列化之后，整个State Map的大小必须小于1mb。试图存储超过此值将导致抛出异常。如果处理器管理状态所需的交互比这更复杂(例如，必须存储和检索大量数据，或者必须单独存储和获取单个键)，则应该使用不同的机制(例如，与外部数据库通信)。 </p>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>当与状态管理器通信时，所有方法调用都需要提供Scope。这个Scope将是Scope.LOCAL或Scope.CLUSTER。如果NiFi在集群中运行，则此Scope向框架提供有关操作应该如何发生的重要信息。 </p>
<p> 如果状态使用 Scope.CLUSTER 存储。集群中的所有节点都将使用相同的状态存储机制进行通信。如果使用 Scope.LOCAL ，那么每个节点将看到状态的不同表示。 </p>
<p>还值得注意的是，如果将NiFi配置为作为独立实例运行，而不是在集群中运行，则 Scope总是使用Scope.LOCAL。这样做是为了允许NiFi组件的开发人员以一种一致的方式编写代码，而不必担心NiFi实例是否集群。相反，开发人员应该假设实例是集群的，并相应地编写代码。 </p>
<h2 id="11-报告处理器的活动"><a href="#11-报告处理器的活动" class="headerlink" title="11. 报告处理器的活动"></a>11. 报告处理器的活动</h2><p> 处理器负责报告其活动，以便用户能够了解其数据发生了什么。处理器应通过ComponentLog记录事件，该事件可通过初始化访问或调用AbstractProcessor的GetLogger方法访问。 </p>
<p>此外，处理器应使用通过ProcessSession的 <code>getProvenanceReporter</code>  方法获得的 <code>ProvenanceReporter</code>  接口。  ProvenanceReporter应该用于指示从外部源接收内容或将内容发送到外部位置的任何时间。  ProvenanceReTorter还具有报告何时克隆，分叉或修改的流文件以及将多个流文件合并到单个流纸上以及将流纸与其他一些标识符关联的方法。  但是，这些功能不太重要，因为该框架能够检测到这些内容并代表处理器发出适当的事件。 </p>
<p> 然而，对于处理器开发人员来说，发出这些事件是最佳实践，因为它在代码中变得明确说明这些事件正在发出，并且开发人员能够为事件提供其他细节，例如该动作采取了有关所采取的措施的信息。  如果处理器发出事件，则该框架将不会发出重复的事件。相反，它总是假设处理器开发人员比框架更了解处理器上下文中发生的事情。 </p>
<p>但是，框架可能会发出另一个事件。例如，如果处理器对FlowFile的内容及其属性进行修改，然后仅发射 ATTRIBUTES_MODIFIED  事件，则该框架将发出 CONTENT_MODIFIED  事件。 </p>
]]></content>
      <categories>
        <category>NiFi</category>
      </categories>
      <tags>
        <tag>NiFi</tag>
        <tag>文档</tag>
      </tags>
  </entry>
</search>
