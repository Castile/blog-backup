<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Castile</title>
  
  
  <link href="https://castile.github.io/atom.xml" rel="self"/>
  
  <link href="https://castile.github.io/"/>
  <updated>2024-02-24T10:02:16.852Z</updated>
  <id>https://castile.github.io/</id>
  
  <author>
    <name>朱宏梁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NiFi自定义扩展文档</title>
    <link href="https://castile.github.io/2024/02/24/NiFi%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95%E6%96%87%E6%A1%A3/"/>
    <id>https://castile.github.io/2024/02/24/NiFi%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95%E6%96%87%E6%A1%A3/</id>
    <published>2024-02-24T10:02:16.000Z</published>
    <updated>2024-02-24T10:02:16.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-NiFi组件"><a href="#一、-NiFi组件" class="headerlink" title="一、 NiFi组件"></a>一、 NiFi组件</h1><p>NiFi提供了几个扩展点，使开发人员能够向应用程序添加功能以满足他们的需求。下面的列表提供了最常见扩展点的高级描述</p><h2 id="1-Processor"><a href="#1-Processor" class="headerlink" title="1. Processor"></a>1. Processor</h2><p>处理器接口是NiFi公开对FlowFiles、其属性和内容的访问的机制。处理器是用于组成NiFi数据流的基本元素。该接口用于完成以下所有任务 </p><ul><li>创建FlowFiles</li><li>读取FlowFile内容</li><li>写FlowFile内容</li><li>读FlowFile属性</li><li>更新FlowFile属性</li><li>摄取数据</li><li>输出数据</li><li>路由数据</li><li>提取数据</li><li>修改数据 </li></ul><h2 id="2-ReportingTask"><a href="#2-ReportingTask" class="headerlink" title="2. ReportingTask"></a>2. ReportingTask</h2><p> ReportingTask接口允许将指标、监控信息和内部NiFi状态发布到外部端点，如日志文件、电子邮件和远程web服务。 </p><h2 id="3-ParameterProvider"><a href="#3-ParameterProvider" class="headerlink" title="3. ParameterProvider"></a>3. ParameterProvider</h2><p>ParameterProvider接口允许外部源提供参数。提供的参数仍然存储在参数上下文中，但是这种机制允许在外部提供和管理它们。 </p><h2 id="4-ControllerService"><a href="#4-ControllerService" class="headerlink" title="4.  ControllerService"></a>4.  ControllerService</h2><p> 在单个JVM中，ControllerService提供跨处理器、其他ControllerServices、参数提供者和reportingtask的共享状态和功能。一个示例用例可能包括将非常大的数据集加载到内存中。通过在ControllerService中执行这项工作，数据可以加载一次，并通过该服务向所有处理器公开，而不是要求许多不同的处理器自己加载数据集。 </p><h2 id="5-FlowFilePrioritizer"><a href="#5-FlowFilePrioritizer" class="headerlink" title="5.  FlowFilePrioritizer"></a>5.  FlowFilePrioritizer</h2><p>FlowFilePrioritizer接口提供了一种机制，通过该机制可以对队列中的FlowFiles进行优先级排序或排序，以便FlowFiles可以按照最有效的顺序处理特定用例。 </p><h2 id="6-AuthorityProvider"><a href="#6-AuthorityProvider" class="headerlink" title="6.  AuthorityProvider"></a>6.  AuthorityProvider</h2><p> AuthorityProvider负责确定应该授予给定用户哪些特权和角色(如果有的话) </p><h1 id="二、-Processor-API"><a href="#二、-Processor-API" class="headerlink" title="二、 Processor API"></a>二、 Processor API</h1><p>处理器是NiFi中使用最广泛的组件。处理器是唯一被赋予创建、删除、修改或检查FlowFiles(数据和属性)权限的组件。所有的处理器都是使用Java的ServiceLoader机制加载和实例化的。</p><p>虽然Processor是一个可以直接实现的接口，但是这样做是非常罕见的，因为org.apache.nifi.processor.AbstractProcessor是几乎所有Processor实现的基类。 AbstractProcessor类提供了大量的功能，这使得开发Processor的任务变得更加容易和方便。在本文的范围内，我们将主要关注处理Processor API时的AbstractProcessor类。 </p><blockquote><p> NiFi是一个高度并发的框架。这意味着所有扩展都必须是线程安全的。如果不熟悉用Java编写并发软件，强烈建议您熟悉Java并发原则。 </p></blockquote><p>为了理解Processor API，我们必须首先理解几个支持类和接口。 </p><h2 id="FlowFile"><a href="#FlowFile" class="headerlink" title="FlowFile"></a>FlowFile</h2><p> FlowFile是一个逻辑概念，它将一段数据与一组关于该数据的属性相关联。这些属性包括FlowFile的唯一标识符，以及它的名称、大小和任何其他特定于流的值。虽然FlowFile的内容和属性可以改变，但FlowFile对象是不可变的。对FlowFile的修改可以通过ProcessSession实现。 </p><p>FlowFiles的核心属性定义在org.apache.nifi.flowfile.attributes.CoreAttributes enum中。</p><ul><li> Filename (filename): FlowFile的文件名。文件名不应包含任何目录结构 </li><li> UUID (uuid):分配给该FlowFile的通用唯一标识符，用于将该FlowFile与系统中的其他FlowFile区分开来。 </li><li> 路径(path): FlowFile的路径是指FlowFile所属的相对目录，不包含文件名。 </li><li>绝对路径( absolute.path ): FlowFile的绝对路径是指FlowFile所属的绝对目录，不包含文件名。 </li><li> 优先级( priority ):表示FlowFile优先级的数值。 </li><li> MIME Type ( mime.type ):这个流文件的MIME类型。 </li><li> 丢弃原因( discard.reason ):指定FlowFile被丢弃的原因。  </li><li>替代标识符( alternate.identifier ):指示FlowFile的UUID之外的标识符，已知该标识符引用该FlowFile。 </li></ul><p><strong>其他的公共属性：</strong></p><p> 虽然这些属性不是CoreAttributes枚举的成员，但它们实际上是整个系统的标准，并且可以在大多数FlowFiles中找到。 </p><ul><li>文件大小(fileSize): FlowFile内容的大小，单位为字节。</li><li> 输入日期(entryDate): FlowFile进入系统(即创建)的日期和时间。此属性的值是一个数字，表示从1970年1月1日午夜(UTC)开始的毫秒数。 </li><li> 血统开始日期(lineageStartDate):任何时候，一个FlowFile被克隆，合并，或者分割，这将导致一个“子”FlowFile被创建。当这些子代被克隆、合并或分裂时，一个祖先链就建立起来了。该值表示最早的祖先进入系统的日期和时间。考虑这个问题的另一种方式是，该属性表示FlowFile通过系统的延迟。取值为数字，表示从1970年1月1日午夜(UTC)开始的毫秒数。 </li></ul><h2 id="ProcessSession"><a href="#ProcessSession" class="headerlink" title="ProcessSession"></a>ProcessSession</h2><p>ProcessSession(通常简称为“会话”)提供了一种机制，通过该机制可以创建、销毁、检查、克隆FlowFiles，并将其传输到其他处理器。此外，ProcessSession提供了通过添加或删除属性或修改FlowFile的内容来创建修改版本的FlowFiles的机制。ProcessSession还公开了一种发出<strong>出处事件（  <a href="https://nifi.apache.org/docs/nifi-docs/html/developer-guide.html#provenance_events">Provenance Events</a> ）</strong>的机制，该机制提供了跟踪FlowFile沿袭和历史的能力。 在对一个或多个FlowFiles执行操作后，ProcessSession可以提交或回滚。 </p><h2 id="ProcessContext"><a href="#ProcessContext" class="headerlink" title="ProcessContext"></a>ProcessContext</h2><p>ProcessContext提供了处理器和框架之间的桥梁。它提供有关处理器当前如何配置的信息，并允许处理器执行特定于框架的任务， 比如释放自己的资源，这样框架就可以在不消耗不必要资源的情况下调度其他处理器运行。 </p><h2 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h2><p>PropertyDescriptor定义了一个属性，该属性将被Processor、ReportingTask、ParameterProvider或ControllerService使用。属性的定义包括其名称、属性描述、可选的默认值、验证逻辑和指示说明是否需要该属性才能使Processor有效。PropertyDescriptor是通过实例化PropertyDescriptor的实例来创建的。构造器类，调用适当的方法来填充有关属性的详细信息，最后调用构建方法。 </p><h2 id="Validator"><a href="#Validator" class="headerlink" title="Validator"></a>Validator</h2><p>属性描述符必须指定一个或多个验证器，用于确保用户输入的属性值是有效的。如果Validator指示属性值无效，则在该属性变为有效之前，组件将无法运行或使用。如果没有指定Validator，组件将被认为是无效的，NiFi将报告不支持该属性。</p><h2 id="ValidationContext"><a href="#ValidationContext" class="headerlink" title="ValidationContext"></a>ValidationContext</h2><p>当验证属性值时，ValidationContext可以用来获取ControllerServices，创建PropertyValue对象，并使用表达式语言编译和计算属性值。</p><h2 id="PropertyValue"><a href="#PropertyValue" class="headerlink" title="PropertyValue"></a>PropertyValue</h2><p>返回给Processor的所有属性值都以PropertyValue对象的形式返回。该对象具有将值从String转换为其他形式(如数字和时间段)的方便方法，并提供用于求值Expression Language的API。 </p><h2 id="Relationship"><a href="#Relationship" class="headerlink" title="Relationship"></a>Relationship</h2><p>关系定义了FlowFile可以从处理器传输到的路由。通过实例化Relationship的实例来 <code>Relationship.Builder</code>  ，调用适当的方法来填充关系的详细信息，最后调用构建方法。 </p><h2 id="StateManager"><a href="#StateManager" class="headerlink" title="StateManager"></a>StateManager</h2><p> StateManager为处理器、报告任务和控制器服务提供了一种容易存储和检索状态的机制， 该API类似于ConcurrentHashMap，但每个操作都需要一个Scope。 这个Scope表示这个state是存在本地还是集群维度的。</p><h2 id="ProcessorInitializationContext"><a href="#ProcessorInitializationContext" class="headerlink" title="ProcessorInitializationContext"></a>ProcessorInitializationContext</h2><p>在创建了一个Processor之后，它的initialize方法将被InitializationContext对象调用。该对象向处理器公开在整个处理器生命周期中不会改变的配置，例如处理器的唯一标识符。 </p><h2 id="ComponentLog"><a href="#ComponentLog" class="headerlink" title="ComponentLog"></a>ComponentLog</h2><p>建议处理器通过ComponentLog接口执行日志记录，而不是获取第三方日志记录器的直接实例。这是因为通过ComponentLog进行日志记录允许框架将超过可配置严重性级别的日志消息呈现给用户界面，从而允许在发生重要事件时通知监视数据流的人员。此外，它通过在DEBUG模式下记录堆栈跟踪并在日志消息中提供处理器的唯一标识符，为所有处理器提供一致的日志记录格式。 </p><h1 id="三、AbstractProcessor-API"><a href="#三、AbstractProcessor-API" class="headerlink" title="三、AbstractProcessor API"></a>三、AbstractProcessor API</h1><p>由于绝大多数处理器将通过扩展AbstractProcessor来创建，因此我们将在本节中研究抽象类。AbstractProcessor提供了几个处理器开发人员会感兴趣的方法。 </p><h2 id="1、-处理器初始化"><a href="#1、-处理器初始化" class="headerlink" title="1、 处理器初始化"></a>1、 处理器初始化</h2><p> 在创建Processor之后，在调用任何其他方法之前，将调用AbstractProcessor的init方法。 该方法接受一个参数，类型为ProcessorInitializationContext。 上下文对象向处理器提供一个ComponentLog、处理器的唯一标识符和一个 ControllerServiceLookup  (可用于与已配置的ControllerServices交互)。这些对象中的每一个都由AbstractProcessor存储，并且可以由子类分别通过getLogger、getIdentifier和getControllerservicellookup方法获得。</p><h2 id="2、-暴露处理器属性"><a href="#2、-暴露处理器属性" class="headerlink" title="2、 暴露处理器属性"></a>2、 暴露处理器属性</h2><p>大多数处理器在使用之前都需要一定数量的用户配置。  处理器支持的属性通过getSupportedPropertyDescriptors方法公开给框架。 此方法不接受任何参数，并返回PropertyDescriptor对象的列表。<strong>列表中对象的顺序很重要，因为它决定了属性在用户界面中呈现的顺序。</strong> </p><h3 id="动态处理器属性"><a href="#动态处理器属性" class="headerlink" title="动态处理器属性"></a>动态处理器属性</h3><p> 除了标准属性之外，有时还希望允许用户配置名称不是预定义的其他属性。  这可以通过覆盖getSupportedDynamicPropertyDescriptor方法来实现。  此方法接受String作为其唯一参数，该参数指示属性的名称。该方法返回一个PropertyDescriptor对象，该对象可用于验证属性的名称和值。  从这个方法返回的任何PropertyDescriptor都应该在PropertyDescriptor中设置isDynamic的值为true。。AbstractProcessor的默认行为是不允许任何动态创建的属性。</p><h3 id="敏感动态属性"><a href="#敏感动态属性" class="headerlink" title="敏感动态属性"></a>敏感动态属性</h3><p>动态属性的默认实现不将属性值视为敏感值。在配置FlowFile属性或自定义表达式等特性时，这种方法是足够的，但它不能为密码或密钥等值提供保护。  </p><p>NiFi 1.17.0通过一个名为SupportsSensitiveDynamicProperties的注解引入了对敏感动态属性的框架支持。注释可以通过getSupportedDynamicPropertyDescriptor方法应用于支持动态属性的处理器、控制器服务或报告任务。注释表明组件允许将单个动态属性标记为敏感属性，以用于持久化和框架处理。 </p><p> getSupportedDynamicPropertyDescriptor必须返回一个 <code>sensitive</code>  设置为false的PropertyDescriptor，以允许自定义敏感状态。在此方法中将敏感字段设置为true将强制将所有动态属性作为敏感属性处理。这种方法允许在受支持的组件中升级敏感状态，但不降级。 </p><p>敏感属性值的安全处理是带注释的类的责任。支<strong>持敏感动态属性的组件不能记录属性值或将属性值作为FlowFile属性提供。</strong> </p><h2 id="3、-验证处理器属性"><a href="#3、-验证处理器属性" class="headerlink" title="3、 验证处理器属性"></a>3、 验证处理器属性</h2><p>如果处理器的配置无效，则处理器无法启动。 </p><p>处理器属性的验证可以通过在PropertyDescriptor上设置Validator或通过PropertyDescriptor限制属性的允许值来实现。Builder的allowableValues方法或identifiesControllerService方法。  此外，如果一个属性依赖于另一个属性( <code>PropertyDescriptor.Builder’s </code>dependsOn` method ），切不满足的话则会被校验住。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PropertyDescriptor USE_FILE = <span class="keyword">new</span> PropertyDescriptor.Buildler()</span><br><span class="line">    .name(<span class="string">&quot;Use File&quot;</span>)</span><br><span class="line">    .displayName(<span class="string">&quot;Use File&quot;</span>)</span><br><span class="line">    .required(<span class="keyword">true</span>)</span><br><span class="line">    .allowableValues(<span class="string">&quot;true&quot;</span>, <span class="string">&quot;false&quot;</span>)</span><br><span class="line">    .defaultValue(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PropertyDescriptor FILE = <span class="keyword">new</span> PropertyDescriptor.Builder()</span><br><span class="line">    .name(<span class="string">&quot;File to Use&quot;</span>)</span><br><span class="line">    .displayName(<span class="string">&quot;File to Use&quot;</span>)</span><br><span class="line">    .required(<span class="keyword">true</span>)</span><br><span class="line">    .addValidator(StandardValidators.FILE_EXISTS_VALIDATOR)</span><br><span class="line">    .dependsOn(USE_FILE, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>有时单独验证一个Processor的属性是不够的。为此，AbstractProcessor公开了一个customValidate方法。该方法接受ValidationContext类型的单个参数。这个方法的返回值是一个ValidationResult对象的集合，它描述了在验证过程中发现的任何问题。只有那些isValid方法返回false的ValidationResult对象才应该被返回。 只有当所有属性根据其关联的验证器和允许值都有效时，才会调用此方法。也就是说，只有当所有属性本身都有效时，这个方法才会被调用，并且这个方法允许将处理器的配置作为一个整体进行验证。 </p><h2 id="4、响应配置中的更改"><a href="#4、响应配置中的更改" class="headerlink" title="4、响应配置中的更改"></a>4、响应配置中的更改</h2><p> 有时，当处理器的属性发生变化时，我们希望它立即做出反应。  onPropertyModified方法允许处理器这样做。当用户更改处理器的属性值时，将为每个修改的属性调用onPropertyModified方法。 </p><p> 该方法接受三个参数:PropertyDescriptor(表示修改了哪个属性、旧值和新值。  如果属性之前没有值，第二个参数将为空。  如果该属性被删除，则第三个参数将为空。重要的是要注意，无论值是否有效，都会调用此方法。这个方法将只在值被实际修改时调用，而不是在用户更新处理器而不更改其值时调用。在调用此方法时，可以保证调用此方法的线程是当前在处理器中执行代码的唯一线程，除非处理器本身创建了自己的线程。 </p><h2 id="5、-执行工作"><a href="#5、-执行工作" class="headerlink" title="5、 执行工作"></a>5、 执行工作</h2><p> 当处理器有工作要做时，它通过框架调用它的onTrigger方法来进行调度。 </p><p> 该方法有两个参数:一个ProcessContext和一个ProcessSession。onTrigger方法的第一步通常是通过调用ProcessSession上的get方法来获取要在其上执行工作的FlowFile。 </p><p> 对于从外部源摄取数据到NiFi的处理器，跳过此步骤。然后处理器可以自由地检查FlowFile属性;添加、删除或修改属性;读取或修改FlowFile内容;并将FlowFiles传输到适当的关系。 </p><h2 id="6、-处理器何时被触发"><a href="#6、-处理器何时被触发" class="headerlink" title="6、  处理器何时被触发"></a>6、  处理器何时被触发</h2><p>处理器的onTrigger方法只有在计划运行时才会被调用，并且处理器有工作要做。如果满足以下任何一个条件，就称处理器存在工作</p><ul><li> 目标是处理器的连接在其队列中至少有一个FlowFile </li><li> 处理器没有传入连接</li><li> 处理器用@TriggerWhenEmpty注释 </li></ul><p>有几个因素会影响处理器的onTrigger方法何时被调用。</p><p>首先，除非用户已将Processor配置为运行，否则不会触发Processor。如果处理器被安排运行，框架会定期(周期由用户在用户界面中配置)检查处理器是否有工作要做。如果是，框架将检查处理器的下游目的地。 </p><p> <strong>如果处理器的任何出站连接已满，默认情况下，处理器将不会被安排运行。</strong> </p><p> 但是，@TriggerWhenAnyDestinationAvailable注释可以添加到Processor的类中。  在这种情况下，需求被更改为只有一个下游目的地必须是“可用的”(如果Connection队列未满，则认为目的地是“可用的”)，而不是要求所有下游目的地都可用。 </p><p>与处理器调度相关的还有 @TriggerSerially 注释。使用此注释的处理器永远不会有多个线程同时运行onTrigger方法。但是，需要注意的是，执行代码的线程在调用之间可能会发生变化。因此，仍然必须小心确保处理器是线程安全的</p><h2 id="7、组件生命周期"><a href="#7、组件生命周期" class="headerlink" title="7、组件生命周期"></a>7、组件生命周期</h2><h3 id="OnAdded"><a href="#OnAdded" class="headerlink" title="@OnAdded"></a>@OnAdded</h3><p> @OnAdded注释会在创建组件时立即调用一个方法 ， <code>initialize</code>  方法将在组件构造之后被调用，然后是带有@OnAdded注释的方法。 该方法在组件的生命周期中只会被调用一次。带有此注释的方法必须不带参数。 </p><h3 id="OnEnabled"><a href="#OnEnabled" class="headerlink" title="@OnEnabled"></a>@OnEnabled</h3><p> @OnEnabled注释可以用来指示一个方法应该在控制器服务被启用时被调用。 任何具有此注释的方法都会在每次用户启用该服务时被调用。此外，每次重启NiFi时，如果将NiFi配置为“ auto-resume state ”并且启用了服务，则将调用该方法。</p><p>如果带有此注释的方法抛出Throwable，则将为该组件发出一条日志消息和公告。在这种情况下，服务将保持在“ ENABLING ”状态，并且将不可用。带有此注释的所有方法将在延迟后再次调用。在所有带有此注释的方法都返回而不抛出任何东西之前，该服务将无法使用。 </p><h3 id="OnRemoved"><a href="#OnRemoved" class="headerlink" title="@OnRemoved"></a>@OnRemoved</h3><p> @OnRemoved注释导致在组件从流中移除之前调用一个方法。这允许在删除组件之前清理资源。带有此注释的方法必须不带参数。<strong>如果带有此注释的方法抛出异常，该组件仍将被删除。</strong> </p><h3 id="OnScheduled"><a href="#OnScheduled" class="headerlink" title="@OnScheduled"></a>@OnScheduled</h3><p> 每次计划运行组件时都应调用该方法。因为ControllerServices没有被调度，所以在ControllerService上使用这个注释是没有意义的。 它应该仅用于处理器和 Reporting Tasks 。如果具有此注释的任何方法抛出Exception，则不会调用具有此注释的其他方法，并将向用户显示通知。 </p><p> 在这种情况下，然后触发带有@OnUnscheduled注释的方法，然后触发带有@OnStopped注释的方法(在此状态下，如果这些方法中的任何一个抛出异常，这些异常将被忽略)。  然后，该组件将在一段时间内执行，这段时间称为“Administrative yield Duration”，这是在nifi中配置的一个值。 最后，进程将再次启动，直到所有带@OnScheduled注释的方法都返回而不抛出任何异常。 </p><p>带有此注释的方法可以不带参数，也可以只带一个参数。如果使用单个参数变体，如果组件是Processor，则参数必须是ProcessContext类型，如果组件是ReportingTask，则参数必须是ConfigurationContext类型。 </p><h3 id="OnUnscheduled"><a href="#OnUnscheduled" class="headerlink" title="@OnUnscheduled"></a>@OnUnscheduled</h3><p>每当处理器或ReportingTask不再调度运行时，将调用带有此注释的方法。此时，在Processor的onTrigger方法中可能仍有许多线程处于活动状态。如果这样的方法抛出异常，将生成一条日志消息，否则将忽略该异常，并且仍将调用带有此注释的其他方法。带有此注释的方法可以不带参数，也可以只带一个参数。如果使用单个参数变体，如果组件是Processor或ConfigurationContext，则参数必须是ProcessContext类型 </p><h3 id="OnStopped"><a href="#OnStopped" class="headerlink" title="@OnStopped"></a>@OnStopped</h3><p> 当处理器或ReportingTask不再调度运行并且所有线程都从onTrigger方法返回时，将调用带有此注释的方法。如果这样的方法抛出异常，将生成一条日志消息，否则该异常将被忽略;使用此注释的其他方法仍将被调用。带有此注释的方法允许接受0或1个参数。如果使用了参数，如果组件是ReportingTask，则参数的类型必须是ConfigurationContext;如果组件是Processor，则参数的类型必须是ProcessContext。 </p><h3 id="OnShutdown"><a href="#OnShutdown" class="headerlink" title="@OnShutdown"></a>@OnShutdown</h3><p>任何带有@OnShutdown注释的方法都将在NiFi成功关闭时被调用。如果这样的方法抛出异常，将生成一条日志消息，否则将忽略该异常，并且仍将调用带有此注释的其他方法。带有此注释的方法<strong>必须不带参数</strong>。注意:虽然NiFi将尝试在使用它的所有组件上调用带有此注释的方法，但这并不总是可能的。 </p><p>例如，进程可能意外终止，在这种情况下，它没有机会调用这些方法。因此，虽然使用此注释的方法可用于清理资源，但不应依赖于关键业务逻辑。 </p><h2 id="8、组件通知"><a href="#8、组件通知" class="headerlink" title="8、组件通知"></a>8、组件通知</h2><h3 id="OnPrimaryNodeStateChange"><a href="#OnPrimaryNodeStateChange" class="headerlink" title="@OnPrimaryNodeStateChange"></a>@OnPrimaryNodeStateChange</h3><p> @OnPrimaryNodeStateChange注释会在集群中主节点的状态发生变化时立即调用方法。带有此注释的方法要么不带参数，要么只带一个PrimaryNodeState类型的参数。PrimaryNodeState提供有关更改内容的上下文，以便组件可以采取适当的操作。PrimaryNodeState枚举器有两种可能的值:ELECTED PRIMARY NODE(接收此状态的节点已被选为NiFi集群的主节点)或PRIMARY NODE REVOKED( 接收此状态的节点是主节点，但现在其主节点角色已被撤销)</p><h2 id="9-、约束组件"><a href="#9-、约束组件" class="headerlink" title="9.、约束组件"></a>9.、约束组件</h2><p>受限制的组件是可用于执行操作员通过NIFI REST API/UI提供的任意不固定的代码，或者可以使用NIFI OS凭据在NIFI主机系统上获取或更改数据。 </p><p>这些组件可以被授权的NiFi用户用于超出应用程序的预期用途，升级特权，或者可能暴露有关NiFi进程或主机系统内部的数据。所有这些功能都应该被认为是特权的，管理员应该知道这些功能，并为一部分受信任的用户显式地启用它们。 </p><p>处理器、控制器服务或报告任务可以使用@Restricted注释进行标记。这将导致组件被视为受限组件，并且需要将用户显式地添加到可以访问受限组件的用户列表中。一旦用户被允许访问受限制的组件，他们将被允许创建和修改这些组件，假设所有其他权限都被允许。如果不能访问受限制的组件，用户仍然会知道这些类型的组件的存在，但即使有其他足够的条件，也无法创建或修改它们。</p><h2 id="10、状态管理"><a href="#10、状态管理" class="headerlink" title="10、状态管理"></a>10、状态管理</h2><p>从ProcessContext、ReportingContext和ControllerServiceInitializationContext中，组件可以调用getStateManager()方法。这个状态管理器负责提供一个简单的API来存储和检索状态。  该机制旨在使开发人员能够轻松地存储一组密钥/值对，检索这些值并原子更新它们。该状态可以在群集中局部存储在节点上，也可以在所有节点中存储。 </p><p>然而，需要注意的是，该机制的目的只是提供一种存储非常“简单”状态的机制。  因此，API只允许存储和检索Map&lt;String, String&gt;，并自动替换整个Map。此外，目前唯一支持存储集群范围状态的实现是由ZooKeeper支持的。  因此，在序列化之后，整个State Map的大小必须小于1mb。试图存储超过此值将导致抛出异常。如果处理器管理状态所需的交互比这更复杂(例如，必须存储和检索大量数据，或者必须单独存储和获取单个键)，则应该使用不同的机制(例如，与外部数据库通信)。 </p><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>当与状态管理器通信时，所有方法调用都需要提供Scope。这个Scope将是Scope.LOCAL或Scope.CLUSTER。如果NiFi在集群中运行，则此Scope向框架提供有关操作应该如何发生的重要信息。 </p><p> 如果状态使用 Scope.CLUSTER 存储。集群中的所有节点都将使用相同的状态存储机制进行通信。如果使用 Scope.LOCAL ，那么每个节点将看到状态的不同表示。 </p><p>还值得注意的是，如果将NiFi配置为作为独立实例运行，而不是在集群中运行，则 Scope总是使用Scope.LOCAL。这样做是为了允许NiFi组件的开发人员以一种一致的方式编写代码，而不必担心NiFi实例是否集群。相反，开发人员应该假设实例是集群的，并相应地编写代码。 </p><h2 id="11-报告处理器的活动"><a href="#11-报告处理器的活动" class="headerlink" title="11. 报告处理器的活动"></a>11. 报告处理器的活动</h2><p> 处理器负责报告其活动，以便用户能够了解其数据发生了什么。处理器应通过ComponentLog记录事件，该事件可通过初始化访问或调用AbstractProcessor的GetLogger方法访问。 </p><p>此外，处理器应使用通过ProcessSession的 <code>getProvenanceReporter</code>  方法获得的 <code>ProvenanceReporter</code>  接口。  ProvenanceReporter应该用于指示从外部源接收内容或将内容发送到外部位置的任何时间。  ProvenanceReTorter还具有报告何时克隆，分叉或修改的流文件以及将多个流文件合并到单个流纸上以及将流纸与其他一些标识符关联的方法。  但是，这些功能不太重要，因为该框架能够检测到这些内容并代表处理器发出适当的事件。 </p><p> 然而，对于处理器开发人员来说，发出这些事件是最佳实践，因为它在代码中变得明确说明这些事件正在发出，并且开发人员能够为事件提供其他细节，例如该动作采取了有关所采取的措施的信息。  如果处理器发出事件，则该框架将不会发出重复的事件。相反，它总是假设处理器开发人员比框架更了解处理器上下文中发生的事情。 </p><p>但是，框架可能会发出另一个事件。例如，如果处理器对FlowFile的内容及其属性进行修改，然后仅发射 ATTRIBUTES_MODIFIED  事件，则该框架将发出 CONTENT_MODIFIED  事件。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、-NiFi组件&quot;&gt;&lt;a href=&quot;#一、-NiFi组件&quot; class=&quot;headerlink&quot; title=&quot;一、 NiFi组件&quot;&gt;&lt;/a&gt;一、 NiFi组件&lt;/h1&gt;&lt;p&gt;NiFi提供了几个扩展点，使开发人员能够向应用程序添加功能以满足他们的需求。下面的列</summary>
      
    
    
    
    <category term="NiFi" scheme="https://castile.github.io/categories/NiFi/"/>
    
    
    <category term="NiFi" scheme="https://castile.github.io/tags/NiFi/"/>
    
    <category term="文档" scheme="https://castile.github.io/tags/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>无状态的NiFi</title>
    <link href="https://castile.github.io/2023/11/26/Stateless-NiFi/"/>
    <id>https://castile.github.io/2023/11/26/Stateless-NiFi/</id>
    <published>2023-11-26T07:35:13.000Z</published>
    <updated>2023-11-26T07:35:13.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Apache NiFi应用程序可以被认为是两个独立但相互交织的组件:流作者组件和流引擎。通过将这两个组件集成到一个应用程序中，NiFi允许用户创建数据流并在同一个用户界面中实时运行它。</p><p>然而，这两个概念是可以分开的。NiFi可以用来创建流，然后不仅可以由NiFi运行，还可以由其他兼容的数据流引擎运行。Apache NiFi项目提供了几个这样的数据流引擎:Apache NiFi本身、MiNiFi Java (Apache NiFi的一个子项目)、MiNiFi c++ (Apache NiFi的一个子项目)和无状态NiFi</p><p>这些数据流引擎中的每一个都有自己的优点和缺点，因此它们有自己最擅长解决的特定用例。本文将介绍无状态NiFi是什么，如何使用它，以及它的优点和缺点</p><h2 id="传统的NiFi"><a href="#传统的NiFi" class="headerlink" title="传统的NiFi"></a>传统的NiFi</h2><p>NiFi被设计为作为大型多租户应用程序运行。它努力充分利用提供给它的所有资源，包括磁盘/存储和许多线程。通常，单个NiFi实例跨许多不同的节点集群，形成一个大型的内聚数据流，该数据流可能由许多不同的子流组成。一般来说，NiFi将承担交付给它的数据的所有权。它将数据可靠地存储在磁盘上，直到它被传递到所有必要的目的地。此数据的交付可以在流中的不同位置进行优先级排序，以便将对特定目的地最重要的数据首先交付到该目的地，而相同的数据可以根据优先级以不同的顺序交付到另一个目的地。NiFi在完成所有这些工作的同时，保持非常细粒度的沿袭，并保持流中每个组件所看到的数据缓冲区(数据沿袭和数据滚动缓冲区的组合称为data Provenance)。</p><p>这些特性中的每一个都非常重要，可以提供一个非常强大、广泛、全面的视图，了解数据是如何在企业上操作和流经企业的。然而，在一些用例中，更轻量级的应用程序可以更好地服务于这些用例。一个能够与NiFi可以交互的所有不同端点进行交互的应用程序，并执行NiFi可以执行的所有转换、路由、过滤和处理。但是一个应用程序被设计为只运行一个小的子流，而不是一个有许多源和汇的大数据流。</p><h2 id="无状态NiFi"><a href="#无状态NiFi" class="headerlink" title="无状态NiFi"></a>无状态NiFi</h2><p>进入无状态NiFi(在本文档中也简称为“无状态”)。无状态NiFi中的许多概念与典型的Apache NiFi引擎中的概念不同。</p><p>无状态提供了一个占用空间更小的数据流引擎。它不包括用于编写或监视数据流的用户界面，而是运行使用NiFi应用程序编写的数据流。NiFi在能够访问快速存储(如SSD和NVMe驱动器)时表现最佳，而Stateless则将所有数据存储在内存中。</p><p>这意味着如果无状态NiFi停止，它将不再能够直接访问正在运行的数据。因此，无状态应该只用于数据源可靠且可重放的数据流，或者数据丢失不是关键问题的场景。</p><p>一个非常常见的用例是让无状态NiFi从Apache Kafka或JMS读取数据，然后执行一些路由/过滤/操作，最后将数据传递到另一个目的地。如果像这样的数据流要在NiFi中运行，那么数据将从源被消耗，写入NiFi的内部存储库，并得到确认，因此NiFi将获得该数据的所有权。然后，它将负责将其传递到所有目的地，即使应用程序重新启动也是如此。</p><p>但是，使用无状态NiFi，数据将被使用，然后传输到流中的下一个处理器。数据不会被写入任何类型的内部存储库，也不会被确认。流中的下一个处理器将处理数据，然后将其传递下去。只有当数据到达整个数据流的末端时，才会确认从源接收到的数据。如果在处理完成之前重新启动Stateless，则数据尚未得到确认，因此只是再次使用它。这允许在内存中处理数据，而不必担心数据丢失，但它也让源承担了可靠地存储数据并使数据可重放的责任。</p><h2 id="可兼容的数据流"><a href="#可兼容的数据流" class="headerlink" title="可兼容的数据流"></a>可兼容的数据流</h2><p>如上所述，无状态NiFi要求数据源既可靠又可重放。这限制了无状态可以合理交互的源。此外，对于无状态引擎能够运行的数据流，还有一些其他限制。</p><h3 id="1、-单一来源、单一目标"><a href="#1、-单一来源、单一目标" class="headerlink" title="1、 单一来源、单一目标"></a>1、 单一来源、单一目标</h3><p>在无状态状态下运行的每个数据流应该保持在单个源和单个接收器或目的地。由于Stateless不存储它正在处理的数据，也不存储元数据，例如数据流中数据排队的位置，因此将单个FlowFile发送到多个目的地可能导致数据重复。</p><p>考虑一个流，其中数据从Apache Kafka消费，然后交付到HDFS和S3。如果数据存储在HDFS中，然后存储到S3失败，则整个会话将被回滚，并且必须再次使用数据。因此，数据可能会被第二次消费并交付给HDFS。如果这种情况继续发生，数据将继续从Kafka提取并存储在HDFS中。根据目的地和流配置，这可能不是一个问题(除了浪费资源之外)，但在许多情况下，这是一个重要的问题。</p><p>因此，如果要使用无状态引擎运行数据流，那么应该将这样的数据流分解为两个不同的数据流。第一个将数据从Apache Kafka传送到HDFS，另一个将数据从Apache Kafka传送到S3。每个数据流都应该为Kafka使用一个单独的Consumer Group，这将导致每个数据流获得相同数据的副本</p><h3 id="2、对合并的支持可能有限"><a href="#2、对合并的支持可能有限" class="headerlink" title="2、对合并的支持可能有限"></a>2、对合并的支持可能有限</h3><p>由于无状态NiFi中的数据从头到尾同步地通过数据流传输，因此使用需要多个flowfile(如MergeContent和MergeRecord)的处理器可能无法接收成功所需的所有数据。如果处理器有数据排队并被触发，但没有取得任何进展，则无状态引擎将再次触发源处理器，以便向处理器提供额外的数据</p><p>然而，这可能导致数据不断被引入的情况，这取决于处理器的行为。为了避免这种情况，可以通过配置限制可能带入数据流的单个调用的数据量。如果数据流配置将每次调用的数据量限制为10 MB，但是配置了MergeContent直到至少有100 MB的可用数据才创建bin，则数据流将继续触发MergeContent运行，而不进行任何进展，直到达到最大bin年龄(如果配置)或数据流超时。</p><p>此外，根据运行Stateless的上下文，触发源组件可能不会提供额外的数据。例如，如果在数据在输入端口中排队，然后触发数据流的环境中运行无状态，则随后触发输入端口运行将不会产生额外的数据</p><p>因此，确保任何包含合并FlowFiles逻辑的数据流都配置了MergeContent和MergeRecord的最大Bin Age是很重要的。</p><h3 id="3、故障处理"><a href="#3、故障处理" class="headerlink" title="3、故障处理"></a>3、故障处理</h3><p>在传统的NiFi中，将从给定处理器的“失败”连接循环回同一处理器是很常见的。这导致处理器不断尝试处理FlowFile，直到它成功为止。这可能非常重要，因为通常一个NiFi接收数据，它负责获得该数据的所有权，并且必须能够保存该数据，直到下游服务能够接收它并随后交付该数据。</p><p>然而，对于无状态NiFi，假定数据源既可靠又可重放。此外，根据设计，无状态NiFi在重启后不会保存数据。因此，对故障处理的考虑可能会有所不同。使用无状态NiFi，如果无法将数据传递到下游系统，通常最好将FlowFile路由到输出端口，然后将输出端口标记为故障端口(参见下面的[失败端口](#failure- Ports)了解更多信息)。</p><h3 id="4、流不应该加载大量文件"><a href="#4、流不应该加载大量文件" class="headerlink" title="4、流不应该加载大量文件"></a>4、流不应该加载大量文件</h3><p>在传统的NiFi中，FlowFile内容存储在磁盘上，而不是内存中。因此，它能够处理任何大小的数据，只要它适合磁盘。然而，在无状态中，FlowFile内容存储在内存中，在JVM堆中。因此，通常不建议尝试将大量文件(例如100 GB数据集)加载到无状态NiFi中。这样做通常会导致OutOfMemoryError，或者至少会导致大量垃圾收集，从而降低性能。</p><h2 id="特性对比"><a href="#特性对比" class="headerlink" title="特性对比"></a>特性对比</h2><p>如上所述，无状态NiFi提供了一组不同于传统NiFi的特性和权衡。在这里，我们总结一下关键的区别。这种比较并不详尽，但可以快速了解这两个运行时是如何运行的。<br>| Feature | Traditional NiFi | Stateless NiFi |<br>|———|——————|—————-|<br>| 数据持久性 | 数据可靠地存储在磁盘上的FlowFile和Content Repositories中 | 数据存储在内存中，必须在重新启动时再次从源端使用 |<br>| 数据排序 | 数据在每个连接中根据选择的优先级排序独立排序 | 数据按照接收到的顺序在系统中流动(先进先出/ FIFO) |<br>| Site-to-Site | 支持完整的Site-to-Site功能，包括服务器和客户端角色 | 可以向NiFi实例推送或从NiFi实例拉取，但不能接收传入的站点到站点连接。也就是说，作为客户端而不是服务器工作 |<br>| Form Factor | 旨在利用多个内核和磁盘的优势 | 轻巧的外形因素。很容易嵌入到另一个应用程序。单线程处理 |<br>| Heap Considerations | 通常，许多用户正在使用许多处理器。不应该将FlowFile内容加载到堆中，因为它很容易导致堆耗尽 | 较小的数据流使用较少的堆。Flow一次只对一个或几个FlowFile进行操作，并将FlowFile的内容保存在Java堆的内存中。 |<br>| Data Provenance | 完全存储、索引的数据来源，可以通过UI浏览并通过Reporting Tasks导出 | 有限的数据来源功能，事件存储在内存中。无法查看，但可以使用Reporting Tasks导出。但是，由于它们在内存中，因此它们将在重新启动时丢失，并且可能在导出之前滚出 |<br>| 嵌入性 | 虽然在技术上可以嵌入传统的NiFi，但不建议这样做，因为它会启动一个重量级的用户界面，处理复杂的身份验证和授权，以及几个基于文件的外部依赖项，这可能很难管理 | 具有最小的外部依赖关系(包含扩展的目录和用于临时存储的工作目录)，并且更易于管理。可嵌入性是无状态NiFi的一个重要特性。 |</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Apache NiFi应用程序可以被认为是两个独立但相互交织的组件:流作者组件和流引擎。通过将这两个组件集成到一个应用程序中，NiFi允许用</summary>
      
    
    
    
    <category term="NiFi" scheme="https://castile.github.io/categories/NiFi/"/>
    
    
    <category term="NiFi" scheme="https://castile.github.io/tags/NiFi/"/>
    
    <category term="Stateless" scheme="https://castile.github.io/tags/Stateless/"/>
    
  </entry>
  
  <entry>
    <title>NiFi身份验证与授权验证（2）</title>
    <link href="https://castile.github.io/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/"/>
    <id>https://castile.github.io/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/</id>
    <published>2023-10-15T10:33:05.000Z</published>
    <updated>2023-10-15T10:33:05.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="授权验证（Authorization）概述"><a href="#授权验证（Authorization）概述" class="headerlink" title="授权验证（Authorization）概述"></a>授权验证（Authorization）概述</h2><p>访问Nifi界面相当于你想进入一个商业写字楼，门口保安可能会拦住你要查看你的身份证（身份验证）。现在保安从身份证上知道了我们的名字（身份验证成功），但是他依然需要确定你是在这个写字楼工作才能让你进去。为此他查找大楼员工花名册（授权验证）。只有当你的名字出现在名册上时你才会被放行。</p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697299271277.png" class width="1697299271277"><p>Nifi授权验证模块与两个数据库有关：一个是授权用户身份数据库（<code>UserGroupProvider</code>），另一个是用户权限数据库（<code>AccessPolicyProvider</code>） </p><p>其中，<code>UserGroupProvider</code>里面列出了所有被授权用户的用户名。只有在这个数据库里面的用户名才真正有权限使用Nifi。而<code>AccessPolicyProvider</code>里面列出了这些被授权用户以及他们所获得的权限之间的一一对应关系。</p><p>因此，Nifi的授权验证模块需要做的，就是先拿从身份验证模块得来的用户名与<code>UserGroupProvider</code>里的用户名做核对，看是否能找到对应的条目。如果有，再到<code>AccessPolicyProvider</code>里查看该用户有哪些权限。</p><p> 接下来，我们就看看，在Nifi当中是怎么对<code>UserGroupProvider</code>和<code>AccessPolicyProvider</code>进行设置的。 </p><h2 id="授权验证设置"><a href="#授权验证设置" class="headerlink" title="授权验证设置"></a>授权验证设置</h2><p>Nifi 会在<code>./conf/authorizers.xml</code>这个文件中寻找<code>UserGroupProvider</code>和<code>AccessPolicyProvider</code>的设置。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authorizers</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">userGroupProvider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileUserGroupProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Users File&quot;</span>&gt;</span>./conf/users.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial User Identity 1&quot;</span>&gt;</span>CN=castile-nifi, OU=nifi<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userGroupProvider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileAccessPolicyProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;User Group Provider&quot;</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Authorizations File&quot;</span>&gt;</span>./conf/authorizations.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial Admin Identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Identity 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Group&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">authorizer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>managed-authorizer<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.StandardManagedAuthorizer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Access Policy Provider&quot;</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">authorizer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorizers</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1、-UserGroupProvider-设置"><a href="#1、-UserGroupProvider-设置" class="headerlink" title="1、 UserGroupProvider 设置"></a>1、 UserGroupProvider 设置</h3><p><code>FileUserGroupProvider</code>的使用最为简单，其本质是把所有授权用户名都存在一个文件里面。在<code>./conf/authorizers.xml</code>文件中与<code>FileUserGroupProvider</code>相关的有以下条目：</p><p> 这个文件储存用户名的文件默认是<code>./conf/users.xml</code>。它可以有类似以下内容 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tenants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groups</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;66fa993d-f882-396e-bc79-3ff4b6994470&quot;</span> <span class="attr">identity</span>=<span class="string">&quot;CN=castile-nifi, OU=nifi&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tenants</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>里面配置一些用户的信息</p><h3 id="2、-AccessPolicyProvider-设置"><a href="#2、-AccessPolicyProvider-设置" class="headerlink" title="2、 AccessPolicyProvider 设置"></a>2、 AccessPolicyProvider 设置</h3><p> Nifi自带<code>AccessPolicyProvider</code>是<code>FileAccessPolicyProvider</code>。在<code>authorizers.xml</code>中相关的设置有以下的条目： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileAccessPolicyProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;User Group Provider&quot;</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Authorizations File&quot;</span>&gt;</span>./conf/authorizations.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial Admin Identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Identity 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Group&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">accessPolicyProvider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，在属性<code>User Group Provider</code>中我们指定了使用哪一个<code>UserGroupProvider</code>。而<code>Authorizations File</code>指定了权限数据都存在哪个文件，默认是<code>./conf/authorizations.xml</code>。这个文件中有类似以下的内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authorizations</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;f99bccd1-a30e-3e4a-98a2-dbc708edc67f&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/flow&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;3fbc23d1-30d2-3068-ba89-9066202e13d7&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;b8775bd4-704a-34c6-987b-84f2daf7a515&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/restricted-components&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;3fbc23d1-30d2-3068-ba89-9066202e13d7&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;ff96062a-fa99-36dc-9942-0f6442ae7212&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/policies&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;3fbc23d1-30d2-3068-ba89-9066202e13d7&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorizations</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 在这个文件中列出了每一条的权限（Policy），而每条权限都对应一个用户，这样形成了一一对应的关系，而Nifi也能够因此确定每个用户拥有什么权限。 </p><h3 id="3、-Authorizer设置"><a href="#3、-Authorizer设置" class="headerlink" title="3、 Authorizer设置"></a>3、 Authorizer设置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authorizer</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>managed-authorizer<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.StandardManagedAuthorizer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Access Policy Provider&quot;</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">authorizer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Nifi自带有managed-authorizer和single-user-authorizer，注意我们要在这里指定<code>AccessPolicyProvider</code>。然后，在<code>nifi.properties</code>中，我们要在以下属性指定我们需要用的<code>authorizer</code>:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">nifi.security.user.authorizer</span>=<span class="string">managed-authorizer </span></span><br><span class="line"><span class="attr">或者：</span></span><br><span class="line"><span class="meta">nifi.security.user.authorizer</span>=<span class="string">single-user-authorizer</span></span><br></pre></td></tr></table></figure><p>这样，我们就告诉了Nifi我们使用的是<code>managed-authorizer</code>，然后<code>managed-authorizer</code>又指定了使用的<code>AccessPolicyProvider</code>，而<code>AccessPolicyProvider</code>又指定了所使用的<code>UserGroupProvider</code>。整个权限验证模块的设置就是这样子被串了起来。</p><h2 id="多用户授权"><a href="#多用户授权" class="headerlink" title="多用户授权"></a>多用户授权</h2><p>在生产环境中推荐使用<code>nifi.security.user.authorizer=managed-authorizer </code>, 这样可以为多个用户登录nifi并设置相应的权限。</p><p>在user.xml添加一个用户，并不设置任何权限</p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697359958358.png" class width="1697359958358"><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697359986486.png" class width="1697359986486"><p>我们是要手动添加条目到<code>./conf/users.xml</code>和<code>./conf/authorizations.xml</code>吗？并不需要，我们可以通过在Nifi的UI界面操作来添加。不过，首先你得有一个管理员账号来登录进Nifi界面才行。无论你采用哪种身份验证方法，对于一个新的加密Nifi，你必须在<code>authorizers.xml</code>的<code>AccessPolicyProvider</code>中找到这一项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial Admin Identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 把你的用户名添加进去即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileAccessPolicyProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;User Group Provider&quot;</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Authorizations File&quot;</span>&gt;</span>./conf/authorizations.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial Admin Identity&quot;</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Identity 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Group&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置Initial User Identity 1： admin</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">userGroupProvider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileUserGroupProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Users File&quot;</span>&gt;</span>./conf/users.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial User Identity 1&quot;</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name=&quot;Initial User Identity 1&quot;&gt;CN=admin, OU=nifi&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userGroupProvider</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>保存，重启Nifi。当你再次访问UI时就发现，关于权限的错误已经消除，主界面也可以进去了。实际上，当你添加了<code>Initial Admin Identity</code>并重启后，Nifi在后台把这名用户添加到了<code>users.xml</code>中，并且在<code>authorizations.xml</code>中添加了一些基础的权限。</p><p>user.xml中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tenants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groups</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">identity</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;user identifier=&quot;6743d555-1f60-343a-9038-0be6fdcbf33b&quot; identity=&quot;CN=admin, OU=nifi&quot;/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tenants</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 当你使用初始管理员账号进入Nifi以后，你会发现大部分的地方都是灰色的，你基本没法做任何操作（下图） </p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697364885070.png" class width="1697364885070"><p>authorizations.xml中的配置湖自动生成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authorizations</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;f99bccd1-a30e-3e4a-98a2-dbc708edc67f&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/flow&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;87dce6d5-be9f-3392-a4ef-dd58a553a6a0&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/data/process-groups/2ba3a086-018b-1000-6247-3dcbfaf4602f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;2cb459c4-151d-3671-9d9b-7fa7f1448886&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/data/process-groups/2ba3a086-018b-1000-6247-3dcbfaf4602f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;f5e329a9-16eb-3aaf-a969-3778d17ad1e4&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/process-groups/2ba3a086-018b-1000-6247-3dcbfaf4602f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;3be25fe5-3d07-302c-9bf9-0b03fa9fb77d&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/process-groups/2ba3a086-018b-1000-6247-3dcbfaf4602f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;b8775bd4-704a-34c6-987b-84f2daf7a515&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/restricted-components&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;627410be-1717-35b4-a06f-e9362b89e0b7&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/tenants&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;15e4e0bd-cb28-34fd-8587-f8d15162cba5&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/tenants&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;ff96062a-fa99-36dc-9942-0f6442ae7212&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/policies&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;ad99ea98-3af6-3561-ae27-5bf09e1d969d&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/policies&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;2e1015cb-0fed-3005-8e0d-722311f21a03&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/controller&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;c6322e6c-4cc1-3bcc-91b3-2ed2111674cf&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/controller&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorizations</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以 通过点击右上侧的菜单栏并选择 user创建用户、Policies可以为用户进行权限管理</p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697365023394.png" class width="1697365023394"><p>创建用户后，自动会写入到user.xml中</p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697365187598.png" class width="1697365187598"><h2 id="TroubleShooting"><a href="#TroubleShooting" class="headerlink" title="TroubleShooting"></a>TroubleShooting</h2><p>1、 </p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697359326101.png" class width="1697359326101"><p>更改user.xml文件，user部分的identity不能有相同的</p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697359835216.png" class width="1697359835216"><p>2、</p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697360312489.png" class width="1697360312489"><p>严格匹配，不能有“”，区分大小写</p><p>3、 当你在配置的是CN=admin, OU=nifi这种格式，那么会会从中解析出admin 作为用户名</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;授权验证（Authorization）概述&quot;&gt;&lt;a href=&quot;#授权验证（Authorization）概述&quot; class=&quot;headerlink&quot; title=&quot;授权验证（Authorization）概述&quot;&gt;&lt;/a&gt;授权验证（Authorization）概述&lt;/</summary>
      
    
    
    
    <category term="NiFi" scheme="https://castile.github.io/categories/NiFi/"/>
    
    
    <category term="NiFi" scheme="https://castile.github.io/tags/NiFi/"/>
    
    <category term="SSL" scheme="https://castile.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>NiFi身份验证与授权验证（1）</title>
    <link href="https://castile.github.io/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/"/>
    <id>https://castile.github.io/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/</id>
    <published>2023-10-14T15:59:46.000Z</published>
    <updated>2023-10-14T15:59:46.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NiFi身份验证和授权验证介绍"><a href="#NiFi身份验证和授权验证介绍" class="headerlink" title="NiFi身份验证和授权验证介绍"></a>NiFi身份验证和授权验证介绍</h2><p>身份验证（Authentication）以及授权验证（Authorization）在Nifi里面是两个相当独立的模块。其中身份验证主要的任务是确认当前操作用户<strong>是否真的是声称的身份</strong>。当用户的身份被证实以后，它的用户名会被传递到授权验证模块，而授权验证模块会在它的数据库里面查找该用户名，并确认该用户<strong>有什么权限</strong>。打个比喻，如果你想进入一个商业写字楼，门口保安可能会拦住你要查看你的身份证（身份验证）。然后他会从一个员工名册上查找你的名字（授权验证）。只有当你的名字出现在名册上时你才会被放行。</p><p>下图表明了Nifi中这两个系统间的关系。当用户试图访问Nifi时，他必须首先通过身份验证。身份验证的时候Nifi可能需要参考一个外部的身份数据库（Identity Provider），如LDAP，Kerberos，OpenID Connect等。当确认你的身份后，你的用户名会被送到授权验证模块进一步核对。授权模块在确认你的权限时也需要参考一个身份数据库（可以是一个文档，或者是LDAP服务器）以及一个记录着用户身份与权限对应关系的数据库。</p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697214104415.png" class width="1697214104415">、<p>身份验证和权限验证是完全可以采用不同的身份数据库的。所以我们说这两个系统相当独立，唯一把他们连接在一起的就是用户名的传递。 </p><h2 id="NiFi-基本配置"><a href="#NiFi-基本配置" class="headerlink" title="NiFi 基本配置"></a>NiFi 基本配置</h2><p>Nifi支持好几种用户验证方式：<code>TLS</code>, <code>LDAP</code>, <code>Kerberos</code>, <code>OpenID Connect</code>, <code>Apache Knox</code>等。我们主要介绍<code>TLS</code>以及<code>LDAP</code>两种方式。只要弄明白这两种，其余方式的设置都很类似。<br> 要开启用户验证功能，我们首先必须设置Nifi，使之只接受<code>https</code>安全连接。要达到这个目的，我们需要更改位于<code>./conf</code> 目录下的<code>nifi.properties</code>设置文件里的以下几项属性</p><p><code>nifi.web.http.port</code>：去除原来的<code>8080</code>，使该行变为<code>nifi.web.http.port=</code>，防止用户从非加密的http端口访问</p><p> <code>nifi.web.https.host</code>：设为运行Nifi的主机名字，例如<code>host-01</code> </p><p> <code>nifi.web.https.port</code>：我们用<code>8443</code>作为<code>https</code>端口</p><p> <code>nifi.security.keystore</code>：keystore的路径，例如<code>/opt/nifi/secrets/keystore.jks</code> </p><p> <code>nifi.security.keystoreType</code>：设为<code>JKS</code> </p><p> <code>nifi.security.keystorePasswd</code>：keystore的密码。</p><p> <code>nifi.security.truststore</code>：truststore的路径，例如<code>/opt/nifi/secrets/truststore.jks</code> </p><p> <code>nifi.security.truststoreType</code>：设为<code>JKS</code> </p><p> <code>nifi.security.truststorePasswd</code>：truststore的密码。</p><p> <code>nifi.remote.input.secure</code>：设为<code>true</code>，使得Nifi之间的Site-to-Site通信也用加密的方式。</p><h2 id="生成keystroe和truststore"><a href="#生成keystroe和truststore" class="headerlink" title="生成keystroe和truststore"></a>生成keystroe和truststore</h2><p>当我们要把Nifi设置成加密模式时，我们需要为其提供keystore和truststore。如果我们想通过TLS身份验证访问Nifi的UI时，我们还需要生成一个客户端的PKCS12文件来导入浏览器中。以下简单介绍怎么用Java自带的keytool来生成以上所提及的文件。</p><h3 id="1、生成KeyStore"><a href="#1、生成KeyStore" class="headerlink" title="1、生成KeyStore"></a>1、生成KeyStore</h3><p> 以下命令生成一个包含自签证书（self-signed certificate）的Java keystore： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -keyalg RSA -alias nifi -keystore keystore.jks -keypass [password] -storepass [password] -validity 365 -keysize 4096 -dname &quot;CN=[hostname], OU=nifi&quot;</span><br></pre></td></tr></table></figure><p> <code>[password]</code>为你想设置的密码，替换<code>[hostname]</code>为你运行Nifi的机器的hostname </p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697214411384.png" class width="1697214411384"><h3 id="2、-生成PKCS12文件以及对应的truststore"><a href="#2、-生成PKCS12文件以及对应的truststore" class="headerlink" title="2、 生成PKCS12文件以及对应的truststore"></a>2、 生成PKCS12文件以及对应的truststore</h3><p><code>PKCS12</code>文件是一种加密文件，一般用于存放证书以及对应的私钥。由于使用keytool无法直接生成<code>PKCS12</code>文件，我们首先生成一个包含自签证书的keystore（与上文生成Keystore的命令很相似）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -keyalg RSA -alias client -keystore client_keystore.jks -keypass password -storepass password -validity 365 -keysize 4096 -dname &quot;CN=castile, OU=nifi&quot;</span><br></pre></td></tr></table></figure><p>这里，我们只是随便设置了一个密码<code>password</code>，因为这个Keystore只是一个过渡的产物，我们最后不会用到，所以随便设置一个就好。</p><p>接着我们把这个keystore转化成PKCS12文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore client_keystore.jks -destkeystore client.p12 -srcstoretype JKS -deststoretype PKCS12 -srcstorepass password -deststorepass as1234567890 -destkeypass as1234567890 -srcalias client -destalias client</span><br></pre></td></tr></table></figure><p> 除了生成PKCS12文件外，我们还需要生成一个信任PKCS12密匙文件中的证书的truststore。为此，我们先从之前的keystore中输出密匙的证书： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -export -keystore client_keystore.jks -alias client -file client.der -storepass password</span><br></pre></td></tr></table></figure><p> 当我们得到证书以后，我们把这个证书引入到<code>truststore.jks</code>当中： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -file client.der -alias client -keystore truststore.jks -storepass as1234567890 -noprompt</span><br></pre></td></tr></table></figure><p>这是执行上述命令生成的文件：</p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697215015715.png" class width="1697215015715"><h2 id="访问nifi-UI界面"><a href="#访问nifi-UI界面" class="headerlink" title="访问nifi UI界面"></a>访问nifi UI界面</h2><p>在浏览器输入：<a href="https://192.168.160.140:9443/nifi">https://192.168.160.140:9443/nifi</a></p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697215948784.png" class width="1697215948784"><p>现在要求你输入用户名和密码，但是这个用户名和密码到底是啥呢？查找官网文档得知，有一个 <em>login-identity-providers.xml</em> 默认配置了用户名和密码</p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697216106597.png" class width="1697216106597"><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697216146697.png" class width="1697216146697"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>single-user-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authentication.single.user.SingleUserLoginIdentityProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Username&quot;</span>&gt;</span>3df4e52a-ab76-477c-9af4-513494f21110<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Password&quot;</span>&gt;</span>$2b$12$NFheiU47xu8ezCrkt0Yz7Oxph/WRhmJaNwMPlDEPkynGSwxEPEibu<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是，貌似没啥作用啊</p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697216230305.png" class width="1697216230305"><p>原来，nifi启动的时候会自动生成一个随机用户名和密码，而且在login-single-user=credentials.xml中配置的密码是通过BCryptPasswordEncoder加密后的，</p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697297856757.png" class width="1697297856757"><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697297612867.png" class width="1697297612867"><p>可以通过以下命令设置一个好记忆的密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nifi.sh set-single-user-credentials USERNAME PASSWORD</span><br></pre></td></tr></table></figure><p>设置完后可以登录界面了</p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697299016832.png" class width="1697299016832">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;NiFi身份验证和授权验证介绍&quot;&gt;&lt;a href=&quot;#NiFi身份验证和授权验证介绍&quot; class=&quot;headerlink&quot; title=&quot;NiFi身份验证和授权验证介绍&quot;&gt;&lt;/a&gt;NiFi身份验证和授权验证介绍&lt;/h2&gt;&lt;p&gt;身份验证（Authenticatio</summary>
      
    
    
    
    <category term="NiFi" scheme="https://castile.github.io/categories/NiFi/"/>
    
    
    <category term="ssl" scheme="https://castile.github.io/tags/ssl/"/>
    
    <category term="nifi" scheme="https://castile.github.io/tags/nifi/"/>
    
    <category term="身份验证" scheme="https://castile.github.io/tags/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>castile-rpc框架：动态代理实现RPC的调用和处理</title>
    <link href="https://castile.github.io/2023/10/08/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0RPC%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>https://castile.github.io/2023/10/08/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0RPC%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E5%A4%84%E7%90%86/</id>
    <published>2023-10-08T14:55:44.000Z</published>
    <updated>2023-10-08T14:55:44.249Z</updated>
    
    <content type="html"><![CDATA[<p>在一个RPC框架中，动态代理可以屏蔽rpc调用时低层的网络通讯、服务发现、负载均衡等具体细节。 使用 RPC 框架的时候，只需要调用接口方法，然后就拿到了返回结果。这些都是通过动态代理去实现的。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的优势是可以很好地遵循设计模式中的开闭原则，对扩展开发，对修改关闭。不需要关注目标类的实现细节，通过代理模式可以在不修改目标类的情况下，增强目标类功能的行为。 </p><p>动态代理是一种代理模式，它提供了一种能够在运行时动态构建代理类以及动态调用目标方法的机制。为什么称为动态是因为代理类和被代理对象的关系是在运行时决定的，代理类可以看作是对被代理对象的包装，对目标方法的调用是通过代理类来完成的。所以通过代理模式可以有效地将服务提供者和服务消费者进行解耦，隐藏了 RPC 调用的具体细节。</p><h2 id="服务消费者动态代理实现"><a href="#服务消费者动态代理实现" class="headerlink" title="服务消费者动态代理实现"></a>服务消费者动态代理实现</h2><p>我们使用@RPCReference注解来标注一个服务端接口，通过一个自定义的RpcReferenceBean完成了所有执行方法的拦截。 RpcReferenceBean 中 init() 方法是代理对象的创建入口，代理对象创建如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化bean，返回代理对象</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       RegistryService registryService = RegistryFactory.getInstance(registryAddr, RegistryType.valueOf(registryType));</span><br><span class="line">       <span class="keyword">this</span>.object = Proxy.newProxyInstance(</span><br><span class="line">               interfaceClass.getClassLoader(),</span><br><span class="line">               <span class="keyword">new</span> Class&lt;?&gt;[]&#123;interfaceClass&#125;,</span><br><span class="line">               <span class="keyword">new</span> RpcInvokerProxy(serviceVersion, timeout, registryService)</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>RpcInvokerProxy 处理器是实现动态代理逻辑的核心所在，其中包含 RPC 调用时底层网络通信、服务发现、负载均衡等具体细节 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcInvokerProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceVersion;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RegistryService registryService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcInvokerProxy</span><span class="params">(String serviceVersion, <span class="keyword">long</span> timeout, RegistryService registryService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceVersion = serviceVersion;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.registryService = registryService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        CastileRpcProtocol&lt;RpcRequest&gt; rpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">        <span class="comment">// 消息头</span></span><br><span class="line">        MessageHeader messageHeader = <span class="keyword">new</span> MessageHeader();</span><br><span class="line">        <span class="comment">// 消息id</span></span><br><span class="line">        <span class="keyword">long</span> requestId = RpcRequestHolder.REQUEST_ID_GEN.incrementAndGet();</span><br><span class="line">        <span class="comment">// 魔数</span></span><br><span class="line">        messageHeader.setMagic(ProtocolConstants.MAGIC);</span><br><span class="line">        <span class="comment">// 版本</span></span><br><span class="line">        messageHeader.setVersion(ProtocolConstants.VERSION);</span><br><span class="line">        <span class="comment">// 序列化算法</span></span><br><span class="line">        messageHeader.setSerialization((<span class="keyword">byte</span>) SerializationTypeEnum.HESSIAN.getType());</span><br><span class="line">        <span class="comment">// 消息类型</span></span><br><span class="line">        messageHeader.setMsgType((<span class="keyword">byte</span>) MsgType.REQUEST.getType());</span><br><span class="line">        messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.SUCCESS.getCode());</span><br><span class="line"></span><br><span class="line">        rpcProtocol.setMessageHeader(messageHeader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息正文</span></span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">        rpcRequest.setServiceVersion(serviceVersion);</span><br><span class="line">        rpcRequest.setClassName(method.getDeclaringClass().getName());</span><br><span class="line">        rpcRequest.setMethodName(method.getName());</span><br><span class="line">        rpcRequest.setParameterTypes(method.getParameterTypes());</span><br><span class="line">        rpcRequest.setParams(args);</span><br><span class="line"></span><br><span class="line">        rpcProtocol.setBody(rpcRequest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建rpc客户端，发送消息进行rpc调用</span></span><br><span class="line">        RpcConsumer consumer = <span class="keyword">new</span> RpcConsumer();</span><br><span class="line"></span><br><span class="line">        RpcFuture&lt;RpcResponse&gt; rpcFuture = <span class="keyword">new</span> RpcFuture&lt;&gt;(<span class="keyword">new</span> DefaultPromise&lt;&gt;(<span class="keyword">new</span> DefaultEventLoop()), timeout);</span><br><span class="line">        RpcRequestHolder.REQUEST_MAP.put(requestId, rpcFuture);</span><br><span class="line">        consumer.sendMessage(rpcProtocol, registryService);</span><br><span class="line">        <span class="keyword">return</span> rpcFuture.getPromise().get(rpcFuture.getTimeout(), TimeUnit.MILLISECONDS).getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke() 方法的核心流程主要分为三步：构造 RPC 协议对象、发起 RPC 远程调用、等待 RPC 调用执行结果。 </p><p>发起 RPC 调用之前，我们需要找到最合适的服务节点，直接调用注册中心服务 RegistryService 的 discovery() 方法即可，默认是采用一致性 Hash 算法实现的服务发现 。为了尽可能使所有服务节点收到的请求流量更加均匀，需要为 discovery() 提供一个 invokerHashCode，一般可以采用 RPC 服务接口参数列表中第一个参数的 hashCode 作为参考依据。找到服务节点地址后，接下来通过 Netty 建立 TCP 连接，然后调用 writeAndFlush() 方法将数据发送到远端服务节点。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(CastileRpcProtocol&lt;RpcRequest&gt; protocolRequest, RegistryService registryService)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RpcRequest request = protocolRequest.getBody();</span><br><span class="line">        Object[] params = request.getParams();</span><br><span class="line">        String serviceKey = RpcServiceHelper.buildServiceKey(request.getMethodName(), request.getServiceVersion());</span><br><span class="line">        <span class="keyword">int</span> invokeHashCode = params.length &gt; <span class="number">0</span> ? params[<span class="number">0</span>].hashCode() : serviceKey.hashCode();</span><br><span class="line">        <span class="comment">// 找到需要发送到哪个服务实例</span></span><br><span class="line">        ServiceMetaData serviceMetaData = registryService.discovery(serviceKey, invokeHashCode);</span><br><span class="line">        <span class="keyword">if</span> (serviceMetaData != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(serviceMetaData.getServiceAddr(), serviceMetaData.getPort()).sync();</span><br><span class="line">            channelFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;connect rpc service &#123;&#125; om port &#123;&#125; success!&quot;</span>, serviceMetaData.getServiceAddr(), serviceMetaData.getPort());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;connect rpc server &#123;&#125; on port &#123;&#125; failed.&quot;</span>, serviceMetaData.getServiceAddr(), serviceMetaData.getPort());</span><br><span class="line">                        channelFuture.cause().printStackTrace();</span><br><span class="line">                        eventLoopGroup.shutdownGracefully();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            channelFuture.channel().writeAndFlush(protocolRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 发送RPC远程调用后，使用Promise机制等待拿到结果。</p><p>Promise 模式本质是一种异步编程模型，我们可以先拿到一个查看任务执行结果的凭证，不必等待任务执行完毕，当我们需要获取任务执行结果时，再使用凭证提供的相关接口进行获取。 </p><h2 id="服务提供者反射调用实现"><a href="#服务提供者反射调用实现" class="headerlink" title="服务提供者反射调用实现"></a>服务提供者反射调用实现</h2><p>消费者通过netty发送消息给服务端后，rpc的请求数据经过解码器解码成CastileRpcProtocol对象后，再交由RpcRequestHandler执行rpcx请求调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, CastileRpcProtocol&lt;RpcRequest&gt; msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 执行rpc调用比较耗时，因此放在业务线程池中去处理</span></span><br><span class="line">        RpcRequestProcessor.submitRequest(() -&gt; &#123;</span><br><span class="line">            CastileRpcProtocol&lt;RpcResponse&gt; rpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">            RpcResponse rpcResponse = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">            MessageHeader messageHeader = msg.getMessageHeader();</span><br><span class="line">            messageHeader.setMsgType((<span class="keyword">byte</span>) MsgType.RESPONSE.getType());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                RpcRequest request = msg.getBody();</span><br><span class="line">                String serviceKey = RpcServiceHelper.buildServiceKey(request.getClassName(), request.getServiceVersion());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取bean对象</span></span><br><span class="line">                Object serviceBean = rpcServiceMap.get(serviceKey);</span><br><span class="line">                <span class="keyword">if</span> (serviceBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 不存在</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;service not exist: %s:%s&quot;</span>, request.getClassName(), request.getMethodName()));</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; serviceClazz = serviceBean.getClass();</span><br><span class="line">                String methodName = request.getMethodName();</span><br><span class="line">                Object[] params = request.getParams();</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">                FastClass fastClass = FastClass.create(serviceClazz);</span><br><span class="line">                <span class="keyword">int</span> index = fastClass.getIndex(methodName, parameterTypes);</span><br><span class="line">                Object result = fastClass.invoke(index, serviceBean, params);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写回到response中</span></span><br><span class="line">                rpcResponse.setData(result);</span><br><span class="line">                messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.SUCCESS.getCode());</span><br><span class="line">                rpcProtocol.setBody(rpcResponse);</span><br><span class="line">                rpcProtocol.setMessageHeader(messageHeader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.FAIL.getCode());</span><br><span class="line">                rpcResponse.setMessage(throwable.toString());</span><br><span class="line">                log.error(<span class="string">&quot;process request &#123;&#125; error&quot;</span>, messageHeader.getRequestId(), throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ctx.writeAndFlush(rpcProtocol);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rpcServiceMap 中存放着服务提供者所有对外发布的服务接口，我们可以通过服务名和服务版本找到对应的服务接口。通过服务接口、方法名、方法参数列表、参数类型列表，我们一般可以使用反射的方式执行方法调用。为了加速服务接口调用的性能，我们采用 Cglib 提供的 FastClass 机制直接调用方法，Cglib 中 MethodProxy 对象就是采用了 FastClass 机制，它可以和 Method 对象完成同样的事情，但是相比于反射性能更高。 </p><p>FastClass 机制并没有采用反射的方式调用被代理的方法，而是运行时动态生成一个新的 FastClass 子类，向子类中写入直接调用目标方法的逻辑。同时该子类会为代理类分配一个 int 类型的 index 索引，FastClass 即可通过 index 索引定位到需要调用的方法。 </p><h1 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h1><p><a href="https://gitee.com/hongliangzhu/castile-rpc">https://gitee.com/hongliangzhu/castile-rpc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在一个RPC框架中，动态代理可以屏蔽rpc调用时低层的网络通讯、服务发现、负载均衡等具体细节。 使用 RPC 框架的时候，只需要调用接口方法，然后就拿到了返回结果。这些都是通过动态代理去实现的。&lt;/p&gt;
&lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class</summary>
      
    
    
    
    <category term="RPC" scheme="https://castile.github.io/categories/RPC/"/>
    
    
    <category term="RPC" scheme="https://castile.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>castile-rpc框架：服务治理-服务发现和负载均衡</title>
    <link href="https://castile.github.io/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://castile.github.io/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2023-09-27T15:25:00.000Z</published>
    <updated>2023-09-27T15:25:00.499Z</updated>
    
    <content type="html"><![CDATA[<p>在一个分布式系统中，每个服务都有多个实例，如果服务实例节点出现负载比较高，那么可能会导致该节点上面的请求处理超时，影响可用性。so，一个良好的rpc框架需要 实现合理的负载均衡算法。</p><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>服务消费者在发起请求之前都需要根据需要调用的服务去服务中心去找那些服务端实例，而且每个服务都有上线和下线的概念，因此消费端还需要感知服务提供者的实例变化，在rpc框架中，一般使用注册中心来实现服务的发现和注册。</p><p>主流的注册中心有zookeeper、Eureka、Etcd？Consul、Nacos等， 高可用的注册中心对 RPC 框架至关重要。说到高可用自然离不开 CAP 理论，一致性 Consistency、可用性 Availability 和分区容忍性 Partition tolerance 是无法同时满足的，注册中心一般分为 <strong>CP 类型注册中心</strong>和 <strong>AP 类型注册中心</strong> 。</p><p>● 一致性：指所有节点在同一时刻的数据完全一致。</p><p>● 可用性：指服务一直可用，而且响应时间正常。例如，不管什么时候访问X节点和Y节点都可以正常获取数据值，而不会出现问题。</p><p>● 分区容错性：指在遇到某节点或网络分区故障时，仍然能够对外提供满足一致性和可用性的服务。例如X节点和Y节点出现故障，但是依然可以很好地对外提供服务 </p><p><strong>CAP的取舍</strong>:</p><p>1、 满足CA舍弃P，也就是满足一致性和可用性，舍弃分区容错性。这也就意味着你的系统不是分布式的了，因为分布式就是把功能分开部署到不同的机器上。</p><p>2、满足CP舍弃A，也就是满足一致性和分区容错性，舍弃可用性。这也就意味着你的系统允许有一段时间访问失效等，不会出现数据不一致的情况。</p><p>3、满足AP舍弃C，也就是满足可用性和分区容错性，舍弃一致性。这也就意味着你的系统在并发访问的时候可能会出现数据不一致的情况。</p><p>在分布式系统中，为了避免单点故障，分区容错是不可避免的，所以对于注册中心来说只能从CP（优先保证数据一致性）、AP（优先保证数据可用性）中根据你的业务场景选择一种。</p><p> 使用最为广泛的 Zookeeper 就是 CP 类型的注册中心，集群中会有一个节点作为 Leader，如果 Leader 节点挂了，会重新进行 Leader 选举，ZooKeeper 保证了所有节点的强一致性，但是在 Leader 选举的过程中是无法对外提供服务的，牺牲了部分可用性。Eureka 是典型的 AP 类型注册中心，在实现服务发现的场景下有很大的优势，整个集群是不存在 Leader、Flower 概念的，如果其中一个节点挂了，请求会立刻转移到其他节点上。可能会存在的问题是如果不同分区无法进行节点通信，那么可能会造成节点之间的数据是有差异的，所以 AP 类型的注册中心通过牺牲强一致性来保证高可用性 。 </p><p>对于 RPC 框架而言，即使注册中心出现问题，也不应该影响服务的正常调用，所以 AP 类型的注册中心在该场景下相比于 CP 类型的注册中心更有优势。 对于成熟的 RPC 框架而言，会提供多种注册中心的选择，接下来我们便设计一个通用的注册中心接口，然后每种注册中心的实现都按该接口规范行扩展。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册微服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceMetaData 服务元数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(ServiceMetaData serviceMetaData)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(ServiceMetaData serviceMetaData)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServiceMetaData <span class="title">discovery</span><span class="params">(String serviceName, <span class="keyword">int</span> invokerHashCode)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> RegistryService 接口包含注册中心四个基本操作：<strong>服务注册 register</strong>、<strong>服务注销 unRegister</strong>、<strong>服务发现 discovery</strong>、<strong>注册中心销毁 destroy</strong>。 </p><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>服务消费者在发起 RPC 调用之前，需要感知有多少服务端节点可用，然后从中选取一个进行调用。之前我们提到了几种常用的负载均衡策略：Round-Robin 轮询、Weighted Round-Robin 权重轮询、Least Connections 最少连接数、Consistent Hash 一致性 Hash 等。  一致性 Hash 算法可以保证每个服务节点分摊的流量尽可能均匀，而且能够把服务节点扩缩容带来的影响降到最低。下面我们一起看下一致性 Hash 算法的设计思路。 </p><p>在服务端节点扩缩容时，一致性 Hash 算法会尽可能保证客户端发起的 RPC 调用还是固定分配到相同的服务节点上。一致性 Hash 算法是采用<strong>哈希环</strong>来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash。</p><p>关于一致性hash算法可参考： <a href="https://zhuanlan.zhihu.com/p/482549860?utm_medium=social&amp;utm_oi=919687111576289280">https://zhuanlan.zhihu.com/p/482549860?utm_medium=social&amp;utm_oi=919687111576289280</a></p><p>负载均衡接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceLoadBalancer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">select</span><span class="params">(List&lt;T&gt; servers, <span class="keyword">int</span> hashCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于zk实现的一致性hash算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConsistentHashLoadBalancer</span> <span class="keyword">implements</span> <span class="title">ServiceLoadBalancer</span>&lt;<span class="title">ServiceInstance</span>&lt;<span class="title">ServiceMetaData</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 虚拟节点数，默认是10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildServiceInstanceKey</span><span class="params">(ServiceInstance&lt;ServiceMetaData&gt; instance)</span> </span>&#123;</span><br><span class="line">        ServiceMetaData payload = instance.getPayload();</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot;:&quot;</span>, payload.getServiceAddr(), String.valueOf(payload.getPort()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance&lt;ServiceMetaData&gt; <span class="title">select</span><span class="params">(List&lt;ServiceInstance&lt;ServiceMetaData&gt;&gt; servers, <span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, ServiceInstance&lt;ServiceMetaData&gt;&gt; ring = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ServiceInstance&lt;ServiceMetaData&gt; instance : servers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE; i++) &#123;</span><br><span class="line">                ring.put((buildServiceInstanceKey(instance) + VIRTUAL_NODE_SIZE + i).hashCode(), instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ceilingEntry() 方法找出大于或等于客户端 hashCode 的第一个节点，即为客户端对应要调用的服务节点</span></span><br><span class="line">        Map.Entry&lt;Integer, ServiceInstance&lt;ServiceMetaData&gt;&gt; entry = ring.ceilingEntry(hashCode);</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            entry = ring.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>服务发现的实现思路比较简单，首先找出被调用服务所有的节点列表，然后通过 ZKConsistentHashLoadBalancer 提供的一致性 Hash 算法找出相应的服务节点。具体代码实现如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ServiceMetaData <span class="title">discovery</span><span class="params">(String serviceName, <span class="keyword">int</span> invokerHashCode)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Collection&lt;ServiceInstance&lt;ServiceMetaData&gt;&gt; serviceInstances = serviceDiscovery.queryForInstances(serviceName);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 通过一些负载均衡算法，选择一个服务实例</span></span><br><span class="line">       ServiceInstance&lt;ServiceMetaData&gt; instance = <span class="keyword">new</span> ZKConsistentHashLoadBalancer().select((List&lt;ServiceInstance&lt;ServiceMetaData&gt;&gt;) serviceInstances, invokerHashCode);</span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance.getPayload();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在一个分布式系统中，每个服务都有多个实例，如果服务实例节点出现负载比较高，那么可能会导致该节点上面的请求处理超时，影响可用性。so，一个良好的rpc框架需要 实现合理的负载均衡算法。&lt;/p&gt;
&lt;h2 id=&quot;注册中心&quot;&gt;&lt;a href=&quot;#注册中心&quot; class=&quot;head</summary>
      
    
    
    
    <category term="RPC" scheme="https://castile.github.io/categories/RPC/"/>
    
    
    <category term="RPC" scheme="https://castile.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>castile-rpc框架：通信协议的设计和编解码器的实现</title>
    <link href="https://castile.github.io/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://castile.github.io/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-09-27T13:37:57.000Z</published>
    <updated>2023-09-27T13:37:57.027Z</updated>
    
    <content type="html"><![CDATA[<p>现在需要建立客户端和服务端之间的通信机制了，主要内容有：</p><ul><li>服务消费者实现协议编码，向服务提供者发送调用数据。</li><li>服务提供者收到数据后解码，然后向服务消费者发送响应数据，暂时忽略 RPC 请求是如何被调用的。</li><li>服务消费者收到响应数据后成功返回。</li></ul><h2 id="1、RPC-通信方案设计"><a href="#1、RPC-通信方案设计" class="headerlink" title="1、RPC 通信方案设计"></a>1、RPC 通信方案设计</h2><img src="/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/1695565921880.png" class width="1695565921880"><h2 id="2、自定义RPC通信协议"><a href="#2、自定义RPC通信协议" class="headerlink" title="2、自定义RPC通信协议"></a>2、自定义RPC通信协议</h2><p>协议是服务消费者和服务提供者之间通信的基础，主流的 RPC 框架都会自定义通信协议，相比于 HTTP、HTTPS、JSON 等通用的协议，自定义协议可以实现更好的性能、扩展性以及安全性。 </p><h3 id="自定义协议要素"><a href="#自定义协议要素" class="headerlink" title="自定义协议要素"></a>自定义协议要素</h3><ul><li>魔数，用来在第一时间判定是否是无效数据包</li><li>版本号，可以支持协议的升级</li><li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li><li>状态： 失败还是成功？ 可选</li><li>消息类型，是请求、响应？这个 跟业务相关</li><li>请求序号，为了双工通信，提供异步能力</li><li>正文长度</li><li>消息正文</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">| 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">| 状态 1byte |        消息 ID 8byte     |      数据长度 4byte     |</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">|                   数据内容 （长度不定）                          |</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>我们把协议分为协议头 Header 和协议体 Body 两个部分。协议头 Header 包含魔数、协议版本号、序列化算法、报文类型、状态、消息 ID、数据长度，协议体 Body 只包含数据内容部分，数据内容的长度是不固定的。RPC 请求和响应都可以使用该协议进行通信，对应协议实体类的定义如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CastileRpcProtocol</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> MessageHeader messageHeader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageHeader</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">short</span> magic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> version;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> serialization;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> msgType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> status;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> requestId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> msgLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、序列化算法选型"><a href="#3、序列化算法选型" class="headerlink" title="3、序列化算法选型"></a>3、序列化算法选型</h2><p>目前比较常用的序列化算法包括 Json、Kryo、Hessian、Protobuf 等，这些第三方序列化算法都比 Java 原生的序列化操作都更加高效。 我们设计了一个 RPC 序列化顶层接口， 所有的序列化算法都需要实现这个接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcSerialization</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 待序列化数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 序列化数据的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 序列化后的字节流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="keyword">byte</span>[] serialize(T obj) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf   数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;   类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] buf, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 我们为 RpcSerialization 提供了 HessianSerialization 和 JsonSerialization 两种类型的实现，为此，可以提供一个序列化工厂来切换不同的序列化算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RpcSerialization <span class="title">getRpcSerialization</span><span class="params">(<span class="keyword">byte</span> type)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        SerializationTypeEnum typeEnum = SerializationTypeEnum.findSerializationType(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (typeEnum)&#123;</span><br><span class="line">            <span class="keyword">case</span> HESSIAN:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HessianSerialization();</span><br><span class="line">            <span class="keyword">case</span> JSON:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JsonSerialization();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;serialization type is illegal, &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、通信协议的编码器"><a href="#4、通信协议的编码器" class="headerlink" title="4、通信协议的编码器"></a>4、通信协议的编码器</h2><p>Netty 提供了两个最为常用的编解码抽象基类 MessageToByteEncoder 和 ByteToMessageDecoder，帮助我们很方便地扩展实现自定义协议。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">CastileRpcProtocol</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">   | 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |</span></span><br><span class="line"><span class="comment">   +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">   | 状态 1byte |        消息 ID 8byte     |      数据长度 4byte     |</span></span><br><span class="line"><span class="comment">   +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">   |                   数据内容 （长度不定）                          |</span></span><br><span class="line"><span class="comment">   +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, CastileRpcProtocol message, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessageHeader messageHeader = message.getMessageHeader();</span><br><span class="line">        <span class="comment">// 魔数</span></span><br><span class="line">        byteBuf.writeShort(messageHeader.getMagic());</span><br><span class="line">        <span class="comment">// 协议版本号</span></span><br><span class="line">        byteBuf.writeByte(messageHeader.getVersion());</span><br><span class="line">        <span class="comment">// 序列化算法</span></span><br><span class="line">        byteBuf.writeByte(messageHeader.getSerialization());</span><br><span class="line">        <span class="comment">// 报文类型</span></span><br><span class="line">        byteBuf.writeByte(messageHeader.getMsgType());</span><br><span class="line">        <span class="comment">// 状态</span></span><br><span class="line">        byteBuf.writeByte(messageHeader.getStatus());</span><br><span class="line">        <span class="comment">// 消息id</span></span><br><span class="line">        byteBuf.writeLong(messageHeader.getRequestId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        RpcSerialization rpcSerialization = SerializationFactory.getRpcSerialization(messageHeader.getSerialization());</span><br><span class="line">        <span class="keyword">byte</span>[] body = rpcSerialization.serialize(message.getBody());</span><br><span class="line">        <span class="comment">// 数据长度</span></span><br><span class="line">        byteBuf.writeInt(body.length);</span><br><span class="line">        byteBuf.writeBytes(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在服务消费者或者服务提供者调用 writeAndFlush() 将数据写给对方前，都已经封装成 RpcRequest 或者 RpcResponse，所以可以采用 CastileRpcProtocol作为 RPC Encoder 编码器能够支持的编码类型。 </p><h2 id="5、-通信协议的解码器"><a href="#5、-通信协议的解码器" class="headerlink" title="5、 通信协议的解码器"></a>5、 通信协议的解码器</h2><p> 解码器 相比于编码器 要复杂很多，解码器的目标是将字节流数据解码为消息对象，并传递给下一个 Inbound 处理器。整个解码过程有几个要点要特别注意： </p><ul><li><p>只有当 ByteBuf 中内容大于协议头 Header 的固定的 18 字节时，才开始读取数据。</p></li><li><p>即使已经可以完整读取出协议头 Header，但是协议体 Body 有可能还未就绪。所以在刚开始读取数据时，需要使用 markReaderIndex() 方法标记读指针位置，当 ByteBuf 中可读字节长度小于协议体 Body 的长度时，再使用 resetReaderIndex() 还原读指针位置，说明现在 ByteBuf 中可读字节还不够一个完整的数据包。</p><blockquote><p>这个其实也可以使用<strong>LengthFieldBasedFrameDecoder</strong>来处理粘包和半包问题</p></blockquote></li><li><p>根据不同的报文类型 MsgType，需要反序列化出不同的协议体对象。在 RPC 请求调用的场景下，服务提供者需要将协议体内容反序列化成 MiniRpcRequest 对象；在 RPC 结果响应的场景下，服务消费者需要将协议体内容反序列化成 MiniRpcResponse 对象。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 消息小于头长度，不完整数据</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &lt; ProtocolConstants.HEADER_TOTAL_LEN) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;message length valid failed! please check request data&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        byteBuf.markReaderIndex();</span><br><span class="line">        <span class="comment">// 魔数</span></span><br><span class="line">        <span class="keyword">short</span> magic = byteBuf.readShort();</span><br><span class="line">        <span class="comment">// 魔数不匹配，不是本系统消息</span></span><br><span class="line">        <span class="keyword">if</span> (magic != ProtocolConstants.MAGIC) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;magic number is illegal, &quot;</span> + magic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span> version = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializeType = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> msgType = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> status = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">long</span> requestId = byteBuf.readLong();</span><br><span class="line">        <span class="keyword">int</span> dataLength = byteBuf.readInt();</span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &lt; dataLength) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;data readableBytes less than data length!&quot;</span>);</span><br><span class="line">            byteBuf.resetReaderIndex();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[dataLength];</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line">        <span class="comment">// 获取消息类型</span></span><br><span class="line">        MsgType byTpye = MsgType.findByType(msgType);</span><br><span class="line">        <span class="keyword">if</span> (byTpye == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;msgType number is illegal, &quot;</span> + msgType);</span><br><span class="line">        &#125;</span><br><span class="line">        MessageHeader header = <span class="keyword">new</span> MessageHeader();</span><br><span class="line">        header.setMagic(magic);</span><br><span class="line">        header.setVersion(version);</span><br><span class="line">        header.setSerialization(serializeType);</span><br><span class="line">        header.setStatus(status);</span><br><span class="line">        header.setRequestId(requestId);</span><br><span class="line">        header.setMsgType(msgType);</span><br><span class="line">        header.setMsgLen(dataLength);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        RpcSerialization rpcSerialization = SerializationFactory.getRpcSerialization(serializeType);</span><br><span class="line">        <span class="keyword">switch</span> (byTpye) &#123;</span><br><span class="line">            <span class="keyword">case</span> REQUEST:</span><br><span class="line">                RpcRequest rpcRequest = rpcSerialization.deserialize(data, RpcRequest.class);</span><br><span class="line">                <span class="keyword">if</span> (rpcRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    CastileRpcProtocol&lt;RpcRequest&gt; castileRpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">                    castileRpcProtocol.setMessageHeader(header);</span><br><span class="line">                    castileRpcProtocol.setBody(rpcRequest);</span><br><span class="line">                    list.add(castileRpcProtocol);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RESPONSE:</span><br><span class="line">                RpcResponse rpcResponse = rpcSerialization.deserialize(data, RpcResponse.class);</span><br><span class="line">                <span class="keyword">if</span> (rpcResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    CastileRpcProtocol&lt;RpcResponse&gt; castileRpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">                    castileRpcProtocol.setMessageHeader(header);</span><br><span class="line">                    castileRpcProtocol.setBody(rpcResponse);</span><br><span class="line">                    list.add(castileRpcProtocol);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> HEARTBEAT:</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6、请求和响应处理"><a href="#6、请求和响应处理" class="headerlink" title="6、请求和响应处理"></a>6、请求和响应处理</h2><p>消费者调用RPC请求后，服务端通过解码器将二进制的数据解码成CastileRpcProtocol<RpcRequest>对象，再传递给RpcRequestHandler处理器执行rpc调用。 RpcRequestHandler 也是一个 Inbound 处理器，它并不需要承担解码工作，所以 RpcRequestHandler 直接继承 SimpleChannelInboundHandler 即可，然后重写 channelRead0() 方法，具体实现如下： </RpcRequest></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">CastileRpcProtocol</span>&lt;<span class="title">RpcRequest</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; rpcServiceMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcRequestHandler</span><span class="params">(Map&lt;String, Object&gt; rpcServiceMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rpcServiceMap = rpcServiceMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, CastileRpcProtocol&lt;RpcRequest&gt; msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 执行rpc调用比较耗时，因此放在业务线程池中去处理</span></span><br><span class="line">        RpcRequestProcessor.submitRequest(() -&gt; &#123;</span><br><span class="line">            CastileRpcProtocol&lt;RpcResponse&gt; rpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">            RpcResponse rpcResponse = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">            MessageHeader messageHeader = msg.getMessageHeader();</span><br><span class="line">            messageHeader.setMsgType((<span class="keyword">byte</span>) MsgType.RESPONSE.getType());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                RpcRequest request = msg.getBody();</span><br><span class="line">                String serviceKey = RpcServiceHelper.buildServiceKey(request.getClassName(), request.getServiceVersion());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取bean对象</span></span><br><span class="line">                Object serviceBean = rpcServiceMap.get(serviceKey);</span><br><span class="line">                <span class="keyword">if</span> (serviceBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 不存在</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;service not exist: %s:%s&quot;</span>, request.getClassName(), request.getMethodName()));</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; serviceClazz = serviceBean.getClass();</span><br><span class="line">                String methodName = request.getMethodName();</span><br><span class="line">                Object[] params = request.getParams();</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">                FastClass fastClass = FastClass.create(serviceClazz);</span><br><span class="line">                <span class="keyword">int</span> index = fastClass.getIndex(methodName, parameterTypes);</span><br><span class="line">                Object result = fastClass.invoke(index, serviceBean, params);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写回到response中</span></span><br><span class="line">                rpcResponse.setData(result);</span><br><span class="line">                messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.SUCCESS.getCode());</span><br><span class="line">                rpcProtocol.setBody(rpcResponse);</span><br><span class="line">                rpcProtocol.setMessageHeader(messageHeader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.FAIL.getCode());</span><br><span class="line">                rpcResponse.setMessage(throwable.toString());</span><br><span class="line">                log.error(<span class="string">&quot;process request &#123;&#125; error&quot;</span>, messageHeader.getRequestId(), throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ctx.writeAndFlush(rpcProtocol);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 服务消费者在发起调用时，维护了请求 requestId 和 RpcFuture的映射关系，RpcResponseHandler 会根据请求的 requestId 找到对应发起调用的 RpcFuture，然后为 RpcFuture 设置响应结果。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">CastileRpcProtocol</span>&lt;<span class="title">RpcResponse</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, CastileRpcProtocol&lt;RpcResponse&gt; msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> requestId = msg.getMessageHeader().getRequestId();</span><br><span class="line">        RpcFuture&lt;RpcResponse&gt; responseRpcFuture = RpcRequestHolder.REQUEST_MAP.remove(requestId);</span><br><span class="line">        responseRpcFuture.getPromise().setSuccess(msg.getBody());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcFuture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Promise&lt;T&gt; promise;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcFuture</span><span class="params">(Promise&lt;T&gt; promise, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.promise = promise;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在需要建立客户端和服务端之间的通信机制了，主要内容有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务消费者实现协议编码，向服务提供者发送调用数据。&lt;/li&gt;
&lt;li&gt;服务提供者收到数据后解码，然后向服务消费者发送响应数据，暂时忽略 RPC 请求是如何被调用的。&lt;/li&gt;
&lt;li&gt;服务消</summary>
      
    
    
    
    <category term="RPC" scheme="https://castile.github.io/categories/RPC/"/>
    
    
    <category term="RPC" scheme="https://castile.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>castile-rpc框架：服务的注册与发现</title>
    <link href="https://castile.github.io/2023/09/24/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    <id>https://castile.github.io/2023/09/24/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</id>
    <published>2023-09-24T14:14:07.000Z</published>
    <updated>2023-09-24T14:14:07.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先考虑用户应该如何使用"><a href="#先考虑用户应该如何使用" class="headerlink" title="先考虑用户应该如何使用"></a>先考虑用户应该如何使用</h1><h2 id="1、-服务端"><a href="#1、-服务端" class="headerlink" title="1、 服务端"></a>1、 服务端</h2><p>服务端定义一个服务接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-03 15:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打招呼</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 姓名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现服务接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-03 15:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RpcService(serviceInterface = HelloService.class, serviceVersion = &quot;1.0.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在服务端启动的时候会向注册中心注册这个服务。</p><h2 id="2、-消费端"><a href="#2、-消费端" class="headerlink" title="2、 消费端"></a>2、 消费端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RpcReference(serviceVersion = &quot;1.0.0&quot;, timeout = 3000)</span></span><br><span class="line">    <span class="keyword">private</span> HelloFacade helloFacade;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloFacade.hello(<span class="string">&quot;mini rpc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="服务提供者提供服务"><a href="#服务提供者提供服务" class="headerlink" title="服务提供者提供服务"></a>服务提供者提供服务</h1><h2 id="1、RPC服务端"><a href="#1、RPC服务端" class="headerlink" title="1、RPC服务端"></a>1、RPC服务端</h2><p>服务提供者采用的是主从 Reactor 线程模型，启动过程包括配置线程池、Channel 初始化、端口绑定三个步骤 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.castile.rpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.castile.rpc.provider.autoconfig.RpcProperties;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动RPC服务端，</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务启动的时候进行服务发现与注册</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-03 22:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServerRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RpcProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String address = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap().group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line">                            <span class="comment">// TODO 添加其他处理器， 如：编解码，消息请求处理</span></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(address, <span class="keyword">this</span>.properties.getPort()).sync();</span><br><span class="line">            log.info(<span class="string">&quot;连接信息：server addr &#123;&#125; started on port &#123;&#125;&quot;</span>, address, <span class="keyword">this</span>.properties.getPort());</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、发布服务"><a href="#2、发布服务" class="headerlink" title="2、发布服务"></a>2、发布服务</h2><p>定义一个注解，用于标识一个服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.castile.rpc.provider;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * rpc服务注解</span><br><span class="line"> *</span><br><span class="line"> * @author Hongliang Zhu</span><br><span class="line"> * @create 2023-09-03 15:51</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Component</span><br><span class="line">public @interface RpcService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 服务所在的接口</span><br><span class="line">     *</span><br><span class="line">     * @return 服务接口</span><br><span class="line">     */</span><br><span class="line">    Class&lt;?&gt; serviceInterface() default Object.class;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 服务版本</span><br><span class="line">     *</span><br><span class="line">     * @return 版本</span><br><span class="line">     */</span><br><span class="line">    String version() default &quot;1.0.0&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有两个重要的属性，serviceInterface表示服务类型接口，version表示服务版本。 服务消费者必须指定完全一样的属性才能正确调用。有了 @RpcService 注解之后，我们就可以在服务实现类上使用它。</p><p>@RpcService 注解本质上就是 @Component，可以将服务实现类注册成 Spring 容器所管理的 Bean。这里需要了解Spring中Bean的生命周期了。</p><img src="/2023/09/24/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/1693753942141.png" class width="1693753942141"><p>Spring的BeanPostProcessor接口提供了对Bean进行再加工的扩展点。 BeanPostProcessor 常用于处理自定义注解。自定义的 Bean 可以通过实现 BeanPostProcessor 接口，在 Bean 实例化的前后加入自定义的逻辑处理。如下所示，我们通过 RpcProvider 实现 BeanPostProcessor 接口，来实现对 声明 @RpcService 注解服务的自定义处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.castile.rpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.castile.rpc.provider.autoconfig.RpcProperties;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描<span class="doctag">@RpcService</span>注解，注册到注册中心中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-03 23:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcProviderProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; rpcServices = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RpcProperties properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        RpcService rpcService = bean.getClass().getAnnotation(RpcService.class);</span><br><span class="line">        <span class="keyword">if</span> (rpcService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String serviceName = rpcService.serviceInterface().getName();</span><br><span class="line">            String serviceVersion = rpcService.version();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String address = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                ServiceMetaData serviceMetaData = <span class="keyword">new</span> ServiceMetaData();</span><br><span class="line">                serviceMetaData.setPort(properties.getPort());</span><br><span class="line">                serviceMetaData.setServiceAddr(address);</span><br><span class="line">                serviceMetaData.setServiceName(serviceName);</span><br><span class="line">                serviceMetaData.setServiceVersion(serviceVersion);</span><br><span class="line">                <span class="comment">// TODO 封装注册信息，注册到注册中心</span></span><br><span class="line"></span><br><span class="line">                rpcServices.put(serviceName + <span class="string">&quot;#&quot;</span> + serviceVersion, bean);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;failed to register service &#123;&#125;#&#123;&#125;&quot;</span>, serviceName, serviceVersion, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="服务消费者订阅服务"><a href="#服务消费者订阅服务" class="headerlink" title="服务消费者订阅服务"></a>服务消费者订阅服务</h1><p>消费者不属于常驻服务， 每次发起 RPC 调用时它才会去选择向哪个远端服务发送数据。 对于声明 @RpcReference 注解的成员变量，我们需要构造出一个可以真正进行 RPC 调用的 Bean，然后将它注册到 Spring 的容器中。</p><p> @RpcReference 注解的定义 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcReference &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用的服务版本</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">serviceVersion</span><span class="params">()</span> <span class="keyword">default</span> &quot;1.0.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rpc调用的超时时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 3000</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要为使用了@RpcReference注解的成员变量构造成一个自定义的bean对象，并且对该bean对象执行的所有方法进行拦截。</p><p>Spring 的 FactoryBean 接口可以帮助我们实现自定义的 Bean，FactoryBean 是一种特种的工厂 Bean，通过 getObject() 方法返回对象，而并不是 FactoryBean 本身。 </p><p>有了 @RpcReference 注解和 RpcReferenceBean 之后，我们可以使用 Spring 的扩展点 BeanFactoryPostProcessor 对 Bean 的定义进行修改。上文中服务提供者使用的是 BeanPostProcessor，BeanFactoryPostProcessor 和 BeanPostProcessor 都是 Spring 的核心扩展点，它们之间有什么区别呢？BeanFactoryPostProcessor 是 Spring 容器加载 Bean 的定义之后以及 Bean 实例化之前执行，所以 BeanFactoryPostProcessor 可以在 Bean 实例化之前获取 Bean 的配置元数据，并允许用户对其修改。而 BeanPostProcessor 是在 Bean 初始化前后执行，它并不能修改 Bean 的配置信息。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcConsumerPostProcessor</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INIT_METHOD_NAME = <span class="string">&quot;init&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; rpcRefBeanDefinitions = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        String[] beanDefinitionNames = configurableListableBeanFactory.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String beanDefName : beanDefinitionNames) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = configurableListableBeanFactory.getBeanDefinition(beanDefName);</span><br><span class="line">            <span class="keyword">final</span> String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">            <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = ClassUtils.resolveClassName(beanClassName, <span class="keyword">this</span>.classLoader);</span><br><span class="line">                ReflectionUtils.doWithFields(clazz, <span class="keyword">this</span>::parseRpcReference);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// beanClassName = null</span></span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) configurableListableBeanFactory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.rpcRefBeanDefinitions.forEach((beanName, definition) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.containsBean(beanName)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;application  context already has a bean named &quot;</span> + beanName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注册到spring中</span></span><br><span class="line">                registry.registerBeanDefinition(beanName, rpcRefBeanDefinitions.get(beanName));</span><br><span class="line">                log.info(<span class="string">&quot;registered RpcReferenceBean &#123;&#125; success.&quot;</span>, beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = applicationContext;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseRpcReference</span><span class="params">(Field field)</span> </span>&#123;</span><br><span class="line">        RpcReference annotation = AnnotationUtils.getAnnotation(field, RpcReference.class);</span><br><span class="line">        <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(RpcReferenceBean.class);</span><br><span class="line">            builder.setInitMethodName(INIT_METHOD_NAME);</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;interfaceClass&quot;</span>, field.getType());</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;serviceVersion&quot;</span>, annotation.serviceVersion());</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;timeout&quot;</span>, annotation.timeout());</span><br><span class="line">            AbstractBeanDefinition definition = builder.getBeanDefinition();</span><br><span class="line">            rpcRefBeanDefinitions.put(field.getName(), definition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;先考虑用户应该如何使用&quot;&gt;&lt;a href=&quot;#先考虑用户应该如何使用&quot; class=&quot;headerlink&quot; title=&quot;先考虑用户应该如何使用&quot;&gt;&lt;/a&gt;先考虑用户应该如何使用&lt;/h1&gt;&lt;h2 id=&quot;1、-服务端&quot;&gt;&lt;a href=&quot;#1、-服务端&quot; cla</summary>
      
    
    
    
    <category term="RPC" scheme="https://castile.github.io/categories/RPC/"/>
    
    
    <category term="rpc" scheme="https://castile.github.io/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>castile-rpc框架</title>
    <link href="https://castile.github.io/2023/09/03/castile-rpc%E6%A1%86%E6%9E%B6/"/>
    <id>https://castile.github.io/2023/09/03/castile-rpc%E6%A1%86%E6%9E%B6/</id>
    <published>2023-09-03T07:28:31.000Z</published>
    <updated>2023-09-03T07:28:31.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC服务框架架构"><a href="#RPC服务框架架构" class="headerlink" title="RPC服务框架架构"></a>RPC服务框架架构</h1><img src="/2023/09/03/castile-rpc%E6%A1%86%E6%9E%B6/1693723330951.png" class width="1693723330951"><p>RPC又称远程过程调用（Remote Procedure Call），用于解决分布式系统中服务之间的调用问题。他可以实现开发者能够像调用本地的方法一样去调用远程的服务。包含了三个重要的组成部分，分别是注册中心、服务提供者、服务消费者，其中，服务消费者也称之为客户端。</p><p>在一次RPC调用的时候，这三个组成部分的交互过程大致如下：</p><p>1、 服务提供者（微服务）启动的时候，会将自己的对外开发的服务列表（接口信息）注册到服务中心中，消费者想注册中心去订阅服务提供者的地址。</p><p>2、 消费者会通过一个本地的代理模块区调用服务提供者，这个代理Proxy模块会将调用的方法。参数等数据封装成网络字节流的形式去传输</p><p>3、在传输之前需要确定发给哪一个服务端，因此会先从服务列表中选取一个服务地址（可以做负载均衡），并将数据通过网络发送给服务端。</p><p>4、 服务提供者接受到消息后，进行解码，拿到要调用的方法和参数。</p><p>5、服务提供者根据解码后的请求去调用对应的服务，然后将返回结果封装成字节流发送给服务消费者。</p><h1 id="服务的注册和发现"><a href="#服务的注册和发现" class="headerlink" title="服务的注册和发现"></a>服务的注册和发现</h1><p>首先最重要的是服务提供者可以去注册到注册中心，消费者可以去注册中心订阅服务。</p><p>为什么要有注册中心呢？传统的分布式系统一般是通过http去调用远端服务，这往往需要知道具体的服务端地址、调用信息等，系统之间的耦合比较严重，为了更好的去洁癖客户端和服务端，引入了注册中心，可以优雅地处理服务的上线和下线。</p><p>注册中心实现服务的注册和发现功能。服务端自行注册服务列表，服务下线的时候需要将自己的服务列表元数据移除，并可通知对应的客户端。客户端发起调用的时候，自己去订阅获取注册中心的服务列表，并通过一些负载均衡算法选择其中的一个实例进行调用，</p><p>那么，如何处理服务下线的问题，服务下线是需要移除注册中心该服务的一些信息的，最能想到的办法就是，服务端主动发送清理消息给注册中心，但是如果服务节点异常退出，比如节点断点了，断网等，还来不及发送消息给注册中心，那么注册中心就一直存在异常服务节点的元数据了，从而可能会造成服务调用失败的问题。</p><p>为了避免上述问题，实现服务优雅下线比较好的方式是采用<strong>主动通知 + 心跳检测</strong>的方案。除了主动通知注册中心下线外，还需要增加节点与注册中心的心跳检测功能，这个过程也叫作探活。心跳检测可以由节点或者注册中心负责，例如注册中心可以向服务节点每 60s 发送一次心跳包，如果 3 次心跳包都没有收到请求结果，可以任务该服务节点已经下线 </p><h1 id="通信协议和序列化"><a href="#通信协议和序列化" class="headerlink" title="通信协议和序列化"></a>通信协议和序列化</h1><p>RPC 是远程调用，必然离不开网络通信协议。客户端在向服务端发起调用之前，需要考虑采用何种方式将调用信息进行编码，并传输到服务端。因为 RPC 框架对性能有非常高的要求，所以通信协议应该越简单越好，这样可以减少编解码的性能损耗。</p><p>RPC 框架可以基于不同的协议实现，大部分主流 RPC 框架会选择 TCP、HTTP 协议，出名的 gRPC 框架使用的则是 HTTP2。TCP、HTTP、HTTP2 都是稳定可靠的，但其实使用 UDP 协议也是可以的，具体看业务使用的场景 。</p><p>客户端和服务端在通信过程中要传输的数据主要有：</p><blockquote><ol><li>调用的接口名称</li><li>方法</li><li>请求参数</li><li>调用属性等信息</li></ol></blockquote><p>这些数据需要在客户端序列化成二进制，通过网络传输到服务端。服务端需要通过反序列化得到调用的信息，然后利用反射调用对应的方法，最后将结果、状态码、异常等信息返回。</p><h1 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h1><h2 id="1、-同步调用"><a href="#1、-同步调用" class="headerlink" title="1、 同步调用"></a>1、 同步调用</h2><p>客户端线程发起RPC调用后会一直阻塞，知道拿到返回的结果。</p><h2 id="2、-异步调用"><a href="#2、-异步调用" class="headerlink" title="2、 异步调用"></a>2、 异步调用</h2><p>客户端发起调用后不会再阻塞等待，而是拿到 RPC 框架返回的 Future 对象，调用结果会被服务端缓存，客户端自行决定后续何时获取返回结果 </p><h2 id="3、-回调调用"><a href="#3、-回调调用" class="headerlink" title="3、 回调调用"></a>3、 回调调用</h2><p>客户端发起调用的时候，将callback对象传给rpc框架，无需等待结果。当得到服务端响应结果或者超时的时候，会执行用户注册的回调函数。callback一般包含onResponse 和 onException 两个方法，分别对应成功返回和异常返回两种情况。</p><h2 id="4、-OneWay单向调用"><a href="#4、-OneWay单向调用" class="headerlink" title="4、 OneWay单向调用"></a>4、 OneWay单向调用</h2><p> 客户端发起请求之后直接返回 ，忽略他的返回结果。</p><h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><p>线程模型是RPC框架重要关注的部分，首先需要知道IO线程和业务线程的区别。</p><p>以Dubbo框架为例， Dubbo 使用 Netty 作为底层的网络通信框架，采用了我们熟悉的主从 Reactor 线程模型，其中 Boss 和 Worker 线程池就可以看作 I/O 线程。I/O 线程可以理解为主要负责处理网络数据，例如事件轮询、编解码、数据传输等。</p><p>业务逻辑如果能够立即完成，也可以使用 I/O 线程进行处理，这样可以省去线程上下文切换的开销。如果业务逻辑耗时较多，例如包含查询数据库、复杂规则计算等耗时逻辑，那么 I/O 必须将这些请求分发到业务线程池中进行处理，以免阻塞 I/O 线程 </p><p> 那么哪些请求需要在 I/O 线程中执行，哪些又需要在业务线程池中执行呢？Dubbo 框架的做法值得借鉴，它给用户提供了多种选择，它一共提供了 5 种分发策略，如下表格所示 </p><table><thead><tr><th>策略类型</th><th>描述</th></tr></thead><tbody><tr><td>all</td><td>所有的请求、事件、心跳等都发送到业务线程池，也就是说Worker线程接收到事件后，会将事件提交到业务线程池中</td></tr><tr><td>connection</td><td>连接建立、断开事件放入队列排队执行，其他所有的消息都分发到业务线程池执行</td></tr><tr><td>direct</td><td>所有事件都在IO线程池中执行</td></tr><tr><td>execution</td><td>只有请求类的消息分发到业务线程池中执行，响应和其他事件消息直接在IO线程池中处理</td></tr><tr><td>message</td><td>只有请求响应消息被分发到业务线程池中执行，其他事件消息都在IO线程池中执行</td></tr></tbody></table><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>服务提供者和服务消费者多实例的，如何保证服务提供者的所有节点的负载均衡呢。主流的方法有以下几种：</p><p> <strong>Round-Robin 轮询</strong>。 </p><p> <strong>Weighted Round-Robin 权重轮询</strong> </p><p> <strong>Least Connections 最少连接数</strong> </p><p> <strong>Consistent Hash 一致性 Hash</strong>。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RPC服务框架架构&quot;&gt;&lt;a href=&quot;#RPC服务框架架构&quot; class=&quot;headerlink&quot; title=&quot;RPC服务框架架构&quot;&gt;&lt;/a&gt;RPC服务框架架构&lt;/h1&gt;&lt;img src=&quot;/2023/09/03/castile-rpc%E6%A1%86%E6</summary>
      
    
    
    
    <category term="RPC" scheme="https://castile.github.io/categories/RPC/"/>
    
    
    <category term="Netty" scheme="https://castile.github.io/tags/Netty/"/>
    
    <category term="rpc" scheme="https://castile.github.io/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>算子链</title>
    <link href="https://castile.github.io/2023/09/03/%E7%AE%97%E5%AD%90%E9%93%BE/"/>
    <id>https://castile.github.io/2023/09/03/%E7%AE%97%E5%AD%90%E9%93%BE/</id>
    <published>2023-09-03T06:26:27.000Z</published>
    <updated>2023-09-03T06:26:27.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并行子任务和并行度"><a href="#并行子任务和并行度" class="headerlink" title="并行子任务和并行度"></a>并行子任务和并行度</h2><p>在 Flink 执行过程中，每一个算子（operator）可以包含一个或多个子任务（operator subtask）， 这些子任务在不同的线程、不同的物理机或不同的容器中完全独立地执行 </p><p> <strong>一个特定算子的子任务（subtask）的个数被称之为其并行度（parallelism）。</strong> </p><p>包含并行子任务的数据流，就是<strong>并行数据流</strong>，它需要多个分区（stream partition）来分配并行任 </p><h2 id="算子间的数据传输"><a href="#算子间的数据传输" class="headerlink" title="算子间的数据传输"></a>算子间的数据传输</h2><img src="/2023/09/03/%E7%AE%97%E5%AD%90%E9%93%BE/1693722079994.png" class width="1693722079994"><p>一个数据流在算子之间传输数据的形式可以是一对一（one-to-one）的直 通 (forwarding)模式，也可以是打乱的重分区（redistributing）模式，具体是哪一种形式，取决 于算子的种类。</p><p> （1）一对一（One-to-one，forwarding） </p><p>数据流维护着分区以及元素的顺序。比如图中的 source 和 map 算子，source 算子读取数据之后，可以直接发送给 map 算子做处理，它们之间不需要重新分区，也不需要 调整数据的顺序。这就意味着 map 算子的子任务，看到的元素个数和顺序跟 source 算子的子 任务产生的完全一样，保证着“一对一”的关系。map、filter、flatMap 等算子都是这种 one-to-one 的对应关系 </p><p> （2）重分区（Redistributing） </p><p>在这种模式下，数据流的分区会发生改变。比图中的 map 和后面的 keyBy/window 算子之 间（这里的 keyBy 是数据传输算子，后面的 window、apply 方法共同构成了 window 算子）, 以及 keyBy/window 算子和 Sink 算子之间，都是这样的关系。</p><h2 id="合并算子链"><a href="#合并算子链" class="headerlink" title="合并算子链"></a>合并算子链</h2><p>在 Flink 中，并行度相同的一对一（one to one）算子操作，可以直接链接在一起形成一个 “大”的任务（task），这样原来的算子就成为了真正任务里的一部分 </p><p>每个 task  会被一个线程执行。这样的技术被称为“算子链”（Operator Chain）。 </p><img src="/2023/09/03/%E7%AE%97%E5%AD%90%E9%93%BE/1693722193555.png" class width="1693722193555"><p>Source 和 map 之间满足了算子链的要求，所以可以直接合并 在一起，形成了一个任务；因为并行度为 2，所以合并后的任务也有两个并行子任务。这样， 这个数据流图所表示的作业最终会有 5 个任务，由 5 个线程并行执行 </p><p> <strong>将算子链接成 task 是非常有效的优 化：可以减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量。</strong> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;并行子任务和并行度&quot;&gt;&lt;a href=&quot;#并行子任务和并行度&quot; class=&quot;headerlink&quot; title=&quot;并行子任务和并行度&quot;&gt;&lt;/a&gt;并行子任务和并行度&lt;/h2&gt;&lt;p&gt;在 Flink 执行过程中，每一个算子（operator）可以包含一个或多个子任务（</summary>
      
    
    
    
    <category term="Flink" scheme="https://castile.github.io/categories/Flink/"/>
    
    
    <category term="Flink" scheme="https://castile.github.io/tags/Flink/"/>
    
    <category term="Operator Chain" scheme="https://castile.github.io/tags/Operator-Chain/"/>
    
  </entry>
  
  <entry>
    <title>任务和任务槽Slot</title>
    <link href="https://castile.github.io/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/"/>
    <id>https://castile.github.io/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/</id>
    <published>2023-09-03T06:16:45.000Z</published>
    <updated>2023-09-03T06:16:45.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="任务槽-（Task-Slots）"><a href="#任务槽-（Task-Slots）" class="headerlink" title="任务槽 （Task Slots）"></a>任务槽 （Task Slots）</h1><p>Flink 中每一个 worker(也就是 TaskManager)都是一个 JVM 进程，它可 6以启动多个独立的线程，来并行执行多个子任务（subtask）。</p><p>任务槽（task slot）其实表示了 TaskManager 拥有计算资源的一个固定大小的子集。 这些资源就是用来独立执行一个子任务的 </p><img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720134334.png" class width="1693720134334"><p>假如一个 TaskManager 有三个 slot，那么它会将管理的内存平均分成三份，每个 slot 独自 占据一份。这样一来，我们在 slot 上执行一个子任务时，相当于划定了一块内存“专款专用”，   就不需要跟来自其他作业的任务去竞争内存资源了。所以现在我们只要 2 个 TaskManager，就 可以并行处理分配好的 5 个任务了。</p><p>slot 目前仅仅用来<strong>隔离内存</strong>，不会涉及 CPU 的隔离。在具体应用时，可 以将 slot 数量配置为机器的 CPU 核心数，尽量避免不同任务之间对 CPU 的竞争。这也是开发 环境默认并行度设为机器 CPU 数量的原因 。</p><h3 id="任务对任务槽的共享"><a href="#任务对任务槽的共享" class="headerlink" title="任务对任务槽的共享"></a>任务对任务槽的共享</h3><img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720264738.png" class width="1693720264738"><p>默认情况下，Flink 是允许子任务共享 slot 的。 只要属于同一个作业，那么对于不同任务节点的并行子任务，就可以放到同一个 slot 上执行。</p><p>每个任务节点的并行子任务一字排开，占据不同的 slot；而不同 的任务节点的子任务可以共享 slot。一个 slot 中，可以将程序处理的所有任务都放在这里执行， 我们把它叫作保存了整个作业的运行管道（pipeline）。 </p><p> 我们知道，一个 slot 对应了一组独立的计算资源。在之前不做共享的时候，每个任务都平 等地占据了一个 slot，但其实不同的任务对资源的占用是不同的。例如这里的前两个任务， source/map 尽管是两个算子合并算子链得到的，但它只是基本的数据读取和简单转换，计算耗 时极短，一般也不需要太大的内存空间；而 window 算子所做的窗口操作，往往会涉及大量的 数据、状态存储和计算，我们一般把这类任务叫作“资源密集型”（intensive）任务。当它们 被平等地分配到独立的 slot 上时，实际运行我们就会发现，大量数据到来时 source/map 和 sink 任务很快就可以完成，但 window 任务却耗时很久；于是下游的 sink 任务占据的 slot 就会等待 闲置，而上游的 source/map 任务受限于下游的处理能力，也会在快速处理完一部分数据后阻 塞对应的资源开始等待（相当于处理<strong>背压</strong>）。这样资源的利用就出现了极大的不平衡，“忙的忙 死，闲的闲死”。 解决这一问题的思路就是允许 slot 共享。当我们将资源密集型和非密集型的任务同时放到 一个 slot 中，它们就可以自行分配对资源占用的比例，从而保证最重的活平均分配给所有的 TaskManager。 </p><p>同一个任务节点的并行子任务是不能共享 slot 的，所以允许 slot 共享之后，运行作业所需的 slot 数量正好就是作业中所有算子并行度的最大值。这样一来，我们考虑当前集群需 要配置多少 slot 资源时，就不需要再去详细计算一个作业总共包含多少个并行子任务了，只看 最大的并行度就够了。  </p><h3 id="任务槽和并行度的关系"><a href="#任务槽和并行度的关系" class="headerlink" title="任务槽和并行度的关系"></a>任务槽和并行度的关系</h3><p>假设一共有 3 个 TaskManager，每一个 TaskManager 中的 slot 数量设置为 3 个，那么一共有 9 个 task slot，表示集群最多能并行执行 9 个任务 </p><img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720541867.png" class width="1693720541867"><p>而我们定义 WordCount 程序的处理操作是四个转换算子： </p><blockquote><p>source→ flatMap→ reduce→ sink</p></blockquote><p>当所有算子并行度相同时，容易看出 source 和 flatMap 可以合并算子链，于是最终有三个任务节点.。如果我们没有任何并行度设置，而配置文件中默认 parallelism.default=1，那么程序运行的 默认并行度为 1，总共有 3 个任务。由于不同算子的任务可以共享任务槽，所以最终占用的 slot 只有 1 个。9 个 slot 只用了 1 个，有 8 个空闲。</p><img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720650260.png" class width="1693720650260"><p>设置并行度为 2，那么总共有 6 个任务，共享任 务槽之后会占用 2 个 slot：</p><img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720782089.png" class width="1693720782089"><p>把并行度设置为 9，这样所有 27 个任务就会完全占用 9 个 slot。 这是当前集群资源下能执行的最大并行度，计算资源得到了充分的利用</p><img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720792252.png" class width="1693720792252"><p> 再考虑对于某个算子单独设置并行度的场景。 考虑到输出可能是写入 文件，那会希望不要并行写入多个文件，就需要设置 sink 算子的并行度为 1。这时其他的算子 并行度依然为 9，所以总共会有 19 个子任务。根据 slot 共享的原则，它们最终还是会占用全 部的 9 个 slot，而 sink 任务只在其中一个 slot 上执行</p><img src="/2023/09/03/%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BDSlot/1693720801175.png" class width="1693720801175"><p>整个流处理程序的并行度，就应该是所有算子并行度中最大的那个， 这代表了运行程序需要的 slot 数量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;任务槽-（Task-Slots）&quot;&gt;&lt;a href=&quot;#任务槽-（Task-Slots）&quot; class=&quot;headerlink&quot; title=&quot;任务槽 （Task Slots）&quot;&gt;&lt;/a&gt;任务槽 （Task Slots）&lt;/h1&gt;&lt;p&gt;Flink 中每一个 wor</summary>
      
    
    
    
    <category term="Flink" scheme="https://castile.github.io/categories/Flink/"/>
    
    
    <category term="Flink" scheme="https://castile.github.io/tags/Flink/"/>
    
    <category term="Slots" scheme="https://castile.github.io/tags/Slots/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计04-限界上下文</title>
    <link href="https://castile.github.io/2023/06/06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A104-%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://castile.github.io/2023/06/06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A104-%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2023-06-06T15:30:14.000Z</published>
    <updated>2023-06-06T15:30:14.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、-限界上下文的含义"><a href="#1、-限界上下文的含义" class="headerlink" title="1、 限界上下文的含义"></a>1、 限界上下文的含义</h2><p>限界上下文(Bounded Context)， <strong>Context</strong> 表现了业务流程的场景片段。整个业务流程由诸多具有时序的活动组成，随着流程的进行，不同的活动需要不同的角色参与，并导致上下文因为某个活动的产生随之发生切换。因而，<strong>上下文（Context）其实是动态的业务流程被边界（Bounded）静态切分的产物</strong>。 </p><p> 一个复杂系统的领域驱动设计，就是以子域为中心进行领域建模，绘制出一张一张的领域模型设计，然后以此作为基础指导程序设计。这一张一张的领域模型设计，称为“<strong>限界上下文</strong>”（Context Bounds，CB）。  根据<strong>业务相关性</strong>、<strong>耦合的强弱程度</strong>、<strong>分离的关注点</strong>对这些活动进行归类，找到不同类别之间存在的边界，这就是<strong>限界上下文</strong>的含义。<strong>上下文（Context）是业务目标，限界（Bounded）则是保护和隔离上下文的边界，避免业务目标的不单一而带来的混乱与概念的不一致。</strong> </p><h2 id="2、限界上下文的价值"><a href="#2、限界上下文的价值" class="headerlink" title="2、限界上下文的价值"></a>2、限界上下文的价值</h2><p>观察角度的不同，限界上下文划定的边界也有所不同。大体可以分为如下三个方面：</p><ul><li><strong>领域逻辑层面</strong>：限界上下文确定了领域模型的业务边界，维护了模型的完整性与一致性，从而降低系统的业务复杂度。</li><li><strong>团队合作层面</strong>：限界上下文确定了开发团队的工作边界，建立了团队之间的合作模式，避免团队之间的沟通变得混乱，从而降低系统的管理复杂度。</li><li><strong>技术实现层面</strong>：限界上下文确定了系统架构的应用边界，保证了系统层和上下文领域层各自的一致性，建立了上下文之间的集成方式，从而降低系统的技术复杂度。</li></ul><p>这三种边界体现了<strong>限界上下文对不同边界的控制力</strong>。业务边界是对领域模型的控制，工作边界是对开发协作的控制，应用边界是对技术风险的控制。引入限界上下文的目的，其实<strong>不在于如何划分边界，而在于如何控制边界</strong>。 </p><p>  EventStorming 创始人 Alberto Brandolini  对限界上下文的理解： bounded context are a mean of safety（限界上下文意味着安全），如何理解安全呢？</p><p>他的意思是：  being in control and no surprise。</p><blockquote><p> Surprise leads to stress and stress leads to no learning, just hard work. （出乎意料的惊讶会导致压力，而压力就会使得团队疲于加班，缺少学习。） </p></blockquote><p>其实限界上下文并不是大多数人理解的那样，是模块、服务、组件或者子系统，而是你对领域模型、团队合作以及技术风险的<strong>控制</strong>。大领域的模型切割成一个一个小的领域模型是很重要的， <strong>更小的模型为我们的软件设计和开发带来了更多的好处，它使得团队能够根据自己的设计和开发职责确定更为明确的</strong>工作边界 。</p><p>小的模型也为项目带来了更好的可维护性：由于上下文由边界确定，因此对其的修改也不会给整个模型的其他部分造成影响。显然，通过限界上下文对领域模型进行分解，就能保证在其边界内创建的模型<strong>内聚性更高</strong>，在<strong>边界隔离</strong>下，受到变化的影响也更小，反映为团队合作的工作边界，就更容易保证团队之间的沟通与协作。 </p><p>限界上下文是“<strong>分而治之</strong>”架构原则的体现，我们引入它的目的其实为了控制（应对）软件的复杂度，它并非某种固定的设计单元，我们不能说它就是模块、服务或组件，而是通过它来帮助我们做出高内聚低耦合的设计。</p><p>可以把限界上下文看成是一个“自治”的单元。 所谓“自治”就是满足四个特征：最小完备、稳定空间、自我履行、独立进化。如下图所示的自治单元就是限界上下文，映射到编码实现，则<strong>可能</strong>是模块、组件或服务： </p><img src="/2023/06/06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A104-%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/1685462880155.png" class width="1685462880155"><p> <strong>最小完备</strong>是实现“自治”的基本条件。自治单元的职责是完整的，不需要依赖别的单元的功能。最小完备是指不要将不必要的职责被错误地添加到该自治单元内。</p><p><strong>自我履行</strong>表示自治单元自身决定需要做什么， 从拟人的角度来思考，就是这些自治单元能够对外部请求做出符合自身利益的明智判断，是否应该履行该职责，由限界上下文拥有的信息来决定。 例如，在当订单上下文履行了验证订单的职责之后，需要执行支付活动时，由于与支付相关的业务行为要操作的信息已经超出了订单上下文的范畴，就应该将该职责转移到支付上下文。自我履行其实意味着对知识的掌握，为避免风险，你要履行的职责一定是你掌握的知识范畴之内。 </p><p><strong>稳定空间</strong>指的是减少外界变化对限界上下文内部的影响。  稳定空间符合<strong>开放封闭原则（OCP）</strong>，即对修改是封闭的，对扩展是开放的，该原则其实体现了一个单元的封闭空间与开放空间。封闭空间体现为对细节的封装与隐藏，开放空间体现为对共性特征的抽象与统一，二者共同确保了整个空间的稳定。</p><p><strong>独立进化</strong>与稳定空间刚好相反，指的是减少限界上下文的变化对外界的影响。 如果借用限界上下文的上下游关系来阐释，则<strong>稳定空间</strong>寓意下游限界上下文，无论上游怎么变，我自岿然不动；<strong>独立进化</strong>寓意上游限界上下文，无论下游有多少，我凌寒独自开。实现上看，要做到独立进化，就必须保证对外公开接口的稳定性，因为这些接口往往被众多消费者使用，一旦修改，就会牵一发而动全身。一个独立进化的限界上下文，需要接口设计良好，符合标准规范，并在版本上考虑了兼容与演化。 </p><p>这四个要素是<strong>高内聚低耦合</strong>思想的体现。我们需要根据业务关注点和技术关注点，尽可能将强相关性的内容放到同一个限界上下文中，同时降低限界上下文之间的耦合。对于整个系统架构而言，不同的限界上下文可以采用不同的架构风格与技术决策，而在每个限界上下文内部保持自己的技术独立性与一致性。由于限界上下文边界对技术实现的隔离，不同限界上下文内部实现的多样性并不会影响整体架构的一致性。</p><h2 id="3、-限界上下文分离了业务边界"><a href="#3、-限界上下文分离了业务边界" class="headerlink" title="3、 限界上下文分离了业务边界"></a>3、 限界上下文分离了业务边界</h2><p>引入限界上下文的目的，不在于如何划分，而在于如何控制边界。  可以说，<strong>限界上下文是连接问题域与解决方案域的重要桥梁</strong>。 </p><p>限界上下文用于区分领域边界，我们在理解领域模型时，是基于当前所在的上下文作为概念语境的， 这样的设计既保证了限界上下文之间的松散耦合，又能够维持限界上下文各自领域模型的一致性，此时的限界上下文成为了保障领域模型不受污染的边界屏障。 </p><h2 id="4、-限界上下文明确了工作边界"><a href="#4、-限界上下文明确了工作边界" class="headerlink" title="4、 限界上下文明确了工作边界"></a>4、 限界上下文明确了工作边界</h2><p> 一个理想的开发团队规模最好能符合亚马逊公司提出的“Two-Pizza Teams”，即 <strong>2PTs</strong> 规则，该规则认为“让团队保持在两个披萨能让成员吃饱的小规模”，大体而言，就是将团队成员人数控制在 7~10 人左右。为何要保证这样的规模呢？因为小团队能够更有效保证有效的沟通。</p><p> 传统的“组件团队”强调的是专业技能与功能重用，例如，熟练掌握数据库开发技能的成员组建一个数据库团队，深谙前端框架的成员组建一个前端开发团队。这种遵循“专业的事情交给专业的人去做”原则的团队组建模式，可以更好地发挥每个人的技能特长，然而牺牲的却是团队成员业务知识的缺失，客户价值的漠视。这种团队组建模式也加大了团队之间的沟通成本，导致系统的整体功能无法持续和频繁的集成。</p><p>特性团队， 是一个<strong>端对端的开发垂直细分领域的跨职能团队</strong>，它将需求分析、架构设计、开发测试等多个角色糅合在一起，专注于领域逻辑，实现该领域特性的完整的端对端开发。 </p><img src="/2023/06/06/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A104-%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/1686065089311.png" class width="1686065089311"><p>特性团队专注的领域特性，是与领域驱动设计中限界上下文对应的领域是相对应的。当我们确定了限界上下文时，其实也就等同于确定了特性团队的工作边界，确定了限界上下文之间的关系，也就意味着确定了特性团队之间的合作模式；反之亦然。之所以如此，则是因为<strong>康威定律（Conway’s Law）</strong>为我们提供了理论支持 </p><p><strong>康威定律</strong>认为：“任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。” <strong>在康威定律中起到关键杠杆作用的是沟通成本</strong>。如果同一个限界上下文的工作交给了两个不同的团队分工完成，为了合力解决问题，就必然需要这两个团队进行密切的沟通。然而，团队间的沟通成本显然要高于团队内的沟通成本，为了降低日趋增高的成本，就需要重新划分团队。反过来，如果让同一个团队分头做两个限界上下文的工作，则会因为工作的弱相关性带来自然而然的团队隔离。 </p><h2 id="5、-限界上下文封装了应用边界"><a href="#5、-限界上下文封装了应用边界" class="headerlink" title="5、 限界上下文封装了应用边界"></a>5、 限界上下文封装了应用边界</h2><p>在划分上下文的时候，不能值满足于业务边界的确立，还需要从控制技术复杂度的角度来考虑技术实现。高并发系统，功能重用，实时性，第三服务集成，遗留系统等案例从技术层面为系统划分边界，这种边界也是由限界上下文完成的，以形成对技术实现的隔离，避免不同的技术方案选择互相干扰导致架构混乱。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、-限界上下文的含义&quot;&gt;&lt;a href=&quot;#1、-限界上下文的含义&quot; class=&quot;headerlink&quot; title=&quot;1、 限界上下文的含义&quot;&gt;&lt;/a&gt;1、 限界上下文的含义&lt;/h2&gt;&lt;p&gt;限界上下文(Bounded Context)， &lt;strong&gt;Co</summary>
      
    
    
    
    <category term="领域驱动设计" scheme="https://castile.github.io/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="DDD" scheme="https://castile.github.io/tags/DDD/"/>
    
    <category term="领域驱动设计" scheme="https://castile.github.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="限界上下文" scheme="https://castile.github.io/tags/%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计03-应用领域场景分析提炼领域知识</title>
    <link href="https://castile.github.io/2023/05/25/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A103-%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%E6%8F%90%E7%82%BC%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/"/>
    <id>https://castile.github.io/2023/05/25/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A103-%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%E6%8F%90%E7%82%BC%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/</id>
    <published>2023-05-25T15:24:03.000Z</published>
    <updated>2023-06-06T15:30:39.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="领域场景分析的-6W-模型"><a href="#领域场景分析的-6W-模型" class="headerlink" title="领域场景分析的 6W 模型"></a>领域场景分析的 6W 模型</h2><p> 组成场景的要素常常被称之为 <strong>6W 模型</strong>，即描写场景的过程必须包含 <strong>W</strong>ho、<strong>W</strong>hat、<strong>W</strong>hy、<strong>W</strong>here、<strong>W</strong>hen 与 ho<strong>W</strong> 这六个要素。</p><p> 在 6W 模型中，可以将领域功能划分为三个层次，即业务价值、业务功能和业务实现。</p><p><img src="/2023/05/25/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A103-%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%E6%8F%90%E7%82%BC%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/1685026515876.png" alt="1685026515876"></p><p>在分析一个需求的时候，要建立场景，识别该场景中的用户角色（Who），通过分析改用户的特征与属性 来辨别该角色在整个场景中参与的活动。这意味着我们需要明确业务功能（What），思考这一功能给该角色能够带来什么样的业务价值（Why）。在不同场景中同一个用户可能代表不同的角色，比如在订单系统中，角色就是买家；在评论系统中，角色变成了评论者。</p><p> 在利用场景进行建模时，还要充分考虑场景的边界，即 6W 模型中的 Where。例如，在“下订单”的案例中，验证商品库存量的业务实现需要调用库存提供的接口，该功能属于下订单场景的边界之外。领域驱动设计引入了<strong>限界上下文（Bounded Context）</strong>来解决这一问题。 </p><p> 业务场景分析的 6W 模型给出了具有指导意义的约束，要求我们提炼的领域知识必须具备模型的六个要素。 6W 模型也是对领域逻辑的一种检验，如果提炼出来的领域逻辑缺乏部分要素，就有可能忽略一些重要的领域概念、规则与约束。这种缺失会对后续的领域建模直接产生影响。</p><h2 id="领域场景分析的方法"><a href="#领域场景分析的方法" class="headerlink" title="领域场景分析的方法"></a>领域场景分析的方法</h2><p> 如果将 6W 模型看做是领域分析的抽象，那么这些领域分析方法就是对 6W 模型各种不同的实现。 这些模式主要有：</p><ul><li>用例（Use Case）</li><li>用户故事（User Story）</li><li>测试驱动开发（TDD）</li></ul><p>用例尤其是用例图的抽象能力更强，更擅长于对系统整体需求进行场景分析；用户故事提供了场景分析的固定模式，善于表达具体场景的业务细节；测试驱动开发则强调对业务的分解，利用编写测试用例的形式驱动领域建模，即使不采用测试先行，让开发者转换为调用者角度去思考领域对象及行为，也是一种很好的建模思想与方法。 </p><p>在提炼领域知识的过程中，我们可以将这三种领域场景分析方法结合起来运用，在不同层次的领域场景中选择不同的场景分析方法，才不至于好高骛远，缺乏对细节的把控，也不至于一叶障目，只见树木不见森林。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;领域场景分析的-6W-模型&quot;&gt;&lt;a href=&quot;#领域场景分析的-6W-模型&quot; class=&quot;headerlink&quot; title=&quot;领域场景分析的 6W 模型&quot;&gt;&lt;/a&gt;领域场景分析的 6W 模型&lt;/h2&gt;&lt;p&gt; 组成场景的要素常常被称之为 &lt;strong&gt;6W </summary>
      
    
    
    
    <category term="领域驱动设计" scheme="https://castile.github.io/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="DDD" scheme="https://castile.github.io/tags/DDD/"/>
    
    <category term="领域驱动设计" scheme="https://castile.github.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计02-应对软件的复杂性</title>
    <link href="https://castile.github.io/2023/05/18/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A102-%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7/"/>
    <id>https://castile.github.io/2023/05/18/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A102-%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7/</id>
    <published>2023-05-17T16:22:14.000Z</published>
    <updated>2023-05-21T02:51:15.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应对软件的复杂性"><a href="#应对软件的复杂性" class="headerlink" title="应对软件的复杂性"></a>应对软件的复杂性</h1><p>需求引起的软件复杂度包含了业务复杂度和技术复杂度：</p><p><strong>技术复杂度来自需求的质量属性</strong>，诸如安全、高性能、高并发、高可用性等需求，为软件设计带来了极大的挑战，让人痛苦的是这些因素彼此之间可能又互相矛盾、互相影响。</p><p> <strong>业务复杂度对应了客户的业务需求</strong>，因而这种复杂度往往会随着需求规模的增大而增加。由于需求不可能做到完全独立，一旦规模扩大到一定程度，不仅产生了功能数量的增加，还会因为功能互相之间的依赖与影响使得这种复杂度产生叠加，进而影响到整个系统的质量属性，比如系统的可维护性与可扩展性。 </p><p> <strong>技术复杂度与业务复杂度并非完全独立，二者混合在一起产生的化合作用更让系统的复杂度变得不可预期，难以掌控</strong>。 </p><h2 id="1、隔离业务复杂度与技术复杂度"><a href="#1、隔离业务复杂度与技术复杂度" class="headerlink" title="1、隔离业务复杂度与技术复杂度"></a>1、隔离业务复杂度与技术复杂度</h2><p> 要避免业务逻辑的复杂度与技术实现的复杂度混淆在一起，<strong>首要任务就是确定业务逻辑与技术实现的边界，从而隔离各自的复杂度</strong>。</p><p> 例如，在电商的领域逻辑中，订单业务关注的业务规则包括验证订单有效性、计算订单总额、提交和审核订单的流程等；技术关注点则从实现层面保障这些业务能够正确地完成，包括确保分布式系统之间的数据一致性，确保服务之间通信的正确性等。</p><p> 业务逻辑并不关心技术是如何实现的，无论采用何种技术，只要业务需求不变，业务规则就不会发生变化。换言之，<strong>在理想状态下，我们应该保证业务规则与技术实现是正交的</strong>。 </p><p> 领域驱动设计通过<strong>分层架构</strong>与<strong>六边形架构</strong>来确保业务逻辑与技术实现的隔离 </p><h2 id="2、分层架构的关注点分离"><a href="#2、分层架构的关注点分离" class="headerlink" title="2、分层架构的关注点分离"></a>2、分层架构的关注点分离</h2><p> 分层架构遵循了“关注点分离”原则，将属于业务逻辑的关注点放到领域层（Domain Layer）中，而将支撑业务逻辑的技术实现放到基础设施层（Infrastructure Layer）中。同时，领域驱动设计又颇具创见的引入了应用层（Application Layer），应用层扮演了双重角色。一方面它作为业务逻辑的外观（Facade），暴露了能够体现业务用例的应用服务接口；另一方面它又是业务逻辑与技术实现的粘合剂，实现二者之间的协作。 </p><p>下图展现的就是一个典型的领域驱动设计分层架构，蓝色区域的内容与业务逻辑有关，灰色区域的内容与技术实现有关，二者泾渭分明，然后汇合在应用层。应用层确定了业务逻辑与技术实现的边界，通过直接依赖或者依赖注入（DI，Dependency Injection）的方式将二者结合起来： </p><img src="/2023/05/18/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A102-%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7/1684339034063.png" class width="1684339034063"><h2 id="3、六边形架构的内外分离"><a href="#3、六边形架构的内外分离" class="headerlink" title="3、六边形架构的内外分离"></a>3、六边形架构的内外分离</h2><p> 由 Cockburn 提出的六边形架构则以“内外分离”的方式，更加清晰地勾勒出了业务逻辑与技术实现的边界，且将业务逻辑放在了架构的核心位置。这种架构模式改变了我们观察系统架构的视角：</p><img src="/2023/05/18/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A102-%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7/1684339190795.png" class width="1684339190795"><p> 体现业务逻辑的应用层与领域层处于六边形架构的<strong>内核</strong>，并通过内部的六边形边界与基础设施的模块隔离开。当我们在进行软件开发时，只要恪守架构上的六边形边界，则不会让技术实现的复杂度污染到业务逻辑，保证了领域的整洁。边界还隔离了变化产生的影响。如果我们在领域层或应用层抽象了技术实现的接口，再通过依赖注入将控制的方向倒转，业务内核就会变得更加的稳定，不会因为技术选型或其他决策的变化而导致领域代码的修改。 </p><h2 id="4、限界上下文的分而治之"><a href="#4、限界上下文的分而治之" class="headerlink" title="4、限界上下文的分而治之"></a>4、限界上下文的分而治之</h2><p>面对一个庞大的问题域，可以划分一些子系统，这些子系统内部也可以进行分层架构。不同子系统之间的抽象层次是一致的，这种概念在DDD中称之为“限界上下文（Bounded Context）”。</p><p>通过限界上下文“分而治之”的思想对问题域进行分解，有效地控制了问题域的规模，进而控制了整个系统的规模。</p><p> 限界上下文对整个系统进行了划分，在将一个大系统拆分为一个个小系统后，我们再利用分层架构与六边形架构思想对其进行逻辑分层，以确保业务逻辑与技术实现的隔离，其设计会变得更易于把控，系统的架构也会变得更加清晰。 </p><p>在一个复杂系统中，可以将识别出来的限界上下文定义为微服务，并对外公开REST服务接口。</p><img src="/2023/05/18/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A102-%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7/1684635011835.png" class width="1684635011835"><p> UI Applications 是一个薄薄的展现层，它会调用后端的 RESTful 服务，也使得服务在保证接口不变的前提下能够单独演化。每个服务都是独立的，可以单独部署，因而可以针对服务建立单独的代码库和对应的特性团队（Feature Team）。服务的重用性和可扩展性也有了更好的保障，服务与 UI 之间的集成变得更简单，整个架构会更加清晰。 </p><h2 id="5、领域模型对领域知识的抽象"><a href="#5、领域模型对领域知识的抽象" class="headerlink" title="5、领域模型对领域知识的抽象"></a>5、领域模型对领域知识的抽象</h2><p>以一个软件项目管理流程来举例子。在一个团队中，使用的软件开发流程大致有如下几类：</p><p>瀑布式开发： 需求、分析、设计、编码、测试、验收 </p><p>RUP（ Rational Unified Process 统一软件开发过程）： 先启阶段（Inception）、细化阶段（Elaboration）、构造阶段（Construction）与交付阶段（Transition）。 每个阶段可以包含一到多个迭代，每个迭代有不同的工作，如业务建模、分析设计、配置与变更管理 </p><p> XP（ Extreme Programming ）： 极限编程作为一种敏捷方法，迭代的增量式开发。先做预研（ Architectual Spike，又被译为架构穿刺 ），初始方案确定后就可以进入每次小版本的交付（Release Planning）。 每个小版本交付又被划分为多个周期相同的迭代。在迭代过程中，要求执行一些必须的活动，如编写用户故事、故事点估算、验收测试等。</p><p> Scrum：确定系统待办项（Product Backlog）、指定发布计划和组件团队、Sprint迭代。 Sprint 迭代过程是一个固定时长的项目过程，在这个过程中，整个团队需要召开计划会议、每日站会（Daliy Scrum）、评审会议（Sprint Review）和回顾会议（Sprint Retrospective）。</p><h3 id="领域分析"><a href="#领域分析" class="headerlink" title="领域分析"></a>领域分析</h3><p> 领域建模就是要从这些纷繁复杂的领域逻辑中寻找到能够表示项目管理领域的概念，并利用面向对象建模范式或其他范式对概念进行抽象，并确定它们之间的关系。</p><p>上面说的几种开发流程在概念上会有差别，比如瀑布模式有六个节阶段，但是没有发布、迭代这些概念。RUP有阶段，有迭代，但是没有发布。Scrum又为迭代引入了Sprint概念。</p><p>除了业务概念外，他们的业务规则也会有不一样的地方。</p><ul><li>首先，从项目管理系统的角度看，无论针对何种项目管理流程，我们的主题需求是不变的，就是要为这些管理流程制定软件开发计划（Plan）</li><li> 计划可以由多个阶段（Phase）组成 </li><li> 阶段（Phase）包含了发布（Release）</li><li> 每个发布又包含了一到多个迭代（Iteration）</li><li> 每个迭代可以开展多种不同的活动（Activity）</li><li> 对于计划而言，我们还需要跟踪任务（Task） </li></ul><p>所以我们可以根据上述分析提炼出统一的领域模型：</p><img src="/2023/05/18/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A102-%E5%BA%94%E5%AF%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7/1684637274676.png" class width="1684637274676"><p> 项目管理者更加方便地制定项目计划，产品经理提出了计划模板功能。当管理者选择对应的项目管理生命周期类型后，系统会自动创建满足其规则的初始计划。 在模型中，LifeCycle Specification 是一个隐含的概念，遵循领域驱动设计提出的规格（Specification）模式，封装了项目开发生命周期的约束规则。</p><p>领域模型以可视化的方式清晰地表达了业务含义， 我们可以根据这个模型来指导后面的程序设计与编码实现，当需求有变更的时候可以根据模型进行更新。同时，领域建模可以很好在团队之间传递知识， 有利于让开发人员从纷繁复杂的业务中解脱出来，从而可以在一定程度上控制业务的复杂度对我们软件交付的影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;应对软件的复杂性&quot;&gt;&lt;a href=&quot;#应对软件的复杂性&quot; class=&quot;headerlink&quot; title=&quot;应对软件的复杂性&quot;&gt;&lt;/a&gt;应对软件的复杂性&lt;/h1&gt;&lt;p&gt;需求引起的软件复杂度包含了业务复杂度和技术复杂度：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术复杂度</summary>
      
    
    
    
    <category term="领域驱动设计" scheme="https://castile.github.io/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="DDD" scheme="https://castile.github.io/tags/DDD/"/>
    
    <category term="领域驱动设计" scheme="https://castile.github.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="软件复杂性" scheme="https://castile.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%A4%8D%E6%9D%82%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计01-概览</title>
    <link href="https://castile.github.io/2023/05/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A101-%E6%A6%82%E8%A7%88/"/>
    <id>https://castile.github.io/2023/05/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A101-%E6%A6%82%E8%A7%88/</id>
    <published>2023-05-17T15:09:03.000Z</published>
    <updated>2023-05-17T15:09:03.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="领域驱动设计概览"><a href="#领域驱动设计概览" class="headerlink" title="领域驱动设计概览"></a>领域驱动设计概览</h1><p>领域驱动设计是一种面向对象的建模方法。</p><p> <strong>将要解决的业务概念和业务规则转换为软件系统中的类型以及类型的属性与行为，通过合理运用面向对象的封装、继承和多态等设计要素</strong>，降低或隐藏整个系统的业务复杂性，并使得系统具有更好的扩展性，应对纷繁多变的现实业务问题。 </p><p> 领域驱动设计的提出，是<strong>设计观念的转变，蕴含了全新的设计思想、设计原则与设计过程</strong>。 </p><h2 id="领域驱动设计过程"><a href="#领域驱动设计过程" class="headerlink" title="领域驱动设计过程"></a>领域驱动设计过程</h2><p> 领域驱动设计强调<strong>领域模型</strong>的重要性，并通过模型驱动设计来保障领域模型与程序设计的一致。从业务需求中提炼出统一语言（Ubiquitous Language），再基于统一语言建立领域模型；这个领域模型会指导着程序设计以及编码实现；最后，又通过重构来发现隐式概念，并运用设计模式改进设计与开发质量 </p><img src="/2023/05/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A101-%E6%A6%82%E8%A7%88/1684334923286.png" class width="1684334923286"><p> 这个过程是一个覆盖<strong>软件全生命周期</strong>的设计闭环，每个环节的输出都可以作为下一个环节的输入，而在其中扮演重要指导作用的则是“领域模型” 。这是一个 螺旋式的迭代设计过程。</p><p> 在为问题域寻求解决方案时，需要从<strong>宏观层次</strong>划分不同业务关注点的<strong>子领域</strong>，然后再深入到子领域中从微观层次对领域进行建模。<strong>宏观层次是战略的层面，微观层次是战术的层面</strong>，只有将战略设计与战术设计结合起来，才是完整的领域驱动设计。 </p><h3 id="战略设计阶段"><a href="#战略设计阶段" class="headerlink" title="战略设计阶段"></a>战略设计阶段</h3><p> 领域驱动设计的战略设计阶段是从下面两个方面来考量的 ：</p><ul><li><p>问题域方面：针对问题域，引入<strong>限界上下文（Bounded Context）和上下文映射（Context Map）对问题域进行合理的分解，识别出核心领域（Core Domain）与子领域（SubDomain）</strong>，并确定领域的边界以及它们之间的关系，维持模型的完整性。</p></li><li><p>架构方面：通过<strong>分层架构</strong>来隔离关注点，尤其是将领域实现独立出来，能够更利于领域模型的单一性与稳定性；引入<strong>六边形架构</strong>可以清晰地表达领域与技术基础设施的边界；CQRS 模式则分离了查询场景和命令场景，针对不同场景选择使用同步或异步操作，来提高架构的低延迟性与高并发能力。</p></li></ul><h3 id="战术设计阶段"><a href="#战术设计阶段" class="headerlink" title="战术设计阶段"></a>战术设计阶段</h3><p> 整个软件系统被分解为多个限界上下文（或领域）后，就可以分而治之，对每个限界上下文进行战术设计。领域驱动设计并不牵涉到技术层面的实现细节，在战术层面，它主要应对的是领域的复杂性。领域驱动设计用以表示模型的主要要素包括：</p><ul><li>值对象（Value Object）</li><li>实体（Entity）</li><li>领域服务（Domain Service）</li><li>领域事件（Domain Event）</li><li>资源库（Repository）</li><li>工厂（Factory）</li><li>聚合（Aggregate）</li><li>应用服务（Application Service）</li></ul><img src="/2023/05/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A101-%E6%A6%82%E8%A7%88/1684335677898.png" class width="1684335677898"><p> 领域驱动设计围绕着领域模型进行设计，通过<strong>分层架构（Layered Architecture）将领域独立出来。表示领域模型的对象包括：实体、值对象和领域服务</strong>，<strong>领域逻辑都应该封装在这些对象中</strong>。这一严格的设计原则可以避免业务逻辑渗透到领域层之外，导致技术实现与业务逻辑的混淆。在领域驱动设计的演进中，又引入了<strong>领域事件</strong>来丰富领域模型。 </p><p> <strong>聚合</strong>是一种边界，它可以封装一到多个<strong>实体</strong>与<strong>值对象</strong>，并维持该边界范围之内的业务完整性。在聚合中，至少包含一个实体，且只有实体才能作为<strong>聚合根（Aggregate Root）</strong>。注意，在领域驱动设计中，没有任何一个类是单独的聚合，因为聚合代表的是边界概念，而非领域概念。在极端情况下，一个聚合可能有且只有一个实体。 </p><p> <strong>工厂</strong>和<strong>资源库</strong>都是对领域对象生命周期的管理。前者负责领域对象的创建，往往用于封装复杂或者可能变化的创建逻辑；后者则负责从存放资源的位置（数据库、内存或者其他 Web 资源）获取、添加、删除或者修改领域对象。领域模型中的资源库不应该暴露访问领域对象的技术实现细节。 </p><img src="/2023/05/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A101-%E6%A6%82%E8%A7%88/1684335927676.png" class width="1684335927676">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;领域驱动设计概览&quot;&gt;&lt;a href=&quot;#领域驱动设计概览&quot; class=&quot;headerlink&quot; title=&quot;领域驱动设计概览&quot;&gt;&lt;/a&gt;领域驱动设计概览&lt;/h1&gt;&lt;p&gt;领域驱动设计是一种面向对象的建模方法。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;将要解决的业务概念和</summary>
      
    
    
    
    <category term="领域驱动设计" scheme="https://castile.github.io/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="DDD" scheme="https://castile.github.io/tags/DDD/"/>
    
    <category term="领域驱动设计" scheme="https://castile.github.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="战略设计" scheme="https://castile.github.io/tags/%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="战术设计" scheme="https://castile.github.io/tags/%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Flink之聚合算子</title>
    <link href="https://castile.github.io/2023/05/06/Flink%E4%B9%8B%E8%81%9A%E5%90%88%E7%AE%97%E5%AD%90/"/>
    <id>https://castile.github.io/2023/05/06/Flink%E4%B9%8B%E8%81%9A%E5%90%88%E7%AE%97%E5%AD%90/</id>
    <published>2023-05-05T16:11:56.000Z</published>
    <updated>2023-05-05T16:11:56.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚合算子"><a href="#聚合算子" class="headerlink" title="聚合算子"></a>聚合算子</h2><p> 我们往往需要对大量的数据进行统计或整合，从而提炼出更有用的 信息。比如要对每个词出现的频次进行叠加统计。这种操作，计算的结果不仅依赖当前数据，还跟之前的数据有关，相当于要把所有数据聚在一起进行汇总合并 ——这就是所谓的“聚合”（Aggregation），也对应着 MapReduce 中的 reduce 操作。  </p><h2 id="KeyBy"><a href="#KeyBy" class="headerlink" title="KeyBy"></a>KeyBy</h2><p> DataStream 是没有直接进行聚合的 API 的。因为我们对海量数据做聚合 肯定要进行分区并行处理，这样才能提高效率。所以在 Flink 中，要做聚合，需要先进行分区； 这个操作就是通过 keyBy 来完成的。</p><img src="/2023/05/06/Flink%E4%B9%8B%E8%81%9A%E5%90%88%E7%AE%97%E5%AD%90/1683215484651.png" class width="1683215484651"><p> 基于不同的 key，流中的数据将被分配到不同的分区中去，这样一来，所 有具有相同的 key 的数据，都将被发往同一个分区，那么下一步算子操作就将会在同一个 slot 中进行处理了。</p><img src="/2023/05/06/Flink%E4%B9%8B%E8%81%9A%E5%90%88%E7%AE%97%E5%AD%90/1683215525749.png" class width="1683215525749"><h2 id="简单聚合"><a href="#简单聚合" class="headerlink" title="简单聚合"></a>简单聚合</h2><p> 有了按键分区的数据流 KeyedStream，我们就可以基于它进行聚合操作了。Flink 为我们 内置实现了一些最基本、最简单的聚合 API，主要有以下几种： </p><p>⚫ sum()：在输入流上，对指定的字段做叠加求和的操作。 </p><p>⚫ min()：在输入流上，对指定的字段求最小值。 </p><p>⚫ max()：在输入流上，对指定的字段求最大值。 </p><p>⚫ minBy()：与 min()类似，在输入流上针对指定字段求最小值。不同的是，min()只计 算指定字段的最小值，其他字段会保留最初第一个数据的值；而 minBy()则会返回包 含字段最小值的整条数据。 </p><p>⚫ maxBy()：与 max()类似，在输入流上针对指定字段求最大值。两者区别与 min()/minBy()完全一致。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hlz.flink.chapter05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.functions.KeySelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单聚合操作2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-05-04 23:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAggregation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        DataStreamSource&lt;Event&gt; streamSource = env.fromElements(</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=100&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=9&quot;</span>, <span class="number">5000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>, <span class="number">6000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">7000L</span>)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按键分组后聚合,提取当</span></span><br><span class="line"></span><br><span class="line">        streamSource.keyBy(<span class="keyword">new</span> KeySelector&lt;Event, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value.user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).max(<span class="string">&quot;timeStamp&quot;</span>)</span><br><span class="line">                .print(<span class="string">&quot;max: &quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><p>max: &gt; Event{user=’Mary’, url=’./home’, timeStamp=1970-01-01 08:00:01.0}<br>max: &gt; Event{user=’Bob’, url=’./cart’, timeStamp=1970-01-01 08:00:02.0}<br>max: &gt; Event{user=’Alice’, url=’./prod?id=100’, timeStamp=1970-01-01 08:00:03.0}<br><font color="red">max: &gt; Event{user=’Bob’, url=’./cart’, timeStamp=1970-01-01 08:00:04.0}</font><br>max: &gt; Event{user=’Bob’, url=’./cart’, timeStamp=1970-01-01 08:00:05.0}<br>max: &gt; Event{user=’Bob’, url=’./cart’, timeStamp=1970-01-01 08:00:06.0}<br>max: &gt; Event{user=’Mary’, url=’./home’, timeStamp=1970-01-01 08:00:07.0}</p><p>看红色这一条数据，第四条数据中的路径应该是/home，但是这里却是原来的/cart，说明max()只计 算指定字段的最小值，其他字段会保留最初第一个数据的。</p><p>把max()换成maxBy(), 结果输出如下：</p><p>maxBy: &gt; Event{user=’Mary’, url=’./home’, timeStamp=1970-01-01 08:00:01.0}<br>maxBy: &gt; Event{user=’Bob’, url=’./cart’, timeStamp=1970-01-01 08:00:02.0}<br>maxBy: &gt; Event{user=’Alice’, url=’./prod?id=100’, timeStamp=1970-01-01 08:00:03.0}<br><font color="red">maxBy: &gt; Event{user=’Bob’, url=’./home’, timeStamp=1970-01-01 08:00:04.0}</font><br>maxBy: &gt; Event{user=’Bob’, url=’./prod?id=9’, timeStamp=1970-01-01 08:00:05.0}<br>maxBy: &gt; Event{user=’Bob’, url=’./prod?id=2’, timeStamp=1970-01-01 08:00:06.0}<br>maxBy: &gt; Event{user=’Mary’, url=’./prod?id=3’, timeStamp=1970-01-01 08:00:07.0}</p><p>第四条数据已经中url变成了本身的数据了。</p><h2 id="规约聚合"><a href="#规约聚合" class="headerlink" title="规约聚合"></a>规约聚合</h2><p> 与简单聚合类似，reduce 操作也会将 KeyedStream 转换为 DataStream。它不会改变流的元 素数据类型，所以输出类型和输入类型是一样的。  </p><p> 调用 KeyedStream 的 reduce 方法时，需要传入一个参数，实现 ReduceFunction 接口， ReduceFunction 接口里需要实现 reduce()方法，这个方法接收两个输入事件，经过转换处 理之后输出一个相同类型的事件；所以，对于一组数据，我们可以先取两个进行合并，然后再 将合并的结果看作一个数据、再跟后面的数据合并，最终会将它“简化”成唯一的一个数据， 这也就是 reduce“归约”的含义。</p><p> 我们将数据流按照用户 id 进行分区，然后用一个 reduce 算子实现 sum 的功能，统计每个 用户访问的频次；进而将所有统计结果分到一组，用另一个 reduce 算子实现 maxBy 的功能， 记录所有用户中访问频次最高的那个，也就是当前访问量最大的用户是谁。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hlz.flink.chapter05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.ReduceFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.TypeHint;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reduce操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-02-16 23:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransReduceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        DataStreamSource&lt;Event&gt; source = env.addSource(new ClickSource());</span></span><br><span class="line"></span><br><span class="line">        DataStreamSource&lt;Event&gt; source = env.fromElements(</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./mary&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./hello&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod&quot;</span>, <span class="number">5000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod1&quot;</span>, <span class="number">6000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">7000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod3&quot;</span>, <span class="number">8000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">        <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod2&quot;</span>, <span class="number">4000L</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将Event类型转换成Tuple元组类型</span></span><br><span class="line"><span class="comment">//        SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Long&gt;&gt; tupleStream = source.map(e -&gt; Tuple3.of(e.getUser(), e.getUrl(), 1L)).returns(new TypeHint&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Long&gt;&gt; reduceStream = source</span><br><span class="line">                .map(e -&gt; Tuple3.of(e.getUser(), e.getUrl(), <span class="number">1L</span>))</span><br><span class="line">                .returns(<span class="keyword">new</span> TypeHint&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                &#125;)</span><br><span class="line">                .keyBy(t -&gt; t.f0)</span><br><span class="line">                .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple3&lt;String, String, Long&gt; <span class="title">reduce</span><span class="params">(Tuple3&lt;String, String, Long&gt; value1, Tuple3&lt;String, String, Long&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 每到一条数据，pv加1</span></span><br><span class="line">                        <span class="keyword">return</span> Tuple3.of(value1.f0, value2.f1, value1.f2 + value2.f2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).keyBy(r -&gt; <span class="string">&quot;hello&quot;</span>).reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找最大值</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple3&lt;String, String, Long&gt; <span class="title">reduce</span><span class="params">(Tuple3&lt;String, String, Long&gt; value1, Tuple3&lt;String, String, Long&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> value1.f2 &gt; value2.f2 ? value1 : value2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        reduceStream.print(<span class="string">&quot;reduceStream&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出:</p><p>reduceStream&gt; (Mary,./mary,1)<br>reduceStream&gt; (Bob,./hello,1)<br>reduceStream&gt; (Alice,./prod,1)<br>reduceStream&gt; (Alice,./prod2,2)<br>reduceStream&gt; (Bob,./prod,2)<br>reduceStream&gt; (Bob,./prod1,3)<br>reduceStream&gt; (Bob,./prod2,4)<br>reduceStream&gt; (Bob,./prod3,5)<br>reduceStream&gt; (Bob,./prod3,5)<br>reduceStream&gt; (Bob,./prod3,5)<br>reduceStream&gt; (Alice,./prod2,5)<br>reduceStream&gt; (Alice,./prod2,6)<br>reduceStream&gt; (Alice,./prod2,7)</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>在使用max操作的时候，报错Cannot reference field by field expression on GenericType&lt;com.hlz.flink.chapter05.Event&gt;Field expressions are only supported on POJO types, tuples, and case classes. (See the Flink documentation on what is considered a POJO.)</p><img src="/2023/05/06/Flink%E4%B9%8B%E8%81%9A%E5%90%88%E7%AE%97%E5%AD%90/1683215675470.png" class width="1683215675470"><p>这是因为我们定义的Event对象不是标准的POJO对象，</p><h4 id="标准的POJO类的要求："><a href="#标准的POJO类的要求：" class="headerlink" title="标准的POJO类的要求："></a>标准的POJO类的要求：</h4><ol><li><p>所有成员变量都是私有的，用private修饰</p></li><li><p>每个成员变量都有对应的getter和setter</p></li><li><p>有一个无参的构造方法</p></li></ol><p>我们Event没有无参构造，因此需要加上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;聚合算子&quot;&gt;&lt;a href=&quot;#聚合算子&quot; class=&quot;headerlink&quot; title=&quot;聚合算子&quot;&gt;&lt;/a&gt;聚合算子&lt;/h2&gt;&lt;p&gt; 我们往往需要对大量的数据进行统计或整合，从而提炼出更有用的 信息。比如要对每个词出现的频次进行叠加统计。这种操作，计算的结</summary>
      
    
    
    
    <category term="Flink" scheme="https://castile.github.io/categories/Flink/"/>
    
    
    <category term="Flink" scheme="https://castile.github.io/tags/Flink/"/>
    
    <category term="聚合" scheme="https://castile.github.io/tags/%E8%81%9A%E5%90%88/"/>
    
    <category term="聚合算子" scheme="https://castile.github.io/tags/%E8%81%9A%E5%90%88%E7%AE%97%E5%AD%90/"/>
    
    <category term="算子" scheme="https://castile.github.io/tags/%E7%AE%97%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>castile-seckill项目jmeter性能压测</title>
    <link href="https://castile.github.io/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/"/>
    <id>https://castile.github.io/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/</id>
    <published>2023-03-27T15:15:17.000Z</published>
    <updated>2023-03-27T15:16:19.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jmeter下载"><a href="#Jmeter下载" class="headerlink" title="Jmeter下载"></a>Jmeter下载</h2><p><a href="https://jmeter.apache.org/download_jmeter.cgi#binaries">https://jmeter.apache.org/download_jmeter.cgi#binaries</a></p><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679830977726.png" class width="1679830977726"><h2 id="jmeter使用简介"><a href="#jmeter使用简介" class="headerlink" title="jmeter使用简介"></a>jmeter使用简介</h2><h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>我们先小测一把，模拟20个请求去访问商品详情页的接口</p><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679831046375.png" class width="1679831046375"><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679831057429.png" class width="1679831057429"><p>结果：</p><p>1、平均值接口响应为13ms</p><p>2、90线：表示有90%的请求的响应在26ms</p><p>3、95线：表示有95%的请求响应在33ms</p><p>4、吞吐量：2.1/s</p><h2 id="发现容量问题"><a href="#发现容量问题" class="headerlink" title="发现容量问题"></a>发现容量问题</h2><p>server端并发线程数上不去</p><p>我们使用的是springboot内嵌的tomcat</p><p>查看当前java进行开启的线程数量：pstree</p><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679831526854.png" class width="1679831526854"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# pstree -p 20919 | wc -l</span><br><span class="line">29</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前有29个线程</p><h3 id="100个线程、循环10次"><a href="#100个线程、循环10次" class="headerlink" title="100个线程、循环10次"></a>100个线程、循环10次</h3><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/111" class width="1679831898788"><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679831918221.png" class width="1679831918221"><h3 id="500个线程、循环10次"><a href="#500个线程、循环10次" class="headerlink" title="500个线程、循环10次"></a>500个线程、循环10次</h3><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/111" class width="1679831898788"><h3 id="5000个线程，循环100"><a href="#5000个线程，循环100" class="headerlink" title="5000个线程，循环100"></a>5000个线程，循环100</h3><p>服务已经出现拒绝连接了：</p><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679836900586.png" class width="1679836900586"><p>线程数量一直在219个：</p><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679836949848.png" class width="1679836949848"><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679837001322.png" class width="1679837001322"><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>spring-configuration-metadata.json</p><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679837237188.png" class width="1679837237188"><p>项目使用的是springboot内嵌的tomcat容器，并且没有对参数进行特定设置；查看springboot的默认配置：</p><p>server.tomcat.accept-count： 等待队列的长度，默认100</p><p>server.tomcat.max-connections： 最大可被连接数，默认8192</p><p>server.tomcat.threads.min-spare：最小工作线程数，默认10</p><p>server.tomcat.threads.max： 最大工作线程数， 默认200</p><p>默认配置下，连接超过8192后出现拒绝连接情况</p><p>默认配置项啊，触发的请求超过200+100后拒绝处理。 </p><p>更改tomcat服务端参数：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据源</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/castile-seckill?characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 404问题的处理, 非通用异常的返回设置</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapping/*.xml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9090</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">accept-count:</span> <span class="number">1000</span></span><br><span class="line">    <span class="attr">threads:</span></span><br><span class="line">      <span class="attr">max:</span> <span class="number">800</span></span><br><span class="line">      <span class="attr">min-spare:</span> <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>容器重新启动后，可以看到还没有开始压测的时候，启动后的线程数量为119：</p><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679841203406.png" class width="1679841203406"><h3 id="优化后：-2000个线程，循环100"><a href="#优化后：-2000个线程，循环100" class="headerlink" title="优化后： 2000个线程，循环100"></a>优化后： 2000个线程，循环100</h3><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679841277.png" class width="1679841277106"><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679841486748.png" class width="1679841486748"><p>最大开启线程数819个</p><img src="/2023/03/27/castile-seckill%E9%A1%B9%E7%9B%AEjmeter%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/1679841277.png" class width="1679841277106"><h3 id="定制内嵌tomcat开发"><a href="#定制内嵌tomcat开发" class="headerlink" title="定制内嵌tomcat开发"></a>定制内嵌tomcat开发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.castile.secondkill.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Connector;</span><br><span class="line"><span class="keyword">import</span> org.apache.coyote.http11.Http11NioProtocol;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.embedded.tomcat.TomcatConnectorCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.ConfigurableWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当Spring容器内没有TomcatEmbeddedServletContainerFactory这个bean时，会把此bean加载到Spring容器中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-3-27 23:01:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServerConfiguration</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用对应工厂类提供给我们的接口定制化我们的tomcat onnector</span></span><br><span class="line">        ((TomcatServletWebServerFactory) factory).addConnectorCustomizers(<span class="keyword">new</span> TomcatConnectorCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">                Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line">                <span class="comment">// 设置30秒内没有请求则断开keepalive连接</span></span><br><span class="line">                protocol.setKeepAliveTimeout(<span class="number">30000</span>);</span><br><span class="line">                <span class="comment">// 当客户端发送超过10000个请求则自动断开keepalive连接</span></span><br><span class="line">                protocol.setMaxKeepAliveRequests(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KeepAliveTimeout: 多少毫秒后不响应就断开keepalive</p><p>MaxKeepAliveRequests： 多少次请求后keepalive断开</p><p>设置这两个参数是为了保证我们的系统不受客户端请求的拖累，在满足需求的同时提升性能</p><h2 id="单web容量上限"><a href="#单web容量上限" class="headerlink" title="单web容量上限"></a>单web容量上限</h2><p>线程数量：4U8G内存单进程调度线程数量800-1000以上后就花费巨大的时间在cpu的调度上</p><p>等待队列长度： 对列做缓冲池使用，但不能无限长，消耗内存，出队入队也耗cpu</p><h2 id="mysql数据库QPS容量问题"><a href="#mysql数据库QPS容量问题" class="headerlink" title="mysql数据库QPS容量问题"></a>mysql数据库QPS容量问题</h2><p><strong>经验</strong></p><ul><li><p>主键查询：千万级别数据= 1-10ms</p></li><li><p>唯一索引查询：千万级别数据 = 10-100ms</p></li><li><p>非唯一索引查询： 千万级别数据=100-1000ms</p></li><li><p>无索引： 百万条数据=1000ms+</p></li><li><p>非插入更新删除操作： 同查询</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Jmeter下载&quot;&gt;&lt;a href=&quot;#Jmeter下载&quot; class=&quot;headerlink&quot; title=&quot;Jmeter下载&quot;&gt;&lt;/a&gt;Jmeter下载&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://jmeter.apache.org/download_jm</summary>
      
    
    
    
    <category term="Java" scheme="https://castile.github.io/categories/Java/"/>
    
    <category term="SpringBoot" scheme="https://castile.github.io/categories/Java/SpringBoot/"/>
    
    <category term="秒杀项目" scheme="https://castile.github.io/categories/Java/SpringBoot/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="https://castile.github.io/tags/Java/"/>
    
    <category term="SpringBoot" scheme="https://castile.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>cstile-seckill项目云端部署</title>
    <link href="https://castile.github.io/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/"/>
    <id>https://castile.github.io/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/</id>
    <published>2023-03-26T10:13:40.000Z</published>
    <updated>2023-03-27T15:16:47.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本地打包"><a href="#本地打包" class="headerlink" title="本地打包"></a>本地打包</h2><p>我们使用jar包与配置文件分离的方式进行打包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--不打入jar包的文件类型或者路径--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 执行的主程序路径 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.castile.secondkill.CastileSeckillApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--是否要把第三方jar放到manifest的classpath中--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--生成的manifest中classpath的前缀，因为要把第三方jar放到lib目录下，所以classpath的前缀是lib/--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 打包时 MANIFEST.MF 文件不记录的时间戳版本 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">useUniqueVersions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">useUniqueVersions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 在 Class-Path 下添加配置文件的路径 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Class-Path</span>&gt;</span>config/<span class="tag">&lt;/<span class="name">Class-Path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib/<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--把配置文件打包到指定路径--&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/config<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679752855016.png" class width="1679752855016"><p>配置文件放在config目录下，项目依赖的jar包放在lib目录下。</p><h2 id="docker远程访问"><a href="#docker远程访问" class="headerlink" title="docker远程访问"></a>docker远程访问</h2><p> 修改 /usr/lib/systemd/system/docker.service 文件，ExecStart中加入如下内容 </p><p> -H tcp://0.0.0.0:2375  -H unix:///var/run/docker.sock </p><img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679753201017.png" class width="1679753201017"><p>重启docker让它生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload    </span><br><span class="line">systemctl restart docker </span><br></pre></td></tr></table></figure><h2 id="idea测试docker连接"><a href="#idea测试docker连接" class="headerlink" title="idea测试docker连接"></a>idea测试docker连接</h2><img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679753357352.png" class width="1679753357352"><p>可以看到连接成功：</p><img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679753392186.png" class width="1679753392186"><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p> 项目中引入docker-maven-plugin插件，在pom.xml引入插件并做相应的配置： </p><h3 id="1、打包的时候忽略resource配置"><a href="#1、打包的时候忽略resource配置" class="headerlink" title="1、打包的时候忽略resource配置"></a>1、打包的时候忽略resource配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-lib、config目录的构建"><a href="#2-lib、config目录的构建" class="headerlink" title="2. lib、config目录的构建"></a>2. lib、config目录的构建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib/<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--把配置文件打包到指定路径--&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/config<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3、启动类-boot-jar"><a href="#3、启动类-boot-jar" class="headerlink" title="3、启动类-boot-jar"></a>3、启动类-boot-jar</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>none-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span>&gt;</span>ZIP<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attach</span>&gt;</span>true<span class="tag">&lt;/<span class="name">attach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>boot<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 执行的主程序路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.castile.secondkill.CastileSeckillApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span></span><br><span class="line">                    repackage</span><br><span class="line">                <span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4、镜像构建"><a href="#4、镜像构建" class="headerlink" title="4、镜像构建"></a>4、镜像构建</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.spotify/docker-maven-plugin --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 当mvn执行install操作的时候，执行docker的build和push --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>buildAndPush<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                            &lt;goal&gt;build&lt;/goal&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                            &lt;goal&gt;push&lt;/goal&gt;--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>build-docker<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 连接到 带docker环境的linux服务器 编译image --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>$&#123;docker.host&#125;<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- push到 docker hub 开始 --&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- serverId 这个是配置在maven的setting.xml中私服的登录账户信息--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">retryPushCount</span>&gt;</span>1<span class="tag">&lt;/<span class="name">retryPushCount</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">retryPushTimeout</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">retryPushTimeout</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">registryUrl</span>&gt;</span>$&#123;docker.registry&#125;<span class="tag">&lt;/<span class="name">registryUrl</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 格式：私有仓库/镜像名称:版本号, 如果要执行push操作， 那么镜像名称必须为私有仓库为前缀，不然无效。--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;docker.registry&#125;/$&#123;project.artifactId&#125;:$&#123;imageVersion&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- push到 docker hub 结束 --&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--指定dockerfile文件路径--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/docker<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- optionally overwrite tags every time image is built with docker:build --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">forceTags</span>&gt;</span>true<span class="tag">&lt;/<span class="name">forceTags</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">SERVICE_PACKAGE</span>&gt;</span>$&#123;project.basedir&#125;/../../target/$&#123;finalName&#125;.tar.gz<span class="tag">&lt;/<span class="name">SERVICE_PACKAGE</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/opt/castile/app<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">include</span>&gt;</span>lib/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">include</span>&gt;</span>config/**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">include</span>&gt;</span>*-boot.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                       <span class="comment">&lt;!-- &lt;resource&gt;</span></span><br><span class="line"><span class="comment">                            &lt;targetPath&gt;/&lt;/targetPath&gt;</span></span><br><span class="line"><span class="comment">                            &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span></span><br><span class="line"><span class="comment">                            &lt;includes&gt;</span></span><br><span class="line"><span class="comment">                                &lt;include&gt;$&#123;finalName&#125;.tar.gz&lt;/include&gt;</span></span><br><span class="line"><span class="comment">                            &lt;/includes&gt;</span></span><br><span class="line"><span class="comment">                        &lt;/resource&gt;--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5、Dockerfile"><a href="#5、Dockerfile" class="headerlink" title="5、Dockerfile"></a>5、Dockerfile</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line">ARG SERVICE_PACKAGE</span><br><span class="line">MAINTAINER zhuhongliang &#x27;castile.github.io&#x27;</span><br><span class="line">ENV APP_HOME=/opt/castile/app</span><br><span class="line"></span><br><span class="line">ADD opt/castile/app /opt/castile/app/</span><br><span class="line">EXPOSE 9090</span><br><span class="line">WORKDIR /opt/castile/app</span><br><span class="line"><span class="meta">#</span><span class="bash">CMD  /bin/bash <span class="variable">$&#123;APP_HOME&#125;</span>/config/docker-start.sh</span></span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-Xbootclasspath/a:/opt/castile/app/config&quot;, &quot;-Djava.ext.dirs=/opt/castile/app/lib:$JAVA_HOME/jre/lib/ext&quot;,&quot;-jar&quot;,&quot;/opt/castile/app/castile-seckill-0.0.1-SNAPSHOT-boot.jar&quot;]</span><br></pre></td></tr></table></figure><p>推送至docker私服：</p><img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679824979208.png" class width="1679824979208"><img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679825019113.png" class width="1679825019113"><h2 id="启动部署"><a href="#启动部署" class="headerlink" title="启动部署"></a>启动部署</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name castile -p 9090:9090 -v /opt/applications/castile-seckill/config/:/opt/castile/app/config  192.168.160.140:5000/castile-seckill:0.0.1-SNAPSHOT</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里设置宿主机的opt/applications/castile-seckill/config/目录和容器内/opt/castile/app/config目录映射，为了修改配置方便些。</p><p>执行的java命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a:/opt/castile/app/config -Djava.ext.dirs=/opt/castile/app/lib:$JAVA_HOME/jre/lib/ext -jar /opt/castile/app/castile-seckill-0.0.1-SNAPSHOT-boot.jar</span><br></pre></td></tr></table></figure><img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679825557145.png" class width="1679825557145"><h2 id="部署msql"><a href="#部署msql" class="headerlink" title="部署msql"></a>部署msql</h2><p>因为项目依赖mysql，因此需要把mysql容器先启动，再启动项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql8 -v /var/mysql/data:/var/lib/mysql -v /var/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -p 3306:                                      3306 -d mysql:8.0.32</span><br></pre></td></tr></table></figure><p>设置远程访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select host, user, plugin,  authentication_string, password_expired from user;</span><br></pre></td></tr></table></figure><img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679825319954.png" class width="1679825319954"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> root@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> root@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line">刷新权限</span><br><span class="line"> FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679825359041.png" class width="1679825359041"><img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679825476826.png" class width="1679825476826"><h2 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h2><p>浏览器输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.160.140:9090/login.html</span><br></pre></td></tr></table></figure><img src="/2023/03/26/cstile-seckill%E9%A1%B9%E7%9B%AE%E4%BA%91%E7%AB%AF%E9%83%A8%E7%BD%B2/1679825153890.png" class width="1679825153890"><p>已经可以成功访问啦，可以验证基本功能都正常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本地打包&quot;&gt;&lt;a href=&quot;#本地打包&quot; class=&quot;headerlink&quot; title=&quot;本地打包&quot;&gt;&lt;/a&gt;本地打包&lt;/h2&gt;&lt;p&gt;我们使用jar包与配置文件分离的方式进行打包：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="Java" scheme="https://castile.github.io/categories/Java/"/>
    
    <category term="SpringBoot" scheme="https://castile.github.io/categories/Java/SpringBoot/"/>
    
    <category term="秒杀项目" scheme="https://castile.github.io/categories/Java/SpringBoot/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="https://castile.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>spring-batch核心概念</title>
    <link href="https://castile.github.io/2023/02/26/spring-batch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <id>https://castile.github.io/2023/02/26/spring-batch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</id>
    <published>2023-02-26T15:30:45.000Z</published>
    <updated>2023-02-26T15:34:06.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="批处理领域语言"><a href="#批处理领域语言" class="headerlink" title="批处理领域语言"></a>批处理领域语言</h1><p>下图是批处理整体框架， spring Batch提供了层、组件和技术服务的物理实现，这些层、组件和技术服务通常存在于健壮的、可维护的系统中，用于创建从简单到复杂的批处理应用程序，其基础设施和扩展用于处理非常复杂的处理需求。 </p><img src="/2023/02/26/spring-batch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/1677378333315.png" class width="1677378333315"><p>黄色部分代表了Spring-batch的核心组件，每一个Job有一或者多个步骤（Step），每个Step都有一个ItemReader、ItemWriter和一个ItemProcessor。而启动一个Job需要一个Job执行器（JobLauncher），并且需要存储有关当前Job进程中的一些元数据（JobRepository）。</p><h2 id="1-Job"><a href="#1-Job" class="headerlink" title="1. Job"></a>1. Job</h2><p> Job是封装整个批处理过程的实体。在Spring-Batch中，一个Job可以简单看做多个Step的容器。 它将逻辑上属于一个流的多个步骤组合在一起，并允许配置所有步骤的全局属性，例如可重新启动性。 </p><img src="/2023/02/26/spring-batch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/1677378628530.png" class width="1677378628530"><p>一个Job可以通过XMl、或者java配置的方式进行配置。主要包含：</p><ul><li>job的名称</li><li>Step的定义和顺序</li><li>Job是否可以restart</li></ul><p>Job接口的默认实现有SimpleJob，提供了一些默认实现。使用Java 的配置方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Job <span class="title">footballJob</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleJob simpleJob = <span class="keyword">new</span> SimpleJob();</span><br><span class="line">        <span class="keyword">return</span> simpleJob;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-JobInstance"><a href="#2-JobInstance" class="headerlink" title="2. JobInstance"></a>2. JobInstance</h2><p>代表是一个Job真正运行的实例。每个Job可以执行多次，每个JobInstance都与一个JobParameter绑定。</p><p> JobInstance的定义与要加载的数据完全无关。完全由ItemReader实现决定如何加载数据。 </p><p> 使用相同的JobInstance决定是否使用以前执行的“状态”(即ExecutionContext，)。使用一个新的JobInstance意味着“从头开始”，而使用一个现有的实例通常意味着“从你离开的地方开始”。 </p><h2 id="3-JobParameters"><a href="#3-JobParameters" class="headerlink" title="3. JobParameters"></a>3. JobParameters</h2><p>那么如何区分JobInstance之间的不同呢？答案就是JobParameters。JobParameters作为一系列的启动参数用于启动一个批处理任务。</p><img src="/2023/02/26/spring-batch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/1677380836783.png" class width="1677380836783"><p>假如一个Job启动了两个实例： 一个在1月1号启动，一个在1月2号启动，他们各自有自己的JobParameters。那么约定：JobInstance = Job+identifying JobParameters 。这允许开发人员有效地控制JobInstance的定义方式，因为他们可以控制传入的参数。 </p><h2 id="4-JobExecution"><a href="#4-JobExecution" class="headerlink" title="4. JobExecution"></a>4. JobExecution</h2><p>JobExecution表示一个Job运行中的技术概念。 执行可能以失败或成功结束，但与给定执行对应的JobInstance不被认为是完成的，除非执行成功完成 。</p><p> 以前面描述的EndOfDay 的Job为例，考虑在第一次运行时失败的JobInstance。如果使用与第一次运行(01-01-2017)相同的标识作业参数再次运行它，则会创建一个新的JobExecution。但是，仍然只有一个JobInstance。</p><p>一个Job定义了任务是怎么样的以及是怎么被执行的， 然而，jobeexecution是运行期间实际发生情况的主要存储机制，它包含许多必须控制和持久化的属性。</p><table><thead><tr><th>Property</th><th>Definition</th></tr></thead><tbody><tr><td>Status</td><td>A <code>BatchStatus</code> object that indicates the status of the execution. While running, it is <code>BatchStatus#STARTED</code>. If it fails, it is <code>BatchStatus#FAILED</code>. If it finishes successfully, it is <code>BatchStatus#COMPLETED</code></td></tr><tr><td>startTime</td><td>A <code>java.util.Date</code> representing the current system time when the execution was started. This field is empty if the job has yet to start.</td></tr><tr><td>endTime</td><td>A <code>java.util.Date</code> representing the current system time when the execution finished, regardless of whether or not it was successful. The field is empty if the job has yet to finish.</td></tr><tr><td>exitStatus</td><td>The <code>ExitStatus</code>, indicating the result of the run. It is most important, because it contains an exit code that is returned to the caller. See chapter 5 for more details. The field is empty if the job has yet to finish.</td></tr><tr><td>createTime</td><td>A <code>java.util.Date</code> representing the current system time when the <code>JobExecution</code> was first persisted. The job may not have been started yet (and thus has no start time), but it always has a createTime, which is required by the framework for managing job level <code>ExecutionContexts</code>.</td></tr><tr><td>lastUpdated</td><td>A <code>java.util.Date</code> representing the last time a <code>JobExecution</code> was persisted. This field is empty if the job has yet to start.</td></tr><tr><td>executionContext</td><td>The “property bag” containing any user data that needs to be persisted between executions.</td></tr><tr><td>failureExceptions</td><td>The list of exceptions encountered during the execution of a <code>Job</code>. These can be useful if more than one exception is encountered during the failure of a <code>Job</code>.</td></tr></tbody></table><p>这些属性是<strong>持久化</strong>的，因此可以完全确定一个execution的执行状态。</p><h2 id="5-Step"><a href="#5-Step" class="headerlink" title="5. Step"></a>5. Step</h2><p> 它封装了批处理作业的一个独立的顺序阶段。 每个Job都完全由一个或多个步骤（Step）组成。一个步骤包含定义和控制实际批处理所需的所有信息。 </p><h2 id="6-StepExecution"><a href="#6-StepExecution" class="headerlink" title="6. StepExecution"></a>6. StepExecution</h2><p> 每次运行Step时都会创建一个新的StepExecution，类似于jobeexecution。但是，如果一个步骤执行失败是因为它之前的步骤失败，则不会为它持久执行。  只有当其Step实际启动时，才会创建StepExecution。 </p><table><thead><tr><th>Property</th><th>Definition</th></tr></thead><tbody><tr><td>Status</td><td>A <code>BatchStatus</code> object that indicates the status of the execution. While running, the status is <code>BatchStatus.STARTED</code>. If it fails, the status is <code>BatchStatus.FAILED</code>. If it finishes successfully, the status is <code>BatchStatus.COMPLETED</code>.</td></tr><tr><td>startTime</td><td>A <code>java.util.Date</code> representing the current system time when the execution was started. This field is empty if the step has yet to start.</td></tr><tr><td>endTime</td><td>A <code>java.util.Date</code> representing the current system time when the execution finished, regardless of whether or not it was successful. This field is empty if the step has yet to exit.</td></tr><tr><td>exitStatus</td><td>The <code>ExitStatus</code> indicating the result of the execution. It is most important, because it contains an exit code that is returned to the caller. See chapter 5 for more details. This field is empty if the job has yet to exit.</td></tr><tr><td>executionContext</td><td>The “property bag” containing any user data that needs to be persisted between executions.</td></tr><tr><td>readCount</td><td>The number of items that have been successfully read.</td></tr><tr><td>writeCount</td><td>The number of items that have been successfully written.</td></tr><tr><td>commitCount</td><td>The number of transactions that have been committed for this execution.</td></tr><tr><td>rollbackCount</td><td>The number of times the business transaction controlled by the <code>Step</code> has been rolled back.</td></tr><tr><td>readSkipCount</td><td>The number of times <code>read</code> has failed, resulting in a skipped item.</td></tr><tr><td>processSkipCount</td><td>The number of times <code>process</code> has failed, resulting in a skipped item.</td></tr><tr><td>filterCount</td><td>The number of items that have been ‘filtered’ by the <code>ItemProcessor</code>.</td></tr><tr><td>writeSkipCount</td><td>The number of times <code>write</code> has failed, resulting in a skipped item.</td></tr></tbody></table><h2 id="7-ExecutionContext"><a href="#7-ExecutionContext" class="headerlink" title="7. ExecutionContext"></a>7. ExecutionContext</h2><p>ExecutionContext代表一系列key-value的数据map。 好的使用例子是方便重新启动。以平面文件输入为例，在处理单个行时，框架定期在提交点持久化ExecutionContext。 </p><h2 id="8-JobRepository"><a href="#8-JobRepository" class="headerlink" title="8. JobRepository"></a>8. JobRepository</h2><p> JobRepository是上述概念的持久化机制。提供了一些CRUD的操作、 当Job第一次启动时，从存储库中获得jobeexecution，并且在执行过程中，通过将StepExecution和jobeexecution实现传递给存储库来持久化它们。 </p><h2 id="9-JobLauncher"><a href="#9-JobLauncher" class="headerlink" title="9. JobLauncher"></a>9. JobLauncher</h2><p>Job 执行器、</p><h2 id="10-Item-Reader"><a href="#10-Item-Reader" class="headerlink" title="10.  Item Reader"></a>10.  Item Reader</h2><p> ItemReader是一种抽象，表示对Step的输入的检索，每次一项。当ItemReader耗尽了它所能提供的项时，它将通过返回null来表示。关于ItemReader接口及其各种实现的更多细节可以在Readers和writer中找到。 </p><h2 id="11-Item-Writer"><a href="#11-Item-Writer" class="headerlink" title="11. Item Writer"></a>11. Item Writer</h2><p> 它表示一个步骤的输出，一次一批或一组项目。通常，ItemWriter不知道它接下来应该接收的输入，只知道在当前调用中传递的项。</p><h2 id="12-Item-Processor"><a href="#12-Item-Processor" class="headerlink" title="12. Item Processor"></a>12. Item Processor</h2><p>每一条数据的处理逻辑。 如果在处理该项时确定该项无效，则返回null表示不应写入该项。 </p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>执行批处理作业时的一个关键问题是重新启动作业时的行为。如果特定JobInstance的jobeexecute已经存在，则启动Job被认为是“重新启动” </p><h4 id="Restartability属性"><a href="#Restartability属性" class="headerlink" title="Restartability属性"></a>Restartability属性</h4><p> 将restarttable设置为false意味着此Job不支持再次启动。重新启动不可重新启动的作业将引发JobRestartException异常 </p><h2 id="EnableBatchProcessing"><a href="#EnableBatchProcessing" class="headerlink" title="EnableBatchProcessing"></a>EnableBatchProcessing</h2><p> @EnableBatchProcessing提供了用于构建批处理任务的基本配置。在这个基本配置中，除了许多可用于自动连接的bean之外，还创建了一个StepScope实例 </p><ul><li><code>JobRepository</code>: bean name “jobRepository”</li><li><code>JobLauncher</code>: bean name “jobLauncher”</li><li><code>JobRegistry</code>: bean name “jobRegistry”</li><li><code>PlatformTransactionManager</code>: bean name “transactionManager”</li><li><code>JobBuilderFactory</code>: bean name “jobBuilders”</li><li><code>StepBuilderFactory</code>: bean name “stepBuilders”</li></ul><h2 id="改变存储机制"><a href="#改变存储机制" class="headerlink" title="改变存储机制"></a>改变存储机制</h2><p>可能不需要将Job的状态存储在数据库中， 出于这个原因，Spring批处理提供了作业存储库的内存中的Map版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This would reside in your BatchConfigurer implementation</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> JobRepository <span class="title">createJobRepository</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MapJobRepositoryFactoryBean factory = <span class="keyword">new</span> MapJobRepositoryFactoryBean();</span><br><span class="line">    factory.setTransactionManager(transactionManager);</span><br><span class="line">    <span class="keyword">return</span> factory.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，内存中的存储库是不稳定的，因此不允许在JVM实例之间重新启动。它也不能保证同时启动两个具有相同参数的作业实例，并且不适合在多线程作业或本地分区Step中使用。因此，只要需要这些特性，就使用存储库的数据库版本。<br>  确实需要定义事务管理器，因为存储库中存在回滚语义，而且业务逻辑可能仍然是事务性的(例如RDBMS访问)。出于测试目的，许多人发现ResourcelessTransactionManager很有用。 </p><p>但是MapJobRepositoryFactoryBean已经过时了，将会在Spring-Batch 5.x版本中移除。因此如果想要基于内存的操作，那么可以配置一个本地的数据库，如H2， Apache Derby or HSQLDB 等，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">            .addScript(<span class="string">&quot;/org/springframework/batch/core/schema-drop-h2.sql&quot;</span>)</span><br><span class="line">            .addScript(<span class="string">&quot;/org/springframework/batch/core/schema-h2.sql&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置数据源后需要结合createJobRepository来设置。</p><h2 id="配置Configuring-a-JobLauncher"><a href="#配置Configuring-a-JobLauncher" class="headerlink" title="配置Configuring a JobLauncher"></a>配置Configuring a JobLauncher</h2><p> 获得jobeexecution后，将它传递给Job的execute方法，最终将jobeexecution返回给调用者，如下图所示 </p><img src="/2023/02/26/spring-batch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/1677424458876.png" class width="1677424458876"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobLauncher <span class="title">jobLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SimpleJobLauncher jobLauncher = <span class="keyword">new</span> SimpleJobLauncher();</span><br><span class="line">jobLauncher.setJobRepository(jobRepository());</span><br><span class="line">jobLauncher.setTaskExecutor(<span class="keyword">new</span> SimpleAsyncTaskExecutor());</span><br><span class="line">jobLauncher.afterPropertiesSet();</span><br><span class="line"><span class="keyword">return</span> jobLauncher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;批处理领域语言&quot;&gt;&lt;a href=&quot;#批处理领域语言&quot; class=&quot;headerlink&quot; title=&quot;批处理领域语言&quot;&gt;&lt;/a&gt;批处理领域语言&lt;/h1&gt;&lt;p&gt;下图是批处理整体框架， spring Batch提供了层、组件和技术服务的物理实现，这些层、组件和技</summary>
      
    
    
    
    <category term="Spring" scheme="https://castile.github.io/categories/Spring/"/>
    
    
    <category term="spring-batch" scheme="https://castile.github.io/tags/spring-batch/"/>
    
  </entry>
  
  <entry>
    <title>Netty-优化与源码分析</title>
    <link href="https://castile.github.io/2022/12/03/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/"/>
    <id>https://castile.github.io/2022/12/03/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/</id>
    <published>2022-12-03T13:11:45.000Z</published>
    <updated>2022-12-03T13:14:48.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四-优化与源码"><a href="#四-优化与源码" class="headerlink" title="四. 优化与源码"></a>四. 优化与源码</h1><h2 id="1-优化"><a href="#1-优化" class="headerlink" title="1. 优化"></a>1. 优化</h2><h3 id="1-1-扩展序列化算法"><a href="#1-1-扩展序列化算法" class="headerlink" title="1.1 扩展序列化算法"></a>1.1 扩展序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上</p><ul><li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li><li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li></ul><p>目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">byte</span>[] body = <span class="keyword">new</span> <span class="keyword">byte</span>[bodyLength];</span><br><span class="line">byteByf.readBytes(body);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(body));</span><br><span class="line">Message message = (Message) in.readObject();</span><br><span class="line">message.setSequenceId(sequenceId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="keyword">new</span> ObjectOutputStream(out).writeObject(message);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = out.toByteArray();</span><br></pre></td></tr></table></figure><p>为了支持更多序列化算法，抽象一个 Serializer 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SerializerAlgorithm</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"><span class="comment">// Java 实现</span></span><br><span class="line">    Java &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ObjectInputStream in = </span><br><span class="line">                    <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">                Object object = in.readObject();</span><br><span class="line">                <span class="keyword">return</span> (T) object;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;SerializerAlgorithm.Java 反序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                <span class="keyword">new</span> ObjectOutputStream(out).writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;SerializerAlgorithm.Java 序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// Json 实现(引入了 Gson 依赖)</span></span><br><span class="line">    Json &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(<span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8), clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Gson().toJson(object).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要从协议的字节中得到是哪种序列化算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SerializerAlgorithm <span class="title">getByInt</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        SerializerAlgorithm[] array = SerializerAlgorithm.values();</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;超过 SerializerAlgorithm 范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[type];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加配置类和配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream in = Config.class.getResourceAsStream(<span class="string">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class="line">            properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getServerPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = properties.getProperty(<span class="string">&quot;server.port&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">8080</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Serializer.<span class="function">Algorithm <span class="title">getSerializerAlgorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String value = properties.getProperty(<span class="string">&quot;serializer.algorithm&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.Java;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.valueOf(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">serializer.algorithm</span>=<span class="string">Json</span></span><br></pre></td></tr></table></figure><p>修改编解码器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>, <span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf out = ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(Config.getSerializerAlgorithm().ordinal());</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Config.getSerializerAlgorithm().serialize(msg);</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magicNum = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span> version = in.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializerAlgorithm = in.readByte(); <span class="comment">// 0 或 1</span></span><br><span class="line">        <span class="keyword">byte</span> messageType = in.readByte(); <span class="comment">// 0,1,2...</span></span><br><span class="line">        <span class="keyword">int</span> sequenceId = in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到反序列化算法</span></span><br><span class="line">        Serializer.Algorithm algorithm = Serializer.Algorithm.values()[serializerAlgorithm];</span><br><span class="line">        <span class="comment">// 确定具体消息类型</span></span><br><span class="line">        Class&lt;? extends Message&gt; messageClass = Message.getMessageClass(messageType);</span><br><span class="line">        Message message = algorithm.deserialize(messageClass, bytes);</span><br><span class="line"><span class="comment">//        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);</span></span><br><span class="line"><span class="comment">//        log.debug(&quot;&#123;&#125;&quot;, message);</span></span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中确定具体消息类型，可以根据 <code>消息类型字节</code> 获取到对应的 <code>消息 class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据消息类型字节，获得对应的消息 class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageType 消息类型字节</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 消息 class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;? extends Message&gt; getMessageClass(<span class="keyword">int</span> messageType) &#123;</span><br><span class="line">        <span class="keyword">return</span> messageClasses.get(messageType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sequenceId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> messageType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LoginRequestMessage = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LoginResponseMessage = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ChatRequestMessage = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ChatResponseMessage = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupCreateRequestMessage = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupCreateResponseMessage = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupJoinRequestMessage = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupJoinResponseMessage = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupQuitRequestMessage = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupQuitResponseMessage = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupChatRequestMessage = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupChatResponseMessage = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupMembersRequestMessage = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GroupMembersResponseMessage = <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PingMessage = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PongMessage = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Class&lt;? extends Message&gt;&gt; messageClasses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);</span><br><span class="line">        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);</span><br><span class="line">        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);</span><br><span class="line">        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-参数调优"><a href="#1-2-参数调优" class="headerlink" title="1.2 参数调优"></a>1.2 参数调优</h3><h4 id="1）CONNECT-TIMEOUT-MILLIS"><a href="#1）CONNECT-TIMEOUT-MILLIS" class="headerlink" title="1）CONNECT_TIMEOUT_MILLIS"></a>1）CONNECT_TIMEOUT_MILLIS</h4><ul><li><p>属于 SocketChannal 参数</p></li><li><p>用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</p></li><li><p>SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConnectionTimeout</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">300</span>)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line">            ChannelFuture future = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            future.sync().channel().closeFuture().sync(); <span class="comment">// 断点1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.debug(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外源码部分 <code>io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Schedule connect timeout.</span></span><br><span class="line">    <span class="keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();</span><br><span class="line">    <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">                ChannelPromise connectPromise = AbstractNioChannel.<span class="keyword">this</span>.connectPromise;</span><br><span class="line">                ConnectTimeoutException cause =</span><br><span class="line">                    <span class="keyword">new</span> ConnectTimeoutException(<span class="string">&quot;connection timed out: &quot;</span> + remoteAddress); <span class="comment">// 断点2</span></span><br><span class="line">                <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                    close(voidPromise());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）SO-BACKLOG"><a href="#2）SO-BACKLOG" class="headerlink" title="2）SO_BACKLOG"></a>2）SO_BACKLOG</h4><ul><li>属于 ServerSocketChannal 参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">participant c as client</span><br><span class="line">participant s as server</span><br><span class="line">participant sq as syns queue</span><br><span class="line">participant aq as accept queue</span><br><span class="line"></span><br><span class="line">s -&gt;&gt; s : bind()</span><br><span class="line">s -&gt;&gt; s : listen()</span><br><span class="line">c -&gt;&gt; c : connect()</span><br><span class="line">c -&gt;&gt; s : 1. SYN</span><br><span class="line">Note left of c : SYN_SEND</span><br><span class="line">s -&gt;&gt; sq : put</span><br><span class="line">Note right of s : SYN_RCVD</span><br><span class="line">s -&gt;&gt; c : 2. SYN + ACK</span><br><span class="line">Note left of c : ESTABLISHED</span><br><span class="line">c -&gt;&gt; s : 3. ACK</span><br><span class="line">sq -&gt;&gt; aq : put</span><br><span class="line">Note right of s : ESTABLISHED</span><br><span class="line">aq --&gt;&gt; s : </span><br><span class="line">s -&gt;&gt; s : accept()</span><br></pre></td></tr></table></figure><ol><li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li><li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li><li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue</li></ol><p>其中</p><ul><li><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p></li><li><p>sync queue - 半连接队列</p><ul><li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li><p>accept queue - 全连接队列</p><ul><li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值</li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><p>netty 中</p><p>可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置大小</p><p>可以通过下面源码查看默认大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServerSocketChannelConfig</span> <span class="keyword">extends</span> <span class="title">DefaultChannelConfig</span></span></span><br><span class="line"><span class="class">                                              <span class="keyword">implements</span> <span class="title">ServerSocketChannelConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> backlog = NetUtil.SOMAXCONN;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>课堂调试关键断点为：<code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p><p>oio 中更容易说明，不用 debug 模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>, <span class="number">2</span>);</span><br><span class="line">        Socket accept = ss.accept();</span><br><span class="line">        System.out.println(accept);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端启动 4 个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket s = <span class="keyword">new</span> Socket();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date()+<span class="string">&quot; connecting...&quot;</span>);</span><br><span class="line">            s.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>),<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date()+<span class="string">&quot; connected...&quot;</span>);</span><br><span class="line">            s.getOutputStream().write(<span class="number">1</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date()+<span class="string">&quot; connecting timeout...&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tue Apr <span class="number">21</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">28</span> CST <span class="number">2020</span> connecting...</span><br><span class="line">Tue Apr <span class="number">21</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">28</span> CST <span class="number">2020</span> connected...</span><br></pre></td></tr></table></figure><p>第 4 个客户端连接时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tue Apr 21 20:53:58 CST 2020 connecting...</span><br><span class="line">Tue Apr 21 20:53:59 CST 2020 connecting timeout...</span><br><span class="line">java.net.SocketTimeoutException: connect timed out</span><br></pre></td></tr></table></figure><h4 id="3）ulimit-n"><a href="#3）ulimit-n" class="headerlink" title="3）ulimit -n"></a>3）ulimit -n</h4><ul><li>属于操作系统参数</li></ul><h4 id="4）TCP-NODELAY"><a href="#4）TCP-NODELAY" class="headerlink" title="4）TCP_NODELAY"></a>4）TCP_NODELAY</h4><ul><li>属于 SocketChannal 参数</li></ul><h4 id="5）SO-SNDBUF-amp-SO-RCVBUF"><a href="#5）SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="5）SO_SNDBUF &amp; SO_RCVBUF"></a>5）SO_SNDBUF &amp; SO_RCVBUF</h4><ul><li>SO_SNDBUF 属于 SocketChannal 参数</li><li>SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）</li></ul><h4 id="6）ALLOCATOR"><a href="#6）ALLOCATOR" class="headerlink" title="6）ALLOCATOR"></a>6）ALLOCATOR</h4><ul><li>属于 SocketChannal 参数</li><li>用来分配 ByteBuf， ctx.alloc()</li></ul><h4 id="7）RCVBUF-ALLOCATOR"><a href="#7）RCVBUF-ALLOCATOR" class="headerlink" title="7）RCVBUF_ALLOCATOR"></a>7）RCVBUF_ALLOCATOR</h4><ul><li>属于 SocketChannal 参数</li><li>控制 netty 接收缓冲区大小</li><li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li></ul><h3 id="1-3-RPC-框架"><a href="#1-3-RPC-框架" class="headerlink" title="1.3 RPC 框架"></a>1.3 RPC 框架</h3><h4 id="1）准备工作"><a href="#1）准备工作" class="headerlink" title="1）准备工作"></a>1）准备工作</h4><p>这些代码可以认为是现成的，无需从头编写练习</p><p>为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略旧的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RPC_MESSAGE_TYPE_REQUEST = <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RPC_MESSAGE_TYPE_RESPONSE = <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);</span><br><span class="line">        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequestMessage</span> <span class="keyword">extends</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用的接口全限定名，服务端根据它找到实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用接口中的方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; returnType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数类型数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class[] parameterTypes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数值数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameterValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcRequestMessage</span><span class="params">(<span class="keyword">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setSequenceId(sequenceId);</span><br><span class="line">        <span class="keyword">this</span>.interfaceName = interfaceName;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">        <span class="keyword">this</span>.returnType = returnType;</span><br><span class="line">        <span class="keyword">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">        <span class="keyword">this</span>.parameterValue = parameterValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RPC_MESSAGE_TYPE_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseMessage</span> <span class="keyword">extends</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object returnValue;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Exception exceptionValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RPC_MESSAGE_TYPE_RESPONSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器架子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// rpc 请求消息处理器，待实现</span></span><br><span class="line">        RpcRequestMessageHandler RPC_HANDLER = <span class="keyword">new</span> RpcRequestMessageHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = serverBootstrap.bind(<span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端架子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// rpc 响应消息处理器，待实现</span></span><br><span class="line">        RpcResponseMessageHandler RPC_HANDLER = <span class="keyword">new</span> RpcResponseMessageHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端的 service 获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServicesFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Object&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream in = Config.class.getResourceAsStream(<span class="string">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class="line">            properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(in);</span><br><span class="line">            Set&lt;String&gt; names = properties.stringPropertyNames();</span><br><span class="line">            <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">                <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;Service&quot;</span>)) &#123;</span><br><span class="line">                    Class&lt;?&gt; interfaceClass = Class.forName(name);</span><br><span class="line">                    Class&lt;?&gt; instanceClass = Class.forName(properties.getProperty(name));</span><br><span class="line">                    map.put(interfaceClass, instanceClass.newInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getService</span><span class="params">(Class&lt;T&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) map.get(interfaceClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关配置 application.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serializer.algorithm=Json</span><br><span class="line">cn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl</span><br></pre></td></tr></table></figure><h4 id="2）服务器-handler"><a href="#2）服务器-handler" class="headerlink" title="2）服务器 handler"></a>2）服务器 handler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequestMessage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequestMessage message)</span> </span>&#123;</span><br><span class="line">        RpcResponseMessage response = <span class="keyword">new</span> RpcResponseMessage();</span><br><span class="line">        response.setSequenceId(message.getSequenceId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取真正的实现对象</span></span><br><span class="line">            HelloService service = (HelloService)</span><br><span class="line">                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取要调用的方法</span></span><br><span class="line">            Method method = service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用方法</span></span><br><span class="line">            Object invoke = method.invoke(service, message.getParameterValue());</span><br><span class="line">            <span class="comment">// 调用成功</span></span><br><span class="line">            response.setReturnValue(invoke);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 调用异常</span></span><br><span class="line">            response.setExceptionValue(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）客户端代码第一版"><a href="#3）客户端代码第一版" class="headerlink" title="3）客户端代码第一版"></a>3）客户端代码第一版</h4><p>只发消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        RpcResponseMessageHandler RPC_HANDLER = <span class="keyword">new</span> RpcResponseMessageHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = channel.writeAndFlush(<span class="keyword">new</span> RpcRequestMessage(</span><br><span class="line">                    <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&quot;cn.itcast.server.service.HelloService&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;sayHello&quot;</span>,</span><br><span class="line">                    String.class,</span><br><span class="line">                    <span class="keyword">new</span> Class[]&#123;String.class&#125;,</span><br><span class="line">                    <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;张三&quot;</span>&#125;</span><br><span class="line">            )).addListener(promise -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (!promise.isSuccess()) &#123;</span><br><span class="line">                    Throwable cause = promise.cause();</span><br><span class="line">                    log.error(<span class="string">&quot;error&quot;</span>, cause);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）客户端-handler-第一版"><a href="#4）客户端-handler-第一版" class="headerlink" title="4）客户端 handler 第一版"></a>4）客户端 handler 第一版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponseMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5）客户端代码-第二版"><a href="#5）客户端代码-第二版" class="headerlink" title="5）客户端代码 第二版"></a>5）客户端代码 第二版</h4><p>包括 channel 管理，代理，接收结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService service = getProxyService(HelloService.class);</span><br><span class="line">        System.out.println(service.sayHello(<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line"><span class="comment">//        System.out.println(service.sayHello(&quot;lisi&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(service.sayHello(&quot;wangwu&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxyService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = serviceClass.getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = <span class="keyword">new</span> Class[]&#123;serviceClass&#125;;</span><br><span class="line">        <span class="comment">//                                                            sayHello  &quot;张三&quot;</span></span><br><span class="line">        Object o = Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1. 将方法调用转换为 消息对象</span></span><br><span class="line">            <span class="keyword">int</span> sequenceId = SequenceIdGenerator.nextId();</span><br><span class="line">            RpcRequestMessage msg = <span class="keyword">new</span> RpcRequestMessage(</span><br><span class="line">                    sequenceId,</span><br><span class="line">                    serviceClass.getName(),</span><br><span class="line">                    method.getName(),</span><br><span class="line">                    method.getReturnType(),</span><br><span class="line">                    method.getParameterTypes(),</span><br><span class="line">                    args</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// 2. 将消息对象发送出去</span></span><br><span class="line">            getChannel().writeAndFlush(msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 准备一个空 Promise 对象，来接收结果             指定 promise 对象异步接收结果线程</span></span><br><span class="line">            DefaultPromise&lt;Object&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(getChannel().eventLoop());</span><br><span class="line">            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            promise.addListener(future -&gt; &#123;</span></span><br><span class="line"><span class="comment">//                // 线程</span></span><br><span class="line"><span class="comment">//            &#125;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 等待 promise 结果</span></span><br><span class="line">            promise.await();</span><br><span class="line">            <span class="keyword">if</span>(promise.isSuccess()) &#123;</span><br><span class="line">                <span class="comment">// 调用正常</span></span><br><span class="line">                <span class="keyword">return</span> promise.getNow();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 调用失败</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(promise.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (T) o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取唯一的 channel 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123; <span class="comment">//  t2</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125;</span><br><span class="line">            initChannel();</span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 channel 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        RpcResponseMessageHandler RPC_HANDLER = <span class="keyword">new</span> RpcResponseMessageHandler();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">        bootstrap.group(group);</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line">                ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6）客户端-handler-第二版"><a href="#6）客户端-handler-第二版" class="headerlink" title="6）客户端 handler 第二版"></a>6）客户端 handler 第二版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponseMessage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//                       序号      用来接收结果的 promise 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; PROMISES = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        <span class="comment">// 拿到空的 promise</span></span><br><span class="line">        Promise&lt;Object&gt; promise = PROMISES.remove(msg.getSequenceId());</span><br><span class="line">        <span class="keyword">if</span> (promise != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object returnValue = msg.getReturnValue();</span><br><span class="line">            Exception exceptionValue = msg.getExceptionValue();</span><br><span class="line">            <span class="keyword">if</span>(exceptionValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                promise.setFailure(exceptionValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setSuccess(returnValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><h3 id="2-1-启动剖析"><a href="#2-1-启动剖析" class="headerlink" title="2.1 启动剖析"></a>2.1 启动剖析</h3><p>我们就来看看 netty 中对下面的代码是怎样进行处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span></span><br><span class="line">Selector selector = Selector.open(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span></span><br><span class="line">NioServerSocketChannel attachment = <span class="keyword">new</span> NioServerSocketChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); </span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 启动 nio boss 线程执行接下来的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span></span><br><span class="line">SelectionKey selectionKey = serverSocketChannel.register(selector, <span class="number">0</span>, attachment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6 head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7 绑定端口</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//8 触发 channel active 事件，在 head 中关注 op_accept 事件</span></span><br><span class="line">selectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><p>入口 <code>io.netty.bootstrap.ServerBootstrap#bind</code></p><p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分</span></span><br><span class="line">    <span class="comment">// 2.1 如果已经完成</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        <span class="comment">// 3.1 立刻调用 doBind0</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 2.2 还没有完成</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        <span class="comment">// 3.2 回调 doBind0</span></span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 处理异常...</span></span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line"><span class="comment">// 3. 由注册线程去执行 doBind0</span></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#initAndRegister</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 处理异常...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理异常...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码 <code>io.netty.bootstrap.ServerBootstrap#init</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里 channel 实际上是 NioServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 NioServerSocketChannel 添加初始化器</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一些检查，略...</span></span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行</span></span><br><span class="line">            <span class="comment">// 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程</span></span><br><span class="line">            <span class="comment">// 这行代码完成的事实是 main -&gt; nio boss 线程的切换</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 日志记录...</span></span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        <span class="comment">// 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel</span></span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对应 server socket channel 还未绑定，isActive 为 false</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Close the channel directly to avoid FD leak.</span></span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码 <code>io.netty.channel.ChannelInitializer#initChannel</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.add(ctx)) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2.2.1 执行初始化</span></span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2.2.2 移除初始化器</span></span><br><span class="line">            ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind0</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.1 或 3.2 执行 doBind0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</span><br><span class="line">        localAddress <span class="keyword">instanceof</span> InetSocketAddress &amp;&amp;</span><br><span class="line">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</span><br><span class="line">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</span><br><span class="line">        <span class="comment">// 记录日志...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3.3 执行端口绑定</span></span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 3.4 触发 active 事件</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.3 关键代码 <code>io.netty.channel.socket.nio.NioServerSocketChannel#doBind</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.4 关键代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line"><span class="comment">// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码 <code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="comment">// readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-NioEventLoop-剖析"><a href="#2-2-NioEventLoop-剖析" class="headerlink" title="2.2 NioEventLoop 剖析"></a>2.2 NioEventLoop 剖析</h3><p>NioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），</p><p>提交任务代码 <code>io.netty.util.concurrent.SingleThreadEventExecutor#execute</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="comment">// 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        <span class="comment">// inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread</span></span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">            <span class="comment">// 如果已经 shutdown，做拒绝逻辑，代码略...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        <span class="comment">// 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程</span></span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒 select 阻塞线程<code>io.netty.channel.nio.NioEventLoop#wakeup</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">(<span class="keyword">boolean</span> inEventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 EventLoop 主循环 <code>io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 将线程池的当前线程保存在成员变量中，以便后续使用</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 清理工作，代码略...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>io.netty.channel.nio.NioEventLoop#run</code> 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// calculateStrategy 的逻辑如下：</span></span><br><span class="line">                <span class="comment">// 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch</span></span><br><span class="line">                <span class="comment">// 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞</span></span><br><span class="line">                <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                        <span class="comment">// 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒</span></span><br><span class="line">                        <span class="comment">// 进行 select 阻塞，并设置唤醒状态为 false</span></span><br><span class="line">                        <span class="keyword">boolean</span> oldWakenUp = wakenUp.getAndSet(<span class="keyword">false</span>);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup</span></span><br><span class="line">                        <span class="comment">// 下面的 select 方法不会阻塞</span></span><br><span class="line">                        <span class="comment">// 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?</span></span><br><span class="line">                        <span class="comment">// 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时</span></span><br><span class="line">                        <span class="comment">// 才能执行，让 select 方法无谓阻塞</span></span><br><span class="line">                        select(oldWakenUp);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                            selector.wakeup();</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                rebuildSelector0();</span><br><span class="line">                handleLoopException(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// ioRatio 默认是 50</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// ioRatio 为 100 时，总是运行完所有非 IO 任务</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                </span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 记录 io 事件处理耗时</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                    <span class="comment">// 运行非 IO 任务，一旦超时会退出 runAllTasks</span></span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⚠️-注意"><a href="#⚠️-注意" class="headerlink" title="⚠️ 注意"></a>⚠️ 注意</h4><blockquote><p>这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：</p><ul><li>由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程</li><li>由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作</li></ul></blockquote><p>参考下图</p><img src="/2022/12/03/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/0032.png" class><p><code>io.netty.channel.nio.NioEventLoop#select</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">        <span class="comment">// 计算等待时间</span></span><br><span class="line">        <span class="comment">// * 没有 scheduledTask，超时时间为 1s</span></span><br><span class="line">        <span class="comment">// * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`</span></span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="comment">// 如果超时，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行</span></span><br><span class="line">            <span class="comment">// wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup</span></span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// select 有限时阻塞</span></span><br><span class="line">            <span class="comment">// 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%</span></span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            <span class="comment">// 计数加 1</span></span><br><span class="line">            selectCnt ++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">               <span class="comment">// 线程被打断，退出循环</span></span><br><span class="line">                <span class="comment">// 记录日志</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                <span class="comment">// 如果超时，计数重置为 1，下次循环就会 break</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512</span></span><br><span class="line">            <span class="comment">// 这是为了解决 nio 空轮询 bug</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                <span class="comment">// 重建 selector</span></span><br><span class="line">                selector = selectRebuildSelector(selectCnt);</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 keys <code>io.netty.channel.nio.NioEventLoop#processSelectedKeys</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet </span></span><br><span class="line">        <span class="comment">// SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）</span></span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="comment">// 当 key 取消或关闭时会导致这个 key 无效</span></span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">        <span class="comment">// 无效时处理...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        <span class="comment">// 连接事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可写事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可读或可接入事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</span></span><br><span class="line">            <span class="comment">// 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</span></span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-accept-剖析"><a href="#2-3-accept-剖析" class="headerlink" title="2.3 accept 剖析"></a>2.3 accept 剖析</h3><p>nio 中如下代码，在 netty 中的流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 阻塞直到事件发生</span></span><br><span class="line">selector.select();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;    </span><br><span class="line">    <span class="comment">//2 拿到一个事件</span></span><br><span class="line">    SelectionKey key = iter.next();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3 如果是 accept 事件</span></span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4 执行 accept</span></span><br><span class="line">        SocketChannel channel = serverSocketChannel.accept();</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5 关注 read 事件</span></span><br><span class="line">        channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看可接入事件处理（accept）</p><p><code>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();    </span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf</span></span><br><span class="line">                <span class="comment">// readBuf 是一个 ArrayList 用来缓存消息</span></span><br><span class="line">                <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">                <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    closed = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// localRead 为 1，就一条消息，即接收一个客户端连接</span></span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            exception = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理</span></span><br><span class="line">            <span class="comment">// io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</span></span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        readBuf.clear();</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closed = closeOnReadError(exception);</span><br><span class="line"></span><br><span class="line">            pipeline.fireExceptionCaught(exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">                close(voidPromise());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码 <code>io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这时的 msg 是 NioSocketChannel</span></span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NioSocketChannel 添加  childHandler 即初始化器</span></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置选项</span></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程</span></span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又回到了熟悉的 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code>  方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一些检查，略...</span></span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这行代码完成的事实是 nio boss -&gt; nio worker 线程的切换</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 日志记录...</span></span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        <span class="comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span></span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                <span class="comment">// 触发 pipeline 上 active 事件</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到了熟悉的代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line"><span class="comment">// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 这时候 interestOps 是 0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 关注 read 事件</span></span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-read-剖析"><a href="#2-4-read-剖析" class="headerlink" title="2.4 read 剖析"></a>2.4 read 剖析</h3><p>再来看可读事件 <code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class="line">        clearReadPending();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="comment">// io.netty.allocator.type 决定 allocator 的实现</span></span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="comment">// 用来分配 byteBuf，确定单次读取大小</span></span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            <span class="comment">// 读取</span></span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">            <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuf.release();</span><br><span class="line">                byteBuf = <span class="keyword">null</span>;</span><br><span class="line">                close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                    readPending = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler</span></span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = <span class="keyword">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 是否要继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        <span class="comment">// 触发 read complete 事件</span></span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">continueReading</span><span class="params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">           <span class="comment">// 一般为 true</span></span><br><span class="line">           config.isAutoRead() &amp;&amp;</span><br><span class="line">           <span class="comment">// respectMaybeMoreData 默认为 true</span></span><br><span class="line">           <span class="comment">// maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true</span></span><br><span class="line">           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;</span><br><span class="line">           <span class="comment">// 小于最大次数，maxMessagePerRead 默认 16</span></span><br><span class="line">           totalMessages &lt; maxMessagePerRead &amp;&amp;</span><br><span class="line">           <span class="comment">// 实际读到了数据</span></span><br><span class="line">           totalBytesRead &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四-优化与源码&quot;&gt;&lt;a href=&quot;#四-优化与源码&quot; class=&quot;headerlink&quot; title=&quot;四. 优化与源码&quot;&gt;&lt;/a&gt;四. 优化与源码&lt;/h1&gt;&lt;h2 id=&quot;1-优化&quot;&gt;&lt;a href=&quot;#1-优化&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Netty" scheme="https://castile.github.io/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://castile.github.io/tags/Netty/"/>
    
  </entry>
  
</feed>
