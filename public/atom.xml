<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Castile</title>
  
  
  <link href="https://castile.github.io/atom.xml" rel="self"/>
  
  <link href="https://castile.github.io/"/>
  <updated>2024-11-11T15:45:16.290Z</updated>
  <id>https://castile.github.io/</id>
  
  <author>
    <name>朱宏梁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>领域驱动设计05-识别限界上下文</title>
    <link href="https://castile.github.io/2024/11/11/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A105-%E8%AF%86%E5%88%AB%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://castile.github.io/2024/11/11/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A105-%E8%AF%86%E5%88%AB%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2024-11-11T15:45:16.000Z</published>
    <updated>2024-11-11T15:45:16.290Z</updated>
    
    <content type="html"><![CDATA[<p>Mike说： “限界上下文是领域驱动设计中最难解释的原则，但或许也是最重要的原则，可以说，没有限界上下文，就不能做领域驱动设计。在了解聚合根（Aggregate Root）、聚合（Aggregate）、实体（Entity）等概念之前，需要先了解限界上下文。”</p><blockquote><p>如何在DDD中识别出正确的限界上下文？ </p><p>答： <strong>凭经验</strong> (正确的废话)</p></blockquote><p>在《程序员的思维修炼》说道： 专家凭直觉工作，而不需要理由。 这说明了这是经验的积累，通过实践无数的项目得出的经验。</p><p>限界上下文就是“<strong>边界</strong>”，这与面向对象设计中的<strong>职责分配</strong>其实是同一道理。限界上下文的识别并不是一蹴而就的，需要演化和迭代。</p><blockquote><p><strong>通过从业务边界到工作边界再到应用边界这三个层次抽丝剥茧，分别以不同的视角、不同的角色协作来运用对应的设计原则，会是一个可行的识别限界上下文的过程方法</strong></p></blockquote><p>整体过程如下：</p><img src="/2024/11/11/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A105-%E8%AF%86%E5%88%AB%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20241110230812456.png" class title="image-20241110230812456"><h2 id="1、从业务边界识别限界上下文"><a href="#1、从业务边界识别限界上下文" class="headerlink" title="1、从业务边界识别限界上下文"></a>1、从业务边界识别限界上下文</h2><p>分析业务场景围绕着“领域”来开展：</p><ol><li> 明确系统问题也业务期望</li><li>和领域专家交流，梳理业务流程</li><li>识别参与者/业务活动/业务价值</li><li>在业务流程的基础上抽象业务场景</li><li>一个业务场景由多个业务活动组成</li><li>采用用例对场景进行分析，一个业务活动就是一个用例</li></ol><p><strong>业务流程是一个由多个用户角色参与的动态过程，而业务场景则是这些用户角色执行业务活动的静态上下文</strong>。从业务流程中抽象出来的业务场景可能是交叉重叠的。</p><p>例如，在针对一款文学阅读产品进行需求分析时，可以根据得到的业务流程划分不同的业务场景：</p><ul><li>阅读作品</li><li>创作作品</li><li>支付</li><li>社交</li><li>消息通知</li><li>注册与登录</li></ul><p>接下来，我们利用领域场景分析的用例分析方法剖析这些场景。我们往往通过参与者（Actor）来驱动对用例的识别，这些参与者恰好就是参与到场景业务活动的角色。根据用例描述出来的业务活动应该与统一语言一致，最好直接从统一语言中撷取。业务活动的描述应该精准地表达领域概念，且通过尽可能简洁的方式进行描述，通常格式为动宾形式。以阅读作品场景为例，可以包括如下业务活动：</p><ul><li>查询作品</li><li>收藏作品</li><li>关注作者</li><li>浏览作品目录</li><li>阅读作品</li><li>标记作品内容</li><li>撰写读书笔记</li><li>评价作品</li><li>评价作者</li><li>分享选中的作品内容</li><li>分享作品链接</li><li>购买作品</li></ul><p>一旦准确地用统一语言描述出这些业务活动，我们就可以从如下两个方面识别业务边界，进而提炼出初步的限界上下文：</p><ul><li>语义相关性</li><li>功能相关性</li></ul><h3 id="1-1-语义相关性"><a href="#1-1-语义相关性" class="headerlink" title="1.1 语义相关性"></a>1.1 语义相关性</h3><p><strong>语义角度去分析业务活动的描述，倘若是相同的语义，可以作为归类的特征</strong>。</p><p>识别语义相关性的前提是准确地使用统一语言描述业务活动。在描述时，应尽量避免使用“管理（manage）”或“维护（maintain）”等过于抽象的词语。抽象的词语容易让我们忽视隐藏的领域语言，缺少对领域的精确表达。</p><p>在进行语义相关性判断时，还需要注意业务活动之间可能存在不同的语义相关性。</p><h3 id="1-2-功能相关性"><a href="#1-2-功能相关性" class="headerlink" title="1.2 功能相关性"></a>1.2 功能相关性</h3><p><strong>从功能角度去分析业务活动是否彼此关联和依赖，倘若存在关联和依赖，可以作为归类的特征</strong>，这种关联性，代表了功能之间的相关性。倘若两个功能必须同时存在，又或者缺少一个功能，另一个功能是不完整的，则二者就是功能强相关的。</p><p>所谓“功能相关性”，指的就是职责的内聚性，强相关就等于高内聚。故而从这个角度看，功能相关性的判断标准恰好符合“高内聚、松耦合”的设计原则。</p><p><strong>两个相关的功能未必一定属于同一个限界上下文</strong>。例如，购买作品与支付购买费用是功能相关的，且前者依赖于后者，但后者从领域知识的角度判断，却应该分配给支付上下文，我们非但不能将其紧耦合在一起，还应该竭尽所能降低二者之间的耦合度。</p><p>事实上，<strong>功能相关性往往会与上下文之间的协作关系有关</strong>。由于这种功能相关性恰恰对应了用例之间的包含与扩展关系，它们往往又可成为识别限界上下文边界的关键点。我在后面讲解上下文映射时还会详细阐释。</p><p>接下来就可以为业务领域进行命名了。</p><h2 id="2、-从工作边界识别限界上下文"><a href="#2、-从工作边界识别限界上下文" class="headerlink" title="2、 从工作边界识别限界上下文"></a>2、 从工作边界识别限界上下文</h2><p>如果说为限界上下文划分业务边界，更多的是从业务相关性（内聚）判断业务的归属，那么基于团队合作划分工作边界可以<strong>帮助我们确定限界上下文合理的工作粒度</strong>。</p><p>工作分配的基础在于“尽可能降低沟通成本”，遵循康威定律，沟通其实就是项目模块之间的依赖，这个过程同样不是一蹴而就的。康威认为：</p><blockquote><p>在大多数情况下，最先产生的设计都不是最完美的，主导的系统设计理念可能需要更改。因此，组织的灵活性对于有效的设计有着举足轻重的作用，必须找到可以鼓励设计经理保持他们的组织精简与灵活的方法。</p></blockquote><p>特性团队正是用来解决这一问题的。换言之，当我们发现团队规模越来越大，失去了组织精简与灵活的优势，实际上就是在传递限界上下文过大的信号。项目经理对此需要有清醒认识，当团队规模违背了 2PTs 时，就该坐下来讨论一下如何细分团队的问题了。因此，按照团队合作的角度划分限界上下文，其实是一个动态的过程、演进的过程。</p><p>如果我们从团队合作层面看待限界上下文，就从技术范畴上升到了管理范畴。Jurgen Appelo 在《管理 3.0：培养和提升敏捷领导力（Management 3.0: Leading Agile Developers，Developing Agile Leaders）》这本书中提到，一个高效的团队需要满足两点要求：</p><ul><li>共同的目标</li><li>团队的边界</li></ul><p>书中对边界的阐释，大致包括：</p><ul><li><strong>团队成员应对团队的边界形成共识</strong>，这就意味着团队成员需要了解自己负责的限界上下文边界，以及该限界上下文如何与外部的资源以及其他限界上下文进行通信。</li><li><strong>团队的边界不能太封闭（拒绝外部输入），也不能太开放（失去内聚力），即所谓的“渗透性边界”</strong>，这种渗透性边界恰恰与“高内聚、松耦合”的设计原则完全契合。</li></ul><p>针对这种“渗透性边界”，团队成员需要对自己负责开发的需求“抱有成见”，在识别限界上下文时，“任劳任怨”的好员工并不是真正的好员工。一个好的员工明确地知道团队的职责边界，他应该学会勇于承担属于团队边界内的需求开发任务，也要敢于推辞职责范围之外强加于他的需求。通过团队每个人的主观能动，就可以渐渐地形成在组织结构上的“自治单元”，进而催生出架构设计上的“自治单元”。同理，“任劳任怨”的好团队也不是真正的好团队，团队对自己的边界已经达成了共识，为什么还要违背这个共识去承接不属于自己边界内的工作呢？这并非团队之间的“恶性竞争”，也不是工作上的互相推诿；<strong>恰恰相反，这实际上是一种良好的合作，表面上维持了自己的利益，然而在一个组织下，如果每个团队都以这种方式维持自我利益，反而会形成一种“互利主义”。</strong></p><p>这种“你给我搔背，我也替你抓抓痒”的互利主义最终会形成团队之间的良好协作。如果团队领导者与团队成员能够充分认识到这一点，就可以从团队层面思考限界上下文。此时，限界上下文就不仅仅是架构师局限于一孔之见去完成甄别，而是每个团队成员自发组织的内在驱动力。当每个人都在思考这项工作该不该我做时，变相地就是在思考职责的分配是否合理，限界上下文的划分是否合理。</p><h2 id="3、-从应用边界识别限界上下文"><a href="#3、-从应用边界识别限界上下文" class="headerlink" title="3、 从应用边界识别限界上下文"></a>3、 从应用边界识别限界上下文</h2><h3 id="3-1-质量属性"><a href="#3-1-质量属性" class="headerlink" title="3.1 质量属性"></a>3.1 质量属性</h3><p>管理的目的在于<strong>打造高效的团队</strong>，但最后还是要落脚到技术实现上来，不懂业务分析的架构师不是一个好的程序员，而一个不懂得提前识别系统风险的程序员更不是一个好的架构师。站在技术层面上看待限界上下文，我们需要关注的其实是质量属性（Quality Attributes）。如果把关乎质量属性的问题都视为在将来可能会发生，其实就是“风险（Risk）”。</p><p>架构是什么？Martin Fowler 认为：架构是重要的东西，是不容易改变的决策。如果我们未曾预测到系统存在的风险，不幸它又发生了，带给系统架构的改变可能是灾难性的。利用限界上下文的边界，就可以将这种风险带来的影响控制在一个极小的范围，这也是前面提及的<strong>安全</strong>。为什么说限界上下文是领域驱动设计中最重要的元素，答案就在这里。</p><h3 id="3-2-重用和变化"><a href="#3-2-重用和变化" class="headerlink" title="3.2 重用和变化"></a>3.2 重用和变化</h3><p>无论是重用领域逻辑还是技术实现，都是在设计层面上我们必须考虑的因素，需求变化更是影响设计策略的关键因素。我在前面分析限界上下文的本质时，就提及一个限界上下文其实是一个“自治”的单元。基于自治的四个特征，我们也可以认为这个自治的单元其实就是逻辑重用和封装变化的设计单元。这时，对限界上下文边界的考虑，更多是出于技术设计因素，而非业务因素。</p><p>运用重用原则分离出来的限界上下文往往对应于子领域（Sub Domain），尤其作为支撑子领域。限界上下文对变化的应对，其实是“单一职责原则”的体现，即一个限界上下文不应该存在两个引起它变化的原因。</p><h3 id="3-3-遗留系统"><a href="#3-3-遗留系统" class="headerlink" title="3.3 遗留系统"></a>3.3 遗留系统</h3><p>自治原则的唯一例外是遗留系统，因为领域驱动设计建议的通常做法是将整个遗留系统视为一个限界上下文。那么，什么是遗留系统？根据维基百科的定义，它是一种旧的方法、旧的技术、旧的计算机系统或应用程序，这个定义并不能解释遗留系统的真相。我认为，系统之所以成为遗留系统，关键在于<strong>知识的缺乏</strong>。文档不够全面真实，掌握系统知识的团队成员泰半离开，系统的代码可能是一个大泥团。因此，我对遗留系统的定义是“<strong>一个还在运行和使用，但已步入软件生命衰老期的缺乏足够知识的软件系统</strong>”。</p><p>倘若运用领域驱动设计的系统要与这样一个遗留系统打交道，应该怎么办？窃以为，粗暴地将整个遗留系统包裹在一个限界上下文中，未免太理想化和简单化了。要点还是<strong>自治</strong>，这时候我们应该站在遗留系统的调用者来观察它，考虑如何与遗留系统集成，然后逐步对遗留系统进行抽取与迁移，形成自治的限界上下文。</p><p>在这个过程中，我们可以借鉴技术栈迁移中常常运用的“抽象分支（Branch By Abstraction）”手法。该手法会站在消费者（Consumer）一方观察遗留系统，找到需要替换的单元（组件）；然后对该组件进行抽象，从而将消费者与遗留系统中的实现解耦。最后，提供一个完全新的组件实现，在保留抽象层接口不变的情况下替换掉遗留系统的旧组件，达到技术栈迁移的目的：</p><img src="/2024/11/11/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A105-%E8%AF%86%E5%88%AB%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20241111234110360.png" class title="image-20241111234110360"><p>如上图所示的抽象层，其实也称之为“防腐层（Anticorruption Layer）”，通过引入这么一个间接层来隔离与遗留系统之间的耦合。这个防腐层往往是作为下游限界上下文的一部分存在。若有必要，也可以单独为其创建一个独立的限界上下文。</p><h2 id="4、-设计驱动力"><a href="#4、-设计驱动力" class="headerlink" title="4、 设计驱动力"></a>4、 设计驱动力</h2><p>通过以上过程去识别限界上下文，仅仅是一种对领域问题域的静态划分，我们还缺少另外一个重要的关注点，即：限界上下文之间是如何协作的？倘若限界上下文识别不合理，协作就会变得更加困难，尤其当一个限界上下文对应一个微服务时，协作成本更会显著增加。反过来，当我们发现彼此协作存在问题时，说明限界上下文的划分出现了问题，这算是对识别限界上下文的一种验证方法。Eric Evans 将这种体现限界上下文协作方式的要素称之为“上下文映射（Context Map）”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Mike说： “限界上下文是领域驱动设计中最难解释的原则，但或许也是最重要的原则，可以说，没有限界上下文，就不能做领域驱动设计。在了解聚合根（Aggregate Root）、聚合（Aggregate）、实体（Entity）等概念之前，需要先了解限界上下文。”&lt;/p&gt;
&lt;bl</summary>
      
    
    
    
    <category term="领域驱动设计" scheme="https://castile.github.io/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="DDD" scheme="https://castile.github.io/tags/DDD/"/>
    
    <category term="领域驱动设计" scheme="https://castile.github.io/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="限界上下文" scheme="https://castile.github.io/tags/%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>nebula图数据库</title>
    <link href="https://castile.github.io/2024/11/07/nebula%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://castile.github.io/2024/11/07/nebula%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2024-11-07T14:04:28.000Z</published>
    <updated>2024-11-07T14:51:46.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图数据库概述"><a href="#图数据库概述" class="headerlink" title="图数据库概述"></a>图数据库概述</h1><p>图数据库是专门存储庞大的图形网络并从中检索信息的数据库。它可以将图中的数据高效存储为点（Vertex）和边（Edge），还可以将属性（Property）附加到点和边上。</p><img src="/2024/11/07/nebula%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/图数据库概述.png" alt="image-20241107220209927" style="zoom:50%;"><p>图数据库适合存储大多数从现实抽象出的数据类型。世界上几乎所有领域的事物都有内在联系，像关系型数据库这样的建模系统会提取实体之间的关系，并将关系单独存储到表和列中，而实体的类型和属性存储在其他列甚至其他表中，这使得数据管理费时费力。</p><p>NebulaGraph 作为一个典型的图数据库，可以将丰富的关系通过边及其类型和属性自然地呈现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图数据库概述&quot;&gt;&lt;a href=&quot;#图数据库概述&quot; class=&quot;headerlink&quot; title=&quot;图数据库概述&quot;&gt;&lt;/a&gt;图数据库概述&lt;/h1&gt;&lt;p&gt;图数据库是专门存储庞大的图形网络并从中检索信息的数据库。它可以将图中的数据高效存储为点（Vertex）和边（</summary>
      
    
    
    
    <category term="图计算" scheme="https://castile.github.io/categories/%E5%9B%BE%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="nebula" scheme="https://castile.github.io/tags/nebula/"/>
    
    <category term="图数据库" scheme="https://castile.github.io/tags/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java四大引用类型</title>
    <link href="https://castile.github.io/2024/11/07/%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/"/>
    <id>https://castile.github.io/2024/11/07/%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/</id>
    <published>2024-11-07T12:48:59.496Z</published>
    <updated>2024-11-07T12:48:59.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四大引用类型"><a href="#四大引用类型" class="headerlink" title="四大引用类型"></a>四大引用类型</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><p>当内存不足。JVM开始垃圾回收，对于强引用的对象，<strong>就算是出现了OOM也不会对该对象进行回收，死都不收。</strong></p><p>强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还活着。垃圾收集器不会碰这种对象。Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，他是不可能被垃圾回收机制回收的。<strong>即使该对象以后永远都不会被用到，jvm也不会回收</strong>。因此，<strong>强引用是造成Java内存泄露的主要原因之一。</strong></p><p>对于一个普通对象，如果没有其他的引用关系，只要超过了引用的作用域或者显示的将强引用赋值为null，一般就认为就是可以被垃圾收集的了，当然具体回收时机还要看垃圾收集策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.reference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-26-20:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这样定义的默认是强引用</span></span><br><span class="line">        Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object obj2 = obj1; <span class="comment">// obj2引用赋值</span></span><br><span class="line">        obj1 = <span class="keyword">null</span>;<span class="comment">// 置为null</span></span><br><span class="line">        System.gc(); <span class="comment">// 并不会马上执行垃圾回收 执行System.gc()函数的作用只是提醒或告诉虚拟机，希望进行一次垃圾回收。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>java.lang.Object@1540e19d</p></blockquote><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><p>软引用通常用在对内存才能敏感的程序中，比如高速缓存就有用到软引用，内存够的时候就保留，不够就回收。</p><p>先设置JVM参数： -Xmx20m，  heap内存为20M</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-26-20:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[] &gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1224</span>*<span class="number">10</span>]);</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line">        <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>]; <span class="comment">//再分配一个数组，heap将装不下，这时系统会进行垃圾回收，先回收一次，如果不够，就会把软引用回收</span></span><br><span class="line"></span><br><span class="line">        System.out.println(softReference.get());  <span class="comment">// 回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>[B@1540e19d<br>[B@1540e19d<br>null</p></blockquote><p>假如有一个应用需要读取大量的本地图片，如果每一次读取图片都是从硬盘中读取则会严重影响性能；如果一次性全部加载到内存中又可能造成内存溢出。</p><p>此时可以使用软引用来解决这个问题。</p><p>设计思路： 用一个HashMap来保存图片的路径和相应图片对象的软引用之间的映射关系，在内存不足时候，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imgCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>被弱引用关联的对象<strong>一定会被回收</strong>，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来创建弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-26-20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakRederenceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakReference&lt;M&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> M());</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>cn.hongliang.reference.M@1540e19d<br>null<br>finalize</p></blockquote><h3 id="weakHashMap"><a href="#weakHashMap" class="headerlink" title="weakHashMap"></a>weakHashMap</h3><p>待补充…</p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p><p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来创建虚引用。</p><p>顾名思义，就是<strong>形同虚设</strong>。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。他不能单独使用，也不能通过他访问对象。虚引用必须和引用队列（ReferenceQueue）联合使用。</p><p>虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize以后做某些事情的机制。PhantomReference 的get方法总是返回null。因此无法访问对应的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收。用来实现比finalization机制更灵活的回收操作。</p><p>换句话说，设置虚引用关联的唯一目的就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步处理。java技术允许使用finalize方法在垃圾收集器将对象从内存中移除出去之前 做必要的清理工作。</p><p>实际上，这个和<strong>直接内存</strong>有关。虚引用的作用就是为了管理直接内存。</p><p>我们程序的内存通常是由JVM来管理的，垃圾回收器是工作在JVM里面，但是为了提高效率，比如说，当OS收到了网络发送来的数据，会通过OS的系统内核的方法将传来的数据放在OS的内存里面，如果Java程序要用的话，需要从OS的内存中copy过来，这样的效率太低了。所以在新版的JVM中提供了一个直接内存（DirectByteBuffer），他可以通过虚拟机的一个指针直接指向OS管理的内存中。可以直接访问操作系统的内存，这样就不需要copy一份了。</p><img src="/2024/11/07/%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/image-20200826210428327.png" class title="image-20200826210428327"><p>那么JVM怎么回收这部分系统内存呢？</p><p>内部机制就是用的虚引用，虚引用new的时候，执指向一个对象，这个对象要回收的时候，会将其放入一个队列里面，相当于跟踪这个对象。主要分为两步，第一步将其放入队列，第二步是通过队列来进行回收的。需要回收的时候发起一个通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-26-20:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Object&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;M&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PhantomReference&lt;M&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> M(), queue);</span><br><span class="line">        System.out.println(phantomReference.get());</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(phantomReference.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Reference&lt;? extends M&gt; poll = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(poll != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;虚引用被JVM回收了...&quot;</span> + poll);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><img src="/2024/11/07/%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8/image-20200826211425980.png" class title="image-20200826211425980"></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;四大引用类型&quot;&gt;&lt;a href=&quot;#四大引用类型&quot; class=&quot;headerlink&quot; title=&quot;四大引用类型&quot;&gt;&lt;/a&gt;四大引用类型&lt;/h1&gt;&lt;h2 id=&quot;强引用&quot;&gt;&lt;a href=&quot;#强引用&quot; class=&quot;headerlink&quot; title=&quot;强引用</summary>
      
    
    
    
    <category term="Java高并发" scheme="https://castile.github.io/categories/Java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Thread" scheme="https://castile.github.io/tags/Thread/"/>
    
    <category term="多线程" scheme="https://castile.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例设计模式</title>
    <link href="https://castile.github.io/2024/11/07/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://castile.github.io/2024/11/07/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-11-07T12:48:59.495Z</published>
    <updated>2024-11-07T12:48:59.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><h1 id="涉及到的知识点"><a href="#涉及到的知识点" class="headerlink" title="涉及到的知识点"></a>涉及到的知识点</h1><ol><li>类加载机制</li><li>字节码知识</li><li>jvm指令重排序</li><li>java序列化机制</li></ol><h1 id="定义及应用场景"><a href="#定义及应用场景" class="headerlink" title="定义及应用场景"></a>定义及应用场景</h1><p>保证一个类只有一个实例，并且提供一个全局访问点</p><p>场景： 线程池、数据库连接池</p><h1 id="单例设计模式八种方式"><a href="#单例设计模式八种方式" class="headerlink" title="单例设计模式八种方式"></a>单例设计模式八种方式</h1><ol><li>饿汉式**(<strong>静态常量</strong>)**</li><li>饿汉式（静态代码块）</li><li>懒汉式(线程不安全)</li><li> 懒汉式(线程安全，同步方法)</li><li>懒汉式(线程安全，同步代码块)</li><li> 双重检查</li><li>静态内部类</li><li>枚举</li></ol><h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><p>使用的时候才开始初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>; <span class="comment">// 单例对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 私有化构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.要想让一个类只能构建一个对象，自然不能让它随便去做new操作，因此Signleton的构造方法是私有的。</p><p>2.instance是Singleton类的静态成员，也是我们的单例对象。它的初始值可以写成Null，也可以写成new Singleton()。至于其中的区别后来会做解释。</p><p>3.getInstance是获取单例对象的方法。</p><p>如果单例初始值是null，还未构建，则构建单例对象并返回。这个写法属于单例模式当中的<strong>懒汉模式。</strong></p><p>如果单例对象一开始就被new Singleton()主动构建，则不再需要判空操作，这种写法属于<strong>饿汉模式</strong>。</p><p>这两个名字很形象：饿汉主动找食物吃，懒汉躺在地上等着人喂</p></blockquote><p>但是上面的代码并不安全，为啥？在多线程的环境下去创建会导致返回多个不同的实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 模拟两个线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123; LazySingleton l1 = getInstance();</span><br><span class="line">            System.out.println(l1);&#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123; LazySingleton l1 = getInstance();</span><br><span class="line">            System.out.println(l1);&#125;).start();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>; <span class="comment">// 单例对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 私有化构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);  <span class="comment">// 休眠2秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>cn.hongliang.singleton.LazySingleton@6afa9656<br>cn.hongliang.singleton.LazySingleton@2b3351f2</p></blockquote><p>可以看到创建了两个不同的实例对象，单例失效了！</p><p>假设Singleton类刚刚被初始化，instance对象还是空，这时候两个线程同时访问getInstance方法：  因为Instance是空，所以两个线程同时通过了条件判断，开始执行new操作： </p><img src="/2024/11/07/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1596726027608.png" class width="1596726027608"><p>这样的话两个线程分别创建一个实例。</p><p>对于线程不安全的问题，我们很直观的就想到加锁，使用synchronized关键字，改写代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>; <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class)&#123; <span class="comment">//  注意，这里要锁类</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123; <span class="comment">// 双重检测机制</span></span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>细节问题：</p><ol><li><p> 为了防止new Singleton被执行多次，因此在<strong>new操作之前</strong>加上<code>Synchronized</code> 同步锁，锁住整个类（注意，这里不能使用对象锁）。 因为锁实例是锁不到的，每个线程还是可以进来。</p></li><li><p>在拿到锁之后，进入到 Synchronized 临界区以后，还要再做一次判空。 因为如果一个线程已经创建了一个实例，下一个进程进来的时候也会执行一次new Singleton操作，这样又创建了两个对象，所以这里要加上双重检测机制。</p></li></ol></blockquote><p>但是上面的代码还是有漏洞， 这就涉及到了JVM 的指令重排序问题了。</p><p>指令重排序：JVM会根据cpu的执行情况，改变程序指令的执行顺序。我们创建一个对象的时候经历了很多步操作，1. 加载： 加载对应的二进制字节码文件，并且在方法区创建对应的数据结构，2. 连接： a. 验证 b.解析 c.初始化， 3. 初始化： 给静态属性赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">  Last modified 2020-8-8; size 435 bytes</span><br><span class="line">  MD5 checksum 3b5f34a0e7b4eb8045214ecd6c8a007d</span><br><span class="line">  Compiled from <span class="string">&quot;User.java&quot;</span></span><br><span class="line">public class cn.hongliang.singleton.User</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   <span class="comment">#1 = Methodref          #4.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#2 = Class              #20            // cn/hongliang/singleton/User</span></span><br><span class="line">   <span class="comment">#3 = Methodref          #2.#19         // cn/hongliang/singleton/User.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#4 = Class              #21            // java/lang/Object</span></span><br><span class="line">   <span class="comment">#5 = Utf8               &lt;init&gt;</span></span><br><span class="line">   <span class="comment">#6 = Utf8               ()V</span></span><br><span class="line">   <span class="comment">#7 = Utf8               Code</span></span><br><span class="line">   <span class="comment">#8 = Utf8               LineNumberTable</span></span><br><span class="line">   <span class="comment">#9 = Utf8               LocalVariableTable</span></span><br><span class="line">  <span class="comment">#10 = Utf8               this</span></span><br><span class="line">  <span class="comment">#11 = Utf8               Lcn/hongliang/singleton/User;</span></span><br><span class="line">  <span class="comment">#12 = Utf8               main</span></span><br><span class="line">  <span class="comment">#13 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#14 = Utf8               args</span></span><br><span class="line">  <span class="comment">#15 = Utf8               [Ljava/lang/String;</span></span><br><span class="line">  <span class="comment">#16 = Utf8               user</span></span><br><span class="line">  <span class="comment">#17 = Utf8               SourceFile</span></span><br><span class="line">  <span class="comment">#18 = Utf8               User.java</span></span><br><span class="line">  <span class="comment">#19 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  <span class="comment">#20 = Utf8               cn/hongliang/singleton/User</span></span><br><span class="line">  <span class="comment">#21 = Utf8               java/lang/Object</span></span><br><span class="line">&#123;</span><br><span class="line">  public cn.hongliang.singleton.User();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcn/hongliang/singleton/User;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           <span class="comment">#2                  // class cn/hongliang/singleton/User</span></span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial <span class="comment">#3                  // Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         7: astore_1</span><br><span class="line">         8: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 10: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">            8       1     1  user   Lcn/hongliang/singleton/User;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;User.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指向简单的一个new对象操作，会执行以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1：分配对象的内存空间 </span><br><span class="line"></span><br><span class="line">ctorInstance(memory);  //2：初始化对象 </span><br><span class="line"></span><br><span class="line">instance =memory;     //3：设置instance指向刚分配的内存地址 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这几条指令不是一成不变的，有可能会经过JVM和CPU的优化，指令重排成下面的顺序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();  //1：分配对象的内存空间 </span><br><span class="line"></span><br><span class="line">instance =memory;   //3：设置instance指向刚分配的内存地址 </span><br><span class="line"></span><br><span class="line">ctorInstance(memory); //2：初始化对象 </span><br></pre></td></tr></table></figure><p>当执行到第二条的时候，对象已经创建了，但是对象没有完成初始化，是一个不完整的对象。而此时线程T2 抢占到了cpu，在第一个if判断语句，得到的结果是不为空，然后直接返回此对象。这样得到的是一个未经过初始化的一个对象，之后很可能会出现空指针异常。</p><img src="/2024/11/07/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1596870204355.png" class width="1596870204355"><p>解决方法是使用volatile关键字，次关键字可以禁止指令重排序。所以改进后的单例设计模式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>; <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class)&#123; <span class="comment">//  注意，这里要锁类</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123; <span class="comment">// 双重检测机制</span></span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如此在线程T2看来，instance对象的引用要么指向null，要么指向一个初始化完毕的Instance，而不会出现某个中间态，保证了安全。 </p><h1 id="synchronized改为reentranlock如何写"><a href="#synchronized改为reentranlock如何写" class="headerlink" title="synchronized改为reentranlock如何写"></a>synchronized改为reentranlock如何写</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LockSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">LockSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LockSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">           lock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   instance  = <span class="keyword">new</span> LockSingleton();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           instance = getInstance();</span><br><span class="line">           System.out.println(instance);</span><br><span class="line">       &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            instance = getInstance();</span><br><span class="line">            System.out.println(instance);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h1><p>在类加载阶段就完成了实例化。通过类加载机制来保证线程安全</p><p>类加载有是三个步骤<br>加载： 加载对应的二进制字节码文件，并且在方法区创建对应的数据结构</p><p>连接： a. 验证 b.解析 c.初始化</p><p>初始化： 给静态属性赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungarySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungarySingleton instance = <span class="keyword">new</span> HungarySingleton();</span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungarySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有的方法返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungarySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>   优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</p></li><li><p>   缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p></li></ol><h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li> 从外部无法访问静态内部类<code>InstanceHolder</code>，只有当调用<code>Singleton.getInstance</code>方法的时候，才能得到单例对象<code>INSTANCE</code>。 </li><li> <code>INSTANCE</code>对象初始化的时机并不是在单例类<code>Singleton</code>被加载的时候，而是在调用<code>getInstance</code>方法，使得静态内部类<code>InstanceHolder</code>被加载的时候。因此这种实现方式是利用<strong>classloader的加载机制</strong>来实现<strong>懒加载</strong>，并保证构建单例的线程安全。 </li></ol><p>可以看到，使用静态内部类的方法创建单例对象是很巧妙的，但是，和以上方法一样，都不能阻止使用反射机制来创建，也就是说，反射机制会打破上述单例模式。</p><p>来看看是怎么实现的。</p><h1 id="反射打破单例"><a href="#反射打破单例" class="headerlink" title="反射打破单例"></a>反射打破单例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefectSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 首先获得构造器</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.hongliang.singleton.Singleton&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; declaredConstructor = clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">// 因为构造方法是private的， 所以设置暴力反射</span></span><br><span class="line">        declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Singleton s1= (Singleton) declaredConstructor.newInstance();</span><br><span class="line">        Singleton s2= (Singleton) declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.hashCode() == s2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>false<br>false</p></blockquote><p>可以看到创建的两个实例对象，所以破坏了单例。</p><p>接下来介绍一下使用枚举类的方法来创建单例对象，枚举的方式可以阻止反射。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span>  <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</li><li>缺点就是并不是使用懒加载的方式实现的。</li><li>这种方式是 <strong>Effective Java</strong> 作者 <strong>Josh Bloch</strong> 提倡的方式.</li></ol><p>如果使用反射来创建实例，会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefectSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        SingletonEnum singletonEnum1 = SingletonEnum.class.getDeclaredConstructor().newInstance();</span><br><span class="line">        SingletonEnum singletonEnum2 = SingletonEnum.class.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(singletonEnum1 == singletonEnum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Exception in thread “main” java.lang.NoSuchMethodException: cn.hongliang.singleton.SingletonEnum.&lt;init&gt;()<br>at java.lang.Class.getConstructor0(Class.java:3082)<br>at java.lang.Class.getDeclaredConstructor(Class.java:2178)<br>at cn.hongliang.singleton.RefectSingleton.main(RefectSingleton.java:24)</p></blockquote><p>刚刚说了枚举既可以防止反射创建单例也能够防止反序列化创建新的对象，我们继续看看什么是序列化。</p><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h2><p>序列化就是将java对象编码成二进制文件，课保存在磁盘中。</p><p>反序列化就是从文件中解码成一个对象。</p><h2 id="怎么实现序列化"><a href="#怎么实现序列化" class="headerlink" title="怎么实现序列化"></a>怎么实现序列化</h2><p>java对象实现<code>Serializable</code>接口，通过<code>ObjectOutputStream</code>， <code>ObjectInputputStream</code>实现序列化和反序列化。</p><h2 id="什么样的数据会序列化到文件中"><a href="#什么样的数据会序列化到文件中" class="headerlink" title="什么样的数据会序列化到文件中"></a>什么样的数据会序列化到文件中</h2><p>对象的默认序列化机制写入的内容是：对象的类，类签名，以及<strong>非瞬态</strong>（<code>transit</code>）和<strong>非静态</strong>字段的值，因为静态static的东西在方法区。</p><p>所以序列化的数据是在堆中的，将堆中数据的生命周期延长，持久化到文件，保存到磁盘中，文件扩展名是.object， 当我们以后想要使用这个类的时候就不需要new了，直接从文件中读取就行。</p><h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p> <code>SerializableUID</code>号是根据类的特征和类的签名算出来的 ，主要用于判断是否为同一个版本的对象。如果没有加上<code>serialVersionUID</code> ，在反序列化之前更改了类的签名或者增加了一些字段，在反序列化的时候就报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeralizVersionIDTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line"><span class="comment">//        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;user&quot;));</span></span><br><span class="line"><span class="comment">//        oos.writeObject(user);</span></span><br><span class="line"><span class="comment">//         反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        User user1 = (User) ois.readObject();</span><br><span class="line">        System.out.println(user1.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        oos.close();</span></span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在反序列化之前，增加了一个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反序列化之后报错</p><img src="/2024/11/07/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1596876224494.png" class width="1596876224494"><p>所以我们需要手动指定一个<code>serialVersionUID</code> ，就可以正常反序列化了。</p><h2 id="静态变量的序列化"><a href="#静态变量的序列化" class="headerlink" title="静态变量的序列化"></a>静态变量的序列化</h2><p>我们在User类中加上一个静态变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>然后在序列化之后，将变量i修改成99， 通过反序列化之后i的值应该是多少呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeralizVersionIDTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        oos.writeObject(user);</span><br><span class="line">        User.i = <span class="number">99</span>; <span class="comment">// 序列化之后改变值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">        User user1 = (User) ois.readObject();</span><br><span class="line">        System.out.println(user1.i);</span><br><span class="line">        oos.close();</span><br><span class="line">        ois.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>99</p></blockquote><p>这说明了序列化不对静态变量序列化。我们总说是对象序列化，但是i数据属于类变量，所以不会序列化静态变量。</p><h2 id="不想要序列化？transit"><a href="#不想要序列化？transit" class="headerlink" title="不想要序列化？transit"></a>不想要序列化？transit</h2><p>那么对于非静态变量就可以序列化，但是可不可以选择不序列化呢？</p><p>当然，那就是<code>transit</code>关键字</p><blockquote><p><code>Transient</code> 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，<code>transient</code> 变量的值被设为初始值，如 <code>int</code> 型的是 0，对象型的是 <code>null</code>。 </p></blockquote><h2 id="父类的序列化"><a href="#父类的序列化" class="headerlink" title="父类的序列化"></a>父类的序列化</h2><p>考虑这种情况，子类实现了<code>Serializable</code>接口，父类没有实现<code>Serializable</code>接口。看看序列化与反序列化的时候会出现什么情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 默认的构造函数， 不加报错</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeralizVersionIDTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;son&quot;</span>));</span><br><span class="line">        oos.writeObject(son);</span><br><span class="line"><span class="comment">//         反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;son&quot;</span>));</span><br><span class="line">        Son s = (Son) ois.readObject();</span><br><span class="line">        System.out.println(s.money); <span class="comment">// 父亲那里继承下来的钱</span></span><br><span class="line">        oos.close();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>0</p></blockquote><p>反序列化子类需要创建父类，调用父类默认的无参构造方法。</p><p>所以除了可以用tansit关键字修饰不想被序列化的属性之外，还可以将不想序列化的属性放入父类中，子类实现<code>Serializable</code>接口， 父类不实现。</p><h1 id="单例解决序列化的问题"><a href="#单例解决序列化的问题" class="headerlink" title="单例解决序列化的问题"></a>单例解决序列化的问题</h1><p>言归正传！！！！！！！！！！！！回到单例设计模式</p><p>下面以饿汉模式举例， 实现<code>Serializable</code>接口，看看序列化的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungarySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungarySingleton instance = <span class="keyword">new</span> HungarySingleton();</span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungarySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有的方法返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungarySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HungarySingleton instance = HungarySingleton.getInstance();</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;instance&quot;</span>));</span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;instance&quot;</span>));</span><br><span class="line">        HungarySingleton instance1 = (HungarySingleton) ois.readObject();</span><br><span class="line">        System.out.println(instance1 == instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>false</p></blockquote><p>可以发现返回的是两个对象，也就是说，序列化破坏了我们的单例模式！</p><p>那怎么解决呢？</p><p>使用 <strong>readResolve</strong>()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungarySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersioUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungarySingleton instance = <span class="keyword">new</span> HungarySingleton();</span><br><span class="line">    <span class="comment">// 私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungarySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有的方法返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungarySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎是加了<code>readResolve()</code>方法后反序列化做的是浅拷贝,也就是拷贝的是之前对象的指针,指的还是原先的对象，  而不加默认是深拷贝?直接开辟新空间, 地址自然就不一样了.</p><p>如果使用枚举的话，可以解决序列化的问题。 使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被<strong>反序列化</strong>的时候，保证反序列的返回结果是同一对象。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例设计模式&quot;&gt;&lt;a href=&quot;#单例设计模式&quot; class=&quot;headerlink&quot; title=&quot;单例设计模式&quot;&gt;&lt;/a&gt;单例设计模式&lt;/h1&gt;&lt;h1 id=&quot;涉及到的知识点&quot;&gt;&lt;a href=&quot;#涉及到的知识点&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="设计模式" scheme="https://castile.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://castile.github.io/tags/Java/"/>
    
    <category term="设计模式" scheme="https://castile.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>初探ThreadLocal</title>
    <link href="https://castile.github.io/2024/11/07/theadlocal/"/>
    <id>https://castile.github.io/2024/11/07/theadlocal/</id>
    <published>2024-11-07T12:48:59.481Z</published>
    <updated>2024-11-07T12:48:59.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>当调用theadlocal的set的方法的时候， </p><p>set方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      Thread t = Thread.currentThread(); <span class="comment">// 获取当前的线程</span></span><br><span class="line">      ThreadLocalMap map = getMap(t); <span class="comment">// 获取当前线程的ThreadLocalMap： threadlocals</span></span><br><span class="line">      <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">          map.set(<span class="keyword">this</span>, value); <span class="comment">// 往map里面put值，key为threadlocal对象，value是threadlocal里面的值</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>进一步看一下getMap里面的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Thread类里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap底层是一个Map结构。在ThreadLocal里面的一个静态内部类，ThreadLocalMap里面又包含一个Entry的静态内部类，是一个k-v键值对的结构，key为threadlocal对象，value是里面的值。还继承了WeakReference， 所以这个Entry是一个弱引用对象，当垃圾收集器看到他的时候会直接回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">         * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们new了一个threadlocal对象，调用set方法的时候，先拿到 当前的线程的ThreadLocalMap threadlocals， 这是一个Map结构，key为threadlocal对象，value是threadlocal对象里面的值，key是通过一个弱引用指向threadlocal对象的。如下图所示。</p><p><img src="/2024/11/07/theadlocal/image-20200826215617400.png" alt="image-20200826215617400"></p><p>为什么是弱引用呢？ 假如这是个强引用，当tl的引用置为null的时候，key的引用不为null，还指向了threadlocal对象，所以这时threadlocal将不会被回收，就可能发生内存泄漏。如果是弱引用的话，当JVM虚拟机运行gc的时候，发现threadlocal是一个弱引用，则直接将其回收，这样就可以解决内存泄漏问题。</p><p>还有一个问题，假如，这时候key为null了，要想通过get方法获得value的话是不可能获取到的，这个value对象的值怎么释放呢？所以，这也会产生内存泄漏 的情况，良好的编程习惯是将这一条记录remove掉，这样就防止了value这部分的内存泄漏。</p><p>假如使用的线程池，如果不清理掉旧的记录，当线程复用的时候，会导致数据混乱。所以，线程池的底层源码就是每次开启一个线程的时候都会将当前线程的ThreadLocalMap置为null。</p><h1 id="ThreadLocal的使用场景"><a href="#ThreadLocal的使用场景" class="headerlink" title="ThreadLocal的使用场景"></a>ThreadLocal的使用场景</h1><p>spring关于事务的管理</p><p>mybatis中分页的处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h1&gt;&lt;p&gt;当调用theadlocal的set的方法的时候， &lt;/p&gt;
&lt;p&gt;s</summary>
      
    
    
    
    <category term="Java高并发" scheme="https://castile.github.io/categories/Java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Thread" scheme="https://castile.github.io/tags/Thread/"/>
    
    <category term="多线程" scheme="https://castile.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java中的各种锁机制</title>
    <link href="https://castile.github.io/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://castile.github.io/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/</id>
    <published>2024-11-07T12:48:59.438Z</published>
    <updated>2024-11-07T12:48:59.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的各种锁机制"><a href="#Java中的各种锁机制" class="headerlink" title="Java中的各种锁机制"></a>Java中的各种锁机制</h1><p>图片来自于美团技术团队<a href="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png">java主流锁</a></p><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/7f749fc8.png" class title="img"><h1 id="一、公平锁和非公平锁"><a href="#一、公平锁和非公平锁" class="headerlink" title="一、公平锁和非公平锁"></a>一、公平锁和非公平锁</h1><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>​    是指多个线程按照申请<strong>锁的顺序</strong>来获取锁，类似排队打饭，先来后到</p><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>​    是指在多线程获取锁的顺序并不是按照申请锁的顺序, 有可能后申请的线程比先申请的线程优先获取到锁, 在高并发的情况下, 有可能造成优先级反转或者饥饿现象。</p><h2 id="公平锁-非公平锁区别"><a href="#公平锁-非公平锁区别" class="headerlink" title="公平锁/非公平锁区别"></a>公平锁/非公平锁区别</h2><p>  并发包ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁 （默认是非公平锁）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>公平锁：</strong> Thread acquire a fair lock in the order in which they requested it</p><p>公平锁就是很公平，在并发环境下，每个线程获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程时等待队列的第一个，就占有锁，否则就会被加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。</p><p><strong>非公平锁：</strong> 非公平锁比较粗鲁， 上来就直接尝试占有锁，如果尝试失败，就在采用类似公平锁那种方式。</p><p>ReentrantLock而言，通过构造函数指定该锁是否是公平锁。默认是非公平锁，非公平锁的优点在于吞吐量比公平锁大。</p><p>对于synchronized而言 也是一种非公平锁。</p><p>下面是ReentrantLock的公平锁和非公平锁源码</p><p>公平锁加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  <span class="comment">// 判断线程是不是同步队列中的第一个</span></span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>非公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p><p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><h1 id="二、可重入锁"><a href="#二、可重入锁" class="headerlink" title="二、可重入锁"></a>二、可重入锁</h1><p>也称为递归锁。指的是同一线程外层函数获得锁之后，内层的方法仍然可以获得该锁的代码。在同一个线程的外层方法获取锁的时候，在进入内层方法会自动获取锁。也就是说，线程可以进入任何一个它已经拥有锁的同步代码。</p><p>其最大的作用就是可以避免死锁。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>接下来证明<code>synchronized</code>是可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t invoke sendMsg&quot;</span>);</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getId()+<span class="string">&quot;\t $$$$$$$$$$$$$$$  invoke sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendMsg();</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sendMsg();</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>11     invoke sendMsg<br>11     $$$$$$$$$$$$$$$  invoke sendEmail<br>12     invoke sendMsg<br>12     $$$$$$$$$$$$$$$  invoke sendEmail</p></blockquote><p>可以看到getID()返回的是同一个线程。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>下面再看看ReentrantLock是不是也是可重入的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot;\t invoke get()&quot;</span>);</span><br><span class="line">            set();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot;\t invoke set()&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">       </span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(phone, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(phone, <span class="string">&quot;t4&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>t3     invoke get()<br>t3     invoke set()<br>t4     invoke get()<br>t4     invoke set()</p></blockquote><h2 id="Synchronized与ReentrantLock的区别"><a href="#Synchronized与ReentrantLock的区别" class="headerlink" title="Synchronized与ReentrantLock的区别"></a>Synchronized与ReentrantLock的区别</h2><ol><li><p>原始构成： Synchronized是关键字，属于JVM层面的。monitorenter和monitorexit指令完成。</p><p>monitorenter 底层是通过monitor对象来完成的，其实wait/notify等方法也是依赖monitor对象  只有在同步块或者方法中才能调用wait/notify等方法。</p><p>而ReentrantLock是具体类，是api层面的锁。</p></li><li><p>使用方法：</p><p>Synchronized 不需要手动释放锁，当Synchronized代码执行完后系统会自动让线程释放对锁的占用。</p><p>ReentrantLock则需要用户手动释放，如果没有手动释放，就有可能导致死锁现象。lock和unlock方法配合try/finally语句块来完成。</p></li><li><p>等待是否可以中断</p><p>Synchronized 不可中断，除非抛出异常或正常运行完成。</p><p>ReentrantLock是可以中断的。1. 通过设置超时方法  trylock(long timeout, TimeUint unit)   2. lockInterruptibly()  放入代码块中，调用interrupt可中断。</p></li><li><p>加锁是否公平</p><p>Synchronized是非公平锁</p><p>ReentrantLock两者都可以，默认是非公平锁，构造方法可以传入boolean值，true为公平锁，false为非公平锁</p></li><li><p>锁绑定多个条件</p><p>Synchronized没有，只能随机唤醒一个或者全部唤醒</p><p>ReentrantLock可以实现精确唤醒</p></li></ol><h1 id="三、自旋锁spinlock"><a href="#三、自旋锁spinlock" class="headerlink" title="三、自旋锁spinlock"></a>三、自旋锁spinlock</h1><p>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p><p>自旋锁的好处： 循环比较直到获取成功为止，没有类似的wait的阻塞</p><h2 id="实现一个自旋锁"><a href="#实现一个自旋锁" class="headerlink" title="实现一个自旋锁"></a>实现一个自旋锁</h2><p>通过CAS操作完成自旋锁，A线程先进来调用mylock方法自己持有锁5秒钟，B随后进来后发现当有线程持有锁，不是null， 所以只能自旋等待，直到A释放锁后B随后抢到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-23-17:32</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现一个自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mylock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread(); <span class="comment">//当前进来的线程</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 进来了...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!atomicReference.compareAndSet(<span class="keyword">null</span>, thread))&#123;</span><br><span class="line">            <span class="comment">// spin</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread(); <span class="comment">//当前进来的线程</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLock lock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 获取锁</span></span><br><span class="line">            lock.mylock();</span><br><span class="line">            <span class="comment">// 休眠</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.mylock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mylock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。</p><h2 id="自旋锁存在的问题"><a href="#自旋锁存在的问题" class="headerlink" title="自旋锁存在的问题"></a>自旋锁存在的问题</h2><ol><li>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。</li><li>上面Java实现的自旋锁不是公平的，即<strong>无法满足等待时间最长的线程优先获取锁</strong>。不公平的锁就会存在“<strong>线程饥饿</strong>”问题。</li></ol><h2 id="自旋锁的优点"><a href="#自旋锁的优点" class="headerlink" title="自旋锁的优点"></a>自旋锁的优点</h2><ol><li>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快</li><li>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</li></ol><h2 id="可重入的自旋锁和不可重入的自旋锁"><a href="#可重入的自旋锁和不可重入的自旋锁" class="headerlink" title="可重入的自旋锁和不可重入的自旋锁"></a>可重入的自旋锁和不可重入的自旋锁</h2><p>我们再来看一下我们实现的自旋锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mylock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread(); <span class="comment">//当前进来的线程</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 进来了...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!atomicReference.compareAndSet(<span class="keyword">null</span>, thread))&#123;</span><br><span class="line">            <span class="comment">// spin</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread(); <span class="comment">//当前进来的线程</span></span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现我们上面的自旋锁不支持可重入，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新希望获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入<code>while</code>循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。</p><p>而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-25-15:55</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可重入的自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantSpinLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Thread&gt; threadAtomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"><span class="comment">//    private int count; // 计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span>(threadAtomicReference.get() == thread)&#123;</span><br><span class="line">            <span class="comment">// 如果当前线程已经获取到了该锁，计数器加1 ，然后直接返回</span></span><br><span class="line"><span class="comment">//            count.incrementAndGet();</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 已经获取了该锁,目前count值为&quot;</span>+ count.getAndIncrement()+<span class="string">&quot;，计数器为&quot;</span>+ count.get());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有获取，则通过CAS自旋</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 开始获取锁，进来了...&quot;</span>+count.get());</span><br><span class="line">        <span class="keyword">while</span> (!threadAtomicReference.compareAndSet(<span class="keyword">null</span>, thread))&#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span>(threadAtomicReference.get() == thread)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count.get() &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//                count.decrementAndGet(); // 如果当前线程获取了锁，则通过count--来模拟释放一次锁</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot; count为&quot;</span>+ count.getAndDecrement()+<span class="string">&quot;，继续释放...&quot;</span>+ count.get());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot; 释放了全部锁...&quot;</span> + count.get());</span><br><span class="line">                <span class="comment">// count == 0 ， 可以将锁释放， 保证获取锁的次数与释放锁的次数一致</span></span><br><span class="line">                threadAtomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantSpinLock spinLock = <span class="keyword">new</span> ReentrantSpinLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                spinLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    spinLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                spinLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            spinLock.unlock();</span><br><span class="line">        &#125;, <span class="string">&quot;BBB&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>AAA 开始获取锁，进来了…0<br>AAA 已经获取了该锁,目前count值为0，计数器为1<br>BBB 开始获取锁，进来了…1<br>AAA count为1，继续释放…0<br>AAA 释放了全部锁…0<br>BBB 释放了全部锁…0</p></blockquote><p>这样可以重入</p><h2 id="自旋锁的变种：TicketLock"><a href="#自旋锁的变种：TicketLock" class="headerlink" title="自旋锁的变种：TicketLock"></a>自旋锁的变种：TicketLock</h2><p><strong>TicketLock主要解决的是公平性的问题。</strong></p><p>思路：每当有线程获取锁的时候，就给该线程分配一个递增的id，我们称之为排队号，同时，锁对应一个服务号，每当有线程释放锁，服务号就会递增，此时如果服务号与某个线程排队号一致，那么该线程就获得锁，由于排队号是递增的，所以就保证了最先请求获取锁的线程可以最先获取到锁，就实现了公平性。</p><p>可以想象成银行办理业务排队，排队的每一个顾客都代表一个需要请求锁的线程，而银行服务窗口表示锁，每当有窗口服务完成就把自己的服务号加一，此时在排队的所有顾客中，只有自己的排队号与服务号一致的才可以得到服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketLockV2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger serviceNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排队号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger ticketNum = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增一个ThreadLocal，用于存储每个线程的排队号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; ticketNumHolder = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentTicketNum = ticketNum.incrementAndGet();</span><br><span class="line">        <span class="comment">// 获取锁的时候，将当前线程的排队号保存起来</span></span><br><span class="line">        ticketNumHolder.set(currentTicketNum);</span><br><span class="line">        <span class="keyword">while</span> (currentTicketNum != serviceNum.get()) &#123;</span><br><span class="line">            <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放锁，从ThreadLocal中获取当前线程的排队号</span></span><br><span class="line">        Integer currentTickNum = ticketNumHolder.get();</span><br><span class="line">        serviceNum.compareAndSet(currentTickNum, currentTickNum + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现方式是将每个线程的排队号放到了ThreadLocal中。</p><p><strong>TicketLock存在的问题:</strong></p><p>多处理器系统上，每个进程/线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。</p><p>下面介绍的CLHLock就是解决这个问题的。</p><h2 id="自旋锁的变种CLHLock"><a href="#自旋锁的变种CLHLock" class="headerlink" title="自旋锁的变种CLHLock"></a>自旋锁的变种CLHLock</h2><p>CLH锁是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋，获得锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CLH的发明人是：Craig，Landin and Hagersten。</span></span><br><span class="line"><span class="comment"> * 代码来源：http://ifeve.com/java_lock_see2/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个节点，默认的lock状态为true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾部节点,只用一个节点即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> CLHNode tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;CLHNode&gt; LOCAL = <span class="keyword">new</span> ThreadLocal&lt;CLHNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater.newUpdater(CLHLock.class, CLHNode.class,</span><br><span class="line">            <span class="string">&quot;tail&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建节点并将节点与当前线程保存起来</span></span><br><span class="line">        CLHNode node = <span class="keyword">new</span> CLHNode();</span><br><span class="line">        LOCAL.set(node);</span><br><span class="line">        <span class="comment">// 将新建的节点设置为尾部节点，并返回旧的节点（原子操作），这里旧的节点实际上就是当前节点的前驱节点</span></span><br><span class="line">        CLHNode preNode = UPDATER.getAndSet(<span class="keyword">this</span>, node);</span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 前驱节点不为null表示当锁被其他线程占用，通过不断轮询判断前驱节点的锁标志位等待前驱节点释放锁</span></span><br><span class="line">            <span class="keyword">while</span> (preNode.isLocked) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode = <span class="keyword">null</span>;</span><br><span class="line">            LOCAL.set(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不存在前驱节点，表示该锁没有被其他线程占用，则当前线程获得锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程对应的节点</span></span><br><span class="line">        CLHNode node = LOCAL.get();</span><br><span class="line">        <span class="comment">// 如果tail节点等于node，则将tail节点更新为null，同时将node的lock状态职位false，表示当前线程释放了锁</span></span><br><span class="line">        <span class="keyword">if</span> (!UPDATER.compareAndSet(<span class="keyword">this</span>, node, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            node.isLocked = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、独占锁（写锁）-共享锁-读锁-互斥锁"><a href="#四、独占锁（写锁）-共享锁-读锁-互斥锁" class="headerlink" title="四、独占锁（写锁）/共享锁(读锁) /互斥锁"></a>四、独占锁（写锁）/共享锁(读锁) /互斥锁</h1><p>独占锁： 指该锁一次只能被一个线程锁持有。ReentrantLock和Synchronized都是独占锁</p><p>共享锁： 该锁可以被多个线程锁共享</p><p>对ReentrantReadWriteLock其读锁是共享的，写锁是独占的。</p><p>读锁的共享锁可以保证并发读是高效的，读写、写写、写读的过程是互斥的。</p><p>独享锁与共享锁是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>我们使用读写锁实现一个分布式缓存，要求写时独占，原子的，读操作可以共享。</p><p>先来看没有加锁的时候，会发生什么状况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-23-23:05</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 读写锁实践： 手写一个 缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 开始写入&quot;</span> + key);</span><br><span class="line">        <span class="comment">// 模拟网络延迟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 开始读取&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟网络延迟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Object value = cache.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span>+ value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">readwriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程操作资源类</span></span><br><span class="line">        MyCache cache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟5个线程写，5个线程读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                cache.put(tmp+<span class="string">&quot;&quot;</span>, tmp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                cache.get(tmp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>1     开始写入1<br>2     开始写入2<br>3     开始写入3<br>4     开始写入4<br>5     开始写入5<br>1     开始读取<br>2     开始读取<br>3     开始读取<br>4     开始读取<br>5     开始读取<br>5     写入完成<br>1     读取完成：null<br>4     写入完成<br>3     写入完成<br>2     写入完成<br>1     写入完成<br>2     读取完成：2<br>3     读取完成：3<br>4     读取完成：4<br>5     读取完成：5</p></blockquote><p>可以发现，写操作被读操作中断了，而且还读到了一个null值。这是并发问题。</p><p>我们要实现写操作是原子的，应该为独占锁，读取操作是各个线程所共享的。可以使用JUC下面的<code>ReentrantReadWriteLock</code>， 称为读写锁。</p><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200823233234155.png" class title="image-20200823233234155"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-23-23:05</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 读写锁实践： 手写一个 缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用写锁</span></span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 开始写入&quot;</span> + key);</span><br><span class="line">            <span class="comment">// 模拟网络延迟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 加读锁</span></span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 开始读取&quot;</span>);</span><br><span class="line">            <span class="comment">// 模拟网络延迟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Object value = cache.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span>+ value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">readwriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程操作资源类</span></span><br><span class="line">        MyCache cache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟5个线程写，5个线程读</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                cache.put(tmp+<span class="string">&quot;&quot;</span>, tmp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                cache.get(tmp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>1     开始写入1<br>1     写入完成<br>2     开始写入2<br>2     写入完成<br>3     开始写入3<br>3     写入完成<br>4     开始写入4<br>4     写入完成<br>5     开始写入5<br>5     写入完成<br>1     开始读取<br>2     开始读取<br>4     开始读取<br>5     开始读取<br>3     开始读取<br>5     读取完成：5<br>2     读取完成：2<br>4     读取完成：4<br>3     读取完成：3<br>1     读取完成：1</p></blockquote><p>可以清楚看到，写操作是配对完成的，中间没有打断。读操作是并发的，可以无序。</p><h2 id="深入理解ReentrantReadWriteLock"><a href="#深入理解ReentrantReadWriteLock" class="headerlink" title="深入理解ReentrantReadWriteLock"></a>深入理解ReentrantReadWriteLock</h2><p>读写锁</p><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825194659342.png" class title="image-20200825194659342"><p>读锁</p><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825194945583.png" class title="image-20200825194945583"><p>写锁</p><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825195030328.png" class title="image-20200825195030328"><p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p><p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825195420880.png" class title="image-20200825195420880"><p>来看看写锁的加锁源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line"><span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line"><span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"><span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li><li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li><li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li><li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li><li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li></ul></blockquote><p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p><p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p><p>接着是读锁的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p></blockquote><h1 id="五、乐观锁和悲观锁"><a href="#五、乐观锁和悲观锁" class="headerlink" title="五、乐观锁和悲观锁"></a>五、乐观锁和悲观锁</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>顾名思义，很悲观，每次去拿数据的时候都担心别人回来修改数据，所以会加锁，其他线程需要这个资源的话只能被阻塞。直到释放锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>很乐观，总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号机制</strong>和<strong>CAS</strong>算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><h2 id="两种锁的适用场景"><a href="#两种锁的适用场景" class="headerlink" title="两种锁的适用场景"></a>两种锁的适用场景</h2><p>乐观锁适用于<strong>多读</strong>的场景，可以提高吞吐量。但是<strong>多写</strong>的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><h2 id="乐观锁的实现方法"><a href="#乐观锁的实现方法" class="headerlink" title="乐观锁的实现方法"></a>乐观锁的实现方法</h2><p>乐观锁一般会使用版本号机制或CAS（Compare-and-Swap，即比较并替换）算法实现。</p><h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>般是在数据表中加上一个数据版本号<code>version</code>字段，表示数据被修改的次数，当数据被修改时，<code>version</code>值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的<code>version</code>值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p>举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><ol><li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 50（50（100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 20（20（100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ol><p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>即 compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul><p>当且仅当 V 的值等于 A时，CAS通过<strong>原子方式</strong>用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p><h2 id="CAS-底层实现原理？"><a href="#CAS-底层实现原理？" class="headerlink" title="CAS 底层实现原理？"></a>CAS 底层实现原理？</h2><p>通过自旋锁+UNSafe类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>UnSafe</code>是CAS的核心类。由于Java 方法无法直接访问底层 ，需要通过本地(native)方法来访问， <code>UnSafe</code>可以直接操作特的内存数据。UnSafe类在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的助兴依赖于UNSafe类的方法。Unsafe它提供了硬件级别的<strong>原子操作</strong>。<strong>注意UnSafe类中所有的方法都是native修饰的,也就是说UnSafe类中的方法都是直接调用操作底层资源执行响应的任务。</strong></p></li><li><p>变量<code>ValueOffset</code>，便是该变量在内存中的偏移地址，因为<code>UnSafe</code>就是根据内存偏移地址获取数据的。</p></li></ol><h2 id="AtomicReference原子引用"><a href="#AtomicReference原子引用" class="headerlink" title="AtomicReference原子引用"></a>AtomicReference原子引用</h2><p><code>AtomicReference</code>是作用是对”<strong>对象”</strong>进行原子操作。<br>提供了一种读和写都是原子性的对象引用变量。原子意味着多个线程试图改变同一个<code>AtomicReference</code>(例如比较和交换操作)将不会使得<code>AtomicReference</code>处于不一致的状态。</p><p><code>AtomicReference</code>和<code>AtomicInteger</code>非常类似，不同之处就在于<code>AtomicInteger</code>是对整数的封装，底层采用的是<code>compareAndSwapInt</code>实现CAS，比较的是数值是否相等，而<code>AtomicReference</code>则对应普通的对象引用，底层使用的是<code>compareAndSwapObject</code>实现CAS，比较的是两个对象的地址是否相等。也就是它可以保证你在修改对象引用时的线程安全性。</p><h2 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h2><h3 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1. ABA 问题"></a>1. ABA 问题</h3><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？</p><p>很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p><p>JDK 1.5 以后的 <code>AtomicStampedReference 类</code>就提供了此种能力，其中的 <code>compareAndSet 方法</code>就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hongliang.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020-08-25-16:33</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CAS 的 ABA问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===以下是ABA问题的产生===&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//先暂停1秒 保证完成ABA</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===以下是ABA问题的解决===&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第1次版本号&quot;</span> + stamp + <span class="string">&quot;\t值是&quot;</span> + stampedReference.getReference());</span><br><span class="line">            <span class="comment">//暂停1秒钟t3线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第2次版本号&quot;</span> + stampedReference.getStamp() + <span class="string">&quot;\t值是&quot;</span> + stampedReference.getReference());</span><br><span class="line">            stampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, stampedReference.getStamp(), stampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第3次版本号&quot;</span> + stampedReference.getStamp() + <span class="string">&quot;\t值是&quot;</span> + stampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 第1次版本号&quot;</span> + stamp + <span class="string">&quot;\t值是&quot;</span> + stampedReference.getReference());</span><br><span class="line">            <span class="comment">//保证线程3完成1次ABA</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 修改成功否&quot;</span> + result + <span class="string">&quot;\t最新版本号&quot;</span> + stampedReference.getStamp());</span><br><span class="line">            System.out.println(<span class="string">&quot;最新的值\t&quot;</span> + stampedReference.getReference());</span><br><span class="line">        &#125;, <span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>===以下是ABA问题的产生===<br>true    2019<br>===以下是ABA问题的解决===<br>t3     第1次版本号1    值是100<br>t4     第1次版本号1    值是100<br>t3     第2次版本号2    值是101<br>t3     第3次版本号3    值是100<br>t4     修改成功否false    最新版本号3<br>最新的值    100</p></blockquote><h3 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2. 循环时间长开销大"></a>2. 循环时间长开销大</h3><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销</strong>。 </p><p>如果JVM能支持处理器提供的<code>pause</code>指令，那么效率会有一定的提升，<code>pause</code>指令有两个作用，第一它可以<strong>延迟流水线执行指令</strong>（<code>de-pipeline</code>），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因<strong>内存顺序冲突</strong>（<code>memory order violation</code>）而引起CPU流水线被清空（<code>CPU pipeline flush</code>），从而提高CPU的执行效率。</p><h3 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3. 只能保证一个共享变量的原子操作"></a>3. 只能保证一个共享变量的原子操作</h3><p><strong>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。</strong>但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p><h2 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h2><p>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），<code>synchronized</code>适用于写比较多的情况下（多写场景，冲突一般较多）</p><ul><li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li></ul><blockquote><p>补充： Java并发编程这个领域中<code>synchronized</code>关键字一直都是元老级的角色，很久之前很多人都会称它为 “<strong>重量级锁</strong>” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它各种优化之后变得在某些情况下并不是那么重了。<code>synchronized</code>的底层实现主要依靠 <code>Lock-Free</code> 的队列，基本思路是 <strong>自旋后阻塞</strong>，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p></blockquote><h1 id="六、无锁VS偏向锁VS轻量级锁VS重量级锁"><a href="#六、无锁VS偏向锁VS轻量级锁VS重量级锁" class="headerlink" title="六、无锁VS偏向锁VS轻量级锁VS重量级锁"></a>六、无锁VS偏向锁VS轻量级锁VS重量级锁</h1><p>先了解几个概念，对象、对象头、Monitor</p><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/object.jpg" class title="img"><p><strong>Mark Word</strong>默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>Monitor：</strong> Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825180516629.png" class title="image-20200825180516629"><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p><strong>synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</strong></p><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“<strong>偏向锁”</strong>和“<strong>轻量级锁</strong>”。</p><p>所以目前锁一共有4种状态，级别从低到高依次是：<strong>无锁、偏向锁、轻量级锁和重量级锁</strong>。<strong>锁状态只能升级不能降级。</strong></p><p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825180621058.png" class title="image-20200825180621058"><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p><strong>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价</strong>。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。<strong>其目标就是在只有一个线程执行同步代码块时能够提高性能。</strong></p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h2><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a><strong>重量级锁</strong></h2><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><h1 id="七、锁膨胀"><a href="#七、锁膨胀" class="headerlink" title="七、锁膨胀"></a>七、锁膨胀</h1><p>锁膨胀的过程：</p><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825182846021.png" class title="image-20200825182846021"><h2 id="轻量级锁获取锁过程"><a href="#轻量级锁获取锁过程" class="headerlink" title="轻量级锁获取锁过程"></a><strong>轻量级锁获取锁过程</strong></h2><ol><li>在线程进入同步方法、同步块的时候，如果<strong>同步对象锁状态为无锁状态(锁标志位为”01”状态，是否为偏向锁为”0”)<strong>，虚拟机首先将在当前线程的栈帧中</strong>建立一个名为锁记录(Lock Recored)的空间</strong>，用于储存锁对象目前的Mark Word的拷贝(官方把这份拷贝加了个Displaced前缀，即Displaced Mark Word)。</li></ol><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/1.jpg" class title="img"><ol><li>将对象头的<code>Mark Word</code>拷贝到线程的锁记录(Lock Recored)中。</li><li>拷贝成功后，虚拟机将使用<code>CAS</code>操作<strong>尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针</strong>。如果这个更新成功了，则执行步骤<code>4</code>，否则执行步骤<code>5</code>。</li><li>更新成功，这个<strong>线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为”00”，即表示此对象处于轻量级锁的状态。</strong>。</li></ol><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/2.jpg" class title="img"><ol start="4"><li>更新失败，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其其它线程抢占了。<strong>进行自旋执行步骤<code>3</code>，如果自旋结束仍然没有获得锁，轻量级锁就需要膨胀为重量级锁，锁标志位状态值变为”10”，Mark Word中储存就是指向<code>monitor</code>对象的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</strong></li></ol><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/3.jpg" class title="img"><h2 id="轻量级释放锁的过程"><a href="#轻量级释放锁的过程" class="headerlink" title="轻量级释放锁的过程"></a><strong>轻量级释放锁的过程</strong></h2><ol><li>使用<code>CAS</code>操作将对象当前的<code>Mark Word</code>和线程中复制的<code>Displaced Mark Word</code>替换回来(依据<code>Mark Word</code>中锁记录指针是否还指向本线程的锁记录)，如果替换成功，则执行步骤<code>2</code>，否则执行步骤<code>3</code>。</li><li>如果替换成功，整个同步过程就完成了，恢复到无锁的状态(01)。</li><li>如果替换失败，说明有其他线程尝试获取该锁(此时锁已膨胀)，那就要在释放锁的同时，唤醒被挂起的线程。</li></ol><h2 id="偏向锁获取锁的过程"><a href="#偏向锁获取锁的过程" class="headerlink" title="偏向锁获取锁的过程"></a>偏向锁获取锁的过程</h2><p><strong>获取锁的过程</strong>：</p><ol><li>检查<code>Mark Word</code>是否为<strong>可偏向锁的状态</strong>，即是否偏向锁即为1即表示支持可偏向锁，否则为0表示不支持可偏向锁。</li><li>如果是可偏向锁，则**检查<code>Mark Word</code>储存的线程<code>ID</code>是否为当前线程<code>ID</code>**，如果是则执行同步块，否则执行步骤<code>3</code>。</li><li>如果检查到<code>Mark Word</code>的<code>ID</code>不是本线程的<code>ID</code>，则通过<code>CAS</code>操作去修改线程<code>ID</code>修改成本线程的<code>ID</code>，如果修改成功则执行同步代码块，否则执行步骤<code>4</code>。</li><li>当拥有该锁的线程到达安全点之后，挂起这个线程，升级为轻量级锁。</li></ol><h2 id="偏向锁释放锁的过程"><a href="#偏向锁释放锁的过程" class="headerlink" title="偏向锁释放锁的过程"></a>偏向锁释放锁的过程</h2><p><strong>锁释放的过程</strong>：</p><ol><li>有其他线程来获取这个锁，偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。</li><li>等待全局安全点(在这个是时间点上没有字节码正在执行)。</li><li>暂停拥有偏向锁的线程，检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置为无锁状态，否则设置为被锁定状态。如果锁对象处于<strong>无锁状态，则恢复到无锁状态(01)<strong>，以允许其他线程竞争，如果</strong>锁对象处于锁定状态</strong>，则挂起持有偏向锁的线程，并将对象头<code>Mark Word</code>的锁记录指针改成当前线程的锁记录，锁**升级为轻量级锁状态(00)**。</li></ol><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/4.jpg" class title="img"><h2 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h2><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/5.jpg" class title="img"><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825204734448.png" class title="image-20200825204734448"><h1 id="八、-AQS"><a href="#八、-AQS" class="headerlink" title="八、 AQS"></a>八、 AQS</h1><h2 id="AQS-介绍"><a href="#AQS-介绍" class="headerlink" title="AQS 介绍"></a>AQS 介绍</h2><p>AQS：<code>AbstractQueneSynchronizer</code>抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。<br>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包</p><blockquote><p><strong>AQS的核心思想</strong>是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。<br>CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。<br><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</strong></p></blockquote><p><strong>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</strong></p><p><strong>注意：AQS是自旋锁：在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功</strong></p><p><strong>实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物</strong></p><h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><img src="/2024/11/07/java%E9%94%81%E6%9C%BA%E5%88%B6/image-20200825213325244.png" class title="image-20200825213325244"><p>AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。state就是共享资源，其访问方式有如下三种：</p><blockquote><ol><li>getState();</li><li>setState();</li><li>compareAndSetState();</li></ol></blockquote><p>AQS 定义了两种资源共享方式：</p><blockquote><p>1.<strong>Exclusive</strong>：独占，只有一个线程能执行，如ReentrantLock<br>2.<strong>Share</strong>：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</p><p>不同的自定义的同步器争用共享资源的方式也不同。</p></blockquote><p><strong>AQS底层使用了模板方法模式</strong>： </p><p>同步器的设计是基<strong>于模板方法模式</strong>的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li><li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。<br>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</li></ol><p>自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。自定义同步器实现的时候主要实现下面几种方法：</p><blockquote><ol><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ol></blockquote><p>以ReentrantLock为例（可重入独占式锁）：state初始化为0，表示未锁定状态，A线程lock()时，会调用tryAcquire()独占锁并将state+1。之后其他线程再想tryAcquire的时候就会失败，直到A线程unlock（）到state=0为止，其他线程才有机会获取该锁。A释放锁之前，自己也是可以重复获取此锁（state累加），这就是可重入的概念。<br><strong>注意：获取多少次锁就要释放多少次锁，保证state是能回到零态的。</strong></p><p>以CountDownLatch为例，任务分N个子线程去执行，state就初始化 为N，N个线程并行执行，每个线程执行完之后countDown() 一次，state就会CAS减一。当N子线程全部执行完毕，state=0，会unpark()主调用线程，主调用线程就会从await()函数返回，继续之后的动作。</p><p>一般来说，自定义同步器要么是独占方式，要么是共享方式，他们也只需实现tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时<strong>实现独占和共享两种方式，如ReentrantReadWriteLock。</strong><br>在acquire() 、acquireShared()两种方式下，线程在等待队列中都是忽略中断的，<strong>acquireInterruptibly()/acquireSharedInterruptibly()是支持响应中断</strong>的。</p><h2 id="AQS的简单应用"><a href="#AQS的简单应用" class="headerlink" title="AQS的简单应用"></a><strong>AQS的简单应用</strong></h2><p>Mutex：不可重入互斥锁，锁资源（state）只有两种状态：0：未被锁定；1：锁定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否锁定状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正同步类的实现都依赖继承于AQS的自定义同步器！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlock&lt;--&gt;release。两者语文一样：释放资源。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁是否占有状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。</p><h1 id="九、-参考"><a href="#九、-参考" class="headerlink" title="九、 参考"></a>九、 参考</h1><ol><li><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></p></li><li><p>《深入理解Java虚拟机》</p></li><li><p>《Java并发编程之美》</p></li><li><p><a href="https://juejin.im/post/6844903805121740814">深入分析synchronized原理和锁膨胀过程(二)</a></p></li><li><p><a href="https://blog.csdn.net/mulinsen77/article/details/84583716">https://blog.csdn.net/mulinsen77/article/details/84583716</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java中的各种锁机制&quot;&gt;&lt;a href=&quot;#Java中的各种锁机制&quot; class=&quot;headerlink&quot; title=&quot;Java中的各种锁机制&quot;&gt;&lt;/a&gt;Java中的各种锁机制&lt;/h1&gt;&lt;p&gt;图片来自于美团技术团队&lt;a href=&quot;https://awps-a</summary>
      
    
    
    
    <category term="Java高并发" scheme="https://castile.github.io/categories/Java%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程" scheme="https://castile.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="锁" scheme="https://castile.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>从网络到IO多路复用</title>
    <link href="https://castile.github.io/2024/11/07/io%E5%A4%8D%E7%94%A8/"/>
    <id>https://castile.github.io/2024/11/07/io%E5%A4%8D%E7%94%A8/</id>
    <published>2024-11-07T12:48:59.430Z</published>
    <updated>2024-11-07T12:48:59.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于linux操作系统"><a href="#基于linux操作系统" class="headerlink" title="基于linux操作系统"></a>基于linux操作系统</h1><p>tcpdump</p><p>strace</p><p>man</p><p>nc</p><p>curl</p><p>nginx</p><h1 id="开篇-基础知识准备"><a href="#开篇-基础知识准备" class="headerlink" title="开篇-基础知识准备"></a>开篇-基础知识准备</h1><p>tcp、ip协议层 。</p><p>TCP： 面向连接的可靠的传输协议， 需要进行3次握手建立连接。</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596339781519.png" class width="1596339781519"><p>四次挥手断开连接</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596340107335.png" class width="1596340107335"><p>软件分层结构，每个层有做自己的事情，解耦合。</p><p>在linux上执行命令访问<a href="http://www.baidu.com/">www.baidu.com</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 6&lt;&gt; /dev/tcp/www.baidu.com/80</span><br></pre></td></tr></table></figure><blockquote><p><code>exec</code>:  将一个程序覆盖当前进程，即将此程序压栈，如果程序执行完是退出，则会让内核触发，将整个进程销毁，断开连接 </p><p>6: 文件描述符，可以自己定义</p><p>&lt;&gt;: 重定向操作符， 表示输入输出</p><p> /dev/tcp/<a href="http://www.baidu.com/80">www.baidu.com/80</a>  ： 虚拟文件系统 </p><p> 0  输入流 1  正确输出流 2  报错输出 </p></blockquote><p> 当前bash里面多了一个6号文件描述符，指向了一个socket， /dev/tcp/<a href="http://www.baidu.com/80%E4%B8%BA%E7%89%B9%E6%AE%8A%E7%9B%AE%E5%BD%95%EF%BC%8C%E8%A7%A6%E5%8F%91%E4%B8%80%E4%B8%AA%E5%86%85%E6%A0%B8%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%AE%A9bash%E5%8F%91%E8%B5%B7%E4%BA%86%E5%AF%B9%E7%99%BE%E5%BA%A6socket%E7%9A%84%E8%BF%9E%E6%8E%A5">www.baidu.com/80为特殊目录，触发一个内核机制，让bash发起了对百度socket的连接</a> 。</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596338215863.png" class width="1596338215863"><p>与百度建立了socket连接后怎么获取百度的主页呢？socket建立表示TCP连接已经建立了，然后应该使用协议来进行交互。是应用层的操作，所以我们需要发送HTTP协议请求头</p><p> http协议请求头 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;GET / HTTP/1.0\n&quot;</span>      -e使得bash能识别换行符</span><br><span class="line"><span class="comment"># 将请求头发送到百度服务器</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;GET/HTTP/1.0\n&quot;</span> 1&gt;&amp;8 <span class="comment"># 1 是输出，表示将输出重定向到 6中， 如果重定向后面是一个文件描述符的话，需要加一个 &amp; </span></span><br><span class="line"><span class="comment"># 读取响应信息</span></span><br><span class="line">cat 0&lt;&amp;8</span><br></pre></td></tr></table></figure><h1 id="使用工具抓包"><a href="#使用工具抓包" class="headerlink" title="使用工具抓包"></a>使用工具抓包</h1><p>使用tcpdump工具</p><p>安装：yum install tcpdump</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596340272940.png" class width="1596340272940"><p>查看网卡 ifconfig</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596340312930.png" class width="1596340312930"><p>看一下tcpdump如何使用： tcpdump –help</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596340347063.png" class width="1596340347063"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn -i ens33 port 80  <span class="comment"># 监听80端口的时间 在网卡 ens33 上</span></span><br></pre></td></tr></table></figure><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596340485781.png" class width="1596340485781"><p>目前还没有，是一个阻塞状态</p><p>然后我们去访问一下百度 curl ， 重开一个ssh</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596340567812.png" class width="1596340567812"><p>在刚刚的侦听界面上：</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596340618884.png" class width="1596340618884"><p>分析一下, 先看建立连接，也就是前三行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">11:55:43.617175 IP 192.168.145.130.51914 &gt; 104.193.88.77.80: Flags [S], seq 3681486933, win 29200, options [mss 1460,sackOK,TS val 41257007 ecr 0,nop,wscale 7], length 0</span><br><span class="line"></span><br><span class="line">表示本机给百度发送了一个 seq ，后面的数字表示序列号。 S 表示 sync</span><br><span class="line"></span><br><span class="line">11:55:43.845875 IP 104.193.88.77.80 &gt; 192.168.145.130.51914: Flags [S.], seq 1297381438, ack 3681486934, win 64240, options [mss 1460], length 0</span><br><span class="line"></span><br><span class="line">接着百度给本机发送 了一个 sync+ ack的包。</span><br><span class="line"></span><br><span class="line">11:55:43.845926 IP 192.168.145.130.51914 &gt; 104.193.88.77.80: Flags [.], ack 1, win 29200, length 0</span><br><span class="line"></span><br><span class="line">然后本地给百度回复了一个 ack 确认</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上就是TCP建立连接的三次握手过程，完成建立后，双方开辟资源。</p><p>接着看中间几行表示本机与百度进行数据传输的过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">11:55:43.846291 IP 192.168.145.130.51914 &gt; 104.193.88.77.80: Flags [P.], seq 1:78, ack 1, win 29200, length 77: HTTP: GET / HTTP/1.1</span><br><span class="line"></span><br><span class="line">本机给百度发送了一个数据包 长度为77  协议HTTP/1.1  以GET的方式请求</span><br><span class="line"></span><br><span class="line">11:55:43.846412 IP 104.193.88.77.80 &gt; 192.168.145.130.51914: Flags [.], ack 78, win 64240, length 0</span><br><span class="line"></span><br><span class="line">百度给本就回复一个确认 ack， 因为是可靠传输</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11:55:44.386992 IP 104.193.88.77.80 &gt; 192.168.145.130.51914: Flags [P.], seq 1:2782, ack 78, win 64240, length 2781: HTTP: HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">接着是百度个本机返回单的响应数据  长度为2781  状态码 200 表示成功</span><br><span class="line">上面两个都是百度发出的，最后有一个P表示，数据发送完了，不要存储在缓存中了，请马上告知应用程序去处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11:55:44.387030 IP 192.168.145.130.51914 &gt; 104.193.88.77.80: Flags [.], ack 2782, win 33580, length 0</span><br><span class="line"></span><br><span class="line">本机给百发送ack确认，表示已经收到</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发送完数据之后，接着是断开连接，也就是四次挥手的过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">11:55:44.387247 IP 192.168.145.130.51914 &gt; 104.193.88.77.80: Flags [F.], seq 78, ack 2782, win 33580, length 0</span><br><span class="line"></span><br><span class="line">本机需要断开连接  fin</span><br><span class="line"></span><br><span class="line">11:55:44.387563 IP 104.193.88.77.80 &gt; 192.168.145.130.51914: Flags [.], ack 79, win 64239, length 0</span><br><span class="line"></span><br><span class="line">百度返回给客户端一个ack，表示知道了你要断开连接。但是这时还没有完全断开，是一个半关闭的转态。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11:55:45.280826 IP 104.193.88.77.80 &gt; 192.168.145.130.51914: Flags [FP.], seq 2782, ack 79, win 64239, length 0</span><br><span class="line"></span><br><span class="line">百度的服务器也要断开连接了，给本机发送了一个fin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11:55:45.280853 IP 192.168.145.130.51914 &gt; 104.193.88.77.80: Flags [.], ack 2783, win 33580, length 0</span><br><span class="line">本机知道了，然后断开</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过以上分析，我们以及知道从客户端发起请求建立连接到传输数据再到四次挥手断开连接的全过程。这一整个过程应该是一个完整的粒度，不应该被拆散。</p><p>比如，我们做负载均衡的时候，客户端给一个服务器发送了一个建立连接的请求数据包sync， 然后这个服务器返回一个sync+ack给客户端，客户端还需要发送一个ack给服务器，但是由于有多台服务器，负载均衡会选择一个最佳的服务器，可能会出现这样的一种情况，就是客户端的ack发送给了另外一台服务器，而原来的这个服务器一直没有收到客户端的ack，所以这个连接就建立不起来。这就是粒度被拆散了。</p><p>这个粒度不能被我们以后所学的技术所拆散的！！！这是一个大前提。</p><h1 id="NetCat"><a href="#NetCat" class="headerlink" title="NetCat"></a>NetCat</h1><p> nc是netcat工具的命令，是一个很好用的网络工具。比如，可以用来端口扫描，文件传输等网络功能。 在 网络工具中有“瑞士军刀”美誉的NetCat， 在我们用了N年了至今仍是爱不释手。 </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nc</span><br></pre></td></tr></table></figure><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596342921077.png" class width="1596342921077"><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/Users\ZHLAS\AppData\Roaming\Typora\typora-user-images\1596342893175.png" alt="1596342893175"></p><h2 id="监听端口"><a href="#监听端口" class="headerlink" title="监听端口"></a>监听端口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -l 8080  <span class="comment"># 开启服务端</span></span><br><span class="line">nc localhost 8080 <span class="comment"># 开启客户端</span></span><br></pre></td></tr></table></figure><p>他们之间就建立了连接，可以相互发送数据</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596343177824.png" class width="1596343177824"><p>查看他们的进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nc</span><br></pre></td></tr></table></figure><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596343270786.png" class width="1596343270786"><p>然后我们用上面的提到的，在 /proc/进程id/fd 目录下面下有进程描述符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> proc/102514/fd</span><br><span class="line">ll</span><br></pre></td></tr></table></figure><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596343753967.png" class width="1596343753967"><h1 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h1><blockquote><p>yum install strace</p></blockquote><p>用来跟踪程序的运行以及系统调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir xxoo  <span class="comment"># 创建一个新文件夹，用来存放程序运行的跟踪文件</span></span><br><span class="line"><span class="built_in">cd</span> xxoo</span><br><span class="line">trace -ff -o out nc -l 8080 <span class="comment"># 跟踪这个程序</span></span><br></pre></td></tr></table></figure><p>然后在xxoo目录下有一个文件 out-4781 , 后面的id表示nc的进程id</p><p>打开这个文件：</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596348250812.png" class width="1596348250812"><p>查看select的作用： man 2  select</p><p>select是一个多路复用器，会阻塞</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596348180958.png" class width="1596348180958"><p>使用 tail命令去动态查看文件的变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f out.4781</span><br></pre></td></tr></table></figure><p>打开一个客户端 nv localhost 8080</p><p>发送一些信息</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596348474672.png" class width="1596348474672"><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596348629679.png" class width="1596348629679"><p>write(1, “zhuhongliang\n”, 13)          = 13 表示在 文件描述符1 写入 。1代表标准写</p><p>看一下recvfrom 的功能：从一个socket接受数据data，返回数据的字节数</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596348842591.png" class width="1596348842591"><h1 id="系统调用system-call"><a href="#系统调用system-call" class="headerlink" title="系统调用system call"></a>系统调用system call</h1><p>read、write、 socket、 bind、listen、accept</p><p>上述系统方法的实现是在linux kernel里面的实现的。kernel只会对应用程序暴露上述方法的调用，所以程序会对系统内核发起系统调用。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>如果程想使用内核完成网络通信的话，这时候会发生哪些事情呢？</p><p>看看下面的过程</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596350428037.png" class width="1596350428037"><p>首先服务端系统调用kernel，socket获取服务端的文件描述符 5，然后使用bind将文件描述符与端口8080进行绑定，之后监听看有没有连接。</p><p>这时候，一个客户端也进行系统调用，经过三次握手之后连接了服务端，服务端系统调用accept， 建立连接 。客户端的文件描述符加入是fd 4 。 然后调用read 读操作，传入客户端的文件描述符4 。但是这个客户端没有发送数据，所以这个read现在被阻塞住了。</p><p>此时又有一个客户端来连接</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596350713176.png" class width="1596350713176"><p>建立完连接后，这时候不会给他分配文件描述符，因为程序已经被阻塞住了，只能运行到accept这个阶段，如果客户端有超时响应的话，会报超时连接错误。</p><p>这是整个IO  发展历程中的第一个时期：BIO，即阻塞IO。</p><p>那么，我们怎么解决这个问题呢？ 可以开辟一个线程。</p><p>一旦出现了一个连接，就分配一个文件描述符，然后开辟一个线程。</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596351333541.png" class width="1596351333541"><p>如果有线程来<code>read</code>了，就启动线程，否则阻塞。上述就是多线程模型。</p><p>这样已经解决服务端无法处理多个客户端连接请求的问题了，但这种多线程模型有什么缺点或者说弊端呢？</p><p>思考一下如果有100000个客户端，那么是不是要与100000个线程的开辟？？？</p><p>这就开销太大了吧。</p><p>我们首先看一下java程序在linux 系统中是如何调用的</p><p>写一个简单的java程序</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596352369785.png" class width="1596352369785"><p>使用是strace 追踪系统调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -ff -o xxoo java Hello</span><br></pre></td></tr></table></figure><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596352460918.png" class width="1596352460918"><p>可以看到，这样一个简单的java程序并不是只开辟了一个线程。打开113151</p><p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/Users\ZHLAS\AppData\Roaming\Typora\typora-user-images\1596352589369.png" alt="1596352589369"></p><p>发现调用了113152线程， 并且使用的系统调用<code>clone</code></p><p>那 我们的主线程是哪个，主线程应该是打印Hello world的那个线程吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;Hello world&quot;</span> ./*</span><br></pre></td></tr></table></figure><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596352739519.png" class width="1596352739519"><p>看到了write系统调用了吗。这是在113152线程中。</p><p>我们可以得出一个结论，线程的创建是通过调用内核的clone系统调用来实现的，主线程都需要clone，然后如果有成千上万个线程的话，就要进行成千上万次系统调用，这个开销很非常大的。因为调用内核不是直接就调用的，需要发生软中断，而且CPU也要切换状态。</p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>在BIO时期这一切万恶之源都是由于系统调用会有阻塞的情况发生，如果一个客户端没有发送数据，就会阻塞。虽然多线程模型可以处理多个客户端的情况，但是由于开销大，系统调用此时多，比较慢。</p><p>那么能不能只创建一个线程就可以处理多个客户端呢？</p><p>我们看看socket： <code>man 2 socket</code></p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596353886051.png" class width="1596353886051"><blockquote><p>SOCK_NONBLOCK :   Set the O_NONBLOCK file status flag on the new open file description.  Using this flag saves extra calls to fcntl(2) to achieve the same result</p></blockquote><p>可以使用非阻塞，fcntl来指定非阻塞的文件描述符</p><p>==所以，内核需要发生变化==</p><p>下面的模型非阻塞的NIO （NON- Block IO）</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596354546614.png" class width="1596354546614"><p>在客户端只需要写一个死循环，然后有一个客户端的文件描述符解accept，如果没有数据传输，就报错，然后程序可以继续执行。这样的模型也有弊端。</p><p>试想一下，如果有10000个客户端，一次循环就进行10000次系统调用，那么如果只有第10000个客户端有数据传输，那这样的开销会很大。</p><p>有没有什么解决方法呢？ 如果能把多次系统调用变成一次系统调用那就好啦！！！</p><p>怎么做？==内核又需要变化了==</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>上面我们提到了select。看看<code>select</code> ： man 2 select </p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596355176202.png" class width="1596355176202"><blockquote><p>select() and pselect() allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become “ready” for some class of I/O operation (e.g., input possible).  A file descriptor  is considered ready if it is possible to perform the corresponding I/O operation (e.g., read(2)) without blocking.</p><p>select()和pselect()允许程序监视多个文件描述符，直到其中一个或多个文件描述符为某些类型的I/O操作(例如，输入)“准备好”。如果文件描述符可以不阻塞地执行相应的I/O操作(如read(2))，则认为它已经准备好了。</p></blockquote><p>下面是使用了select或者poll的模型</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596355593306.png" class width="1596355593306"><p>将各个客户端的文件描述符给select，然后select会去主动遍历每一个文件描述符，哪个有数据输出就返回哪个文件描述符，然后通过系统调用read去读取。这样的话就只用以一次系统调用就把需要read的文件描述符选择出来了，比上面的需要非常多的系统调用模型更加优秀。另外，select是系统调用，会主动遍历每一个文件操作符，时间复杂度为O(N)。</p><p>这还没有完，这种模型还没有很优美，虽然减少了系统调用，但是select里面的轮询还是O(N)的，这该怎么改进呢？</p><p>epoll终于来了！！！</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>讲epoll之前先来看看<code>nginx</code>，看看nginx怎么工作的。</p><p>首先需要安装nginx： <a href="https://blog.csdn.net/qq_37345604/article/details/90034424">https://blog.csdn.net/qq_37345604/article/details/90034424</a> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.9.9.tar.gz  </span><br><span class="line">tar -zxvf  nginx-1.9.9.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx目录</span><br><span class="line">./configure</span><br><span class="line"> </span><br><span class="line">make</span><br><span class="line"> </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>运行nginx在 usr/local/nginx/sbin 目录下</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596374161025.png" class width="1596374161025"><p>我们来看看nginx有多少个线程，不出意外的话，应该是两个，一个是master，一个是worker。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -ff -o out ./nginx</span><br></pre></td></tr></table></figure><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596374461886.png" class width="1596374461886"><p>我们看看对应的out下有多少文件</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596374545591.png" class width="1596374545591"><p>可以看到有3635、3636、3637三个进程，不应该是两个吗？？？</p><p>我们来看看3635这个进程：</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596374748379.png" class width="1596374748379"><p>这个进程只是启动进程，最后是退出了的，它clone了3636进程， 然后3636进程clone了3637进程，如下图。</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596374641173.png" class width="1596374641173"><p>所以他们是父子关系。  3635–&gt; 3636 –&gt; 3637。 因为3636是master进程，可以看到他其实没有做什么事情， 就是将3637 worker进程clone出来了。</p><p>其实一开始文件描述符是在3635进程，也就是启动线程就去确定了，通过clone将文件描述符带给3636进程， 3636又带去3637进程</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596375190301.png" class width="1596375190301"><p>再看看3637进程</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596375290597.png" class width="1596375290597"><p>文件描述符6 放进了8 里面，8 是上面的<code>epoll_create</code>创建出来的。</p><p>那么epoll_create 是干嘛的，运行命令 man 2 epoll_create 查看系统调用</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596375526366.png" class width="1596375526366"><blockquote><p>  epoll_create() returns a file descriptor referring to the new epoll instance.  This file descriptor is used for all the subsequent calls to the epoll interface.  When no longer required, the file descriptor returned by epoll_create() should be closed by using close(2).  When all file descriptors referring to an epoll instance have been closed, the kernel  destroys  the  instance  and releases the associated resources for reuse.</p><p>epoll_create()返回引用新epoll实例的文件描述符。<strong>此文件描述符用于随后对epoll接口的所有调用。</strong>当不再需要时，应该使用close(2)关闭epoll_create()返回的文件描述符。当引用epoll实例的所有文件描述符都被关闭时，内核会销毁该实例并释放相关的资源以供重用。</p></blockquote><p>其实系统调用<code>epoll_create()</code> 在内核中开辟一个空间， 使用文件描述符指向这个空间。然后通过epoll_ctl(8, 6) 将文件描述符6放进 8里面。然后epoll_wait(8,  等待， 开始阻塞。</p><p><code>epoll_wait</code>会返回有数据输出的文件描述符数量。</p><blockquote><p>The  epoll_wait()  system  call  waits for events on the epoll(7) instance referred to by the file descriptor epfd.  The memory area pointed to by events will contain the events that will be available for the caller.  Up to maxevents are returned by epoll_wait().  The maxevents argument must be greater than zero.</p><p> The timeout argument specifies the minimum number of milliseconds that epoll_wait() will block.  (This interval will be rounded up to the system  clock  granularity,  and  kernel  scheduling delays  mean  that the blocking interval may overrun by a small amount.)  Specifying a timeout of -1 causes epoll_wait() to block indefinitely, while specifying a timeout equal to zero cause  epoll_wait() to return immediately, even if no events are available.</p><p>RETURN VALUE( 返回值 )<br>       When successful, epoll_wait() returns the number of file descriptors ready for the requested I/O, or zero if no file descriptor became ready during the requested timeout milliseconds.   When  an error occurs, epoll_wait() returns -1 and errno is set appropriately.</p></blockquote><blockquote><p>epoll_wait()系统调用等待文件描述符epfd引用的epoll(7)实例上的事件。事件指向的内存区域将包含调用者可用的事件。epoll_wait()返回最多maxevents。maxevents参数必须大于零。</p><p>超时参数指定epoll_wait()将阻塞的最小毫秒数。(这个时间间隔将被舍入到系统时钟粒度，内核调度延迟意味着阻塞时间间隔可能会超出一小部分。)将超时指定为-1将导致epoll_wait()无限期阻塞，而将超时指定为0将导致epoll_wait()立即返回，即使没有可用的事件。</p><p>成功时，epoll_wait()返回为请求的I/O准备好的文件描述符的数量，如果在请求的超时毫秒期间没有文件描述符准备好，则返回0。当发生错误时，epoll_wait()返回-1,errno被适当地设置。</p></blockquote><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596376139195.png" class width="1596376139195"><p>我们来模拟一下访问，目前3637进程是阻塞的，因为没有客户端来连接。</p><p>使用tail命令去查看动态的文件变化</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596376468601.png" class width="1596376468601"><p>使用curl来模拟访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost 80</span><br></pre></td></tr></table></figure><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596376962580.png" class width="1596376962580"><p>out文件的变化</p><p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/Users\ZHLAS\AppData\Roaming\Typora\typora-user-images\1596376939382.png" alt="1596376939382"></p><p>主要看看这几句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">accept4(6, &#123;sa_family=AF_INET, sin_port=htons(34306), sin_addr=inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>)&#125;, [110-&gt;16], SOCK_NONBLOCK) = 3</span><br><span class="line"></span><br><span class="line">一个客户端请求后，首先系统调用accept(6, ...)，6是服务端的文件描述符，客户端的文件描述符是3</span><br><span class="line"></span><br><span class="line">epoll_ctl(8, EPOLL_CTL_ADD, 3, &#123;EPOLLIN|EPOLLRDHUP|EPOLLET, &#123;u32=4200120752, u64=139994364166576&#125;&#125;) = 0</span><br><span class="line"> 紧接着 将3放进8 里面去，这时候还没有客户端的数据流出</span><br><span class="line"></span><br><span class="line">epoll_wait(8, [&#123;EPOLLIN, &#123;u32=4200120752, u64=139994364166576&#125;&#125;], 512, 60000) = 1</span><br><span class="line">epoll_wait 去监听8 里面的文件描述符的 数据到达事件</span><br><span class="line"></span><br><span class="line">recvfrom(3, <span class="string">&quot;GET / HTTP/1.1\r\nUser-Agent: curl&quot;</span>..., 1024, 0, NULL, NULL) = 73</span><br><span class="line"></span><br><span class="line">有事件到达了， 收到的数据是从文件描述3发来的</span><br><span class="line"></span><br><span class="line"><span class="built_in">stat</span>(<span class="string">&quot;/usr/local/nginx/html/index.html&quot;</span>, &#123;st_mode=S_IFREG|0644, st_size=612, ...&#125;) = 0</span><br><span class="line"></span><br><span class="line">判断是请求主页的</span><br><span class="line"></span><br><span class="line">open(<span class="string">&quot;/usr/local/nginx/html/index.html&quot;</span>, O_RDONLY|O_NONBLOCK) = 10</span><br><span class="line">打开主页的文件， 文件描述符是10</span><br><span class="line"></span><br><span class="line">fstat(10, &#123;st_mode=S_IFREG|0644, st_size=612, ...&#125;) = 0</span><br><span class="line">查看文件描述符10 的状态</span><br><span class="line"></span><br><span class="line">writev(3, [&#123;iov_base=<span class="string">&quot;HTTP/1.1 200 OK\r\nServer: nginx/1&quot;</span>..., iov_len=237&#125;], 1) = 237</span><br><span class="line">返回给文件描述符3 的数据，给3写入</span><br><span class="line"></span><br><span class="line">sendfile(3, 10, [0] =&gt; [612], 612)      = 612</span><br><span class="line">发送数据 将10 发送给3 </span><br><span class="line">write(4, <span class="string">&quot;127.0.0.1 - - [02/Aug/2020:22:01&quot;</span>..., 86) = 86</span><br><span class="line">写的时间</span><br><span class="line">close(10)     = 0</span><br><span class="line">关闭文件描述符10</span><br><span class="line">setsockopt(3, SOL_TCP, TCP_NODELAY, [1], 4) = 0</span><br><span class="line">recvfrom(3, <span class="string">&quot;&quot;</span>, 1024, 0, NULL, NULL)    = 0</span><br><span class="line">close(3)  <span class="comment">#  连接断开就会关闭文件描述符3                </span></span><br></pre></td></tr></table></figure><p>我们也可以使用nc 来模拟多个客户端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc localhost 80  <span class="comment"># 客户端1</span></span><br><span class="line">nc localhost 80 <span class="comment"># 客户端2</span></span><br></pre></td></tr></table></figure><p>这是out文件的变化，可以看到有两个文件描述符加入8 中</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596378280120.png" class width="1596378280120"><p>所以，所有的连接只需要通过epoll_ctl（8， ）放入8一次，未来就连续调用epoll_wait来监听那个文件描述符有数据到达， 对于文件描述符6来说，等待的是accept事件，对于3、10 等其他的客户端的文件描述符是等待read，一旦监听到了，就将这个文件描述符放入一个集合中。</p><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596378843696.png" class width="1596378843696"><p>这样的模型不像select会一次将10000个文件描述符拷贝给内核，内核开辟了一个空间，来了一个客户端就通过epoll_ctl将文件描述符放入到指定的区域里面，只要连接不断开，那么可以通过epoll_wait获取到客户端的所有事件。</p><p>内核是被动的，中断的事件会让8 里面的文件描述符进入到右边的返回区，然后主程序就是一个epol_wait死循环，一直判断返回区里面有没有事件。</p><p>零拷贝： sendFile系统调用</p><p>直接内存</p><h1 id="附：发展历程图示"><a href="#附：发展历程图示" class="headerlink" title="附：发展历程图示"></a>附：发展历程图示</h1><img src="/2024/11/07/io%E5%A4%8D%E7%94%A8/1596381266279.png" class width="1596381266279"><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Socket">https://cyc2018.github.io/CS-Notes/#/notes/Socket</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于linux操作系统&quot;&gt;&lt;a href=&quot;#基于linux操作系统&quot; class=&quot;headerlink&quot; title=&quot;基于linux操作系统&quot;&gt;&lt;/a&gt;基于linux操作系统&lt;/h1&gt;&lt;p&gt;tcpdump&lt;/p&gt;
&lt;p&gt;strace&lt;/p&gt;
&lt;p&gt;man&lt;/</summary>
      
    
    
    
    <category term="Redis" scheme="https://castile.github.io/categories/Redis/"/>
    
    
    <category term="io" scheme="https://castile.github.io/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>Java专题之Socket编程</title>
    <link href="https://castile.github.io/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/"/>
    <id>https://castile.github.io/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/</id>
    <published>2024-11-07T12:48:59.263Z</published>
    <updated>2024-11-07T12:48:59.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h1><p>Java 中的网络支持：</p><ul><li><code>InetAddress</code>：用于表示网络上的硬件资源，即 IP 地址；</li><li><code>URL</code>：统一资源定位符；</li><li><code>Sockets</code>：使用 TCP 协议实现网络通信；</li><li><code>Datagram</code>：使用 UDP 协议实现网络通信。</li></ul><hr><h1 id="二、-InetAddress"><a href="#二、-InetAddress" class="headerlink" title="二、 InetAddress"></a>二、 InetAddress</h1><p> 没有公有的构造函数，只能通过静态方法来创建实例。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IP  InetAddress</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-19 21:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        InetAddress address = InetAddress.getLocalHost(); <span class="comment">// 192.168.145.1</span></span><br><span class="line">        System.out.println(address.getHostAddress());</span><br><span class="line">        System.out.println(address.getHostName()); <span class="comment">// zhuhongliang</span></span><br><span class="line">        <span class="comment">// 根据域名得到InetAddress</span></span><br><span class="line">        <span class="comment">//根据域名得到InetAddress对象</span></span><br><span class="line">        address = InetAddress.getByName(<span class="string">&quot;www.163.com&quot;</span>);</span><br><span class="line">        System.out.println(address.getHostAddress());<span class="comment">//返回 163服务器的ip:183.216.182.9</span></span><br><span class="line">        System.out.println(address.getHostName());  <span class="comment">//输出：www.163.com</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据ip得到InetAddress对象</span></span><br><span class="line">        address = InetAddress.getByName(<span class="string">&quot;183.216.182.7&quot;</span>);</span><br><span class="line">        System.out.println(address.getHostAddress());  <span class="comment">//返回 163服务器的ip:61.135.253.15</span></span><br><span class="line">        System.out.println(address.getHostName());<span class="comment">//输出ip而不是域名。如果这个IP地 址不存在或DNS 服务器不允许进行IP地址和域名的映射，getHostName方法就直接返回这个IP地址。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>ip地址用来标识一台计算机，端口用来区分不同的程序。</p><blockquote><p>常用的命令：</p><p>查看所有端口： netstat -ano</p><p>查看指定端口： netstat -ano | findstr “5023”</p><p>查看指定进程： tasklist | findstr “5032”</p><p>查看具体程序： 使用任务管理器查看pid</p></blockquote><img src="/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582167681824.png" alt="1582167681824" style="zoom:100%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含端口</span></span><br><span class="line">InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>); <span class="comment">//指定了端口</span></span><br><span class="line">InetSocketAddress socketAddress2 = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">9000</span>);</span><br><span class="line">System.out.println(socketAddress.getHostName()); <span class="comment">// 127.0.0.1</span></span><br><span class="line">System.out.println(socketAddress2.getAddress()); <span class="comment">//  localhost/127.0.0.1</span></span><br><span class="line">System.out.println(socketAddress.getPort()); <span class="comment">// 8080</span></span><br></pre></td></tr></table></figure><hr><h1 id="三、-URL"><a href="#三、-URL" class="headerlink" title="三、 URL"></a>三、 URL</h1><p>URL（Uniform Resource Locator）：  统一资源定位符 ， 由4部分组成：协议 、存放资源的主机域名、端口号和资源文件名。 如： <a href="http://www.www.baidu.com:9090/index.html">http://www.www.baidu.com:9090/index.html</a></p><p>URL是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引 擎的查询。</p><blockquote><p>互联网的三大基石： html， http， url</p></blockquote><p>URI（Universal Resource Identifier）： 统一资源标志符，用来标识抽象或者物理资源的一个紧凑字符串。</p><p>URN（Universal Resource Name）：统一资源名称， 通过特定命名空间中的唯一名称或ID来标识资源。</p><img src="/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582123666801.png" alt="1582167681824" style="zoom:100%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * URL: 统一资源定位符  区分资源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-19 22:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com:9090/index.html?uname=zhu&amp;age=18#a&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取四个值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;协议：&quot;</span>+ url.getProtocol());</span><br><span class="line">        System.out.println(<span class="string">&quot;域名|ip： &quot;</span>+ url.getHost());</span><br><span class="line">        System.out.println(<span class="string">&quot;请求的资源1：&quot;</span>+ url.getFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;请求的资源2： &quot;</span>+ url.getPath());</span><br><span class="line">        <span class="comment">//参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;参数：&quot;</span>+ url.getQuery());</span><br><span class="line">        <span class="comment">// 锚点</span></span><br><span class="line">        System.out.println(<span class="string">&quot;锚点： &quot;</span>+ url.getRef());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>协议：http<br>域名|ip： <a href="http://www.baidu.com/">www.baidu.com</a><br>请求的资源1：/index.html?uname=zhu&amp;age=18<br>请求的资源2： /index.html<br>参数：uname=zhu&amp;age=18<br>锚点： a</p></blockquote><h2 id="爬虫原理"><a href="#爬虫原理" class="headerlink" title="爬虫原理"></a>爬虫原理</h2><p>使用url来下载资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * URL下载资源  爬虫原理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-20 10:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpyderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://www.jd.com&quot;</span>);</span><br><span class="line"><span class="comment">//        URL url = new URL(&quot;https://www.dianping.com&quot;); //不是所有的网站都可以爬</span></span><br><span class="line">        InputStream is  = url.openStream(); <span class="comment">//</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is, <span class="string">&quot;utf8&quot;</span>));</span><br><span class="line">        String msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != (msg=br.readLine()))&#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于不能直接通过URL来获取资源的，可以通过浏览器请求方式来获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *爬虫原理  : 模拟浏览器访问</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-20 10:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpyderTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://www.dianping.com&quot;</span>);</span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection)url.openConnection();</span><br><span class="line">        conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        conn.setRequestProperty(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36&quot;</span>);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream(), <span class="string">&quot;utf8&quot;</span>));</span><br><span class="line">        String msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != (msg = br.readLine()))&#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="四、-传输协议TCP-amp-UDP"><a href="#四、-传输协议TCP-amp-UDP" class="headerlink" title="四、 传输协议TCP&amp;UDP"></a>四、 传输协议TCP&amp;UDP</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 </p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 </p><h2 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h2><p>​        我们开发的网络应用程序位于<strong>应用层</strong>，TCP和UDP属于传输层协议，在应用层如何使用传输层 的服务呢？在应用层和传输层之间，则是使用套接字来进行分离。 </p><p>​        套接字就像是传输层为应用层开的一个小口，应用程序通过这个小口向远程发送数据，或者 接收远程发来的数据；而这个小口以内，也就是数据进入这个口之后，或者数据从这个口出来之前，是不知道也不需要知道的，也不会关心它如何传输，这属于网络其它层次的工作。</p><img src="/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582169809295.png" alt="1582169809295" style="zoom:100%;"><p>​        Socket实际是网络传输层供给应用层的编程接口。传输层则在网络层的基础上提供进 程到进程问的逻辑通道，而应用层的进程则利用传输层向另一台主机的某一进程通 信。Socket就是应用层与传输层之间的桥梁 。</p><p>​        使用Socket编程可以开发客户机和服务器应用程序，可以在本地网络上进行通信，也 可通过Internet在全球范围内通信。</p><blockquote><p>生活案例1：</p><p>​        如果你想写封邮件发给远方的朋友，如何写信、将信 打包，属于应用层。信怎么写，怎么打包完全由我们做主；<br>​        而当我们将信投入邮筒时，邮筒的那个口就是套接字， 在进入套接字之后，就是传输层、网络层等（邮局、公路交管或者航线等）其它层次的工作了。我们从来不会去关心信是如何从西安发往北京的，我们只知道 写好了投入邮筒就OK了。</p></blockquote><img src="/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582170182414.png" alt="1582170182414" style="zoom:80%;"><blockquote><p>生活案例2:</p><p>如果你想发货给国外，你只要把 货物放入集装箱，然后交给码头就可以了。发送什么货物，货物如何打包, 完全有你做主。 码头就是套接字，剩下的事情就 交给港口和货运公司处理就行了，具体细节我们无需了解。</p></blockquote><p>​                                     <img src="/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/socket.jpg" alt="img" style="zoom:60%;"> </p><hr><h1 id="五、-UDP编程"><a href="#五、-UDP编程" class="headerlink" title="五、 UDP编程"></a>五、 UDP编程</h1><h2 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h2><ul><li>DatagramSocket：通信类 :  用于发送或者接受数据包的套接字</li><li>DatagramPacket：数据包类</li></ul><p>使用基于UDP协议的Socket网络编程实现 ：</p><p>​        不需要利用IO流实现数据的传输。 每个数据发送单元被统一封装成数据包的方式，发送方将数据包发送到网络中，数据包在网络中去寻找他的目的地。</p><p>UDP编程 ： 一切转换成字节数组</p><p>接收端：</p><blockquote><p>1.使用DatagramSocket 指定端口 创建接收端</p><p>2.指定容器， 封装DatagramPacket包</p><p>3.阻塞式接受包裹receive（DatagramPacket p）</p><p>4.分析数据  byte[]    getData()     getLength()</p><p>5.释放资源</p></blockquote><p>发送端</p><blockquote><p>1.使用DatagramSocket 指定端口 创建发送端</p><p>2.准备数据  ==》  一定要转成字节数组</p><p>3.封装 DatagramPacket包，需要指定目的地 + 端口</p><p>4.发送包裹  send( DatagramPacket p）</p><p>5.释放资源</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受端：</span></span><br><span class="line"><span class="comment"> * 1. 使用DatagramSocket 指定端口 创建接收端</span></span><br><span class="line"><span class="comment"> * 2. 指定容器， 封装DatagramPacket包</span></span><br><span class="line"><span class="comment"> * 3. 阻塞式接受包裹receive（DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 4. 分析数据</span></span><br><span class="line"><span class="comment"> *  byte[] getData()</span></span><br><span class="line"><span class="comment"> *          getLength()</span></span><br><span class="line"><span class="comment"> *  5.  释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020-02-20 11:51</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收端启动中...&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 使用DatagramSocket 指定端口 创建接收端</span></span><br><span class="line">        DatagramSocket server = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2. 指定容器， 封装DatagramPacket包</span></span><br><span class="line">        <span class="keyword">byte</span>[] contiainer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">60</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(contiainer, <span class="number">0</span>, contiainer.length);</span><br><span class="line">        <span class="comment">// 3. 阻塞式接受包裹receive（DatagramPacket p）</span></span><br><span class="line">        server.receive(packet);</span><br><span class="line">        <span class="comment">// 4. 分析数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] datas = packet.getData();</span><br><span class="line">        <span class="keyword">int</span> len = packet.getLength();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(datas, <span class="number">0</span>, len));</span><br><span class="line">        <span class="comment">// 5.  释放资源</span></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送端：</span></span><br><span class="line"><span class="comment"> * 1. 使用DatagramSocket 指定端口 创建发送端</span></span><br><span class="line"><span class="comment"> * 2. 准备数据 一定转成字节数组</span></span><br><span class="line"><span class="comment"> * 3. 封装DatagramPacket包，需要指定目的地</span></span><br><span class="line"><span class="comment"> * 4. 发送包裹send( DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 5.  释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-20 17:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UPDCilent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送方启动中...&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 使用DatagramSocket 指定端口 创建发送端</span></span><br><span class="line">        DatagramSocket client = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2. 准备数据 一定转成字节数组</span></span><br><span class="line">        String data = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] datas = data.getBytes();</span><br><span class="line">        <span class="comment">//3. 封装DatagramPacket包，需要指定目的地</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length,</span><br><span class="line">                <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        <span class="comment">// 4. 发送包裹send( DatagramPacket p）</span></span><br><span class="line">        client.send(packet);</span><br><span class="line">        <span class="comment">// 5.  释放资源</span></span><br><span class="line">        client.close();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="UDP编程：-传输基本数据类型和引用"><a href="#UDP编程：-传输基本数据类型和引用" class="headerlink" title="UDP编程： 传输基本数据类型和引用"></a>UDP编程： 传输基本数据类型和引用</h2><p>服务端（接收端）： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受端： 基本数据类型和引用  </span></span><br><span class="line"><span class="comment"> * 1. 使用DatagramSocket 指定端口 创建接收端</span></span><br><span class="line"><span class="comment"> * 2. 指定容器， 封装DatagramPacket包</span></span><br><span class="line"><span class="comment"> * 3. 阻塞式接受包裹receive（DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 4. 分析数据</span></span><br><span class="line"><span class="comment"> *  5.  释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-20 19:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPTypeServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传输基本数据类型==&gt;接收端启动中。。。。&quot;</span>);</span><br><span class="line">        DatagramSocket server = <span class="keyword">new</span> DatagramSocket(<span class="number">9898</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] datas = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">90</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length);</span><br><span class="line">        server.receive(packet);</span><br><span class="line">        <span class="keyword">byte</span>[] data = packet.getData();</span><br><span class="line">        <span class="keyword">int</span> len = packet.getLength();</span><br><span class="line">        ObjectInputStream dis = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> ByteArrayInputStream(data)));</span><br><span class="line">        <span class="comment">// 按照顺序读取</span></span><br><span class="line">        String msg = dis.readUTF(); <span class="comment">//  读取</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = dis.readBoolean();</span><br><span class="line">        <span class="keyword">int</span> a = dis.readInt();</span><br><span class="line">        Object o = dis.readObject();</span><br><span class="line">        System.out.println(len);</span><br><span class="line">        System.out.println(a+<span class="string">&quot;=&gt;&quot;</span>+msg+<span class="string">&quot;--&gt;&quot;</span>+flag);</span><br><span class="line"><span class="comment">//        o.toString();</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Employee)&#123;</span><br><span class="line">            Employee e = (Employee)o;</span><br><span class="line">            e.toString();</span><br><span class="line">            System.out.println(<span class="string">&quot;的确是马云&quot;</span>);</span><br><span class="line">            System.out.println(e.getName() +<span class="string">&quot;:&quot;</span>+  e.getMoney());</span><br><span class="line">        &#125;</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端（发送端）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送端： 基本数据类型和引用</span></span><br><span class="line"><span class="comment"> * 1. 使用DatagramSocket 指定端口 创建发送端</span></span><br><span class="line"><span class="comment"> * 2. 准备数据 一定转成字节数组</span></span><br><span class="line"><span class="comment"> * 3. 封装DatagramPacket包，需要指定目的地</span></span><br><span class="line"><span class="comment"> * 4. 发送包裹send( DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 5.  释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-20 17:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UPDTypeCilent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;传输基本数据类型==&gt;发送方启动中...&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 使用DatagramSocket 指定端口 创建发送端</span></span><br><span class="line">        DatagramSocket client = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2. 准备数据 一定转成字节数组</span></span><br><span class="line">        ByteArrayOutputStream  bao = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream dos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> BufferedOutputStream(bao));</span><br><span class="line">        dos.writeUTF(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">        dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">        dos.writeInt(<span class="number">99</span>);</span><br><span class="line">        <span class="comment">// 对象</span></span><br><span class="line">        Employee e = <span class="keyword">new</span> Employee(<span class="string">&quot;马云&quot;</span>, <span class="number">900000</span>);</span><br><span class="line">        dos.writeObject(e);</span><br><span class="line">        dos.flush();</span><br><span class="line">        <span class="keyword">byte</span>[] datas = bao.toByteArray();</span><br><span class="line">        <span class="comment">//3. 封装DatagramPacket包，需要指定目的地</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length,</span><br><span class="line">                <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">9898</span>));</span><br><span class="line">        <span class="comment">// 4. 发送包裹send( DatagramPacket p）</span></span><br><span class="line">        client.send(packet);</span><br><span class="line">        <span class="comment">// 5.  释放资源</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>传输基本数据类型==&gt;发送方启动中…</p><p>66<br>99=&gt;Hello world!–&gt;true<br>的确是马云<br>null:900000.0</p></blockquote><h2 id="UDP编程：-传输文件"><a href="#UDP编程：-传输文件" class="headerlink" title="UDP编程： 传输文件"></a>UDP编程： 传输文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送端： 发送文件</span></span><br><span class="line"><span class="comment"> * 1. 使用DatagramSocket 指定端口 创建发送端</span></span><br><span class="line"><span class="comment"> * 2. 准备数据 一定转成字节数组</span></span><br><span class="line"><span class="comment"> * 3. 封装DatagramPacket包，需要指定目的地</span></span><br><span class="line"><span class="comment"> * 4. 发送包裹send( DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 5.  释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-20 17:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UPDFileCilent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件 ==&gt; 发送方启动中...&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 使用DatagramSocket 指定端口 创建发送端</span></span><br><span class="line">        DatagramSocket client = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2. 准备数据 一定转成字节数组</span></span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;./socket/socket.png&quot;</span>);  <span class="comment">// 注意图片不能太大，否则会报异常</span></span><br><span class="line">        BufferedInputStream bi = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">        ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] data  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">60</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ( -<span class="number">1</span> !=  (len = is.read(data,<span class="number">0</span>, data.length)))&#123;</span><br><span class="line">            os.write(data, <span class="number">0</span>, len);</span><br><span class="line">            os.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] datas = os.toByteArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 封装DatagramPacket包，需要指定目的地</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length,</span><br><span class="line">                <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        <span class="comment">// 4. 发送包裹send( DatagramPacket p）</span></span><br><span class="line">        client.send(packet);</span><br><span class="line">        <span class="comment">// 5.  释放资源</span></span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受端：</span></span><br><span class="line"><span class="comment"> * 1. 使用DatagramSocket 指定端口 创建接收端</span></span><br><span class="line"><span class="comment"> * 2. 指定容器， 封装DatagramPacket包</span></span><br><span class="line"><span class="comment"> * 3. 阻塞式接受包裹receive（DatagramPacket p）</span></span><br><span class="line"><span class="comment"> * 4. 分析数据</span></span><br><span class="line"><span class="comment"> *  byte[] getData()</span></span><br><span class="line"><span class="comment"> *          getLength()</span></span><br><span class="line"><span class="comment"> *  5.  释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment">* <span class="doctag">@create</span> 2020-02-20 11:51</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPFileServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收端启动中...&quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 使用DatagramSocket 指定端口 创建接收端</span></span><br><span class="line">        DatagramSocket server = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 2. 指定容器， 封装DatagramPacket包</span></span><br><span class="line">        <span class="keyword">byte</span>[] contiainer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">60</span>];</span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(contiainer, <span class="number">0</span>, contiainer.length);</span><br><span class="line">        <span class="comment">// 3. 阻塞式接受包裹receive（DatagramPacket p）</span></span><br><span class="line">        server.receive(packet);</span><br><span class="line">        <span class="comment">// 4. 分析数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] datas = packet.getData();</span><br><span class="line">        <span class="keyword">int</span> len = packet.getLength();</span><br><span class="line"><span class="comment">//        System.out.println(new String(datas, 0, len));</span></span><br><span class="line">        BufferedOutputStream os =<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./socket/copy.png&quot;</span>)); <span class="comment">//接受数据</span></span><br><span class="line">        os.write(datas, <span class="number">0</span>, datas.length);</span><br><span class="line">        os.flush();</span><br><span class="line">        <span class="comment">// 5.  释放资源</span></span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="UDP案例：-多线程实现在线咨询"><a href="#UDP案例：-多线程实现在线咨询" class="headerlink" title="UDP案例： 多线程实现在线咨询"></a>UDP案例： 多线程实现在线咨询</h2><h3 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送端： 使用面向对象封装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 10:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">talkSend</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket client ; <span class="comment">// 发送端套接字</span></span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader; <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">private</span> String toIP; <span class="comment">// 发送到服务端的IP</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> toPort; <span class="comment">// 服务端的端口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">talkSend</span><span class="params">(<span class="keyword">int</span> port, String toIP, <span class="keyword">int</span> toPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.toIP = toIP;</span><br><span class="line">        <span class="keyword">this</span>.toPort = toPort;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.client = <span class="keyword">new</span> DatagramSocket(port);</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            String msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg = reader.readLine();</span><br><span class="line">                <span class="keyword">byte</span>[] datas = msg.getBytes();</span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas, <span class="number">0</span>, datas.length, <span class="keyword">new</span> InetSocketAddress(<span class="keyword">this</span>.toIP, <span class="keyword">this</span>.toPort));</span><br><span class="line">                client.send(packet); <span class="comment">// 发送</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equals(msg))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 11:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">talkRecieve</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket server;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">talkRecieve</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.server = <span class="keyword">new</span> DatagramSocket(port);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">60</span>];</span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(data,<span class="number">0</span>, data.length);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                server.receive(packet);</span><br><span class="line">                <span class="keyword">byte</span>[] datas = packet.getData();</span><br><span class="line">                String msg = <span class="keyword">new</span> String(datas);</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;bye&quot;</span>.equals(msg))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建学生端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生端： 加入多线程，实现在线交流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 11:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkStudent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> talkSend(<span class="number">8989</span>, <span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> talkRecieve(<span class="number">10024</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建教师端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 教室端： 加入多线程，实现在线交流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 11:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkTeacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> talkRecieve(<span class="number">9999</span>)).start(); <span class="comment">// 接受信息</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> talkSend(<span class="number">10025</span>, <span class="string">&quot;localhost&quot;</span>, <span class="number">10024</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582258221891.png" class width="1582258221891"><hr><h1 id="六、-TCP-编程"><a href="#六、-TCP-编程" class="headerlink" title="六、 TCP 编程"></a>六、 TCP 编程</h1><p>TCP协议基于请求-响应模式，  在网络通讯中，第一次主动发起通讯的程序被称作客户端(Client)程序，第一次通讯中等待连接的程序被称作服务器端 (Server)程序。利用IO流实现数据的传输。</p><img src="/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582261736199.png" alt="1582261736199" style="zoom:100%;"><h2 id="TCP通信原理"><a href="#TCP通信原理" class="headerlink" title="TCP通信原理"></a>TCP通信原理</h2><p> 服务器创建<code>ServerSocket</code>，在指定端口监听并并处理请求。</p><p>客户端创建<code>Socket</code>，向服务器发送请求。</p><img src="/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582262725020.png" alt="1582262725020" style="zoom:100%;"><h2 id="完成网络登录功能"><a href="#完成网络登录功能" class="headerlink" title="完成网络登录功能"></a>完成网络登录功能</h2><p>使用基于TCP协议的Socket网络编程实现。</p><blockquote><p>单向：客户端向服务器端发送字符串，服务器获取字符串并输出<br>双向：服务器端给出客户端反馈，客户端得到反馈并输出<br>对象：客户端向服务器端发送User对象，服务器端获取对象并输出<br>多线程：服务器接收多个客户端的请求，并给出反馈每个客户请求开启一个线程</p></blockquote><p>服务端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">/**</span><br><span class="line"> * TCP单向： 服务端</span><br><span class="line"> * @author Hongliang Zhu</span><br><span class="line"> * @create 2020-02-21 13:28</span><br><span class="line"> */</span><br><span class="line">public class TCPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;-----------服务端--------------&quot;);</span><br><span class="line">        ServerSocket server = new ServerSocket(9696);</span><br><span class="line">        Socket cilent = server.accept(); //  监听连接请求， 返回对应的客户端</span><br><span class="line">        System.out.println(&quot;建立了一个连接&quot;);</span><br><span class="line">        InputStream is = cilent.getInputStream();</span><br><span class="line">        DataInputStream dis = new DataInputStream(is);</span><br><span class="line">        // 读取</span><br><span class="line">        String uname = null;</span><br><span class="line">        String upwd = null;</span><br><span class="line">        String msg = dis.readUTF();</span><br><span class="line">        String []datas = msg.split(&quot;&amp;&quot;);</span><br><span class="line">        for(String s: datas)&#123;</span><br><span class="line">            String[] info = s.split(&quot;=&quot;);</span><br><span class="line">            if(&quot;uname&quot;.equals(info[0]))&#123;</span><br><span class="line">                System.out.println(&quot;您的用户名为：&quot;+ info[1]);</span><br><span class="line">                uname = info[1];</span><br><span class="line">            &#125;</span><br><span class="line">            if(&quot;upwd&quot;.equals(info[0]))&#123;</span><br><span class="line">                System.out.println(&quot;您的密码为：&quot;+ info[1]);</span><br><span class="line">                upwd = info[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断：返回给客户端的信息</span><br><span class="line">        String back = null;</span><br><span class="line">        DataOutputStream dos = new DataOutputStream(cilent.getOutputStream());</span><br><span class="line">        if(&quot;zhuhongliang&quot;.equals(uname) &amp;&amp; &quot;123456&quot;.equals(upwd))&#123;</span><br><span class="line">            back = &quot;登录成功， 欢迎回来&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            back = &quot;用户名或者密码错误！&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        dos.writeUTF(back);</span><br><span class="line">        dos.flush();</span><br><span class="line"></span><br><span class="line">        // 关闭资源</span><br><span class="line">        dos.close();</span><br><span class="line">        dis.close();</span><br><span class="line">        cilent.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCp 客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 13:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------客户端---------------&quot;</span>);</span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">9696</span>); <span class="comment">//服务器的ip和端口</span></span><br><span class="line">        <span class="comment">// 操作： 输入输出流</span></span><br><span class="line">        String uname;</span><br><span class="line">        String upwd;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">        uname = br.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        upwd = br.readLine();</span><br><span class="line">        String msg = <span class="string">&quot;uname=&quot;</span>+ uname +<span class="string">&quot;&amp;&quot;</span>+<span class="string">&quot;upwd=&quot;</span>+upwd;</span><br><span class="line">        <span class="comment">// 写出</span></span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">        dos.writeUTF(msg);</span><br><span class="line">        dos.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收服务端返回的结果</span></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">        String res = dis.readUTF();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        dos.close();</span><br><span class="line">        br.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582267524749.png" alt="1582267524749" style="zoom:100%;"><img src="/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582267597408.png" alt="1582267597408" style="zoom:100%;"><img src="/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582267550778.png" alt="1582267550778" style="zoom:100%;"><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCp 客户端  文件上传</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 13:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------客户端---------------&quot;</span>);</span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">9696</span>); <span class="comment">//服务器的ip和端口</span></span><br><span class="line">        <span class="comment">// 操作： 输入输出流</span></span><br><span class="line">        <span class="comment">// 文件拷贝</span></span><br><span class="line">        InputStream is = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;./io/io.png&quot;</span>));</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> BufferedOutputStream(client.getOutputStream());</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (-<span class="number">1</span> != (len = is.read(buff)))&#123;</span><br><span class="line">            os.write(buff,<span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        os.flush();</span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP:服务端  保存文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 13:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------服务端--------------&quot;</span>);</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9696</span>);</span><br><span class="line">        Socket cilent = server.accept(); <span class="comment">//  监听连接请求， 返回对应的客户端</span></span><br><span class="line">        System.out.println(<span class="string">&quot;建立了一个连接&quot;</span>);</span><br><span class="line">        <span class="comment">// 接受数据</span></span><br><span class="line">        InputStream is = <span class="keyword">new</span> BufferedInputStream(cilent.getInputStream());</span><br><span class="line">        OutputStream os = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;./socket/tcp.png&quot;</span>)));</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (-<span class="number">1</span> != (len = is.read(buff)))&#123;</span><br><span class="line">            os.write(buff,<span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        os.flush();</span><br><span class="line">        is.close();</span><br><span class="line">        os.close();</span><br><span class="line">        cilent.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多用户登录"><a href="#多用户登录" class="headerlink" title="多用户登录"></a>多用户登录</h2><p>服务端： 使用了<strong>多线程</strong>实现多个用户同时处理，将对接管道封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP多用户登录： 服务端  多线程处理  面向对象高度封装！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-02-21 13:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPMutiServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// main方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------服务端--------------&quot;</span>);</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9696</span>);</span><br><span class="line">        <span class="keyword">boolean</span> isRuning = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (isRuning)&#123;</span><br><span class="line">            Socket cilent = server.accept(); <span class="comment">//  监听连接请求， 返回对应的客户端</span></span><br><span class="line">            System.out.println(<span class="string">&quot;建立了一个连接&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Channel(cilent)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 封装管道 里面有输入流和输出流 ，使用多线程可以服务多个客户端</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket client; <span class="comment">// 客户端</span></span><br><span class="line">        <span class="keyword">private</span> DataInputStream dis; <span class="comment">// 输入流  ==&gt; 用于客户端请求服务端的信息</span></span><br><span class="line">        <span class="keyword">private</span> DataOutputStream dos; <span class="comment">//  输出流 ==&gt; 服务端给客户端的响应信息</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Channel</span><span class="params">(Socket client)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = client;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">this</span>.client.getInputStream()); <span class="comment">// 获取客户端输入</span></span><br><span class="line">                dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">this</span>.client.getOutputStream()); <span class="comment">// 给客户端的响应</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">recieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">            String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg = dis.readUTF();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送给客户端数据</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dos.writeUTF(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != dos)</span><br><span class="line">                    dos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != dis)</span><br><span class="line">                    dis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != client)</span><br><span class="line">                    client.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 读取读取</span></span><br><span class="line">            String msg = recieve();</span><br><span class="line">            String uname = <span class="keyword">null</span>;</span><br><span class="line">            String upwd = <span class="keyword">null</span>;</span><br><span class="line">            String []datas = msg.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(String s: datas)&#123;</span><br><span class="line">                String[] info = s.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;uname&quot;</span>.equals(info[<span class="number">0</span>]))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的用户名为：&quot;</span>+ info[<span class="number">1</span>]);</span><br><span class="line">                    uname = info[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;upwd&quot;</span>.equals(info[<span class="number">0</span>]))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的密码为：&quot;</span>+ info[<span class="number">1</span>]);</span><br><span class="line">                    upwd = info[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断：返回给客户端的信息</span></span><br><span class="line">            String back = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;zhuhongliang&quot;</span>.equals(uname) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(upwd))&#123;</span><br><span class="line">                back = <span class="string">&quot;登录成功， 欢迎回来&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                back = <span class="string">&quot;用户名或者密码错误！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            send(back); <span class="comment">// 发送给客户端</span></span><br><span class="line">            release(); <span class="comment">// 释放资源</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端： 对发送和接受高度封装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多用户登录： 面向对象思维高度封装！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020年2月21日23:57:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPMultiClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------客户端---------------&quot;</span>);</span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">9696</span>); <span class="comment">//服务器的ip和端口</span></span><br><span class="line">        <span class="comment">// 操作： 输入输出流</span></span><br><span class="line">        <span class="keyword">new</span> Send(client).send();</span><br><span class="line">        <span class="comment">//接收</span></span><br><span class="line">        <span class="keyword">new</span> Recieve(client).recieve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送给服务器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket client;</span><br><span class="line">        <span class="keyword">private</span> BufferedReader br;</span><br><span class="line">        <span class="keyword">private</span> DataOutputStream dos;</span><br><span class="line">        String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Send</span><span class="params">(Socket client)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = client;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">                dos = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">                msg = init();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">            String uname = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            String upwd = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">                uname = br.readLine();</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">                upwd = br.readLine();</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;uname=&quot;</span>+ uname +<span class="string">&quot;&amp;&quot;</span>+<span class="string">&quot;upwd=&quot;</span>+upwd;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// 写出</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dos.writeUTF(msg);</span><br><span class="line">                dos.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收服务器的返回消息</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Recieve</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket client;</span><br><span class="line">        <span class="keyword">private</span> DataInputStream dis;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Recieve</span><span class="params">(Socket client)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = client;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String res = dis.readUTF();</span><br><span class="line">                System.out.println(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="七、-实例：-手写在线聊天室"><a href="#七、-实例：-手写在线聊天室" class="headerlink" title="七、 实例： 手写在线聊天室"></a>七、 实例： 手写在线聊天室</h1><h2 id="1-服务器"><a href="#1-服务器" class="headerlink" title="1.  服务器"></a>1.  服务器</h2><p>功能：相当于消息的中转站（转发器）</p><blockquote><p>1.可以同时处理多个客户端的请求。</p><p>2.当一个用户进入群聊的时候，会给群聊中所有的用户群发一条系统消息，提示所有用户有人进来了群聊当中。</p><p>3.当一个用户成功进入群聊的时候， 服务器会发送一条问候语给当前客户。</p><p>4.当一个用户离开群聊的时候，会给群聊中所有的用户群发一条系统消息，提示所有用户xxx离开了群聊。</p><p>5.一个用户发送的消息可以给群聊中的所有用户发送。</p><p>6.可以对指定的用户私聊，消息只对指定的用户看见。格式： @xxx：message</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatVersion;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.relation.Relation;</span><br><span class="line"><span class="keyword">import</span> javax.print.attribute.standard.MediaSize.Other;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在线聊天室： 群聊版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZHLAS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chat</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> CopyOnWriteArrayList&lt;Channel&gt; all = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;-------------服务器启动中------------------&quot;</span>);</span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line"><span class="comment">// 等待连接</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">Socket client = server.accept();</span><br><span class="line">System.out.println(<span class="string">&quot;建立一个连接&quot;</span>);</span><br><span class="line">Channel c = <span class="keyword">new</span> Channel(client);</span><br><span class="line">all.add(c); <span class="comment">// 加入一个客户端</span></span><br><span class="line"><span class="keyword">new</span> Thread(c).start();<span class="comment">// 开始服务</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个Channel代表一个客户端</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket client;</span><br><span class="line"><span class="keyword">private</span> DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isRuning = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">//当前客户端的名字</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Channel</span><span class="params">(Socket client)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.client = client;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">dos= <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line"><span class="comment">//欢迎您的到来</span></span><br><span class="line"><span class="keyword">this</span>.name = recieve(); <span class="comment">///接收到客户端的名字</span></span><br><span class="line"><span class="keyword">this</span>.send(<span class="string">&quot;欢迎您来到聊天室！&quot;</span>); <span class="comment">// 发送给对应客户端的欢迎词</span></span><br><span class="line">sendOthers(<span class="keyword">this</span>.name+ <span class="string">&quot;加入了群聊...&quot;</span>, <span class="keyword">true</span>); <span class="comment">//告诉大家谁加入了群聊</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">relese();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务器接收到客户端发送的数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">recieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">msg = dis.readUTF();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">relese();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器给客户点发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">dos.writeUTF(msg);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">relese();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 群发 ： 获取自己的消息， 发送给别人</span></span><br><span class="line"><span class="comment"> * 私聊： 约定数据格式 ： <span class="doctag">@xxx</span>:msg</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendOthers</span><span class="params">(String msg, <span class="keyword">boolean</span> isSys)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> isPrivate = msg.startsWith(<span class="string">&quot;@&quot;</span>); <span class="comment">//私聊</span></span><br><span class="line"><span class="keyword">if</span>(isPrivate)&#123; <span class="comment">//私聊</span></span><br><span class="line"><span class="keyword">int</span> idx = msg.indexOf(<span class="string">&quot;:&quot;</span>); <span class="comment">//冒号的位置</span></span><br><span class="line"><span class="comment">// 获取目标和数据</span></span><br><span class="line">String targetName = msg.substring(<span class="number">1</span>, idx);</span><br><span class="line">msg = msg.substring(idx+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 遍历客户，找到指定目标</span></span><br><span class="line"><span class="keyword">for</span>(Channel target : all)&#123;</span><br><span class="line"><span class="keyword">if</span>(target.name.equals(targetName))&#123;</span><br><span class="line">target.send(<span class="keyword">this</span>.name +<span class="string">&quot;悄悄地对你说： &quot;</span>+msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 遍历容器</span></span><br><span class="line"><span class="keyword">for</span>(Channel c: all)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == c)&#123; <span class="comment">//自己</span></span><br><span class="line"><span class="keyword">continue</span>; </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!isSys)</span><br><span class="line">c.send(<span class="keyword">this</span>.name+<span class="string">&quot;对所有人说： &quot;</span>+msg);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">c.send(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relese</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.isRuning = <span class="keyword">false</span>;</span><br><span class="line">Release.reslese(dos, dis, client);</span><br><span class="line"><span class="comment">// 移除容器的客户端</span></span><br><span class="line">all.remove(<span class="keyword">this</span>);</span><br><span class="line">sendOthers(<span class="keyword">this</span>.name+<span class="string">&quot;离开了群聊...&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String msg =<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(isRuning)&#123;</span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line">msg  = recieve();</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(msg))&#123;</span><br><span class="line"><span class="comment">//send(msg);</span></span><br><span class="line">sendOthers(msg, <span class="keyword">false</span>); <span class="comment">// 群聊</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h2><p>功能：</p><blockquote><p>1.发送消息给服务器</p><p>2.从服务器那边接收消息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatVersion;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.nio.Buffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.omg.CosNaming.NamingContextExtPackage.StringNameHelper;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在线聊天室：客户端  </span></span><br><span class="line"><span class="comment"> * 目标：群聊 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZHLAS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;-------------客户端--------------&quot;</span>);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的姓名：&quot;</span>);</span><br><span class="line">String name = br.readLine();</span><br><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>); <span class="comment">// 建立连接</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Send(client, name)).start();  <span class="comment">//  发送</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Recieve(client)).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatVersion;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 发送端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZHLAS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket client;</span><br><span class="line"><span class="comment">// 准备数据</span></span><br><span class="line"><span class="keyword">private</span> BufferedReader br; </span><br><span class="line"><span class="keyword">private</span> DataOutputStream dos;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isRuning = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> String name; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Send</span><span class="params">(Socket client, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.client = client;</span><br><span class="line">br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">dos = <span class="keyword">new</span> DataOutputStream(client.getOutputStream());</span><br><span class="line">send(name); <span class="comment">// 把客户端的名称发送给服务器</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">this</span>.isRuning = <span class="keyword">false</span>;</span><br><span class="line">Release.reslese(dos, br, client);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 写出</span></span><br><span class="line">dos.writeUTF(msg);</span><br><span class="line">dos.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">this</span>.isRuning = <span class="keyword">false</span>;</span><br><span class="line">Release.reslese(dos, br);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(isRuning)&#123;</span><br><span class="line">String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">msg = br.readLine();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">this</span>.isRuning = <span class="keyword">false</span>;</span><br><span class="line">Release.reslese(br);</span><br><span class="line">&#125;</span><br><span class="line">send(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatVersion;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ZHLAS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recieve</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket client;</span><br><span class="line"><span class="keyword">private</span> DataInputStream dis;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isRuning = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Recieve</span><span class="params">(Socket client)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.client = client;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">dis = <span class="keyword">new</span> DataInputStream(client.getInputStream());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">this</span>.isRuning = <span class="keyword">false</span>;</span><br><span class="line">Release.reslese(dis, client);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">recieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String msg =<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">msg = dis.readUTF();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">Release.reslese(dis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(isRuning)&#123;</span><br><span class="line">String msg = recieve();</span><br><span class="line"><span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(msg))</span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-释放资源"><a href="#3-释放资源" class="headerlink" title="3. 释放资源"></a>3. 释放资源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatVersion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Release</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reslese</span><span class="params">(Closeable... targets)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(Closeable target: targets)&#123;</span><br><span class="line"><span class="keyword">if</span>(target != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">target.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-运行效果"><a href="#4-运行效果" class="headerlink" title="4. 运行效果"></a>4. 运行效果</h2><img src="/2024/11/07/Java%E4%B8%93%E9%A2%98%E4%B9%8BSocket%E7%BC%96%E7%A8%8B/1582388285811.png" alt="1582388285811" style="zoom:150%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、-概述&quot;&gt;&lt;a href=&quot;#一、-概述&quot; class=&quot;headerlink&quot; title=&quot;一、 概述&quot;&gt;&lt;/a&gt;一、 概述&lt;/h1&gt;&lt;p&gt;Java 中的网络支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;InetAddress&lt;/code&gt;：用于表示网络上</summary>
      
    
    
    
    <category term="Java" scheme="https://castile.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://castile.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实战45讲精华</title>
    <link href="https://castile.github.io/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/"/>
    <id>https://castile.github.io/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/</id>
    <published>2024-06-05T15:52:28.000Z</published>
    <updated>2024-06-08T16:14:37.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-一条SQL查询语句是如何执行的"><a href="#01-一条SQL查询语句是如何执行的" class="headerlink" title="01 一条SQL查询语句是如何执行的"></a>01 一条SQL查询语句是如何执行的</h2><p>见 <a href="https://castile.github.io/2021/07/23/mysql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/">https://castile.github.io/2021/07/23/mysql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</a></p><h2 id="02-日志系统：一条SQL更新语句是如何执行的"><a href="#02-日志系统：一条SQL更新语句是如何执行的" class="headerlink" title="02 日志系统：一条SQL更新语句是如何执行的"></a>02 日志系统：一条SQL更新语句是如何执行的</h2><p>更新语句：<code> update T set c=c+1 where ID=2;</code></p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717170384442.png" class width="1717170384442"><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>redo log使用WAL技术（<code>Write-Ahead Logging</code>），也就是先写日志再写磁盘。 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做 </p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717170442866.png" class width="1717170442866"><p> <code>write pos</code> 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。 </p><p> redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。 </p><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>与redo log的区别：</p><ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><p>更新语句执行流程图：</p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717170669560.png" class width="1717170669560"><p>注意，这里使用了两阶段提交。是因为要保证 数据库的状态和用它的日志恢复出来的库的一致。</p><h2 id="03-事务隔离"><a href="#03-事务隔离" class="headerlink" title="03  事务隔离"></a>03  事务隔离</h2><h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。</p><p> SQL 标准的事务隔离级别包括： 读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717170896058.png" class width="1717170896058"><p>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。 </p><p>当没有事务再需要用到这些回滚日志时，回滚日志会被删除，因此尽量不要使用长事务。 <strong>由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间</strong> </p><h3 id="查询事务"><a href="#查询事务" class="headerlink" title="查询事务"></a>查询事务</h3><p> 可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</span><br></pre></td></tr></table></figure><h3 id="如何避免长事务对业务的影响？"><a href="#如何避免长事务对业务的影响？" class="headerlink" title="如何避免长事务对业务的影响？"></a>如何避免长事务对业务的影响？</h3><p><strong>首先，从应用开发端来看：</strong></p><ol><li>确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。</li><li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。</li><li>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li></ol><p><strong>其次，从数据库端来看：</strong></p><ol><li>监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；</li><li>Percona 的 pt-kill 这个工具不错，推荐使用；</li><li>在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；</li><li>如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li></ol><h2 id="04-深入浅出索引（上）"><a href="#04-深入浅出索引（上）" class="headerlink" title="04 深入浅出索引（上）"></a>04 深入浅出索引（上）</h2><p> <strong>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样</strong> </p><h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><p>常见的有哈希表、有序数组和搜索树。 </p><ul><li><p>哈希索引： 通过hash函数计算key所在的位置从而找到value，冲突后后面挂了一条链表。 <strong>哈希表这种结构适用于只有等值查询的场景</strong> ， 区间查询需要遍历全部，查询很慢。</p></li><li><p>有序数组：  <strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong> ，  但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。  所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。 </p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717171297503.png" class width="1717171297503"></li><li><p> 二叉搜索树 ：  O(log(N)) 的查询复杂度 ， 新的时间复杂度也是 O(log(N))。 </p></li></ul>  <img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717171369348.png" class width="1717171369348"><h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><p> 在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为<strong>索引组织表</strong> </p><p> nnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的， 每一个索引在 InnoDB 里面对应一棵 B+ 树。 <strong>B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数</strong> </p><p>建表语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table T(</span><br><span class="line">id int primary key, </span><br><span class="line">k int not null, </span><br><span class="line">name varchar(16),</span><br><span class="line">index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure><p> 表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)， </p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717171588759.png" class width="1717171588759"><p> 根据叶子节点的内容，索引类型分为主键索引和非主键索引 </p><ul><li><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</p></li><li><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）</p></li></ul><p> <strong>基于主键索引和普通索引的查询有什么区别？</strong> </p><ul><li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li><li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h3 id="索引如何维护"><a href="#索引如何维护" class="headerlink" title="索引如何维护"></a>索引如何维护</h3><p>插入数据的时候就需要维护索引B+树，可能会涉及到页分裂、合并操作。</p><p>*<strong>哪些场景下应该使用自增主键，而哪些场景下不应该？</strong></p><p>自增主键：  插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值；  每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂 </p><p>有的 业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p><p>除了考虑性能外，我们还可以从存储空间的角度来看， <strong>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</strong> </p><blockquote><p>“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。 </p></blockquote><h2 id="05-深入浅出索引（下）"><a href="#05-深入浅出索引（下）" class="headerlink" title="05 深入浅出索引（下）"></a>05 深入浅出索引（下）</h2><p>语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">index k(k))</span><br><span class="line">engine=InnoDB;</span><br><span class="line"> </span><br><span class="line">insert into T values(100,1, &#x27;aa&#x27;),(200,2,&#x27;bb&#x27;),(300,3,&#x27;cc&#x27;),(500,5,&#x27;ee&#x27;),(600,6,&#x27;ff&#x27;),(700,7,&#x27;gg&#x27;);</span><br></pre></td></tr></table></figure><p> 执行<code>select * from T where k between 3 and 5</code>，需要执行几次树的搜索操作，会扫描多少行？ </p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717172560950.png" class width="1717172560950"><ol><li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li><li>再到 ID 索引树查到 ID=300 对应的 R3；</li><li>在 k 索引树取下一个值 k=5，取得 ID=500；</li><li>再回到 ID 索引树查到 ID=500 对应的 R4；</li><li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li></ol><p> 可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。 </p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p> 如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。 </p><p> <strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong> </p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p> <strong>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong> </p><p> 用（name，age）这个联合索引来分析。  索引项是按照索引定义里面出现的字段顺序排序的。 </p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717173042998.png" class width="1717173042998"><p> 当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果.</p><p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止 </p><p>这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。 </p><p> <strong>在建立联合索引的时候，如何安排索引内的字段顺序</strong>?</p><p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong> </p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>最左前缀可以用于在索引中定位记录，那些不符合最左前缀的部分，会怎么样呢？ </p><p> 市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tuser where name like &#x27;张 %&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure><p> 搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3， 后面只能从ID3开始回表操作，找出数据行再比较字段值。</p><p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p><p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717173602091.png" class width="1717173602091"><p>InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次 </p><h2 id="06-全局锁和表锁"><a href="#06-全局锁和表锁" class="headerlink" title="06 全局锁和表锁"></a>06 全局锁和表锁</h2><p> <strong>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类</strong> </p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。 </p><p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都 select 出来存成文本。 </p><p>全库备份的方式</p><p>1、   Flush tables with read lock (FTWRL)</p><p>2、使用可重复读的事务隔离级别。 逻辑备份工具是 mysqldump。  使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。  <strong>但前提是引擎要支持这个隔离级别。</strong>比如，对于 MyISAM 这种不支持事务的引擎。</p><p>3、 <strong>全库只读，为什么不使用 set global readonly=true 的方式呢</strong>？但是建议使用FTWRL，原因如下：</p><ul><li>一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。</li><li>二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。 </p><p> <strong>表锁的语法是 lock tables … read/write</strong>。 可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。</p><p><strong>另一类表级的锁是 MDL（metadata lock)。</strong>MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。 </p><p>当要对表做结构变更操作的时候，加 MDL 写锁。</p><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p><strong>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</strong> </p><p> <strong>如何安全地给小表加字段？</strong> </p><p>1、 我们要解决长事务，事务不提交，就会一直占着 MDL 锁。 如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。 </p><p> 如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？ </p><blockquote><p>在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。 </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name NOWAIT add column ...</span><br><span class="line">ALTER TABLE tbl_name WAIT N add column ... </span><br></pre></td></tr></table></figure><h2 id="07-行锁功过：怎么减少行锁对性能的影响？"><a href="#07-行锁功过：怎么减少行锁对性能的影响？" class="headerlink" title="07 行锁功过：怎么减少行锁对性能的影响？"></a>07 行锁功过：怎么减少行锁对性能的影响？</h2><p>行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。 </p><p> <strong>InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong> 因此， <strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong> </p><h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。 </p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717426107205.png" class width="1717426107205"><p> 事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略： </p><ul><li><p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。默认是50s</p></li><li><p>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</p></li></ul><p>那种好用呢？</p><p>如果采用第一种，使用默认值的话，出现了死锁要等待50s才能超时退出，对于在线服务来说是无法接受的。但是如果值设置成1s，太短，会出现误伤。</p><p>采用第二种的话，如果客户端并发更新1000次，死锁检查就要执行100w次（每个线程都需要循环判断1000次，所以是10的6次方），那么死锁检测就需要大量的cpu， 你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。 </p><p><strong>解决方法：</strong></p><p>1、 <strong>确保这个业务一定不会出现死锁，可以临时把死锁检测关掉</strong> ： innodb_deadlock_detect = off</p><p>2、 <strong>控制并发度</strong> ：  对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。 </p><p>3、 冗余行设计： 减少冲突概率，减少锁等待次数，也就减少了死锁检测的CPU消耗。</p><p>如果你要删除一个表里面的前 10000 行数据，有以下三种方法可以做到：</p><ul><li>第一种，直接执行 delete from T limit 10000;</li><li>第二种，在一个连接中循环执行 20 次 delete from T limit 500;</li><li>第三种，在 20 个连接中同时执行 delete from T limit 500。</li></ul><p>你会选择哪一种方法呢？为什么呢？</p><p>第二种好一点。</p><p> 第一种方式： 单个语句占用时间长，锁的时间也比较长；而且大事务还会导致主从延迟。 </p><p> 第三种方式 ： 会人为造成锁冲突</p><h2 id="08-事务到底是隔离的还是不隔离的？"><a href="#08-事务到底是隔离的还是不隔离的？" class="headerlink" title="08 事务到底是隔离的还是不隔离的？"></a>08 事务到底是隔离的还是不隔离的？</h2><h3 id="“快照”在-MVCC-里是怎么工作的？"><a href="#“快照”在-MVCC-里是怎么工作的？" class="headerlink" title="“快照”在 MVCC 里是怎么工作的？"></a>“快照”在 MVCC 里是怎么工作的？</h3><p> 可重复读隔离级别： 一个事务在启动的时候看到的数据，在整个事务过程中看到的数据是一致的。</p><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，<strong>这个快照是基于整库的</strong>。        </p><h4 id="快照的实现"><a href="#快照的实现" class="headerlink" title="快照的实现"></a>快照的实现</h4><p>每个事务有一个唯一的事务 ID，叫作 transaction id，且是严格递增的。</p><p>每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。也就是说数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。 </p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717596918523.png" class width="1717596918523"><blockquote><p> 虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。 </p></blockquote><p>三个虚线箭头，就是 undo log(回滚日志)；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p><p> InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。  </p><p>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。 这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p><p>而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717597097920.png" class title="数据版本可见性规则"><p>对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p><ol><li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在黄色部分，那就包括两种情况：<ul><li>a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见； </li><li>b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ul></li></ol><p> <strong>InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong> </p><h3 id="事务的可重复读的能力是怎么实现的"><a href="#事务的可重复读的能力是怎么实现的" class="headerlink" title="事务的可重复读的能力是怎么实现的"></a><strong>事务的可重复读的能力是怎么实现的</strong></h3><p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用<strong>当前读</strong>。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。 </p><p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是： </p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, k) values(1,1),(2,2);</span><br></pre></td></tr></table></figure><h4 id="可重复读隔离级别下"><a href="#可重复读隔离级别下" class="headerlink" title="可重复读隔离级别下"></a>可重复读隔离级别下</h4><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717599590908.png" class width="1717599590908"><p>这里，我们不妨做如下假设：</p><ol><li>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</li><li>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</li><li>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。</li></ol><p>这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。</p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717599642597.png" class width="1717599642597"><p>事务 A 查询语句的读数据流程是这样的：</p><ul><li>找到 (1,3) 的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看 row trx_id=102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的 row trx_id=90，比低水位小，处于绿色区域，可见。</li></ul><p><strong>总结就是：一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</strong></p><ol><li><strong>版本未提交，不可见；</strong></li><li><strong>版本已提交，但是是在视图创建后提交的，不可见；</strong></li><li><strong>版本已提交，而且是在视图创建前提交的，可见。</strong></li></ol><h4 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h4><p> 用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong> </p><p>因此，在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 row trx_id 是 101。</p><p>所以，在执行事务 B 查询语句的时候，一看自己的版本号是 101，最新数据的版本号也是 101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。</p><h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><p> 事务 C 不是马上提交的，而是变成了下面的事务 C’，会怎么样呢？  更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。</p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717599761178.png" class width="1717599761178"><p>事务 C’没提交，也就是说 (1,2) 这个版本上的写锁还没释放。而事务 B 是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C’释放这个锁，才能继续它的当前读。 </p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717599793215.png" class width="1717599793215"><p>本地验证结果也符合预期：</p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717599909603.png" class width="1717599909603"><h4 id="读提交隔离级别下的情况"><a href="#读提交隔离级别下的情况" class="headerlink" title="读提交隔离级别下的情况"></a>读提交隔离级别下的情况</h4><p> 在读提交隔离级别下，事务 A 和事务 B 的查询语句查到的 k，分别应该是多少呢？ </p><blockquote><p>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</p></blockquote><p> “start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的 start transaction。 </p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717600004535.png" class title="读提交隔离级别下的事务状态图"><p>事务 A 的查询语句的视图数组是在执行这个语句的时候创建的，时序上 (1,2)、(1,3) 的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：</p><ul><li>(1,3) 还没提交，属于情况 1，不可见；</li><li>(1,2) 提交了，属于情况 3，可见。</li></ul><p>所以，这时候事务 A 查询语句返回的是 k=2。</p><p>显然地，事务 B 查询结果 k=3。</p><h2 id="09-普通索引和唯一索引，应该怎么选择？"><a href="#09-普通索引和唯一索引，应该怎么选择？" class="headerlink" title="09 普通索引和唯一索引，应该怎么选择？"></a>09 普通索引和唯一索引，应该怎么选择？</h2><p>假设有以下索引组织结构：</p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717685526053.png" class width="1717685526053"><p>从这两种索引对查询语句和更新语句的性能影响来进行分析 </p><h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li></ul><p> <strong>这个不同带来的性能差距会有多少呢？答案是，微乎其微</strong>。 因为 InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p> 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在<code> change buffer</code> 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 <code>change buffer </code>中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。 </p><blockquote><p> 虽然名字叫作<code> change buffer</code>，实际上它是可以持久化的数据。也就是说，<code>change buffer </code>在内存中有拷贝，也会被写入到磁盘上 </p></blockquote><p>将 <code>change buffer </code>中的操作应用到原数据页，得到最新结果的过程称为 <code>merge</code>。</p><p><strong>merge的时机：</strong></p><p><strong>1、 访问这个数据页</strong></p><p><strong>2、数据库正常关闭时</strong></p><h3 id="什么条件下可以使用-change-buffer"><a href="#什么条件下可以使用-change-buffer" class="headerlink" title="什么条件下可以使用 change buffer"></a><strong>什么条件下可以使用 change buffer</strong></h3><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反<strong>唯一性约束</strong>，这样就必须要将数据页读入内存中才能判断，这就没必要使用<code>change buffer</code></p><p> <strong>实际上也只有普通索引可以使用。</strong> </p><p><code>change buffer</code> 用的是 <code>buffer pool </code>里的内存，因此不能无限增大。<code>change buffer</code> 的大小，可以通过参数 <code>innodb_change_buffer_max_size </code>来动态设置。这个参数设置为 25的时候，表示 <code>change buffer</code> 的大小最多只能占用<code> buffer pool</code> 的 25%。 </p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717686055244.png" class width="1717686055244"><p> <strong>如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。</strong> </p><ul><li> <strong>这个记录要更新的目标页在内存中</strong> </li><li>对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</li></ul><p>   普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间 </p><ul><li> <strong>这个记录要更新的目标页不在内存中</strong> </li><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在 <code>change buffer</code>，语句执行就结束了。</li></ul><p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。<code>change buffer</code> 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。 </p><h3 id="change-buffer-的使用场景"><a href="#change-buffer-的使用场景" class="headerlink" title="change buffer 的使用场景"></a>change buffer 的使用场景</h3><p><code>change buffer</code> 只限于用在普通索引的场景下，而不适用于唯一索引。</p><p>普通索引的所有场景，使用` change buffer 都可以起到加速作用吗？ </p><p>因为 merge 的时候是真正进行数据更新的时刻，而 <code>change buffer </code>的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前<code>change buffer </code>记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。 </p><p>1、 对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 <code>change buffer </code>的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。 </p><p> 2、假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 <code>change buffer </code>，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了<code>change buffer </code>的维护代价。所以，对于这种业务模式来说，<code>change buffer </code> 反而起到了副作用。 </p><h3 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h3><p>1、 查询上无差别，考虑更新性能选择普通索引</p><p>2、数据量大的表更新，选择普通索引</p><p>3、机械硬盘时，尽量使用普通索引，然后把 change buffer 尽量开大</p><h3 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure><p> 我们假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (<code>InnoDB buffer pool</code>) 中，k2 所在的数据页不在内存中。如图所示是带 <code>change buffer</code> 的更新状态图。 </p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717686786799.png" class width="1717686786799"><p> 它涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。 </p><p>这条更新语句做了如下的操作（按照图中的数字顺序）： </p><ol><li>Page 1 在内存中，直接更新内存；</li><li>Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息</li><li>将上述两个动作记入 redo log 中（图中 3 和 4）。</li></ol><p>做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。 </p><p> 现在要执行 <code>select * from t where k in (k1, k2)</code>。  如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了 </p><img src="/2024/06/05/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E7%B2%BE%E5%8D%8E/1717687061080.png" class title="change buffer 的读过程"><p>1、 读 Page 1 的时候，直接从内存返回 </p><p>2、要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果。</p><p>可以看到，直到需要读 Page 2 的时候，这个数据页才会被读入内存。 </p><p><strong>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。</strong></p><h2 id="10-MySQL为什么有时候会选错索引？"><a href="#10-MySQL为什么有时候会选错索引？" class="headerlink" title="10 MySQL为什么有时候会选错索引？"></a>10 MySQL为什么有时候会选错索引？</h2><p>选择索引是优化器的工作， 而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。 </p><p>1、 索引的区分度 ，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。 基数是通过采样统计的方法。</p><p>2、 索引统计信息不准确导致的问题，可以用 analyze table 来解决。  可以用来重新统计索引信息 。</p><h3 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h3><p>1、  <strong>采用 force index 强行选择一个索引</strong> </p><p>2、 <strong>可以考虑修改语句，引导 MySQL 使用我们期望的索引</strong> </p><p>3、 <strong>新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引</strong> </p><h2 id="11-怎么给字符串字段加索引？"><a href="#11-怎么给字符串字段加索引？" class="headerlink" title="11 怎么给字符串字段加索引？"></a>11 怎么给字符串字段加索引？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;01-一条SQL查询语句是如何执行的&quot;&gt;&lt;a href=&quot;#01-一条SQL查询语句是如何执行的&quot; class=&quot;headerlink&quot; title=&quot;01 一条SQL查询语句是如何执行的&quot;&gt;&lt;/a&gt;01 一条SQL查询语句是如何执行的&lt;/h2&gt;&lt;p&gt;见 &lt;a h</summary>
      
    
    
    
    <category term="MySQL" scheme="https://castile.github.io/categories/MySQL/"/>
    
    
    <category term="mysql" scheme="https://castile.github.io/tags/mysql/"/>
    
    <category term="数据库" scheme="https://castile.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://castile.github.io/2024/04/19/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://castile.github.io/2024/04/19/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2024-04-19T14:37:58.000Z</published>
    <updated>2024-04-19T14:37:58.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-道之伊始"><a href="#一-道之伊始" class="headerlink" title="一. 道之伊始"></a>一. 道之伊始</h1><p>宇宙初开之际，混沌之气笼罩着整个宇宙，一切模糊不清。</p><p>然后，盘古开天，女娲造人：日月乃出、星辰乃现，山川蜿蜒、江河奔流、生灵万物，欣欣向荣。此日月、星辰、山川、江河、生灵万物，谓之【对象】，皆随时间而化。</p><p>然而：日月之行、星汉灿烂、山川起伏、湖海汇聚，冥冥中有至理藏其中。名曰【道】，乃万物遵循之规律，亦谓之【函数】，它无问东西，亘古不变</p><p>作为<strong>设计宇宙洪荒</strong>的程序员</p><ul><li>造日月、筑山川、划江河、开湖海、演化生灵万物、令其生生不息，则必用面向【对象】之手段</li><li>若定规则、求本源、追纯粹，论不变，则当选【函数】编程之思想</li></ul><p>下面就让我们从【函数】开始。</p><h2 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h2><p>什么是函数呢？函数即规则</p><p>数学上：</p><img src="/2024/04/19/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/image-20240129152419304.png" class title="image-20240129152419304"><p>例如：</p><table><thead><tr><th>INPUT</th><th>f(x)</th><th>OUTPUT</th></tr></thead><tbody><tr><td>1</td><td>?</td><td>1</td></tr><tr><td>2</td><td>?</td><td>4</td></tr><tr><td>3</td><td>?</td><td>9</td></tr><tr><td>4</td><td>?</td><td>16</td></tr><tr><td>5</td><td>?</td><td>25</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><ul><li>$f(x) = x^2$ 是一种规律， input 按照此规律变化为 output</li><li>很多规律已经由人揭示，例如 $e = m \cdot c^2$</li><li>程序设计中<strong>更</strong>可以自己去制定规律，一旦成为规则的制定者，你就是神</li></ul><h2 id="大道无情"><a href="#大道无情" class="headerlink" title="大道无情"></a>大道无情</h2><h3 id="无情"><a href="#无情" class="headerlink" title="无情"></a>无情</h3><p>何为无情：</p><ul><li>只要输入相同，无论多少次调用，无论什么时间调用，输出相同。</li></ul><h3 id="佛祖成道"><a href="#佛祖成道" class="headerlink" title="佛祖成道"></a>佛祖成道</h3><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMutable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(pray(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        System.out.println(pray(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        System.out.println(pray(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Buddha</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Buddha</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Buddha buddha = <span class="keyword">new</span> Buddha(<span class="string">&quot;佛祖&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">pray</span><span class="params">(String person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (person + <span class="string">&quot;向[&quot;</span> + buddha.name + <span class="string">&quot;]虔诚祈祷&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 pray 的执行结果，除了参数变化外，希望函数的执行规则永远不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张三向[佛祖]虔诚祈祷</span><br><span class="line">张三向[佛祖]虔诚祈祷</span><br><span class="line">张三向[佛祖]虔诚祈祷</span><br></pre></td></tr></table></figure><p>然而，由于设计上的缺陷，函数引用了外界可变的数据，如果这么使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buddha.name = <span class="string">&quot;魔王&quot;</span>;</span><br><span class="line">System.out.println(pray(<span class="string">&quot;张三&quot;</span>));</span><br></pre></td></tr></table></figure><p>结果就会是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">张三向[魔王]虔诚祈祷</span><br></pre></td></tr></table></figure><p>问题出在哪儿呢？函数的目的是除了参数能变化，其它部分都要不变，这样才能成为规则的一部分。佛祖要成为规则的一部分，也要保持不变</p><p>改正方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Buddha</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Buddha</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Buddha</span><span class="params">(String name)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>不是说函数不能引用外界的数据，而是它引用的数据必须也能作为规则的一部分</li><li>让佛祖不变，佛祖才能成为规则</li></ul><h3 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h3><p>方法本质上也是函数。不过方法绑定在对象之上，它是对象个人法则</p><p>函数是</p><ul><li>函数（对象数据，其它参数）</li></ul><p>而方法是</p><ul><li>对象数据.方法（其它参数）</li></ul><h3 id="不变的好处"><a href="#不变的好处" class="headerlink" title="不变的好处"></a>不变的好处</h3><p>只有不变，才能在滚滚时间洪流中屹立不倒，成为规则的一部分。</p><p>多线程编程中，不变意味着线程安全</p><h3 id="合格的函数无状态"><a href="#合格的函数无状态" class="headerlink" title="合格的函数无状态"></a>合格的函数无状态</h3><h2 id="大道无形"><a href="#大道无形" class="headerlink" title="大道无形"></a>大道无形</h2><h3 id="函数化对象"><a href="#函数化对象" class="headerlink" title="函数化对象"></a>函数化对象</h3><p>函数本无形，也就是它代表的规则：位置固定、不能传播。</p><p>若要有形，让函数的规则能够传播，需要将函数化为对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>与</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Lambda add = (a, b) -&gt; a + b; <span class="comment">// 它已经变成了一个 lambda 对象</span></span><br></pre></td></tr></table></figure><p>区别在哪？</p><ul><li>前者是纯粹的一条两数加法规则，它的位置是固定的，要使用它，需要通过 MyClass.add 找到它，然后执行</li><li>而后者（add 对象）就像长了腿，它的位置是可以变化的，想去哪里就去哪里，哪里要用到这条加法规则，把它传递过去</li><li>接口的目的是为了将来用它来执行函数对象，此接口中只能有一个方法定义</li></ul><p>函数化为对象做个比喻</p><ul><li>之前是大家要统一去西天取经</li><li>现在是每个菩萨、罗汉拿着经书，入世传经</li></ul><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket s = ss.accept();</span><br><span class="line">                Thread.ofVirtual().start(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(s.getInputStream());</span><br><span class="line">                        Lambda lambda = (Lambda) is.readObject();</span><br><span class="line">                        <span class="keyword">int</span> a = ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">                        <span class="keyword">int</span> b = ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%s %d op %d = %d%n&quot;</span>,</span><br><span class="line">                   s.getRemoteSocketAddress().toString(), a, b, lambda.calculate(a, b));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>(Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))&#123;</span><br><span class="line">                Lambda lambda = (Lambda &amp; Serializable) (a, b) -&gt; a + b;</span><br><span class="line">                ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(s.getOutputStream());</span><br><span class="line">                os.writeObject(lambda);</span><br><span class="line">                os.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Client2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>(Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))&#123;</span><br><span class="line">                Lambda lambda = (Lambda &amp; Serializable) (a, b) -&gt; a - b;</span><br><span class="line">                ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(s.getOutputStream());</span><br><span class="line">                os.writeObject(lambda);</span><br><span class="line">                os.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Client3</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>(Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))&#123;</span><br><span class="line">                Lambda lambda = (Lambda &amp; Serializable) (a, b) -&gt; a * b;</span><br><span class="line">                ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(s.getOutputStream());</span><br><span class="line">                os.writeObject(lambda);</span><br><span class="line">                os.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的例子做了一些简单的扩展，可以看到不同的客户端可以上传自己的计算规则</li></ul><blockquote><p><em><strong>P.S.</strong></em></p><ul><li>大部分文献都说 lambda 是匿名函数，但我觉得需要在这个说法上进行补充</li><li>至少在 java 里，虽然 lambda 表达式本身不需要起名字，但不得提供一个对应接口嘛</li></ul></blockquote><h3 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h3><p>已知学生类定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对一组学生集合，筛选出男学生，下面的代码实现如何，评价一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Student&gt; students = List.of(</span><br><span class="line">            <span class="keyword">new</span> Student(<span class="string">&quot;张无忌&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Student(<span class="string">&quot;杨不悔&quot;</span>, <span class="number">16</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Student(<span class="string">&quot;周芷若&quot;</span>, <span class="number">19</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Student(<span class="string">&quot;宋青书&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    System.out.println(filter(students)); <span class="comment">// 能得到 张无忌，宋青书</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Student&gt; <span class="title">filter</span><span class="params">(List&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line">    List&lt;Student&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        <span class="keyword">if</span> (student.sex.equals(<span class="string">&quot;男&quot;</span>)) &#123;</span><br><span class="line">            result.add(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需求再变动一下，要求找到 18 岁以下的学生，上面代码显然不能用了，改动方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Student&gt; <span class="title">filter</span><span class="params">(List&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line">    List&lt;Student&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        <span class="keyword">if</span> (student.age &lt;= <span class="number">18</span>) &#123;</span><br><span class="line">            result.add(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(filter(students)); <span class="comment">// 能得到 张无忌，杨不悔</span></span><br></pre></td></tr></table></figure><p>那么需求如果再要变动，找18岁以下男学生，怎么改？显然上述做法并不太好… 更希望一个方法能处理各种情况，仔细观察以上两个方法，找不同。</p><p>不同在于筛选条件部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student.sex.equals(<span class="string">&quot;男&quot;</span>)</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student.age &lt;= <span class="number">18</span></span><br></pre></td></tr></table></figure><p>既然它们就是不同，那么能否把它作为参数传递进来，这样处理起来不就一致了吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Student&gt; <span class="title">filter</span><span class="params">(List&lt;Student&gt; students, ???)</span> </span>&#123;</span><br><span class="line">    List&lt;Student&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        <span class="keyword">if</span> (???) &#123;</span><br><span class="line">            result.add(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它俩要判断的逻辑不同，那这两处不同的逻辑必然要用函数来表示，将来这两个函数都需要用到 student 对象来判断，都应该返回一个 boolean 结果，怎么描述函数的长相呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Student student)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法可以统一成下述代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Student&gt; <span class="title">filter</span><span class="params">(List&lt;Student&gt; students, Lambda lambda)</span> </span>&#123;</span><br><span class="line">    List&lt;Student&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lambda.test(student)) &#123;</span><br><span class="line">            result.add(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，最后怎么给它传递不同实现呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(students, student -&gt; student.sex.equals(<span class="string">&quot;男&quot;</span>));</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(students, student -&gt; student.age &lt;= <span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>还有新需求也能满足</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(students, student -&gt; student.sex.equals(<span class="string">&quot;男&quot;</span>) &amp;&amp; student.age &lt;= <span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>这样就实现了以不变应万变，而变换即是一个个函数对象，也可以称之为行为参数化</p><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>在记录日志时，假设日志级别是 INFO，debug 方法会遇到下面的问题：</p><ul><li>本不需要记录日志，但 expensive 方法仍被执行了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Logger logger = LogManager.getLogger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(logger.getLevel());</span><br><span class="line">    logger.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, expensive());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">expensive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行耗时操作&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;结果&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(logger.isDebugEnabled())</span><br><span class="line">    logger.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, expensive());</span><br></pre></td></tr></table></figure><p>显然这么做，很多类似代码都要加上这样 if 判断，很不优雅</p><p>改进方法2：</p><p>在 debug 方法外再套一个新方法，内部逻辑大概是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">final</span> String msg, <span class="keyword">final</span> Supplier&lt;?&gt; lambda)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.debug(msg, lambda.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, () -&gt; expensive());</span><br></pre></td></tr></table></figure><p>expensive() 变成了不是立刻执行，在未来 if 条件成立时才执行</p><h3 id="函数对象的不同类型"><a href="#函数对象的不同类型" class="headerlink" title="函数对象的不同类型"></a>函数对象的不同类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Student&gt; c = </span><br><span class="line">    (Student s1, Student s2) -&gt; Integer.compare(s1.age, s2.age);</span><br><span class="line">        </span><br><span class="line">BiFunction&lt;Student, Student, Integer&gt; f = </span><br><span class="line">                (Student s1, Student s2) -&gt; Integer.compare(s1.age, s2.age);</span><br></pre></td></tr></table></figure><h1 id="二-函数编程语法"><a href="#二-函数编程语法" class="headerlink" title="二. 函数编程语法"></a>二. 函数编程语法</h1><h2 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h2><p>在 Java 语言中，lambda 对象有两种形式：lambda 表达式与方法引用</p><p>lambda 对象的类型是由它的行为决定的，如果有一些 lambda 对象，它们的入参类型、返回值类型都一致，那么它们可以看作是同一类的 lambda 对象，它们的类型，用函数式接口来表示</p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>练习：将 lambda 对象分类，见 PPT</p><p>函数接口的命名规律</p><ul><li>带有 Unary 是一元的意思，表示一个参数</li><li>带有 Bi 或 Binary 是二元的意思，表示两个参数</li><li>Ternary 三元</li><li>Quatenary 四元</li><li>…</li></ul><p>方法引用也是类似，入参类型、返回值类型都一致的话，可以看作同一类的对象，也是用函数式接口表示</p><h2 id="六种方法引用"><a href="#六种方法引用" class="headerlink" title="六种方法引用"></a>六种方法引用</h2><h3 id="1）类名-静态方法名"><a href="#1）类名-静态方法名" class="headerlink" title="1）类名::静态方法名"></a>1）类名::静态方法名</h3><p>如何理解：</p><ul><li>函数对象的逻辑部分是：调用此静态方法</li><li>因此这个静态方法需要什么参数，函数对象也提供相应的参数即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type2Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            需求：挑选出所有男性学生</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream.of(</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="string">&quot;宋青书&quot;</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .filter(Type2Test::isMale)</span><br><span class="line">                .forEach(student -&gt; System.out.println(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student.sex.equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">record</span> <span class="title">Student</span><span class="params">(String name, String sex)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>filter 这个高阶函数接收的函数类型（Predicate）是：一个 T 类型的入参，一个 boolean 的返回值<ul><li>因此我们只需要给它提供一个相符合的 lambda 对象即可</li></ul></li><li>isMale 这个静态方法有入参 Student 对应 T，有返回值 boolean 也能对应上，所以可以直接使用</li></ul><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student[name=张无忌, sex=男]</span><br><span class="line">Student[name=宋青书, sex=男]</span><br></pre></td></tr></table></figure><h3 id="2）类名-非静态方法名"><a href="#2）类名-非静态方法名" class="headerlink" title="2）类名::非静态方法名"></a>2）类名::非静态方法名</h3><p>如何理解：</p><ul><li>函数对象的逻辑部分是：调用此非静态方法</li><li>因此这个函数对象需要提供一个额外的对象参数，以便能够调用此非静态方法</li><li>非静态方法的剩余参数，与函数对象的剩余参数一一对应</li></ul><p>例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type3Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        highOrder(Student::hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">highOrder</span><span class="params">(Type3 lambda)</span> </span>&#123;</span><br><span class="line">        System.out.println(lambda.transfer(<span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>), <span class="string">&quot;你好&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Type3</span> </span>&#123;</span><br><span class="line">        <span class="function">String <span class="title">transfer</span><span class="params">(Student stu, String message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot; say: &quot;</span> + message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中函数类型的</p><ul><li>参数1 对应着 hello 方法所属类型 Student</li><li>参数2 对应着 hello 方法自己的参数 String</li><li>返回值对应着 hello 方法自己的返回值 String</li></ul><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">张三 say: 你好</span><br></pre></td></tr></table></figure><p>例2：改写之前根据性别过滤的需求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type2Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            需求：挑选出所有男性学生</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream.of(</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="string">&quot;宋青书&quot;</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .filter(Student::isMale)</span><br><span class="line">                .forEach(student -&gt; System.out.println(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">record</span> <span class="title">Student</span><span class="params">(String name, String sex)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sex.equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>filter 这个高阶函数接收的函数类型（Predicate）是：一个 T 类型的入参，一个 boolean 的返回值<ul><li>因此我们只需要给它提供一个相符合的 lambda 对象即可</li></ul></li><li>它的入参1 T 对应着 isMale 非静态方法的所属类型 Student</li><li>它没有其它参数，isMale 方法也没有参数</li><li>返回值都是 boolean</li></ul><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student[name=张无忌, sex=男]</span><br><span class="line">Student[name=宋青书, sex=男]</span><br></pre></td></tr></table></figure><p>例3：将学生对象仅保留学生的姓名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type2Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.of(</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="string">&quot;宋青书&quot;</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .map(Student::name)</span><br><span class="line">                .forEach(student -&gt; System.out.println(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">record</span> <span class="title">Student</span><span class="params">(String name, String sex)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sex.equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map 这个高阶函数接收的函数类型是（Function）是：一个 T 类型的参数，一个 R 类型的返回值</li><li>它的入参1 T 对应着 name 非静态方法的所属类型 Student</li><li>它没有剩余参数，name 方法也没有参数</li><li>它的返回值 R 对应着 name 方法的返回值 String</li></ul><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">张无忌</span><br><span class="line">周芷若</span><br><span class="line">宋青书</span><br></pre></td></tr></table></figure><h3 id="3）对象-非静态方法名"><a href="#3）对象-非静态方法名" class="headerlink" title="3）对象::非静态方法名"></a>3）对象::非静态方法名</h3><p>如何理解：</p><ul><li>函数对象的逻辑部分是：调用此非静态方法</li><li>因为对象已提供，所以不必作为函数对象参数的一部分</li><li>非静态方法的剩余参数，与函数对象的剩余参数一一对应</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type4Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Util util = <span class="keyword">new</span> Util(); <span class="comment">// 对象</span></span><br><span class="line">        Stream.of(</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> Student(<span class="string">&quot;宋青书&quot;</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .filter(util::isMale)</span><br><span class="line">                .map(util::getName)</span><br><span class="line">                .forEach(student -&gt; System.out.println(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">record</span> <span class="title">Student</span><span class="params">(String name, String sex)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sex.equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> student.sex.equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">String <span class="title">getName</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> student.name();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实较为典型的一个应用就是 <code>System.out</code> 对象中的非静态方法，最后的输出可以修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>这是因为 </p><ul><li>forEach  这个高阶函数接收的函数类型（Consumer）是一个 T 类型参数，void 无返回值</li><li>而 System.out 对象中有非静态方法 void println(Object x) 与之一致，因此可以将此方法化为 lambda 对象给 forEach 使用</li></ul><h3 id="4）类名-new"><a href="#4）类名-new" class="headerlink" title="4）类名::new"></a>4）类名::new</h3><p>对于构造方法，也有专门的语法把它们转换为 lambda 对象</p><p>函数类型应满足</p><ul><li>参数部分与构造方法参数一致</li><li>返回值类型与构造方法所在类一致</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type5Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = <span class="string">&quot;某人&quot;</span>;</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Type51</span> </span>&#123;</span><br><span class="line">        <span class="function">Student <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Type52</span> </span>&#123;</span><br><span class="line">        <span class="function">Student <span class="title">create</span><span class="params">(String name)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Type53</span> </span>&#123;</span><br><span class="line">        <span class="function">Student <span class="title">create</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hiOrder((Type51) Student::<span class="keyword">new</span>);</span><br><span class="line">        hiOrder((Type52) Student::<span class="keyword">new</span>);</span><br><span class="line">        hiOrder((Type53) Student::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hiOrder</span><span class="params">(Type51 creator)</span> </span>&#123;</span><br><span class="line">        System.out.println(creator.create());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hiOrder</span><span class="params">(Type52 creator)</span> </span>&#123;</span><br><span class="line">        System.out.println(creator.create(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hiOrder</span><span class="params">(Type53 creator)</span> </span>&#123;</span><br><span class="line">        System.out.println(creator.create(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5）this-非静态方法名"><a href="#5）this-非静态方法名" class="headerlink" title="5）this::非静态方法名"></a>5）this::非静态方法名</h3><p>算是形式2的特例，只能用在类内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type6Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Util util = <span class="keyword">new</span> UtilExt();</span><br><span class="line">        util.hiOrder(Stream.of(</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Student(<span class="string">&quot;宋青书&quot;</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">record</span> <span class="title">Student</span><span class="params">(String name, String sex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> student.sex.equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isFemale</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> student.sex.equals(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hiOrder</span><span class="params">(Stream&lt;Student&gt; stream)</span> </span>&#123;</span><br><span class="line">            stream</span><br><span class="line">                    .filter(<span class="keyword">this</span>::isMale)</span><br><span class="line">                    .forEach(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6）super-非静态方法名"><a href="#6）super-非静态方法名" class="headerlink" title="6）super::非静态方法名"></a>6）super::非静态方法名</h3><p>算是形式2的特例，只能用在类内部（用在要用 super 区分重载方法时）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Type6Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilExt</span> <span class="keyword">extends</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hiOrder</span><span class="params">(Stream&lt;Student&gt; stream)</span> </span>&#123;</span><br><span class="line">            stream</span><br><span class="line">                    .filter(<span class="keyword">super</span>::isFemale)</span><br><span class="line">                    .forEach(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7）特例"><a href="#7）特例" class="headerlink" title="7）特例"></a>7）特例</h3><p>函数接口和方法引用之间，可以差一个返回值，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable task1 = ExceptionTest::print1;</span><br><span class="line">        Runnable task2 = ExceptionTest::print2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task1 running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task2 running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到 Runnable 接口不需要返回值，而实际的函数对象多出的返回值也不影响使用</li></ul><h2 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h2><p>何为闭包，闭包就是<strong>函数对象</strong>与<strong>外界变量</strong>绑定在一起，形成的整体。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosureTest1</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Lambda</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        highOrder(y -&gt; x + y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">highOrder</span><span class="params">(Lambda lambda)</span> </span>&#123;</span><br><span class="line">        System.out.println(lambda.add(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码中的 $y \rightarrow x + y$ 和 $x = 10$，就形成了一个闭包</li><li>可以想象成，函数对象有个背包，背包里可以装变量随身携带，将来函数对象甭管传递到多远的地方，包里总装着个 $x = 10$</li><li>有个限制，局部变量 x 必须是 final 或 effective final 的，effective final 意思就是，虽然没有用 final 修饰，但就像是用 final 修饰了一样，不能重新赋值，否则就语法错误。<ul><li>意味着闭包变量，在装进包里的那一刻，就不能变化了</li><li>道理也简单，为了保证函数的不变性，防止破坏成道</li></ul></li><li>闭包是一种给函数执行提供数据的手段，函数执行既可以使用函数入参，还可以使用闭包变量</li></ul><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosureTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 闭包作用：给函数对象提供参数以外的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 10 个任务对象，并且每个任务对象给一个任务编号</span></span><br><span class="line">        List&lt;Runnable&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i + <span class="number">1</span>;</span><br><span class="line">            Runnable task </span><br><span class="line">                = () -&gt; System.out.println(Thread.currentThread()+<span class="string">&quot;:执行任务&quot;</span> + k);</span><br><span class="line">            list.add(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ExecutorService service = Executors.newVirtualThreadPerTaskExecutor();</span><br><span class="line">        <span class="keyword">for</span> (Runnable task : list) &#123;</span><br><span class="line">            service.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="柯里化（Carrying）"><a href="#柯里化（Carrying）" class="headerlink" title="柯里化（Carrying）"></a>柯里化（Carrying）</h2><p>柯里化的作用是让函数对象分步执行（本质上是利用多个函数对象和闭包）</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Carrying1Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        highOrder(a -&gt; b -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">highOrder</span><span class="params">(Step1 step1)</span> </span>&#123;</span><br><span class="line">        Step2 step2 = step1.exec(<span class="number">10</span>);</span><br><span class="line">        System.out.println(step2.exec(<span class="number">20</span>));</span><br><span class="line">        System.out.println(step2.exec(<span class="number">50</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Step1</span> </span>&#123;</span><br><span class="line">        <span class="function">Step2 <span class="title">exec</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Step2</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中</p><ul><li> $a \rightarrow …$ 是第一个函数对象，它的返回结果  $b \rightarrow …$ 是第二个函数对象</li><li>后者与前面的参数 a 构成了闭包</li><li>step1.exec(10) 确定了 a 的值是 10，返回第二个函数对象 step2，a 被放入了 step2 对象的背包记下来了</li><li>step2.exec(20) 确定了 b 的值是 20，此时可以执行 a + b 的操作，得到结果 30</li><li>step2.exec(50) 分析过程类似</li></ul><h2 id="高阶函数（Higher-Order-Functions）"><a href="#高阶函数（Higher-Order-Functions）" class="headerlink" title="高阶函数（Higher-Order Functions）"></a>高阶函数（Higher-Order Functions）</h2><h3 id="1-内循环"><a href="#1-内循环" class="headerlink" title="1) 内循环"></a>1) 内循环</h3><p>不想写集合便利代码</p><p>不知道那种遍历效率高</p><p>对集合的元素只读</p><h3 id="2-遍历二叉树"><a href="#2-遍历二叉树" class="headerlink" title="2) 遍历二叉树"></a>2) 遍历二叉树</h3><h3 id="3-简单流"><a href="#3-简单流" class="headerlink" title="3) 简单流"></a>3) 简单流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.castile.functional.hiorder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Castile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2024-04-17 20:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleStream</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Collection&lt;T&gt; collection;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">        SimpleStream.of(list)</span><br><span class="line">                .filter(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                .map(x -&gt; x * x)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;T&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T t : collection) &#123;</span><br><span class="line">            consumer.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleStream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;T&gt; predicate)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (T t : collection) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(t)) &#123;</span><br><span class="line">                list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleStream&lt;&gt;(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">SimpleStream&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;T, U&gt; function)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;U&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (T t : collection) &#123;</span><br><span class="line">            list.add(function.apply(t));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleStream&lt;&gt;(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">SimpleStream&lt;T&gt; <span class="title">of</span><span class="params">(Collection&lt;T&gt; collection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleStream&lt;&gt;(collection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SimpleStream</span><span class="params">(Collection&lt;T&gt; collection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.collection = collection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-简单流-化简"><a href="#4-简单流-化简" class="headerlink" title="4) 简单流-化简"></a>4) 简单流-化简</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">reduce</span><span class="params">(T init, BinaryOperator&lt;T&gt; operator)</span> </span>&#123;</span><br><span class="line">       T p = init;</span><br><span class="line">       <span class="keyword">for</span> (T t : collection) &#123;</span><br><span class="line">           p = operator.apply(p, t);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="5-简单流-收集"><a href="#5-简单流-收集" class="headerlink" title="5) 简单流-收集"></a>5) 简单流-收集</h3><h2 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h2><p>✅❌</p><h3 id="1）判断语法正确性"><a href="#1）判断语法正确性" class="headerlink" title="1）判断语法正确性"></a>1）判断语法正确性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lambda1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">op</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lambda2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">op</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Lambda1 lambda = a, b -&gt; a - b</code>  ❌</li><li><code>Lambda1 lambda = (c, d) -&gt; c * d</code> ✅</li><li><code>Lambda1 lambda = (int a, b) -&gt; a + b</code> ❌</li><li><code>Lambda2 lambda = Object a -&gt; System.out.println(a)</code> ❌</li></ol><h3 id="2）写出等价的-lambda-表达式"><a href="#2）写出等价的-lambda-表达式" class="headerlink" title="2）写出等价的 lambda 表达式"></a>2）写出等价的 lambda 表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>Math::random</code>   </p><p><code>()-&gt;Math.random()</code></p></li><li><p><code>Math::sqrt</code></p><p><code>(double number)-&gt;Math.sqrt(number)</code></p></li><li><p><code>Student::getName</code></p><p><code>(Student stu)-&gt;stu.getName()</code></p></li><li><p><code>Student::setName</code></p><p><code>(Student stu, String newName) -&gt; stu.setName(newName)</code></p></li><li><p><code>Student::hashCode</code></p><p><code>(Student stu) -&gt; stu.hashCode()</code></p></li><li><p><code>Student::equals</code></p><p><code>(Student stu, Object o) -&gt; stu.equals(o)</code></p></li></ol><p>假设已有对象 <code>Student stu = new Student(&quot;张三&quot;);</code></p><ol><li><p><code>stu::getName</code></p><p><code>()-&gt;stu.getName()</code></p></li><li><p><code>stu::setName</code></p><p><code>(String newName)-&gt;stu.setName(newName)</code></p></li><li><p><code>Student::new</code></p><p><code>(String name)-&gt;new Student(name)</code></p></li></ol><h3 id="3）使用函数接口解决问题"><a href="#3）使用函数接口解决问题" class="headerlink" title="3）使用函数接口解决问题"></a>3）使用函数接口解决问题</h3><p>把下列方法中，可能存在变化的部分，抽象为函数对象，从外界传递进来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title">filter</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer number : list) &#123;</span><br><span class="line">        <span class="comment">// 筛选：判断是否是偶数，但以后可能改变判断规则</span></span><br><span class="line">        <span class="keyword">if</span>((number &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;String&gt; <span class="title">map</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer number : list) &#123;</span><br><span class="line">        <span class="comment">// 转换：将数字转为字符串，但以后可能改变转换规则</span></span><br><span class="line">        result.add(String.valueOf(number));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer number : list) &#123;</span><br><span class="line">        <span class="comment">// 消费：打印，但以后可能改变消费规则</span></span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title">supply</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 生成：随机数，但以后可能改变生成规则</span></span><br><span class="line">        result.add(ThreadLocalRandom.current().nextInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4）写出等价的方法引用"><a href="#4）写出等价的方法引用" class="headerlink" title="4）写出等价的方法引用"></a>4）写出等价的方法引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; lambda = (String s) -&gt; Integer.parseInt(s);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiPredicate&lt;List&lt;String&gt;, String&gt; lambda = (list, element) -&gt; list.contains(element);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiPredicate&lt;Student, Object&gt; lambda = (stu, obj) -&gt; stu.equals(obj);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;File&gt; lambda = (file) -&gt; file.exists();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runtime runtime = Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">Supplier&lt;Long&gt; lambda = () -&gt; runtime.freeMemory();</span><br></pre></td></tr></table></figure><h3 id="5）补充代码"><a href="#5）补充代码" class="headerlink" title="5）补充代码"></a>5）补充代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Color</span><span class="params">(Integer red, Integer green, Integer blue)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>如果想用 <code>Color::new</code> 来构造 Color 对象，还应当补充哪些代码</p><h3 id="6）实现需求"><a href="#6）实现需求" class="headerlink" title="6）实现需求"></a>6）实现需求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">highOrder</span><span class="params">(Predicate&lt;Student&gt; predicate)</span> </span>&#123;</span><br><span class="line">    List&lt;Student&gt; list = List.of(</span><br><span class="line">            <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>),</span><br><span class="line">            <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">17</span>),</span><br><span class="line">            <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (Student stu : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate.test(stu)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;通过测试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入参数时，分别用</p><ul><li>类名::静态方法名</li><li>类名::非静态方法名</li></ul><p>来表示【学生年龄大于等于18】的条件</p><h1 id="三-Stream-API"><a href="#三-Stream-API" class="headerlink" title="三. Stream API"></a>三. Stream API</h1><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Fruit</span><span class="params">(String cname, String name, String category, String color)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">Stream.of(</span><br><span class="line">    <span class="keyword">new</span> Fruit(<span class="string">&quot;草莓&quot;</span>, <span class="string">&quot;Strawberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;红色&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> Fruit(<span class="string">&quot;桑葚&quot;</span>, <span class="string">&quot;Mulberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;紫色&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> Fruit(<span class="string">&quot;杨梅&quot;</span>, <span class="string">&quot;Waxberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;红色&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> Fruit(<span class="string">&quot;核桃&quot;</span>, <span class="string">&quot;Walnut&quot;</span>, <span class="string">&quot;坚果&quot;</span>, <span class="string">&quot;棕色&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> Fruit(<span class="string">&quot;草莓&quot;</span>, <span class="string">&quot;Peanut&quot;</span>, <span class="string">&quot;坚果&quot;</span>, <span class="string">&quot;棕色&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> Fruit(<span class="string">&quot;蓝莓&quot;</span>, <span class="string">&quot;Blueberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;蓝色&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><img src="/2024/04/19/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/1.png" class><p>找到所有浆果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.filter(f -&gt; f.category.equals(<span class="string">&quot;浆果&quot;</span>))</span><br></pre></td></tr></table></figure><p>找到蓝色的浆果</p><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.filter(f -&gt; f.category().equals(<span class="string">&quot;浆果&quot;</span>) &amp;&amp; f.color().equals(<span class="string">&quot;蓝色&quot;</span>))</span><br></pre></td></tr></table></figure><p>方法2：让每个 lambda 只做一件事，两次 filter 相对于并且关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.filter(f -&gt; f.category.equals(<span class="string">&quot;浆果&quot;</span>))</span><br><span class="line">.filter(f -&gt; f.color().equals(<span class="string">&quot;蓝色&quot;</span>))</span><br></pre></td></tr></table></figure><p>方法3：让每个 lambda 只做一件事，不过比方法2强的地方可以 or，and，nagate 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.filter(((Predicate&lt;Fruit&gt;) f -&gt; f.category.equals(<span class="string">&quot;浆果&quot;</span>)).and(f -&gt; f.color().equals(<span class="string">&quot;蓝色&quot;</span>)))</span><br></pre></td></tr></table></figure><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><img src="/2024/04/19/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/2.png" class title="映射"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.map(f -&gt; f.cname() + <span class="string">&quot;酱&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p>例1</p><img src="/2024/04/19/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/image-20240301105938703.png" class title="image-20240301105938703"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(</span><br><span class="line">        List.of(</span><br><span class="line">                <span class="keyword">new</span> Fruit(<span class="string">&quot;草莓&quot;</span>, <span class="string">&quot;Strawberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;红色&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Fruit(<span class="string">&quot;桑葚&quot;</span>, <span class="string">&quot;Mulberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;紫色&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Fruit(<span class="string">&quot;杨梅&quot;</span>, <span class="string">&quot;Waxberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;红色&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Fruit(<span class="string">&quot;蓝莓&quot;</span>, <span class="string">&quot;Blueberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;蓝色&quot;</span>)</span><br><span class="line">        ),</span><br><span class="line">        List.of(</span><br><span class="line">                <span class="keyword">new</span> Fruit(<span class="string">&quot;核桃&quot;</span>, <span class="string">&quot;Walnut&quot;</span>, <span class="string">&quot;坚果&quot;</span>, <span class="string">&quot;棕色&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Fruit(<span class="string">&quot;草莓&quot;</span>, <span class="string">&quot;Peanut&quot;</span>, <span class="string">&quot;坚果&quot;</span>, <span class="string">&quot;棕色&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">)</span><br><span class="line">    </span><br><span class="line">.flatMap(Collection::stream)    </span><br></pre></td></tr></table></figure><ul><li>这样把坚果和浆果两个集合变成了含六个元素的水果流</li></ul><p>例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(</span><br><span class="line">        <span class="keyword">new</span> Order(<span class="number">1</span>, List.of(</span><br><span class="line">                <span class="keyword">new</span> Item(<span class="number">6499</span>, <span class="number">1</span>, <span class="string">&quot;HUAWEI MateBook 14s&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(<span class="number">6999</span>, <span class="number">1</span>, <span class="string">&quot;HUAWEI Mate 60 Pro&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(<span class="number">1488</span>, <span class="number">1</span>, <span class="string">&quot;HUAWEI WATCH GT 4&quot;</span>)</span><br><span class="line">        )),</span><br><span class="line">        <span class="keyword">new</span> Order(<span class="number">1</span>, List.of(</span><br><span class="line">                <span class="keyword">new</span> Item(<span class="number">8999</span>, <span class="number">1</span>, <span class="string">&quot;Apple MacBook Air 13&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(<span class="number">7999</span>, <span class="number">1</span>, <span class="string">&quot;Apple iPhone 15 Pro&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> Item(<span class="number">2999</span>, <span class="number">1</span>, <span class="string">&quot;Apple Watch Series 9&quot;</span>)</span><br><span class="line">        ))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>想逐一处理每个订单中的商品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.flatMap(order -&gt; order.items().stream())</span><br></pre></td></tr></table></figure><p>这样把一个有两个元素的订单流，变成了一个有六个元素的商品流</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>根据已有的数组构建流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(array)</span><br></pre></td></tr></table></figure><p>根据已有的 Collection 构建流（包括 List，Set 等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>).stream()</span><br></pre></td></tr></table></figure><p>把一个对象变成流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d&quot;</span>)</span><br></pre></td></tr></table></figure><p>把多个对象变成流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><p>两个流拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.concat(Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>), Stream.of(<span class="string">&quot;d&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.concat(Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>), Stream.of(<span class="string">&quot;d&quot;</span>))</span><br><span class="line">    .skip(<span class="number">1</span>)</span><br><span class="line">    .limit(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>skip 是跳过几个元素</li><li>limit 是限制处理的元素个数</li></ul><ul><li><p>dropWhile 是 drop 流中元素，直到条件不成立，留下剩余元素</p></li><li><p>takeWhile 是 take 流中元素，直到条件不成立，舍弃剩余元素</p></li></ul><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>生成从 0 ~ 9 的数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.rangeClosed(<span class="number">0</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>如果想订制，可以用 iterate 方法，例如下面生成奇数序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>参数1 是初始值</li><li>参数2 是一个特殊 Function，即参数类型与返回值相同，它会根据上一个元素 x 的值计算出当前元素</li><li>需要用 limit 限制元素个数</li></ul><p>也可以用 iterate 的重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">1</span>, x -&gt; x &lt; <span class="number">10</span>, x -&gt; x + <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>参数1 是初始值</li><li>参数2 用来限制元素个数，一旦不满足此条件，流就结束</li><li>参数3 相当于上个方法的参数2</li></ul><p>iterate 的特点是根据上一个元素计算当前元素，如果不需要依赖上一个元素，可以改用 generate 方法</p><p>例如下面是生成 5 个随机 int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(()-&gt; ThreadLocalRandom.current().nextInt()).limit(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>不过如果只是生成随机数的话，有更简单的办法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalRandom.current().ints(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>如果要指定上下限，例如下面是生成从 0~9 的100个随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalRandom.current().ints(<span class="number">100</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="查找与判断"><a href="#查找与判断" class="headerlink" title="查找与判断"></a>查找与判断</h2><p>下面的代码找到流中任意（Any）一个偶数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">Arrays.stream(array)</span><br><span class="line">    .filter(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    .findAny()</span><br><span class="line">    .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>注意 findAny 返回的是 OptionalInt 对象，因为可能流中不存在偶数</li><li>对于 OptionalInt 对象，一般需要用 ifPresent 或 orElse（提供默认值）来处理</li></ul><p>与 findAny 比较类似的是 firstFirst，它俩的区别</p><ul><li>findAny 是找在流中任意位置的元素，不需要考虑顺序，对于上例返回 6 也是可以的</li><li>findFirst 是找第一个出现在元素，需要考虑顺序，对于上例只能返回 4</li><li>findAny 在顺序流中与 findFirst 表现相同，区别在于并行流下会更快</li></ul><p>判断流中是否存在任意一个偶数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(array).anyMatch(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>它返回的是 boolean 值，可以直接用来判断</li></ul><p>判断流是否全部是偶数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(array).allMatch(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>同样，它返回的是 boolean 值，可以直接用来判断</li></ul><p>判断流是否全部不是偶数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(array).noneMatch(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>noneMatch 与 allMatch 含义恰好相反</li></ul><h2 id="排序与去重"><a href="#排序与去重" class="headerlink" title="排序与去重"></a>排序与去重</h2><p>已知有数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Hero</span><span class="params">(String name, <span class="keyword">int</span> strength)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">Stream.of(</span><br><span class="line">    <span class="keyword">new</span> Hero(<span class="string">&quot;独孤求败&quot;</span>, <span class="number">100</span>),</span><br><span class="line">    <span class="keyword">new</span> Hero(<span class="string">&quot;令狐冲&quot;</span>, <span class="number">90</span>),</span><br><span class="line">    <span class="keyword">new</span> Hero(<span class="string">&quot;风清扬&quot;</span>, <span class="number">98</span>),</span><br><span class="line">    <span class="keyword">new</span> Hero(<span class="string">&quot;东方不败&quot;</span>, <span class="number">98</span>),</span><br><span class="line">    <span class="keyword">new</span> Hero(<span class="string">&quot;方证&quot;</span>, <span class="number">92</span>),</span><br><span class="line">    <span class="keyword">new</span> Hero(<span class="string">&quot;任我行&quot;</span>, <span class="number">92</span>),</span><br><span class="line">    <span class="keyword">new</span> Hero(<span class="string">&quot;冲虚&quot;</span>, <span class="number">90</span>),</span><br><span class="line">    <span class="keyword">new</span> Hero(<span class="string">&quot;向问天&quot;</span>, <span class="number">88</span>),</span><br><span class="line">    <span class="keyword">new</span> Hero(<span class="string">&quot;不戒&quot;</span>, <span class="number">88</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>要求，首先按 strength 武力排序（逆序），武力相同的，按姓名长度排序（正序）</p><p>仅用 lambda 来解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.sorted((a,b)-&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.compare(b.strength(), a.strength());</span><br><span class="line">    <span class="keyword">return</span> (res == <span class="number">0</span>) ? Integer.compare(a.nameLength(), b.nameLength()) : res; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方法引用改写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.sorted(</span><br><span class="line">    Comparator.comparingInt(Hero::strength)</span><br><span class="line">      .reversed()</span><br><span class="line">      .thenComparingInt(Hero::nameLength)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>comparingInt 接收一个 key 提取器（说明按对象中哪部分来比较），返回一个比较器</li><li>reversed 返回一个顺序相反的比较器</li><li>thenComparingInt 接收一个 key 提取器，返回一个新比较器，新比较器在原有比较器结果相等时执行新的比较逻辑</li></ul><p>增加一个辅助方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Hero</span><span class="params">(String name, <span class="keyword">int</span> strength)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nameLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.sorted((e, f) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> res =</span><br><span class="line">        ((Comparator&lt;Hero&gt;) (c, d) -&gt;</span><br><span class="line">            ((Comparator&lt;Hero&gt;) (a, b) -&gt; Integer.compare(a.strength(), b.strength()))</span><br><span class="line">                .compare(d, c))</span><br><span class="line">            .compare(e, f);</span><br><span class="line">    <span class="keyword">return</span> (res == <span class="number">0</span>) ? Integer.compare(e.nameLength(), f.nameLength()) : res;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果不好看，改成下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.sorted(step3(step2(step1())))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Comparator&lt;Hero&gt; <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a, b) -&gt; Integer.compare(a.strength(), b.strength());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Comparator&lt;Hero&gt; <span class="title">step2</span><span class="params">(Comparator&lt;Hero&gt; step1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c, d) -&gt; step1.compare(d, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Comparator&lt;Hero&gt; <span class="title">step3</span><span class="params">(Comparator&lt;Hero&gt; step2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (e, f) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> res = step2.compare(e, f);</span><br><span class="line">        <span class="keyword">return</span> (res == <span class="number">0</span>) ? Integer.compare(e.nameLength(), f.nameLength()) : res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h2><p><code>reduce(init, (p,x) -&gt; r)</code></p><ul><li>init 代表初始值</li><li><code>(p,x) -&gt; r</code> 是一个 BinaryOperator，作用是根据上次化简结果 p 和当前元素 x，得到本次化简结果 r</li></ul><p>这样两两化简，可以将流中的所有元素合并成一个结果</p><h2 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h2><p>collect( supplier, accumulator, combiner)</p><ul><li>supplier 是描述如何创建收集容器 c ：<code>()-&gt; c</code></li><li>accumulator 是描述如何向容器 c 添加元素 x：<code>(c, x) -&gt; void</code></li><li>combiner 是描述如何合并两个容器：<code>(c1, c2) -&gt; void</code><ul><li>串行流下不需要合并容器</li><li>并行流如果用的是并发容器，也不需要合并</li></ul></li></ul><h2 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h2><p>Collectors 类中提供了很多现成的收集器，详情见网页</p><h2 id="下游收集器"><a href="#下游收集器" class="headerlink" title="下游收集器"></a>下游收集器</h2><p>做 groupingBy 分组收集时，组内可能需要进一步的数据收集，称为下游收集器，详情见网页</p><h2 id="基本流"><a href="#基本流" class="headerlink" title="基本流"></a>基本流</h2><p>基本类型流指 IntStream、LongStream 和 DoubleStream，它们在做数值计算时有更好的性能。</p><p>转换成基本流</p><ul><li>mapToInt</li><li>mapToLong</li><li>mapToDouble</li><li>flatMapToInt</li><li>flatMapToLong</li><li>flatMapToDouble</li><li>mapMultiToInt</li><li>mapMultiToLong</li><li>mapMultiToDouble</li></ul><p>基本流转对象流</p><ul><li>mapToObj</li><li>boxed</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>一次使用：流只能使用一次（终结方法只能调用一次）</li><li>两类操作：<ol><li>中间操作，lazy 懒惰的</li><li>终结操作，eager 迫切的</li></ol></li></ol><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    .parallel()</span><br><span class="line">    .collect(Collector.of(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%-12s %s%n&quot;</span>,simple(),<span class="string">&quot;create&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            &#125;,</span><br><span class="line">            (list, x) -&gt; &#123;</span><br><span class="line">                List&lt;Integer&gt; old = <span class="keyword">new</span> ArrayList&lt;&gt;(list);</span><br><span class="line">                list.add(x);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%-12s %s.add(%d)=&gt;%s%n&quot;</span>,simple(), old, x, list);</span><br><span class="line">            &#125;,</span><br><span class="line">            (list1, list2) -&gt; &#123;</span><br><span class="line">                List&lt;Integer&gt; old = <span class="keyword">new</span> ArrayList&lt;&gt;(list1);</span><br><span class="line">                list1.addAll(list2);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%-12s %s.add(%s)=&gt;%s%n&quot;</span>, simple(),old, list2, list1);</span><br><span class="line">                <span class="keyword">return</span> list1;</span><br><span class="line">            &#125;,</span><br><span class="line">            list -&gt; list,</span><br><span class="line">            Collector.Characteristics.IDENTITY_FINISH</span><br><span class="line">    ));</span><br></pre></td></tr></table></figure><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="1-数组求和"><a href="#1-数组求和" class="headerlink" title="1) 数组求和"></a>1) 数组求和</h3><p>其中</p><ul><li>primitive 用 loop 循环对 int 求和</li><li>intStream 用 IntStream 对 int 求和</li><li>boxed 用 loop 循环对 Integer 求和</li><li>stream 用 Stream 对 Integer 求和</li></ul><p>元素个数 100</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns/op)</th><th>Error (ns/op)</th><th>Units</th></tr></thead><tbody><tr><td>T01Sum.primitive</td><td>avgt</td><td>5</td><td>25.424</td><td>± 0.782</td><td>ns/op</td></tr><tr><td>T01Sum.intStream</td><td>avgt</td><td>5</td><td>47.482</td><td>± 1.145</td><td>ns/op</td></tr><tr><td>T01Sum.boxed</td><td>avgt</td><td>5</td><td>72.457</td><td>± 4.136</td><td>ns/op</td></tr><tr><td>T01Sum.stream</td><td>avgt</td><td>5</td><td>465.141</td><td>± 4.891</td><td>ns/op</td></tr></tbody></table><p>元素个数 1000</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns/op)</th><th>Error (ns/op)</th><th>Units</th></tr></thead><tbody><tr><td>T01Sum.primitive</td><td>avgt</td><td>5</td><td>270.556</td><td>± 1.277</td><td>ns/op</td></tr><tr><td>T01Sum.intStream</td><td>avgt</td><td>5</td><td>292.467</td><td>± 10.987</td><td>ns/op</td></tr><tr><td>T01Sum.boxed</td><td>avgt</td><td>5</td><td>583.929</td><td>± 57.338</td><td>ns/op</td></tr><tr><td>T01Sum.stream</td><td>avgt</td><td>5</td><td>5948.294</td><td>± 2209.211</td><td>ns/op</td></tr></tbody></table><p>元素个数 10000</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns/op)</th><th>Error (ns/op)</th><th>Units</th></tr></thead><tbody><tr><td>T01Sum.primitive</td><td>avgt</td><td>5</td><td>2681.651</td><td>± 12.614</td><td>ns/op</td></tr><tr><td>T01Sum.intStream</td><td>avgt</td><td>5</td><td>2718.408</td><td>± 52.418</td><td>ns/op</td></tr><tr><td>T01Sum.boxed</td><td>avgt</td><td>5</td><td>6391.285</td><td>± 358.154</td><td>ns/op</td></tr><tr><td>T01Sum.stream</td><td>avgt</td><td>5</td><td>44414.884</td><td>± 3213.055</td><td>ns/op</td></tr></tbody></table><p>结论：</p><ul><li>做数值计算，优先挑选基本流（IntStream 等）在数据量较大时，它的性能已经非常接近普通 for 循环</li><li>做数值计算，应当避免普通流（Stream）性能与其它几种相比，慢一个数量级</li></ul><h3 id="2-求最大值"><a href="#2-求最大值" class="headerlink" title="2) 求最大值"></a>2) 求最大值</h3><p>其中（原始数据都是 int，没有包装类）</p><ul><li>custom 自定义多线程并行求最大值</li><li>parallel 并行流求最大值</li><li>sequence 串行流求最大值</li><li>primitive loop 循环求最大值</li></ul><p>元素个数 100</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns/op)</th><th>Error (ns/op)</th><th>Units</th></tr></thead><tbody><tr><td>T02Parallel.custom</td><td>avgt</td><td>5</td><td>39619.796</td><td>± 1263.036</td><td>ns/op</td></tr><tr><td>T02Parallel.parallel</td><td>avgt</td><td>5</td><td>6754.239</td><td>± 79.894</td><td>ns/op</td></tr><tr><td>T02Parallel.primitive</td><td>avgt</td><td>5</td><td>29.538</td><td>± 3.056</td><td>ns/op</td></tr><tr><td>T02Parallel.sequence</td><td>avgt</td><td>5</td><td>80.170</td><td>± 1.940</td><td>ns/op</td></tr></tbody></table><p>元素个数 10000</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns/op)</th><th>Error (ns/op)</th><th>Units</th></tr></thead><tbody><tr><td>T02Parallel.custom</td><td>avgt</td><td>5</td><td>41656.093</td><td>± 1537.237</td><td>ns/op</td></tr><tr><td>T02Parallel.parallel</td><td>avgt</td><td>5</td><td>11218.573</td><td>± 1994.863</td><td>ns/op</td></tr><tr><td>T02Parallel.primitive</td><td>avgt</td><td>5</td><td>2217.562</td><td>± 80.981</td><td>ns/op</td></tr><tr><td>T02Parallel.sequence</td><td>avgt</td><td>5</td><td>5682.482</td><td>± 264.645</td><td>ns/op</td></tr></tbody></table><p>元素个数 1000000</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns/op)</th><th>Error (ns/op)</th><th>Units</th></tr></thead><tbody><tr><td>T02Parallel.custom</td><td>avgt</td><td>5</td><td>194984.564</td><td>± 25794.484</td><td>ns/op</td></tr><tr><td>T02Parallel.parallel</td><td>avgt</td><td>5</td><td>298940.794</td><td>± 31944.959</td><td>ns/op</td></tr><tr><td>T02Parallel.primitive</td><td>avgt</td><td>5</td><td>325178.873</td><td>± 81314.981</td><td>ns/op</td></tr><tr><td>T02Parallel.sequence</td><td>avgt</td><td>5</td><td>618274.062</td><td>± 5867.812</td><td>ns/op</td></tr></tbody></table><p>结论：</p><ul><li>并行流相对自己用多线程实现分而治之更简洁</li><li>并行流只有在数据量非常大时，才能充分发力，数据量少，还不如用串行流</li></ul><h3 id="3-并行-发-收集"><a href="#3-并行-发-收集" class="headerlink" title="3) 并行(发)收集"></a>3) 并行(发)收集</h3><p>元素个数 100</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns/op)</th><th>Error (ns/op)</th><th>Units</th></tr></thead><tbody><tr><td>loop1</td><td>avgt</td><td>5</td><td>1312.389</td><td>±  90.683</td><td>ns/op</td></tr><tr><td>loop2</td><td>avgt</td><td>5</td><td>1776.391</td><td>± 255.271</td><td>ns/op</td></tr><tr><td>sequence</td><td>avgt</td><td>5</td><td>1727.739</td><td>±  28.821</td><td>ns/op</td></tr><tr><td>parallelNoConcurrent</td><td>avgt</td><td>5</td><td>27654.004</td><td>± 496.970</td><td>ns/op</td></tr><tr><td>parallelConcurrent</td><td>avgt</td><td>5</td><td>16320.113</td><td>± 344.766</td><td>ns/op</td></tr></tbody></table><p>元素个数 10000</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns/op)</th><th>Error (ns/op)</th><th>Units</th></tr></thead><tbody><tr><td>loop1</td><td>avgt</td><td>5</td><td>211526.546</td><td>± 13549.703</td><td>ns/op</td></tr><tr><td>loop2</td><td>avgt</td><td>5</td><td>203794.146</td><td>± 3525.972</td><td>ns/op</td></tr><tr><td>sequence</td><td>avgt</td><td>5</td><td>237688.651</td><td>±  7593.483</td><td>ns/op</td></tr><tr><td>parallelNoConcurrent</td><td>avgt</td><td>5</td><td>527203.976</td><td>±  3496.107</td><td>ns/op</td></tr><tr><td>parallelConcurrent</td><td>avgt</td><td>5</td><td>369630.728</td><td>± 20549.731</td><td>ns/op</td></tr></tbody></table><p>元素个数 1000000</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ms/op)</th><th>Error (ms/op)</th><th>Units</th></tr></thead><tbody><tr><td>loop1</td><td>avgt</td><td>5</td><td>69.154</td><td>± 3.456</td><td>ms/op</td></tr><tr><td>loop2</td><td>avgt</td><td>5</td><td>83.815</td><td>± 2.307</td><td>ms/op</td></tr><tr><td>sequence</td><td>avgt</td><td>5</td><td>103.585</td><td>± 0.834</td><td>ns/op</td></tr><tr><td>parallelNoConcurrent</td><td>avgt</td><td>5</td><td>167.032</td><td>± 15.406</td><td>ms/op</td></tr><tr><td>parallelConcurrent</td><td>avgt</td><td>5</td><td>52.326</td><td>± 1.501</td><td>ms/op</td></tr></tbody></table><p>结论：</p><ul><li>sequence 是一个容器单线程收集，数据量少时性能占优</li><li>parallelNoConcurrent 是多个容器多线程并行收集，时间应该花费在合并容器上，性能最差</li><li>parallelConcurrent 是一个容器多线程并发收集，在数据量大时性能较优</li></ul><h3 id="4）MethodHandle-性能"><a href="#4）MethodHandle-性能" class="headerlink" title="4）MethodHandle 性能"></a>4）MethodHandle 性能</h3><p>正常方法调用、反射、MethodHandle、Lambda 的性能对比</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score</th><th>Error</th><th>Units</th></tr></thead><tbody><tr><td>Sample2.lambda</td><td>thrpt</td><td>5</td><td>389307532.881</td><td>± 332213073.039</td><td>ops/s</td></tr><tr><td>Sample2.method</td><td>thrpt</td><td>5</td><td>157556577.611</td><td>± 4048306.620</td><td>ops/s</td></tr><tr><td>Sample2.origin</td><td>thrpt</td><td>5</td><td>413287866.949</td><td>± 65182730.966</td><td>ops/s</td></tr><tr><td>Sample2.reflection</td><td>thrpt</td><td>5</td><td>91640751.456</td><td>± 37969233.369</td><td>ops/s</td></tr></tbody></table><h2 id="综合练习-1"><a href="#综合练习-1" class="headerlink" title="综合练习"></a>综合练习</h2><ol><li><p>将 filter 的课堂例题修改为方法引用方式实现</p></li><li><p>takeWhile 与 filter 的区别</p></li><li><p>三级排序</p></li><li><p>包含 null 值的排序</p></li><li><p>二维流扁平映射</p></li><li><p>三维流扁平映射</p></li><li><p>用 stream 打印九九乘法表</p></li><li><p>用 stream 生成斐波那契数列的前 10 项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, x -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x[<span class="number">1</span>], x[<span class="number">0</span>] + x[<span class="number">1</span>]&#125;)</span><br><span class="line">    .map(x -&gt; x[<span class="number">0</span>])</span><br><span class="line">    .limit(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p>自定义 Collector 求平均 </p></li></ol><h1 id="四-实际应用"><a href="#四-实际应用" class="headerlink" title="四. 实际应用"></a>四. 实际应用</h1><h2 id="数据统计分析"><a href="#数据统计分析" class="headerlink" title="数据统计分析"></a>数据统计分析</h2><h3 id="1）每月的销售量"><a href="#1）每月的销售量" class="headerlink" title="1）每月的销售量"></a>1）每月的销售量</h3><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1970-01 订单数1307</span><br><span class="line">2020-01 订单数14270</span><br><span class="line">2020-02 订单数17995</span><br><span class="line">2020-03 订单数18688</span><br><span class="line">2020-04 订单数11868</span><br><span class="line">2020-05 订单数40334</span><br><span class="line">2020-06 订单数41364</span><br><span class="line">2020-07 订单数76418</span><br><span class="line">2020-08 订单数100007</span><br><span class="line">2020-09 订单数70484</span><br><span class="line">2020-10 订单数104063</span><br><span class="line">2020-11 订单数66060</span><br></pre></td></tr></table></figure><ul><li>其中 1970-01 应该是数据的问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(a -&gt; YearMonth.from(formatter.parse(a[TIME])), </span><br><span class="line">                        TreeMap::<span class="keyword">new</span>, counting()))</span><br><span class="line">    .forEach((k, v) -&gt; &#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot; 订单数 &quot;</span> + v);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="2）销量最高的月份"><a href="#2）销量最高的月份" class="headerlink" title="2）销量最高的月份"></a>2）销量最高的月份</h3><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1970-01 订单数1307</span><br><span class="line">2020-01 订单数14270</span><br><span class="line">2020-02 订单数17995</span><br><span class="line">2020-03 订单数18688</span><br><span class="line">2020-04 订单数11868</span><br><span class="line">2020-05 订单数40334</span><br><span class="line">2020-06 订单数41364</span><br><span class="line">2020-07 订单数76418</span><br><span class="line">2020-08 订单数100007</span><br><span class="line">2020-09 订单数70484</span><br><span class="line">2020-10 订单数104063  *</span><br><span class="line">2020-11 订单数66060</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(a -&gt; YearMonth.from(formatter.parse(a[TIME])), counting()))</span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .max(Comparator.comparingLong(Map.Entry::getValue))</span><br><span class="line">    <span class="comment">// 也可以用 Map.Entry.comparingByValue()</span></span><br><span class="line">    .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="3）求销量最高的商品"><a href="#3）求销量最高的商品" class="headerlink" title="3）求销量最高的商品"></a>3）求销量最高的商品</h3><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1515966223517846928=2746</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(a -&gt; a[PRODUCT_ID], counting()))</span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .max(Comparator.comparingLong(Map.Entry::getValue))</span><br><span class="line">    .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h3 id="4）下单最多的前10用户"><a href="#4）下单最多的前10用户" class="headerlink" title="4）下单最多的前10用户"></a>4）下单最多的前10用户</h3><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.515915625512423e+18 订单数1092</span><br><span class="line">1.5159156255121183e+18 订单数1073</span><br><span class="line">1.515915625512378e+18 订单数1040</span><br><span class="line">1.515915625512377e+18 订单数1028</span><br><span class="line">1.5159156255136955e+18 订单数1002</span><br><span class="line">1.515915625512422e+18 订单数957</span><br><span class="line">1.515915625513446e+18 订单数957</span><br><span class="line">1.515915625513447e+18 订单数928</span><br><span class="line">1.515915625514598e+18 订单数885</span><br><span class="line">1.5159156255147195e+18 订单数869</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(a -&gt; a[USER_ID], counting()))</span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted(Map.Entry.&lt;String, Long&gt;comparingByValue().reversed())</span><br><span class="line">    .limit(<span class="number">10</span>).forEach(e -&gt; &#123;</span><br><span class="line">        System.out.println(e.getKey() + <span class="string">&quot; 订单数 &quot;</span> + e.getValue());</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(comparator);</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> r = <span class="keyword">super</span>.offer(e);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; max) &#123;</span><br><span class="line">            <span class="keyword">this</span>.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(a -&gt; a[USER_ID], counting()))</span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .parallel()</span><br><span class="line">    .collect(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> MyQueue&lt;&gt;(Map.Entry.comparingByValue(), <span class="number">10</span>),</span><br><span class="line">            MyQueue::offer,</span><br><span class="line">            AbstractQueue::addAll</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h3 id="5-1）每个地区下单最多的用户"><a href="#5-1）每个地区下单最多的用户" class="headerlink" title="5.1）每个地区下单最多的用户"></a>5.1）每个地区下单最多的用户</h3><p>结果应为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">上海=Optional[1.5159156255127636e+18=634]</span><br><span class="line">广东=Optional[1.515915625512377e+18=1028]</span><br><span class="line">天津=Optional[1.5159156255120858e+18=530]</span><br><span class="line">四川=Optional[1.5159156255121551e+18=572]</span><br><span class="line">浙江=Optional[1.5159156255121183e+18=564]</span><br><span class="line">重庆=Optional[1.515915625512764e+18=632]</span><br><span class="line">湖北=Optional[1.5159156255121183e+18=509]</span><br><span class="line">湖南=Optional[1.5159156255120548e+18=545]</span><br><span class="line">江苏=Optional[1.5159156255122386e+18=551]</span><br><span class="line">海南=Optional[1.5159156255121178e+18=556]</span><br><span class="line">北京=Optional[1.5159156255128172e+18=584]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(line -&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(array -&gt; array[USER_REGION], </span><br><span class="line">                        groupingBy(array -&gt; array[USER_ID], counting())))</span><br><span class="line">    .entrySet().stream()</span><br><span class="line">    .map(e -&gt; Map.entry(</span><br><span class="line">            e.getKey(),</span><br><span class="line">            e.getValue().entrySet().stream().max(Map.Entry.comparingByValue())</span><br><span class="line">    ))</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="5-2）每个地区下单最多的前3用户"><a href="#5-2）每个地区下单最多的前3用户" class="headerlink" title="5.2）每个地区下单最多的前3用户"></a>5.2）每个地区下单最多的前3用户</h3><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">上海</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255127636e+18=634</span><br><span class="line">1.515915625512118e+18=583</span><br><span class="line">1.515915625512422e+18=561</span><br><span class="line">广东</span><br><span class="line">--------------------------</span><br><span class="line">1.515915625512377e+18=1028</span><br><span class="line">1.5159156255121544e+18=572</span><br><span class="line">1.5159156255120845e+18=571</span><br><span class="line">天津</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255120858e+18=530</span><br><span class="line">1.5159156255122383e+18=504</span><br><span class="line">1.5159156255123333e+18=481</span><br><span class="line">四川</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255121551e+18=572</span><br><span class="line">1.5159156255123768e+18=568</span><br><span class="line">1.515915625512055e+18=552</span><br><span class="line">浙江</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255121183e+18=564</span><br><span class="line">1.515915625513058e+18=520</span><br><span class="line">1.515915625512423e+18=513</span><br><span class="line">重庆</span><br><span class="line">--------------------------</span><br><span class="line">1.515915625512764e+18=632</span><br><span class="line">1.5159156255121188e+18=572</span><br><span class="line">1.515915625512085e+18=562</span><br><span class="line">湖北</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255121183e+18=509</span><br><span class="line">1.515915625512818e+18=508</span><br><span class="line">1.5159156255148017e+18=386</span><br><span class="line">湖南</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255120548e+18=545</span><br><span class="line">1.5159156255120855e+18=543</span><br><span class="line">1.5159156255134449e+18=511</span><br><span class="line">江苏</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255122386e+18=551</span><br><span class="line">1.5159156255122842e+18=541</span><br><span class="line">1.5159156255120842e+18=499</span><br><span class="line">海南</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255121178e+18=556</span><br><span class="line">1.5159156255128174e+18=547</span><br><span class="line">1.5159156255122022e+18=545</span><br><span class="line">北京</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255128172e+18=584</span><br><span class="line">1.515915625512423e+18=579</span><br><span class="line">1.5159156255123786e+18=558</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(a -&gt; a[USER_REGION], groupingBy(a -&gt; a[USER_ID], counting())))</span><br><span class="line">    <span class="comment">/*.forEach((k,v)-&gt;&#123;</span></span><br><span class="line"><span class="comment">        System.out.println(k);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;---------------&quot;);</span></span><br><span class="line"><span class="comment">        v.forEach((x,y)-&gt;&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(x + &quot;:&quot; + y);</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">    &#125;);*/</span></span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .map(e -&gt;</span><br><span class="line">        Map.entry(</span><br><span class="line">            e.getKey(),</span><br><span class="line">            e.getValue().entrySet().stream()</span><br><span class="line">                .sorted(Map.Entry.&lt;String, Long&gt;comparingByValue().reversed())</span><br><span class="line">            .limit(<span class="number">3</span>)</span><br><span class="line">            .toList()</span><br><span class="line">        )</span><br><span class="line">    ).forEach(e -&gt; &#123;</span><br><span class="line">        System.out.println(e.getKey());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        e.getValue().forEach(System.out::println);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="6-1）按类别统计销量"><a href="#6-1）按类别统计销量" class="headerlink" title="6.1）按类别统计销量"></a>6.1）按类别统计销量</h3><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">accessories.bag 订单数 3063</span><br><span class="line">accessories.umbrella 订单数 33</span><br><span class="line">apparel.costume 订单数 2</span><br><span class="line">apparel.glove 订单数 1942</span><br><span class="line">apparel.shirt 订单数 235</span><br><span class="line">apparel.shoes 订单数 2</span><br><span class="line">apparel.sock 订单数 21</span><br><span class="line">apparel.trousers 订单数 99</span><br><span class="line">apparel.tshirt 订单数 372</span><br><span class="line">appliances.environment.air_conditioner 订单数 7379</span><br><span class="line">appliances.environment.air_heater 订单数 2599</span><br><span class="line">appliances.environment.climate 订单数 101</span><br><span class="line">appliances.environment.fan 订单数 3855</span><br><span class="line">appliances.environment.vacuum 订单数 15971</span><br><span class="line">appliances.environment.water_heater 订单数 3644</span><br><span class="line">appliances.iron 订单数 8249</span><br><span class="line">appliances.ironing_board 订单数 2128</span><br><span class="line">appliances.kitchen.blender 订单数 8672</span><br><span class="line">appliances.kitchen.coffee_grinder 订单数 811</span><br><span class="line">appliances.kitchen.coffee_machine 订单数 1250</span><br><span class="line">appliances.kitchen.dishwasher 订单数 2663</span><br><span class="line">appliances.kitchen.fryer 订单数 97</span><br><span class="line">appliances.kitchen.grill 订单数 1579</span><br><span class="line">appliances.kitchen.hood 订单数 9045</span><br><span class="line">appliances.kitchen.juicer 订单数 1187</span><br><span class="line">appliances.kitchen.kettle 订单数 12740</span><br><span class="line">appliances.kitchen.meat_grinder 订单数 4520</span><br><span class="line">appliances.kitchen.microwave 订单数 7615</span><br><span class="line">appliances.kitchen.mixer 订单数 2610</span><br><span class="line">appliances.kitchen.oven 订单数 4000</span><br><span class="line">appliances.kitchen.refrigerators 订单数 20259</span><br><span class="line">appliances.kitchen.steam_cooker 订单数 464</span><br><span class="line">appliances.kitchen.toster 订单数 1381</span><br><span class="line">appliances.kitchen.washer 订单数 14563</span><br><span class="line">appliances.personal.hair_cutter 订单数 2716</span><br><span class="line">appliances.personal.massager 订单数 1724</span><br><span class="line">appliances.personal.scales 订单数 6727</span><br><span class="line">appliances.sewing_machine 订单数 1576</span><br><span class="line">appliances.steam_cleaner 订单数 119</span><br><span class="line">auto.accessories.alarm 订单数 252</span><br><span class="line">auto.accessories.anti_freeze 订单数 109</span><br><span class="line">auto.accessories.compressor 订单数 276</span><br><span class="line">auto.accessories.player 订单数 117</span><br><span class="line">auto.accessories.radar 订单数 80</span><br><span class="line">auto.accessories.videoregister 订单数 533</span><br><span class="line">computers.components.cdrw 订单数 158</span><br><span class="line">computers.components.cooler 订单数 3377</span><br><span class="line">computers.components.cpu 订单数 4147</span><br><span class="line">computers.components.hdd 订单数 5054</span><br><span class="line">computers.components.memory 订单数 1597</span><br><span class="line">computers.components.motherboard 订单数 860</span><br><span class="line">computers.components.power_supply 订单数 986</span><br><span class="line">computers.components.sound_card 订单数 26</span><br><span class="line">computers.components.videocards 订单数 1190</span><br><span class="line">computers.desktop 订单数 1041</span><br><span class="line">computers.ebooks 订单数 397</span><br><span class="line">computers.gaming 订单数 164</span><br><span class="line">computers.network.router 订单数 6473</span><br><span class="line">computers.notebook 订单数 25866</span><br><span class="line">computers.peripherals.camera 订单数 1041</span><br><span class="line">computers.peripherals.joystick 订单数 1192</span><br><span class="line">computers.peripherals.keyboard 订单数 3803</span><br><span class="line">computers.peripherals.monitor 订单数 3272</span><br><span class="line">computers.peripherals.mouse 订单数 12664</span><br><span class="line">computers.peripherals.printer 订单数 3458</span><br><span class="line">computers.peripherals.scanner 订单数 74</span><br><span class="line">construction.components.faucet 订单数 133</span><br><span class="line">construction.tools.drill 订单数 622</span><br><span class="line">construction.tools.generator 订单数 46</span><br><span class="line">construction.tools.heater 订单数 348</span><br><span class="line">construction.tools.light 订单数 10</span><br><span class="line">construction.tools.pump 订单数 65</span><br><span class="line">construction.tools.saw 订单数 169</span><br><span class="line">construction.tools.screw 订单数 2408</span><br><span class="line">construction.tools.welding 订单数 183</span><br><span class="line">country_yard.cultivator 订单数 33</span><br><span class="line">country_yard.lawn_mower 订单数 111</span><br><span class="line">country_yard.watering 订单数 5</span><br><span class="line">country_yard.weather_station 订单数 53</span><br><span class="line">electronics.audio.acoustic 订单数 438</span><br><span class="line">electronics.audio.dictaphone 订单数 12</span><br><span class="line">electronics.audio.headphone 订单数 20084</span><br><span class="line">electronics.audio.microphone 订单数 1062</span><br><span class="line">electronics.audio.subwoofer 订单数 70</span><br><span class="line">electronics.calculator 订单数 35</span><br><span class="line">electronics.camera.photo 订单数 348</span><br><span class="line">electronics.camera.video 订单数 133</span><br><span class="line">electronics.clocks 订单数 6474</span><br><span class="line">electronics.smartphone 订单数 102365</span><br><span class="line">electronics.tablet 订单数 6395</span><br><span class="line">electronics.telephone 订单数 2437</span><br><span class="line">electronics.video.projector 订单数 114</span><br><span class="line">electronics.video.tv 订单数 17618</span><br><span class="line">furniture.bathroom.bath 订单数 232</span><br><span class="line">furniture.bathroom.toilet 订单数 44</span><br><span class="line">furniture.bedroom.bed 订单数 451</span><br><span class="line">furniture.bedroom.blanket 订单数 68</span><br><span class="line">furniture.bedroom.pillow 订单数 1882</span><br><span class="line">furniture.kitchen.chair 订单数 3084</span><br><span class="line">furniture.kitchen.table 订单数 11260</span><br><span class="line">furniture.living_room.cabinet 订单数 3117</span><br><span class="line">furniture.living_room.chair 订单数 1439</span><br><span class="line">furniture.living_room.shelving 订单数 2572</span><br><span class="line">furniture.living_room.sofa 订单数 401</span><br><span class="line">furniture.universal.light 订单数 22</span><br><span class="line">kids.bottles 订单数 63</span><br><span class="line">kids.carriage 订单数 41</span><br><span class="line">kids.dolls 订单数 379</span><br><span class="line">kids.fmcg.diapers 订单数 11</span><br><span class="line">kids.skates 订单数 1159</span><br><span class="line">kids.swing 订单数 8</span><br><span class="line">kids.toys 订单数 643</span><br><span class="line">medicine.tools.tonometer 订单数 1106</span><br><span class="line">sport.bicycle 订单数 569</span><br><span class="line">sport.diving 订单数 10</span><br><span class="line">sport.ski 订单数 17</span><br><span class="line">sport.snowboard 订单数 3</span><br><span class="line">sport.tennis 订单数 87</span><br><span class="line">sport.trainer 订单数 210</span><br><span class="line">stationery.battery 订单数 5210</span><br><span class="line">stationery.cartrige 订单数 2473</span><br><span class="line">stationery.paper 订单数 1085</span><br><span class="line">stationery.stapler 订单数 97</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">       .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">       .filter(a -&gt; !a[CATEGORY_CODE].isEmpty())</span><br><span class="line">       .collect(groupingBy(a -&gt; a[CATEGORY_CODE], TreeMap::<span class="keyword">new</span>, counting()))</span><br><span class="line">       .forEach((k, v) -&gt; &#123;</span><br><span class="line">           System.out.println(k + <span class="string">&quot; 订单数 &quot;</span> + v);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h3 id="6-2）按一级类别统计销量"><a href="#6-2）按一级类别统计销量" class="headerlink" title="6.2）按一级类别统计销量"></a>6.2）按一级类别统计销量</h3><p>结果应为</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">accessories 订单数 3096</span><br><span class="line">apparel 订单数 2673</span><br><span class="line">appliances 订单数 150244</span><br><span class="line">auto 订单数 1367</span><br><span class="line">computers 订单数 76840</span><br><span class="line">construction 订单数 3984</span><br><span class="line">country_yard 订单数 202</span><br><span class="line">electronics 订单数 157585</span><br><span class="line">furniture 订单数 24572</span><br><span class="line">kids 订单数 2304</span><br><span class="line">medicine 订单数 1106</span><br><span class="line">sport 订单数 896</span><br><span class="line">stationery 订单数 8865</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .filter(a -&gt; !a[CATEGORY_CODE].isEmpty())</span><br><span class="line">    .collect(groupingBy(TestData::firstCategory, TreeMap::<span class="keyword">new</span>, counting()))</span><br><span class="line">    .forEach((k, v) -&gt; &#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot; 订单数 &quot;</span> + v);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstCategory</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">    String category = a[CATEGORY_CODE];</span><br><span class="line">    <span class="keyword">int</span> dot = category.indexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> category.substring(<span class="number">0</span>, dot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7）按价格区间统计销量"><a href="#7）按价格区间统计销量" class="headerlink" title="7）按价格区间统计销量"></a>7）按价格区间统计销量</h3><ul><li>p &lt;100</li><li>100&lt;= p &lt;500</li><li>500&lt;=p&lt;1000</li><li>1000&lt;=p</li></ul><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0,100)=291624</span><br><span class="line">[1000,∞)=14514</span><br><span class="line">[500,1000)=52857</span><br><span class="line">[100,500)=203863</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">priceRange</span><span class="params">(Double price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (price &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[0,100)&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (price &gt;= <span class="number">100</span> &amp;&amp; price &lt; <span class="number">500</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[100,500)&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (price &gt;= <span class="number">500</span> &amp;&amp; price &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[500,1000)&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[1000,∞)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(line -&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .map(array -&gt; Double.parseDouble(array[PRICE]))</span><br><span class="line">    .collect(groupingBy(TestData::priceRange, counting()))</span><br></pre></td></tr></table></figure><h3 id="8）不同年龄段女性所下不同类别订单"><a href="#8）不同年龄段女性所下不同类别订单" class="headerlink" title="8）不同年龄段女性所下不同类别订单"></a>8）不同年龄段女性所下不同类别订单</h3><ul><li>a &lt; 18</li><li>18 &lt;= a &lt; 30</li><li>30 &lt;= a &lt; 50</li><li>50 &lt;= a</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[0,18)       accessories      81</span><br><span class="line">[0,18)       apparel          60</span><br><span class="line">[0,18)       appliances       4326</span><br><span class="line">[0,18)       computers        1984</span><br><span class="line">...</span><br><span class="line">[18,30)      accessories      491</span><br><span class="line">[18,30)      apparel          488</span><br><span class="line">[18,30)      appliances       25240</span><br><span class="line">[18,30)      computers        13076</span><br><span class="line">...</span><br><span class="line">[30,50)      accessories      890</span><br><span class="line">[30,50)      apparel          893</span><br><span class="line">[30,50)      appliances       42755</span><br><span class="line">[30,50)      computers        21490</span><br><span class="line">...</span><br><span class="line">[50,∞)       accessories      41</span><br><span class="line">[50,∞)       apparel          41</span><br><span class="line">[50,∞)       appliances       2255</span><br><span class="line">[50,∞)       computers        1109</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">ageRange</span><span class="params">(String[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = Double.valueOf(array[USER_AGE]).intValue();</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[0,18)&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[18,30)&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">50</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[30,50)&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[50,∞)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(line -&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .filter(array -&gt; !array[CATEGORY_CODE].isEmpty())</span><br><span class="line">    .filter(array -&gt; array[USER_SEX].equals(<span class="string">&quot;女&quot;</span>))</span><br><span class="line">    .collect(groupingBy(TestData::ageRange, </span><br><span class="line">                        groupingBy(TestData::firstCategory, TreeMap::<span class="keyword">new</span>, counting())))</span><br></pre></td></tr></table></figure><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>例子 1: 使用<code>ExecutorService</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>)) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;开始统计&quot;</span>);</span><br><span class="line">        service.submit(() -&gt; monthlySalesReport(map-&gt;map.entrySet().forEach(e-&gt;logger.info(e.toString()))));</span><br><span class="line">        logger.info(<span class="string">&quot;执行其它操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">monthlySalesReport</span><span class="params">(Consumer&lt;Map&lt;YearMonth, Long&gt;&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Path.of(<span class="string">&quot;./data.txt&quot;</span>))) &#123;</span><br><span class="line">        Map&lt;YearMonth, Long&gt; collect = lines.skip(<span class="number">1</span>)</span><br><span class="line">                .map(line -&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">                .collect(groupingBy(array -&gt; YearMonth.from(formatter.parse(array[TIME])), TreeMap::<span class="keyword">new</span>, counting()));</span><br><span class="line">        consumer.accept(collect);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子 2: 使用<code>CompletableFuture</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;开始统计&quot;</span>);</span><br><span class="line">    CompletableFuture</span><br><span class="line">        .supplyAsync(() -&gt; monthlySalesReport())</span><br><span class="line">            .thenAccept(map -&gt; map.entrySet().forEach(e -&gt; logger.info(e.toString())));</span><br><span class="line">    logger.info(<span class="string">&quot;执行其它操作&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;YearMonth, Long&gt; <span class="title">monthlySalesReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Path.of(<span class="string">&quot;./data.txt&quot;</span>))) &#123;</span><br><span class="line">        Map&lt;YearMonth, Long&gt; collect = lines.skip(<span class="number">1</span>)</span><br><span class="line">                .map(line -&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">                .collect(groupingBy(array -&gt; YearMonth.from(formatter.parse(array[TIME])), TreeMap::<span class="keyword">new</span>, counting()));</span><br><span class="line">        <span class="keyword">return</span> collect;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h2><ul><li>什么是框架？<ul><li>半成品软件，帮助开发者快速构建应用程序</li><li>框架提供的都是固定<strong>不变的</strong>、<strong>已知的</strong>、可以重用的代码</li><li>而那些每个应用不同的业务逻辑，<strong>变化的</strong>、<strong>未知的</strong>部分，则在框架外由开发者自己实现</li></ul></li></ul><h3 id="将未知交给子类"><a href="#将未知交给子类" class="headerlink" title="将未知交给子类"></a>将未知交给子类</h3><p>Spring 延迟创建 bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">class DefaultSingletonBeanRegistry &#123;</span><br><span class="line">   - singletonObjects: Map</span><br><span class="line">   + getSingleton(name, factory)</span><br><span class="line">&#125;</span><br><span class="line">class AbstractAutowireCapableBeanFactory &#123;</span><br><span class="line">   # createBean(name, definition, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultSingletonBeanRegistry &lt;|-- AbstractAutowireCapableBeanFactory</span><br></pre></td></tr></table></figure><p>Spring 中的很多类有非常复杂的继承关系，并且它们分工明确，你做什么，我做什么，职责是划分好的。例如：</p><ul><li>DefaultSingletonBeanRegistry 是父类，它有个职责是缓存单例 bean，用下面方法实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; factory)</span></span></span><br></pre></td></tr></table></figure><ul><li>但如何创建 bean，这个父类是不知道的，创建 bean 是子类 AbstractAutowireCapableBeanFactory 的职责</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父类中 getSingleton 的内部就要使用 singletonFactory 函数对象来获得创建好的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span>(singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        singletonObject = singletonFactory.getObject();</span><br><span class="line">        addSingleton(beanName, singletonObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后子类创建单例 bean 时，会把 ObjectFactory 这个函数对象传进去<ul><li>创建其它 scope bean，不需要用 getSingleton 缓存</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将未知交给用户"><a href="#将未知交给用户" class="headerlink" title="将未知交给用户"></a>将未知交给用户</h3><p>JdbcTemplate</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student (</span><br><span class="line">   id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">   name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">   sex <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;赵一伤&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;钱二败&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;孙三毁&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;李四摧&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;周五输&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="string">&#x27;吴六破&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="string">&#x27;郑七灭&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="string">&#x27;王八衰&#x27;</span>, <span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure><p>spring 中 JdbcTemplate 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJdbc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HikariDataSource dataSource = <span class="keyword">new</span> HikariDataSource();</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">        JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">        String sql = <span class="string">&quot;select id,name,sex from student&quot;</span>;</span><br><span class="line">        template.query(sql, (rs, index) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> id = rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            String sex = rs.getString(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student(id, name, sex);</span><br><span class="line">        &#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">record</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name, String sex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对 query 来讲，建立数据库连接，创建 Statement 对象，执行查询这些步骤都是固定的</li><li>而结果要如何用 java 对象封装，这对框架代码是未知的，用 RowMapper 接口代表，将来它的 lambda 实现将结果转换成需要的 java 对象</li></ul><p>ApplicationListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExtend</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context </span><br><span class="line">            = SpringApplication.run(TestExtend.class, args);</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> MyEvent(<span class="string">&quot;context&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationListener&lt;MyEvent&gt; <span class="title">myListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (event -&gt; System.out.println(<span class="string">&quot;收到事件:&quot;</span> + event));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            context.publishEvent(<span class="keyword">new</span> MyEvent(<span class="string">&quot;controller&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对 spring 来讲，它并不知道如何处理事件</li><li>因此可以提供一个类型为 ApplicationListener 的 lambda 对象</li></ul><h3 id="延迟拼接条件"><a href="#延迟拼接条件" class="headerlink" title="延迟拼接条件"></a>延迟拼接条件</h3><p>Mybatis-Plus</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyBatisPlus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context </span><br><span class="line">            = SpringApplication.run(TestMyBatisPlus.class, args);</span><br><span class="line">        StudentMapper mapper = context.getBean(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        test(mapper, List.of(<span class="string">&quot;赵一伤&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(StudentMapper mapper, List&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">        LambdaQueryWrapper&lt;Student&gt; query = <span class="keyword">new</span> LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">        query.in(!names.isEmpty(), Student::getName, names);</span><br><span class="line">        System.out.println(mapper.selectList(query));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较典型的用法有两处：</p><p>第一，在调用 in 等方法添加条件时，第一个参数是 boolean 为 true 才会拼接 SQL 条件，否则不拼接</p><p>如何实现的呢？用 DoSomething 类型的 lambda 对象来延迟拼接操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DoSomething</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Children <span class="title">maybeDo</span><span class="params">(<span class="keyword">boolean</span> condition, DoSomething something)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        something.doIt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> typedThis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然而，它在实现 <code>()-&gt;appendSqlSegments(...)</code> 拼接时，是不断修改一个 expression 状态变量，为函数编程所不齿</li></ul><h3 id="偏门用法"><a href="#偏门用法" class="headerlink" title="偏门用法"></a>偏门用法</h3><p>第二，如果用 LambdaQueryWrapper 拼接 sql 条件时，<strong>为了取得列名</strong>，采用了这个办法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student::getName</span><br></pre></td></tr></table></figure><p>它要做的事很简单，但内部实现却比较复杂</p><ol><li>必须用 <code>Student::getName</code> 方法引用，而不能用其它 Lambda 对象</li><li>它会实现 Serializable 接口，序列化时会把它变成 SerializedLambda</li><li>想办法拿到 SerializedLambda 对象（反射调用 writeReplace）</li><li>通过 SerializedLambda 能够获得它对应的实际方法，也就是 String getName() 和所在类 Student</li><li>再通过方法名推导得到属性名（去掉 is，get）即 name</li><li>所在类 Student 知道了，属性名 name 也有了，就可以进一步确定列名<ol><li>属性上的 @TableField 指定的列名优先</li><li>没有 @TableField，把属性名当作列名</li></ol></li></ol><blockquote><p><em><strong>P.S.</strong></em></p><ul><li>不是很喜欢这种做法，比较恶心</li><li>但它确实是想做这么一件事：在代码中全面使用 java 的字段名，避免出现数据库的列名</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        Type1 lambda = (Type1 &amp; Serializable) (a, b) -&gt; a + b;</span></span><br><span class="line">    Type2 lambda = (Type2 &amp; Serializable) Student::getName;</span><br><span class="line">    <span class="comment">// 将 lambda 对象序列化</span></span><br><span class="line">    Method writeReplace = lambda.getClass().getDeclaredMethod(<span class="string">&quot;writeReplace&quot;</span>);</span><br><span class="line">    SerializedLambda serializedLambda = (SerializedLambda) writeReplace.invoke(lambda);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到 lambda 对象使用类、所属类和实现方法名</span></span><br><span class="line">    System.out.println(serializedLambda.getCapturingClass());</span><br><span class="line">    System.out.println(serializedLambda.getImplClass());</span><br><span class="line">    System.out.println(serializedLambda.getImplMethodName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Type2</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(Student student)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Type1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><p>统计页面的访问次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Pattern reg = Pattern.compile(<span class="string">&quot;(\\S+) - \\[(.+)] (.+) (.+)&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FILES = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            sequence();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sequence</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Map&lt;String, Long&gt; m0 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FILES; i++) &#123;</span><br><span class="line">            Map&lt;String, Long&gt; mi = one(i);</span><br><span class="line">            m0 = Stream.of(m0, mi)</span><br><span class="line">                    .flatMap(m -&gt; m.entrySet().stream())</span><br><span class="line">                    .collect(toMap(Map.Entry::getKey, Map.Entry::getValue, Long::sum));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Long&gt; e : m0.entrySet()) &#123;</span><br><span class="line"><span class="comment">//            System.out.println(e);</span></span><br><span class="line">            sum += e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;cost: &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Long&gt; <span class="title">one</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Path.of(String.format(<span class="string">&quot;web_server_access_%d.log&quot;</span>, i)))) &#123;</span><br><span class="line">            <span class="keyword">return</span> lines</span><br><span class="line"><span class="comment">//                            .limit(10)</span></span><br><span class="line">                    .map(reg::matcher)</span><br><span class="line">                    .filter(Matcher::find)</span><br><span class="line">                    .map(matcher -&gt; matcher.group(<span class="number">3</span>))</span><br><span class="line">                    .collect(groupingBy(identity(), counting()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallel</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        List&lt;CompletableFuture&lt;Map&lt;String, Long&gt;&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FILES; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i;</span><br><span class="line">            CompletableFuture&lt;Map&lt;String, Long&gt;&gt; future = CompletableFuture.supplyAsync(() -&gt; one(k));</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Map&lt;String, Long&gt;&gt; f0 = futures.getFirst();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; futures.size(); i++) &#123;</span><br><span class="line">            f0 = f0.thenCombine(futures.get(i), (m1, m2) -&gt;</span><br><span class="line">                    Stream.of(m1, m2)</span><br><span class="line">                            .flatMap(m -&gt; m.entrySet().stream())</span><br><span class="line">                            .collect(toMap(Map.Entry::getKey, Map.Entry::getValue, Long::sum))</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Long&gt; map = f0.get();</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Long&gt; e : map.entrySet()) &#123;</span><br><span class="line"><span class="comment">//            System.out.println(e);</span></span><br><span class="line">            sum += e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;cost: &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UI-事件"><a href="#UI-事件" class="headerlink" title="UI 事件"></a>UI 事件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUIEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame frame = <span class="keyword">new</span> JFrame(<span class="string">&quot;Lambda Example&quot;</span>);</span><br><span class="line">        JButton button = <span class="keyword">new</span> JButton(<span class="string">&quot;Click me&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式定义按钮的点击事件处理程序</span></span><br><span class="line">        button.addActionListener(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Button clicked!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        frame.add(button);</span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-实现原理"><a href="#五-实现原理" class="headerlink" title="五. 实现原理"></a>五. 实现原理</h1><h2 id="lambda-原理"><a href="#lambda-原理" class="headerlink" title="lambda 原理"></a>lambda 原理</h2><p>以下面代码为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test((a, b) -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(BinaryOperator&lt;Integer&gt; lambda)</span> </span>&#123;</span><br><span class="line">        System.out.println(lambda.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="第一步，生成静态方法"><a href="#第一步，生成静态方法" class="headerlink" title="第一步，生成静态方法"></a>第一步，生成静态方法</h3><p>如何证明？用反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : TestLambda.class.getDeclaredMethods()) &#123;</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为（去掉了包名，容易阅读）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> TestLambda.main(java.lang.String[])</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> TestLambda.test(BinaryOperator)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> java.lang.Integer TestLambda.lambda$main$<span class="number">0</span>(Integer,Integer)</span><br></pre></td></tr></table></figure><ul><li><p>可以看到除了我们自己写的 main 和 test 以外，多出一个名为 <code>lambda$main$0</code> 的方法</p></li><li><p>这个方法是在编译期间由编译器生成的方法，是 synthetic（合成）方法</p></li><li><p>它的参数、内容就是 lambda 表达式提供的参数和内容，如下面代码片段所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer lambda$main$<span class="number">0</span>(Integer a, Integer b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="第二步，生成实现类字节码"><a href="#第二步，生成实现类字节码" class="headerlink" title="第二步，生成实现类字节码"></a>第二步，生成实现类字节码</h3><p>如果是我自己造一个对象包含此方法，可以这么做</p><p>先创建一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaObject</span> <span class="keyword">implements</span> <span class="title">BinaryOperator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TestLambda.lambda$main$<span class="number">0</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将来使用时，创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="keyword">new</span> LambdaObject());</span><br></pre></td></tr></table></figure><p>只不过，jvm 是在运行期间造出的这个类以及对象而已，要想查看这个类</p><p>在 jdk 21 中运行时添加虚拟机参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles</span><br></pre></td></tr></table></figure><p>早期 jdk 添加的参数是（没有去进行版本比对了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djdk.internal.lambda.dumpProxyClasses</span><br></pre></td></tr></table></figure><p>若想实现在运行期间生成上述 class 字节码，有两种手段</p><ul><li>一是动态代理，jdk 并没有采用这种办法来生成 Lambda 类</li><li>二是用 LambdaMetaFactory，它配合 MethodHandle API 在执行时更具性能优势</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        test((a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line">        MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">        MethodType factoryType = MethodType.methodType(BinaryOperator.class);</span><br><span class="line">        MethodType interfaceMethodType = MethodType.methodType(Object.class, Object.class, Object.class);</span><br><span class="line">        MethodType implementsMethodType = MethodType.methodType(Integer.class, Integer.class, Integer.class);</span><br><span class="line"></span><br><span class="line">        MethodHandle implementsMethod = lookup.findStatic(TestLambda1.class, <span class="string">&quot;lambda$main$1&quot;</span>, implementsMethodType);</span><br><span class="line"></span><br><span class="line">        MethodType lambdaType = MethodType.methodType(Integer.class, Integer.class, Integer.class);</span><br><span class="line">        CallSite callSite = LambdaMetafactory.metafactory(lookup,</span><br><span class="line">                <span class="string">&quot;apply&quot;</span>, factoryType, interfaceMethodType,</span><br><span class="line">                implementsMethod,</span><br><span class="line">                lambdaType);</span><br><span class="line"></span><br><span class="line">        BinaryOperator&lt;Integer&gt; lambda = (BinaryOperator) callSite.getTarget().invoke();</span><br><span class="line">        test(lambda);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Integer lambda$main$<span class="number">1</span>(Integer a, Integer b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(BinaryOperator&lt;Integer&gt; lambda)</span> </span>&#123;</span><br><span class="line">        System.out.println(lambda.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><p>“apply” 是接口方法名</p></li><li><p>factoryType 是工厂方法长相</p></li><li><p>interfaceMethodType 是接口方法长相</p></li><li><p>implementsMethod 是实现方法</p><ul><li>implementsMethodType 是实现方法长相</li></ul></li><li><p>lambdaType 是实际函数对象长相</p></li><li><p>callSite.getTarget() 实际是调用实现类的构造方法对应的 mh，最后 invoke 返回函数对象</p></li></ul><h2 id="方法引用原理"><a href="#方法引用原理" class="headerlink" title="方法引用原理"></a>方法引用原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">test(String::toLowerCase);</span><br><span class="line">        </span><br><span class="line">        MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">        MethodType factoryType = MethodType.methodType(Function.class);</span><br><span class="line">        MethodType interfaceMethodType = MethodType.methodType(Object.class, Object.class);</span><br><span class="line">        MethodHandle implementsMethod = lookup.findVirtual(String.class, <span class="string">&quot;toLowerCase&quot;</span>, MethodType.methodType(String.class));</span><br><span class="line">        MethodType lambdaType = MethodType.methodType(String.class, String.class);</span><br><span class="line">        CallSite callSite = LambdaMetafactory.metafactory(lookup,</span><br><span class="line">                <span class="string">&quot;apply&quot;</span>, factoryType, interfaceMethodType,</span><br><span class="line">                implementsMethod,</span><br><span class="line">                lambdaType);</span><br><span class="line"></span><br><span class="line">        Function&lt;String, String&gt; lambda = (Function&lt;String, String&gt;) callSite.getTarget().invoke();</span><br><span class="line">        System.out.println(lambda.apply(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Function&lt;String,String&gt; lambda)</span> </span>&#123;</span><br><span class="line">        System.out.println(lambda.apply(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包原理"><a href="#闭包原理" class="headerlink" title="闭包原理"></a>闭包原理</h2><p>捕获基本类型变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">test((a, b) -&gt; a + b + c);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(BinaryOperator&lt;Integer&gt; lambda)</span> </span>&#123;</span><br><span class="line">    System.out.println(lambda.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成一个带 3 个参数的方法，但它和 BinaryOperator 还差一个 int 参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Integer lambda$main$<span class="number">1</span>(<span class="keyword">int</span> c, Integer a, Integer b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//        int c = 10;</span></span><br><span class="line"><span class="comment">//        test((a, b) -&gt; a + b + c);</span></span><br><span class="line"></span><br><span class="line">        MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">        MethodType factoryType = MethodType.methodType(BinaryOperator.class, <span class="keyword">int</span>.class);</span><br><span class="line">        MethodType interfaceMethodType = MethodType.methodType(Object.class, Object.class, Object.class);</span><br><span class="line">        MethodType implementsMethodType = MethodType.methodType(Integer.class, <span class="keyword">int</span>.class, Integer.class, Integer.class);</span><br><span class="line"></span><br><span class="line">        MethodHandle implementsMethod = lookup.findStatic(TestLambda2.class, <span class="string">&quot;lambda$main$1&quot;</span>, implementsMethodType);</span><br><span class="line"></span><br><span class="line">        MethodType lambdaType = MethodType.methodType(Integer.class, Integer.class, Integer.class);</span><br><span class="line">        CallSite callSite = LambdaMetafactory.metafactory(lookup,</span><br><span class="line">                <span class="string">&quot;apply&quot;</span>, factoryType, interfaceMethodType,</span><br><span class="line">                implementsMethod,</span><br><span class="line">                lambdaType);</span><br><span class="line"></span><br><span class="line">        BinaryOperator&lt;Integer&gt; lambda = (BinaryOperator) callSite.getTarget().invoke(<span class="number">10</span>);</span><br><span class="line">        test(lambda);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Integer lambda$main$<span class="number">1</span>(<span class="keyword">int</span> c, Integer a, Integer b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(BinaryOperator&lt;Integer&gt; lambda)</span> </span>&#123;</span><br><span class="line">        System.out.println(lambda.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同之处</p><ul><li>factoryType，除了原本的接口类型之外，多了实现方法第一个参数的类型</li><li>产生 lambda 对象的时候，通过 invoke 把这个参数的实际值传进去</li></ul><p>这样产生的 LambdaType 就是这样，并且生成 Lambda 对象时，c 的值被固定为 10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaType</span> <span class="keyword">implements</span> <span class="title">BinaryOperator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestLambda2$$Lambda(<span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TestLambda2.lambda$main$<span class="number">1</span>(<span class="keyword">this</span>.c, (Integer)a, (Integer)b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获引用类型变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRef</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyRef</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">/*MyRef ref = new MyRef(10);</span></span><br><span class="line"><span class="comment">        test((a, b) -&gt; a + b + ref.age);*/</span></span><br><span class="line"></span><br><span class="line">        MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">        MethodType factoryType = MethodType.methodType(BinaryOperator.class, MyRef.class);</span><br><span class="line">        MethodType interfaceMethodType = MethodType.methodType(Object.class, Object.class, Object.class);</span><br><span class="line">        MethodType implementsMethodType = MethodType.methodType(Integer.class, MyRef.class, Integer.class, Integer.class);</span><br><span class="line"></span><br><span class="line">        MethodHandle implementsMethod = lookup.findStatic(TestLambda4.class, <span class="string">&quot;lambda$main$1&quot;</span>, implementsMethodType);</span><br><span class="line"></span><br><span class="line">        MethodType lambdaType = MethodType.methodType(Integer.class, Integer.class, Integer.class);</span><br><span class="line">        CallSite callSite = LambdaMetafactory.metafactory(lookup,</span><br><span class="line">                <span class="string">&quot;apply&quot;</span>, factoryType, interfaceMethodType,</span><br><span class="line">                implementsMethod,</span><br><span class="line">                lambdaType);</span><br><span class="line"></span><br><span class="line">        BinaryOperator&lt;Integer&gt; lambda = (BinaryOperator) callSite.getTarget().bindTo(<span class="keyword">new</span> MyRef(<span class="number">20</span>)).invoke();</span><br><span class="line">        test(lambda);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Integer lambda$main$<span class="number">1</span>(MyRef c, Integer a, Integer b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(BinaryOperator&lt;Integer&gt; lambda)</span> </span>&#123;</span><br><span class="line">        System.out.println(lambda.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与捕获基本类型变量类似，不过</p><p>除了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callSite.getTarget().invoke(<span class="keyword">new</span> MyRef(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><p>还可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callSite.getTarget().bindTo(<span class="keyword">new</span> MyRef(<span class="number">20</span>)).invoke();</span><br></pre></td></tr></table></figure><h2 id="Stream-构建"><a href="#Stream-构建" class="headerlink" title="Stream 构建"></a>Stream 构建</h2><p>自定义可切分迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpliterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpliterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T[] array;</span><br><span class="line">        <span class="keyword">int</span> begin;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MySpliterator</span><span class="params">(T[] array, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.array = array;</span><br><span class="line">            <span class="keyword">this</span>.begin = begin;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            action.accept(array[begin++]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (estimateSize() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (begin + end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                MySpliterator&lt;T&gt; res = <span class="keyword">new</span> MySpliterator&lt;&gt;(array, begin, mid);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + res);</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.toString(Arrays.copyOfRange(array, begin, end + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> end - begin + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterator.SUBSIZED | Spliterator.ORDERED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] all = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        MySpliterator&lt;Integer&gt; spliterator = <span class="keyword">new</span> MySpliterator&lt;&gt;(all, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        StreamSupport.stream(spliterator, <span class="keyword">false</span>)</span><br><span class="line">                .parallel()</span><br><span class="line">                .forEach(x -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：按每次切分固定大小来实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-道之伊始&quot;&gt;&lt;a href=&quot;#一-道之伊始&quot; class=&quot;headerlink&quot; title=&quot;一. 道之伊始&quot;&gt;&lt;/a&gt;一. 道之伊始&lt;/h1&gt;&lt;p&gt;宇宙初开之际，混沌之气笼罩着整个宇宙，一切模糊不清。&lt;/p&gt;
&lt;p&gt;然后，盘古开天，女娲造人：日月乃出、</summary>
      
    
    
    
    <category term="Java" scheme="https://castile.github.io/categories/Java/"/>
    
    
    <category term="函数式编程" scheme="https://castile.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Lambda" scheme="https://castile.github.io/tags/Lambda/"/>
    
    <category term="纯函数" scheme="https://castile.github.io/tags/%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用InvokeScriptedProcessor处理Record</title>
    <link href="https://castile.github.io/2024/03/18/%E4%BD%BF%E7%94%A8InvokeScriptedProcessor%E5%A4%84%E7%90%86Record/"/>
    <id>https://castile.github.io/2024/03/18/%E4%BD%BF%E7%94%A8InvokeScriptedProcessor%E5%A4%84%E7%90%86Record/</id>
    <published>2024-03-17T16:43:38.000Z</published>
    <updated>2024-03-17T16:43:38.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="InvokeScriptedProcessor模板-一个更快的ExecuteScript"><a href="#InvokeScriptedProcessor模板-一个更快的ExecuteScript" class="headerlink" title="InvokeScriptedProcessor模板(一个更快的ExecuteScript)"></a>InvokeScriptedProcessor模板(一个更快的ExecuteScript)</h2><p>原文地址：<a href="https://funnifi.blogspot.com/2017/06/invokescriptedprocessor-template-faster.html">https://funnifi.blogspot.com/2017/06/invokescriptedprocessor-template-faster.html</a></p><p> 对于Apache Nifi中的快速，简单且小的脚本任务，ExecuteScript通常比InvokescriptedProcessor更好，因为很少有样板代码，关系和属性已经定义和支持，并且某些与Nifi API相关的对象（例如ProcessSession，ProcessContext和ComponentLog）已经被绑定到脚本引擎，作为脚本可以轻松使用的变量。 </p><p> 然而，一个权衡是性能;在ExecuteScript中，每次onTrigger被执行时，脚本都会被 evaluated  。对于InvokeScriptedProcessor，只要脚本(或任何InvokeScriptedProcessor属性)没有改变，脚本化的Processor实例就由处理器维护，当NiFi框架调用onTrigger()等父方法时，它的方法就会被简单地调用。 </p><p> 为了获得两者的最佳效果，我将InvokeScriptedProcessor实例放在一起，该实例的配置方式与ExecuteScript相同。提供了“成功”和“失败”的关系，API对象是可用的，如果您只是将您的ExecuteScript代码粘贴到下面脚本中的相同位置，它将表现得像一个性能更高的ExecuteScript实例。代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// imports go here</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>&#123;</span> <span class="keyword">void</span> executeScript(session, context, log, REL_SUCCESS, REL_FAILURE) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">        <span class="comment">// your code goes here</span></span><br><span class="line">        <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroovyProcessor</span> <span class="keyword">implements</span> <span class="title">Processor</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> REL_SUCCESS = <span class="keyword">new</span> Relationship.Builder().name(<span class="string">&quot;success&quot;</span>).description(<span class="string">&#x27;FlowFiles that were successfully processed are routed here&#x27;</span>).build()</span><br><span class="line">    <span class="keyword">def</span> REL_FAILURE = <span class="keyword">new</span> Relationship.Builder().name(<span class="string">&quot;failure&quot;</span>).description(<span class="string">&#x27;FlowFiles that were not successfully processed are routed here&#x27;</span>).build()</span><br><span class="line">    <span class="keyword">def</span> ComponentLog log</span><br><span class="line">    <span class="keyword">def</span> e = <span class="keyword">new</span> E()   </span><br><span class="line">    <span class="keyword">void</span> initialize(ProcessorInitializationContext context) &#123; log = context.logger &#125;</span><br><span class="line">    Set&lt;Relationship&gt; getRelationships() &#123; <span class="keyword">return</span> [REL_FAILURE, REL_SUCCESS] <span class="keyword">as</span> Set &#125;</span><br><span class="line">    Collection&lt;ValidationResult&gt; validate(ValidationContext context) &#123; <span class="literal">null</span> &#125;</span><br><span class="line">    PropertyDescriptor getPropertyDescriptor(String name) &#123; <span class="literal">null</span> &#125;</span><br><span class="line">    <span class="keyword">void</span> onPropertyModified(PropertyDescriptor descriptor, String oldValue, String newValue) &#123; &#125;</span><br><span class="line">    List&lt;PropertyDescriptor&gt; getPropertyDescriptors() &#123; <span class="literal">null</span> &#125;</span><br><span class="line">    String getIdentifier() &#123; <span class="literal">null</span> &#125;    </span><br><span class="line">    <span class="keyword">void</span> onTrigger(ProcessContext context, ProcessSessionFactory sessionFactory) <span class="keyword">throws</span> ProcessException &#123;</span><br><span class="line">        <span class="keyword">def</span> session = sessionFactory.createSession()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            e.executeScript(session, context, log, REL_SUCCESS, REL_FAILURE)</span><br><span class="line">            session.commit()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable t) &#123;</span><br><span class="line">            log.error(<span class="string">&#x27;&#123;&#125; failed to process due to &#123;&#125;; rolling back session&#x27;</span>, [<span class="built_in">this</span>, t] <span class="keyword">as</span> Object[])</span><br><span class="line">            session.rollback(<span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">throw</span> t</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line">processor = <span class="keyword">new</span> GroovyProcessor()</span><br></pre></td></tr></table></figure><h2 id="InvokeScriptedProcessor模板-使用Jython"><a href="#InvokeScriptedProcessor模板-使用Jython" class="headerlink" title="InvokeScriptedProcessor模板(使用Jython)"></a>InvokeScriptedProcessor模板(使用Jython)</h2><p> 我在Groovy中提供了一个模板，该模板将允许NIFI用户将其ExecuteScript Groovy脚本移植到更快的InvokescriptedProcessor（ISP）处理器中。ISP比ExecuteScript更快，因为仅当代码或其他配置更改时才重新加载脚本，而executeScript每次调用处理器时都会评估脚本。 </p><p> 自从那篇文章以来，我已经收到了使用Jython编写的ISP模板的几个请求（例如此请求），因此使用Jython脚本执行的用户可以从ISP性能提升中受益。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">#// imports go here</span></span><br><span class="line"><span class="comment">#////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">from</span> org.apache.nifi.processor <span class="keyword">import</span> Processor,Relationship</span><br><span class="line"><span class="keyword">from</span> java.lang <span class="keyword">import</span> Throwable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">executeScript</span>(<span class="params">self,session, context, log, REL_SUCCESS, REL_FAILURE</span>):</span></span><br><span class="line">        log.warn(<span class="string">&quot;=====Hello========&quot;</span>)</span><br><span class="line"><span class="comment">#end class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JythonProcessor</span>(<span class="params">Processor</span>):</span>   </span><br><span class="line">    REL_SUCCESS = Relationship.Builder().name(<span class="string">&quot;success&quot;</span>).description(<span class="string">&#x27;FlowFiles that were successfully processed are routed here&#x27;</span>).build()</span><br><span class="line">    REL_FAILURE = Relationship.Builder().name(<span class="string">&quot;failure&quot;</span>).description(<span class="string">&#x27;FlowFiles that were not successfully processed are routed here&#x27;</span>).build()</span><br><span class="line">    log = <span class="literal">None</span></span><br><span class="line">    e = E()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span>(<span class="params">self,context</span>):</span></span><br><span class="line">        self.log = context.logger</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRelationships</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>([self.REL_SUCCESS, self.REL_FAILURE])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self,context</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onPropertyModified</span>(<span class="params">self,descriptor, oldValue, newValue</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPropertyDescriptors</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIdentifier</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">onTrigger</span>(<span class="params">self,context, sessionFactory</span>):</span></span><br><span class="line">        session = sessionFactory.createSession()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.e.executeScript(session, context, self.log, self.REL_SUCCESS, self.REL_FAILURE)</span><br><span class="line">            session.commit()</span><br><span class="line">        <span class="keyword">except</span> Throwable, t:</span><br><span class="line">            self.log.error(<span class="string">&#x27;&#123;&#125; failed to process due to &#123;&#125;; rolling back session&#x27;</span>, [self, t])</span><br><span class="line">            session.rollback(true)</span><br><span class="line">            <span class="keyword">raise</span> t</span><br><span class="line"><span class="comment">#end class</span></span><br><span class="line"></span><br><span class="line">processor = JythonProcessor()</span><br></pre></td></tr></table></figure><h2 id="可复用的脚本"><a href="#可复用的脚本" class="headerlink" title="可复用的脚本"></a>可复用的脚本</h2><p>我们可以使用动态属性(在开发人员指南和之前的文章中有解释)，因为它们作为变量传递给ExecuteScript。然而，处理器的用户必须知道要添加和填充哪些属性，并且没有好的方法将这些信息传递给用户(至少使用ExecuteScript是这样)。 </p><p>但是，IndokescriptedProcessor可让您提供完整处理器实例的脚本实现。这意味着您可以定义自己的属性和关系，以及对它们的文档和验证。您的脚本可以提供功能，取决于处理器用户配置处理器的方式，而无需与脚本进行交互！ </p><p>一个带有单个InvokescriptedProcessor（包含工作脚本）的模板可以拖到画布上，基本上就像将自定义处理器拖到画布上一样！当用户打开对话框时，他们会看到您添加的属性/关系，并且将像普通的属性一样（脚本语言，body等）进行验证。</p><p>脚本化的处理器只需要实现processor接口，该接口又扩展了AbstractConfigurableComponent。Groovy的基本框架是这样的:一个类包含一组被覆盖的接口方法</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">implements</span> <span class="title">Processor</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> initialize(ProcessorInitializationContext context) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;Relationship&gt; getRelationships() &#123; <span class="keyword">return</span> [] <span class="keyword">as</span> Set &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> onTrigger(ProcessContext context, ProcessSessionFactory sessionFactory) <span class="keyword">throws</span> ProcessException &#123;</span><br><span class="line">      <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Collection&lt;ValidationResult&gt; validate(ValidationContext context) &#123; <span class="keyword">return</span> <span class="literal">null</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    PropertyDescriptor getPropertyDescriptor(String name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> onPropertyModified(PropertyDescriptor descriptor, String oldValue, String newValue) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    List&lt;PropertyDescriptor&gt; getPropertyDescriptors() &#123; <span class="keyword">return</span> [] <span class="keyword">as</span> List &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String getIdentifier() &#123; <span class="keyword">return</span> <span class="string">&#x27;MyProcessor-InvokeScriptedProcessor&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processor = <span class="keyword">new</span> MyProcessor()</span><br></pre></td></tr></table></figure><p>请注意，类必须实现处理器并声明一个名为“Processor”的变量，该变量包含类的实例。这是InvokescriptedProcessor所要求的约定。</p><p>重要的是：尽管您可能会在NIFI代码中找到许多处理器扩展AbstractProcessor或AbstrackSessionFactoryProcessor，但是如果它扩展了这些类之一，则您的脚本很可能无法正常工作。这是由于这些类的validation() 方法被声明为最终，并且基本实现将期望一组受支持的属性描述符包括Invokescriptedprocessor（例如脚本文件），但仅使用列表来使用该列表您的脚本处理器提供。可能会有一个黑客解决这个问题，但即使可能，也不值得。</p><p>继续前进，假设我们要创建一个可重复使用的脚本处理器，该处理器工作于GenerateFlowFile，但允许用户提供流量文件的内容以及其“文件名”属性的值。此外，也许内容可以包括Nifi Expression语言（EL）构造，例如$ {hostName（）}。由于内容可能具有类似EL语句的内容，但是用户可能不希望对其进行评估，因此我们应该让用户决定是否在写入流文件之前评估EL语句的内容。最后，这是一个“生成”处理器，因此我们只需要“成功”关系。“失败”在这里没有真正的意义。话虽如此，捕获您的代码可以投掷的所有异常将很重要；在ProcessException并重新启动中包装每个，以便该框架可以正确处理。 </p><ol><li>添加“成功”关系并将其返回（在集合中）中的 getRealationships()</li><li>添加一个“文件内容”属性以包含流量文件的预期内容（可能包括EL）</li><li>添加一个“评估内容中的表达式”属性，以指示是否评估EL的内容</li><li>添加一个可选的“文件名”属性，以覆盖默认的“文件名”属性。</li><li>触发处理器时，创建一个流文件，写入内容（可能在评估EL之后），并可能设置文件名属性</li></ol><p>下面是一个Groovy语言的代码示例：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenerateFlowFileWithContent</span> <span class="keyword">implements</span> <span class="title">Processor</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> REL_SUCCESS = <span class="keyword">new</span> Relationship.Builder()</span><br><span class="line">            .name(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">            .description(<span class="string">&#x27;The flow file with the specified content and/or filename was successfully transferred&#x27;</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> CONTENT = <span class="keyword">new</span> PropertyDescriptor.Builder()</span><br><span class="line">            .name(<span class="string">&#x27;File Content&#x27;</span>).description(<span class="string">&#x27;The content for the generated flow file&#x27;</span>)</span><br><span class="line">            .required(<span class="literal">false</span>).expressionLanguageSupported(<span class="literal">true</span>).addValidator(Validator.VALID).build()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> CONTENT_HAS_EL = <span class="keyword">new</span> PropertyDescriptor.Builder()</span><br><span class="line">            .name(<span class="string">&#x27;Evaluate Expressions in Content&#x27;</span>).description(<span class="string">&#x27;Whether to evaluate NiFi Expression Language constructs within the content&#x27;</span>)</span><br><span class="line">            .required(<span class="literal">true</span>).allowableValues(<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;false&#x27;</span>).defaultValue(<span class="string">&#x27;false&#x27;</span>).build()</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> FILENAME = <span class="keyword">new</span> PropertyDescriptor.Builder()</span><br><span class="line">            .name(<span class="string">&#x27;Filename&#x27;</span>).description(<span class="string">&#x27;The name of the flow file to be stored in the filename attribute&#x27;</span>)</span><br><span class="line">            .required(<span class="literal">false</span>).expressionLanguageSupported(<span class="literal">true</span>).addValidator(StandardValidators.NON_EMPTY_VALIDATOR).build()</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> initialize(ProcessorInitializationContext context) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;Relationship&gt; getRelationships() &#123; <span class="keyword">return</span> [REL_SUCCESS] <span class="keyword">as</span> Set &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> onTrigger(ProcessContext context, ProcessSessionFactory sessionFactory) <span class="keyword">throws</span> ProcessException &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">def</span> session = sessionFactory.createSession()</span><br><span class="line">        <span class="keyword">def</span> flowFile = session.create()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> hasEL = context.getProperty(CONTENT_HAS_EL).asBoolean()</span><br><span class="line">        <span class="keyword">def</span> contentProp = context.getProperty(CONTENT)</span><br><span class="line">        <span class="keyword">def</span> content = (hasEL ? contentProp.evaluateAttributeExpressions().value : contentProp.value) ?: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> filename = context.getProperty(FILENAME)?.evaluateAttributeExpressions()?.getValue()</span><br><span class="line">        </span><br><span class="line">        flowFile = session.write(flowFile, &#123; outStream -&gt;</span><br><span class="line">                outStream.write(content.getBytes(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line">            &#125; as OutputStreamCallback)</span><br><span class="line">        </span><br><span class="line">        if(filename != null) &#123; flowFile = session.putAttribute(flowFile, <span class="string">&#x27;filename&#x27;</span>, filename) &#125;</span><br><span class="line">        <span class="comment">// transfer</span></span><br><span class="line">        session.transfer(flowFile, REL_SUCCESS)</span><br><span class="line">        session.commit()</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">          throw new ProcessException(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Collection&lt;ValidationResult&gt; validate(ValidationContext context) &#123; return null &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    PropertyDescriptor getPropertyDescriptor(String name) &#123;</span><br><span class="line">        switch(name) &#123;</span><br><span class="line">            case <span class="string">&#x27;File Content&#x27;</span>: return CONTENT</span><br><span class="line">            case <span class="string">&#x27;Evaluate Expressions in Content&#x27;</span>: <span class="keyword">return</span> CONTENT_HAS_EL</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;Filename&#x27;</span>: <span class="keyword">return</span> FILENAME</span><br><span class="line">            <span class="symbol">default:</span> <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> onPropertyModified(PropertyDescriptor descriptor, String oldValue, String newValue) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    List&lt;PropertyDescriptor&gt;&gt; getPropertyDescriptors() &#123; <span class="keyword">return</span> [CONTENT, CONTENT_HAS_EL, FILENAME] <span class="keyword">as</span> List &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String getIdentifier() &#123; <span class="keyword">return</span> <span class="string">&#x27;GenerateFlowFile-InvokeScriptedProcessor&#x27;</span> &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processor = <span class="keyword">new</span> GenerateFlowFileWithContent()</span><br></pre></td></tr></table></figure><p>将其输入到InvokeScriptedProcessor的脚本主体中，语言设置为Groovy，然后应用(通过单击对话框上的Apply)，那么当重新打开对话框时，您应该看到关系设置为“success”，属性添加到配置对话框中。</p><p>此时，您可以将单个处理器保存为模板，称其为“生成FlowFileWithContent”之类的东西。现在，它是一个基本上可以作为处理器重复使用的模板。尝试将其拖到画布上并输入一些值，然后将其接线到其他处理器（例如Putfile）（查看它是否有效）：</p><p>希望这说明了InvokescriptedProcessor的功能和灵活性，以及如何使用自定义逻辑来创建可重复使用的处理器模板，而无需构建和部署NAR。</p><p> 最合适的方法可能是使用InvoKescriptedProcessor，因为您可以添加更复杂的属性（指定控制器服务，例如），而不是用户。 - 定义的executeScript属性。 </p><p> 话虽如此，对于任何基于记录的脚本处理器，您都需要大量的设置代码，并且在如何处理记录的情况下，有最佳练习，即您在创建RecordSetWriter之前处理第一个记录，以防万一您的自定义处理器代码需要更新RecordSetWriter将使用的架构。下面的 Groovy  示例改编自 <a href="https://github.com/apache/nifi/blob/master/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/main/java/org/apache/nifi/processors/standard/AbstractRecordProcessor.java">AbstractRecordProcessor</a> ，这是标准NAR中所有记录处理器的共同基类。请注意，要处理第一个和其余记录的两个注释部分，这些是您将自定义代码处理记录的地方。最好是在脚本处理器中添加私有方法，然后将其调用一次以获取第一个记录，然后再次在循环中（这就是AbstractRecordProcessor所做的） </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.nifi.flowfile.attributes.CoreAttributes</span><br><span class="line"><span class="keyword">import</span> org.apache.nifi.processor.AbstractProcessor</span><br><span class="line"><span class="keyword">import</span> org.apache.nifi.processor.ProcessContext</span><br><span class="line"><span class="keyword">import</span> org.apache.nifi.processor.ProcessSession</span><br><span class="line"><span class="keyword">import</span> org.apache.nifi.processor.Relationship</span><br><span class="line"><span class="keyword">import</span> org.apache.nifi.processor.io.StreamCallback</span><br><span class="line"><span class="keyword">import</span> org.apache.nifi.serialization.*</span><br><span class="line"><span class="keyword">import</span> org.apache.nifi.serialization.record.*</span><br><span class="line"><span class="keyword">import</span> org.apache.nifi.schema.access.SchemaNotFoundException</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRecordProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Properties</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> PropertyDescriptor RECORD_READER = <span class="keyword">new</span> PropertyDescriptor.Builder()</span><br><span class="line">        .name(<span class="string">&quot;record-reader&quot;</span>)</span><br><span class="line">        .displayName(<span class="string">&quot;Record Reader&quot;</span>)</span><br><span class="line">        .description(<span class="string">&quot;Specifies the Controller Service to use for reading incoming data&quot;</span>)</span><br><span class="line">        .identifiesControllerService(RecordReaderFactory.<span class="keyword">class</span>)</span><br><span class="line">        .required(<span class="literal">true</span>)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> PropertyDescriptor RECORD_WRITER = <span class="keyword">new</span> PropertyDescriptor.Builder()</span><br><span class="line">        .name(<span class="string">&quot;record-writer&quot;</span>)</span><br><span class="line">        .displayName(<span class="string">&quot;Record Writer&quot;</span>)</span><br><span class="line">        .description(<span class="string">&quot;Specifies the Controller Service to use for writing out the records&quot;</span>)</span><br><span class="line">        .identifiesControllerService(RecordSetWriterFactory.<span class="keyword">class</span>)</span><br><span class="line">        .required(<span class="literal">true</span>)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> REL_SUCCESS = <span class="keyword">new</span> Relationship.Builder().name(<span class="string">&quot;success&quot;</span>).description(<span class="string">&#x27;FlowFiles that were successfully processed are routed here&#x27;</span>).build()</span><br><span class="line">    <span class="keyword">def</span> REL_FAILURE = <span class="keyword">new</span> Relationship.Builder().name(<span class="string">&quot;failure&quot;</span>).description(<span class="string">&#x27;FlowFiles are routed here if an error occurs during processing&#x27;</span>).build()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;PropertyDescriptor&gt; getSupportedPropertyDescriptors() &#123;</span><br><span class="line">        <span class="keyword">def</span> properties = [] <span class="keyword">as</span> ArrayList</span><br><span class="line">        properties.add(RECORD_READER)</span><br><span class="line">        properties.add(RECORD_WRITER)</span><br><span class="line">        properties</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    Set&lt;Relationship&gt; getRelationships() &#123;</span><br><span class="line">       [REL_SUCCESS, REL_FAILURE] <span class="keyword">as</span> Set&lt;Relationship&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> onTrigger(ProcessContext context, ProcessSession session) &#123;</span><br><span class="line">        <span class="keyword">def</span> flowFile = session.get()</span><br><span class="line">        <span class="keyword">if</span> (!flowFile) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> readerFactory = context.getProperty(RECORD_READER).asControllerService(RecordReaderFactory)</span><br><span class="line">        <span class="keyword">def</span> writerFactory = context.getProperty(RECORD_WRITER).asControllerService(RecordSetWriterFactory)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; attributes = <span class="keyword">new</span> HashMap&lt;&gt;()</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger recordCount = <span class="keyword">new</span> AtomicInteger()</span><br><span class="line">        <span class="keyword">final</span> FlowFile original = flowFile</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; originalAttributes = flowFile.attributes</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            flowFile = session.write(flowFile,  &#123; inStream, outStream -&gt;</span><br><span class="line">                    <span class="keyword">def</span> reader = readerFactory.createRecordReader(originalAttributes, inStream, getLogger())</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Get the first record and process it before we create the Record Writer. </span></span><br><span class="line">                        <span class="comment">// We do this so that if the Processor updates the Record&#x27;s schema, we can provide </span></span><br><span class="line">                        <span class="comment">// an updated schema to the Record Writer. If there are no records, then we can</span></span><br><span class="line">                        <span class="comment">// simply create the Writer with the Reader&#x27;s schema and begin &amp; end the RecordSet</span></span><br><span class="line">                        <span class="keyword">def</span> firstRecord = reader.nextRecord()</span><br><span class="line">                        <span class="keyword">if</span> (!firstRecord) &#123;</span><br><span class="line">                            <span class="keyword">def</span> writeSchema = writerFactory.getSchema(originalAttributes, reader.schema)</span><br><span class="line">                            <span class="keyword">def</span> writer = writerFactory.createWriter(getLogger(), writeSchema, outStream)</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                writer.beginRecordSet()</span><br><span class="line">                                <span class="keyword">def</span> writeResult = writer.finishRecordSet()</span><br><span class="line">                                attributes[<span class="string">&#x27;record.count&#x27;</span>] = String.valueOf(writeResult.recordCount)</span><br><span class="line">                                attributes[CoreAttributes.MIME_TYPE.key()] = writer.mimeType</span><br><span class="line">                                attributes.putAll(writeResult.attributes)</span><br><span class="line">                                recordCount.set(writeResult.recordCount)</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                writer.close()</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/////////////////////////////////////////</span></span><br><span class="line">                        <span class="comment">// TODO process first record</span></span><br><span class="line">                        <span class="comment">/////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">def</span> writeSchema = writerFactory.getSchema(originalAttributes, firstRecord.schema)</span><br><span class="line">                        <span class="keyword">def</span> writer = writerFactory.createWriter(getLogger(), writeSchema, outStream)</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            writer.beginRecordSet()</span><br><span class="line">                            writer.write(firstRecord)</span><br><span class="line">                            <span class="keyword">def</span> record</span><br><span class="line">                            <span class="keyword">while</span> (record = reader.nextRecord()) &#123;</span><br><span class="line">                                <span class="comment">//////////////////////////////////////////</span></span><br><span class="line">                                <span class="comment">// TODO process next record</span></span><br><span class="line">                                <span class="comment">//////////////////////////////////////////</span></span><br><span class="line">                                writer.write(processed)</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">def</span> writeResult = writer.finishRecordSet()</span><br><span class="line">                            attributes.put(<span class="string">&#x27;record.count&#x27;</span>, String.valueOf(writeResult.recordCount))</span><br><span class="line">                            attributes.put(CoreAttributes.MIME_TYPE.key(), writer.mimeType)</span><br><span class="line">                            attributes.putAll(writeResult.attributes)</span><br><span class="line">                            recordCount.set(writeResult.recordCount)</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            writer.close()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchemaNotFoundException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ProcessException(e.localizedMessage, e)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> MalformedRecordException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ProcessException(<span class="string">&#x27;Could not parse incoming data&#x27;</span>, e)</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        reader.close()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">as</span> StreamCallback)</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">            getLogger().error(<span class="string">&#x27;Failed to process &#123;&#125;; will route to failure&#x27;</span>, [flowFile, e] <span class="keyword">as</span> Object[])</span><br><span class="line">            session.transfer(flowFile, REL_FAILURE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flowFile = session.putAllAttributes(flowFile, attributes)</span><br><span class="line">        recordCount.get() ?  session.transfer(flowFile, REL_SUCCESS) : session.remove(flowFile)</span><br><span class="line">        <span class="keyword">def</span> count = recordCount.get()</span><br><span class="line">        session.adjustCounter(<span class="string">&#x27;Records Processed&#x27;</span>, count, <span class="literal">false</span>)</span><br><span class="line">        getLogger().info(<span class="string">&#x27;Successfully converted &#123;&#125; records for &#123;&#125;&#x27;</span>, [count, flowFile] <span class="keyword">as</span> Object[])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processor = <span class="keyword">new</span> MyRecordProcessor()</span><br></pre></td></tr></table></figure><p>在session.write（）streamCallback内部，我们首先检查是否有任何记录，如果没有任何记录）并写出一个 zero-record 的flowfile。</p><p>在那之后，是时候与其他人分开处理第一个记录了。这是因为读者和/或自定义处理器代码可能会从读者的架构中更改作者的架构。例如，在架构推理期间，发生这种情况是自NIFI 1.9.0以来的读者的功能。</p><p>然后编写了第一个记录，其余记录的过程仍在继续。最后，填充了基于标准的记录的属性，然后更新流量文件并传输。上面的脚本还包括出现问题时的错误处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;InvokeScriptedProcessor模板-一个更快的ExecuteScript&quot;&gt;&lt;a href=&quot;#InvokeScriptedProcessor模板-一个更快的ExecuteScript&quot; class=&quot;headerlink&quot; title=&quot;Invo</summary>
      
    
    
    
    <category term="NiFi" scheme="https://castile.github.io/categories/NiFi/"/>
    
    
    <category term="NiFi" scheme="https://castile.github.io/tags/NiFi/"/>
    
  </entry>
  
  <entry>
    <title>一些有意思的关于NiFi的Blog汇总</title>
    <link href="https://castile.github.io/2024/03/18/%E4%B8%80%E4%BA%9B%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%85%B3%E4%BA%8ENiFi%E7%9A%84Blog%E6%B1%87%E6%80%BB/"/>
    <id>https://castile.github.io/2024/03/18/%E4%B8%80%E4%BA%9B%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%85%B3%E4%BA%8ENiFi%E7%9A%84Blog%E6%B1%87%E6%80%BB/</id>
    <published>2024-03-17T16:43:29.000Z</published>
    <updated>2024-03-17T16:43:29.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NiFi-HDF-Dataflow-Optimization-Part-1-of-2"><a href="#NiFi-HDF-Dataflow-Optimization-Part-1-of-2" class="headerlink" title="NiFi/HDF Dataflow Optimization (Part 1 of 2)"></a><a href="https://community.cloudera.com/t5/Community-Articles/NiFi-HDF-Dataflow-Optimization-Part-1-of-2/ta-p/245102">NiFi/HDF Dataflow Optimization (Part 1 of 2)</a></h1><h1 id="NiFi-HDF-Dataflow-Optimization-Part-2-of-2"><a href="#NiFi-HDF-Dataflow-Optimization-Part-2-of-2" class="headerlink" title="NiFi/HDF Dataflow Optimization (Part 2 of 2) "></a><a href="https://community.cloudera.com/t5/Community-Articles/NiFi-HDF-Dataflow-Optimization-Part-2-of-2/ta-p/245113">NiFi/HDF Dataflow Optimization (Part 2 of 2) </a></h1><h2 id="怎么预防系统或者Processor过载运行"><a href="#怎么预防系统或者Processor过载运行" class="headerlink" title="怎么预防系统或者Processor过载运行"></a>怎么预防系统或者Processor过载运行</h2><ol><li>使用connection中背压控制</li><li>结合ControRate处理器</li></ol><h2 id="理解Processors所需的资源"><a href="#理解Processors所需的资源" class="headerlink" title="理解Processors所需的资源"></a>理解Processors所需的资源</h2><p> 数据流优化的另一个方面是了解每个处理器所需的资源。这将允许更好的数据流执行。例如，CompressContent处理器将使用1个CPU/并发任务，因此，如果该处理器具有4个并发任务，并且队列中有4个文件，则该处理器将使用4个CPU，直到文件被压缩为止。对于小型文件，这比处理大型文件少于资源瓶颈。一个很好的例子是，将中小型，中和大文件都从单独的流路路径沿着3个不同的压缩处理器流动，每个流程都有自己的并发任务数量。在下面的示例中，所有三个CompressContent处理器都有一个并发任务。 </p><img src="/2024/03/18/%E4%B8%80%E4%BA%9B%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%85%B3%E4%BA%8ENiFi%E7%9A%84Blog%E6%B1%87%E6%80%BB/1710691506263.png" class width="1710691506263"><p>该图提供了优化吞吐量的一个很好的例子。每个CompressContent处理器的“ Tasks/Time”清楚地表明，随着文件的增加，压缩较大文件所需的时间呈指数较大。这提供了更好地利用CPU处理最多文件数量，而不是让任意的大文件放慢整个流程。这不是在文档中明确指出的，而是通过压缩NIFI内部或外部文件的唯一方法是使用每个文件使用要在完成操作的系统上使用CPU使用CPU。 </p><p> 请注意，处理器的某些文档指出了当特定处理器具有应意识到的行为时。例如，MemgeContent处理器的文档具有以下行：<em>建议仅使用单个传入连接配置处理器，因为不会从不同连接的FlowFiles创建一组FlowFiles。</em> </p><p> FlowFiles的大小和遍历各种数据流路径的流档数量将对某些处理器产生不同的影响。学习阅读有关处理器的信息可以帮助您确定何时何地应用一些或全部讨论的优化策略。 </p><h2 id="NIFI如何帮助您找到可以优化的位置-如何优化？"><a href="#NIFI如何帮助您找到可以优化的位置-如何优化？" class="headerlink" title="NIFI如何帮助您找到可以优化的位置/如何优化？"></a>NIFI如何帮助您找到可以优化的位置/如何优化？</h2><p> 每个处理器提供了大量信息，可以帮助DFM确定故障点在流动中的位置；请参阅下面的描述： </p><img src="/2024/03/18/%E4%B8%80%E4%BA%9B%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%85%B3%E4%BA%8ENiFi%E7%9A%84Blog%E6%B1%87%E6%80%BB/1710691926009.png" class width="1710691926009"><p><strong>In</strong>:  根据滑动5分钟的窗口，处理器从其传入连接的队列中取出的数据量。该值表示为<count> / <size>其中<count>是已从队列中提取的流file的数量，而<size>是这些FlowFiles内容的总大小。在此示例中，处理器已从输入队列中取出1270个flowfile，总共12.4兆字节（MB）。 </size></count></size></count></p><p><strong>Read/Write</strong>: 处理器已从磁盘读取并写入磁盘的flowfile内容的总大小。这提供了有关此处理器所需的I/O性能的有价值的信息。有些处理器只能在不编写任何内容的情况下读取数据，而有些则不会读取数据，而只会写数据。其他人则既不读取也不会写数据，而某些处理器则将读取和写入数据。在此示例中，我们看到在过去的五分钟内，该处理器读取了12.4 MB的flowfile，并且还写了12.4 MB。这就是我们期望的，因为该处理器只是将流file的内容复制到磁盘上。 </p><p><strong>Out</strong>： 处理器已转移到其出站连接的数据量。这不包括处理器删除自身的flowfiles，也不包括与自动终止的连接路由的流文件。就像上面的“ In”指标一样，此值表示为<count> / <size>，其中<count>是已将其传输到出站连接的flowfile的数量，<size>是这些FlowFiles内容的总大小。在此示例中，所有文件都写入磁盘，并且连接被自动终止，因此没有将文件移出到下游连接。 </size></count></size></count></p><p> <strong>Tasks/Time</strong>： 反映了在过去5分钟内完成运行的任务数量以及这些任务完成的总时间。您可能有1个线程，一个任务需要20分钟才能完成。完成后，将在接下来的5分钟内添加到此累积报告中。时间的格式为&lt; hour&gt;：&lt; minute &gt;：&lt; second &gt;。请注意，所花费的时间可能超过五分钟，因为许多任务可以并行执行。例如，如果安排处理器运行60个并发任务，并且这些任务中的每一个都需要一秒钟才能完成，则所有60个任务可能会在一秒钟内完成。但是，在这种情况下，我们将看到时间指标表明它花了60秒，而不是1秒。 </p><p>利用处理器提供的信息，读取/写入的数量以及每个任务的任务/时间来查找图表上的“热点”。例如，如果大量任务运行，但是通过处理器传递的数据量较低，则处理器可能被配置为过于频繁或同时执行的任务过多。对于处理器，至少需要更仔细的外观。<strong>一个完成任务很少的处理器以及较高的任务时间表明该处理器是CPU密集的。如果数据流量很高，并且处理器显示大量的已完成线程和高任务时间，则可以通过增加处理器调度的运行持续时间（Run Duration）来提高性能。</strong> </p><h2 id="产生了背压"><a href="#产生了背压" class="headerlink" title="产生了背压"></a>产生了背压</h2><p> 如果在数据始终始终积压的流程中存在连接，则如果处理数据的任何延迟是不可接受的，则可能是一个关注点。但是，只需在以上的情况下向处理器添加更多并发任务，就可以在图表的另一部分中导致线程饥饿（下面更详细地介绍）。再次在这里，DFM必须注意了解为什么数据在图中的此特定点备份。它只是可以是一个非常密集的处理器，并且在整个图中只有如此多的CPU可使用。这些文件可能对系统非常大，并且可能需要每个文件的读取和写入，这是昂贵的操作。如果资源不是问题，请添加更多的并发任务，看看是否解决了积压的问题。如果资源是问题，则必须重新设计流量以更好地利用可用的内容，否则必须将工作负载分配到多个系统上，这意味着群集两个或多个系统以减少任何一个系统的负载。文件可能是积压的，因为对其进行处理的处理器是I/O密集型。处理器统计信息应显示。检查磁盘；我是/o还是接近100％？添加更多线程不会更快地处理文件，而是会导致线程饥饿。 </p><h2 id="NiFi线程饥饿"><a href="#NiFi线程饥饿" class="headerlink" title="NiFi线程饥饿"></a>NiFi线程饥饿</h2><p> 优化的另一个方面是如何配置处理器，使其在流的一个区域占用太多可用资源，然后在流的另一个区域耗尽线程。</p><p> 假设有一个处理器是CPU和磁盘密集型，需要10个并行的任务来维持日常操作流量。然后对图进行修改以添加需要系统资源的其他数据流。将附加数据流添加到图表后，注意到具有10个并发任务的处理器无法跟上数据速率。因此，将另外5个并发任务添加到处理器中。然后，图上的另一个流开始备份数据，然后将其他并发任务添加到该流程中，依此类推……很快，已将太多并发任务添加到了图中，以至于数据流实际上永远不会获得线程，系统花费了确定哪个处理器应该获得线程的所有资源，但永远不会允许完成任务，并且系统陷入了此周期。 </p><p> 为了防止这种情况发生在数据流程中，每次更新或添加图表之后，DFM应检查系统资源利用率的当前级别。如果更新或添加后，数据开始在以前未看到的流程的点上积压，则更改以某种方式不堪重负，并建议关闭添加的流量，直到它可以确定哪个系统资源正在过度使用。另一个解决方案是通过集群系统将流量平衡在两个或多个系统上。 </p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p> 即使在优化的数据流中，物理资源耗尽也可以而且确实发生。当这种情况发生时，最好的方法是将数据负载分散在NIFI群集中的多个NIFI实例上。 </p><p> NIFI管理员或DataFlow Manager（DFM）可能会发现，在单个服务器上使用NIFI的一个实例不足以处理其拥有的数据量。因此，一种解决方案是在多个单独的NIFI服务器上运行相同的数据流。但是，这会引起管理问题，因为每次DFM都想更改或更新数据流，它们必须在每个服务器上进行更改，然后单独监视每个服务器。通过聚类NIFI服务器，可以使增加的处理能力以及单个接口进行通过，以使数据流更改并监视数据流。聚类允许DFM仅进行每个更改一次，然后将更改复制到集群的所有节点。通过单个接口，DFM还可以监视所有节点的健康和状态 </p><p> NIFI集群的设计是一个简单的主/从模型，其中有一个或一个或多个从属。在NIFI群集中，我们将主人称为NIFI群集管理器（NCM），而奴隶称为节点。尽管该模型是主和从属的模型，但如果NCM死亡，则指示节点继续操作，因为它们是为了确保数据流保持生存。NCM的缺失仅表示新节点不能连接群集，并且在恢复NCM之前，不会发生群集流量变化。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NiFi-HDF-Dataflow-Optimization-Part-1-of-2&quot;&gt;&lt;a href=&quot;#NiFi-HDF-Dataflow-Optimization-Part-1-of-2&quot; class=&quot;headerlink&quot; title=&quot;NiFi/HDF</summary>
      
    
    
    
    <category term="NiFi" scheme="https://castile.github.io/categories/NiFi/"/>
    
    
    <category term="NiFi" scheme="https://castile.github.io/tags/NiFi/"/>
    
  </entry>
  
  <entry>
    <title>NiFi自定义扩展文档</title>
    <link href="https://castile.github.io/2024/02/24/NiFi%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95%E6%96%87%E6%A1%A3/"/>
    <id>https://castile.github.io/2024/02/24/NiFi%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95%E6%96%87%E6%A1%A3/</id>
    <published>2024-02-24T10:02:16.000Z</published>
    <updated>2024-02-24T10:02:16.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-NiFi组件"><a href="#一、-NiFi组件" class="headerlink" title="一、 NiFi组件"></a>一、 NiFi组件</h1><p>NiFi提供了几个扩展点，使开发人员能够向应用程序添加功能以满足他们的需求。下面的列表提供了最常见扩展点的高级描述</p><h2 id="1-Processor"><a href="#1-Processor" class="headerlink" title="1. Processor"></a>1. Processor</h2><p>处理器接口是NiFi公开对FlowFiles、其属性和内容的访问的机制。处理器是用于组成NiFi数据流的基本元素。该接口用于完成以下所有任务 </p><ul><li>创建FlowFiles</li><li>读取FlowFile内容</li><li>写FlowFile内容</li><li>读FlowFile属性</li><li>更新FlowFile属性</li><li>摄取数据</li><li>输出数据</li><li>路由数据</li><li>提取数据</li><li>修改数据 </li></ul><h2 id="2-ReportingTask"><a href="#2-ReportingTask" class="headerlink" title="2. ReportingTask"></a>2. ReportingTask</h2><p> ReportingTask接口允许将指标、监控信息和内部NiFi状态发布到外部端点，如日志文件、电子邮件和远程web服务。 </p><h2 id="3-ParameterProvider"><a href="#3-ParameterProvider" class="headerlink" title="3. ParameterProvider"></a>3. ParameterProvider</h2><p>ParameterProvider接口允许外部源提供参数。提供的参数仍然存储在参数上下文中，但是这种机制允许在外部提供和管理它们。 </p><h2 id="4-ControllerService"><a href="#4-ControllerService" class="headerlink" title="4.  ControllerService"></a>4.  ControllerService</h2><p> 在单个JVM中，ControllerService提供跨处理器、其他ControllerServices、参数提供者和reportingtask的共享状态和功能。一个示例用例可能包括将非常大的数据集加载到内存中。通过在ControllerService中执行这项工作，数据可以加载一次，并通过该服务向所有处理器公开，而不是要求许多不同的处理器自己加载数据集。 </p><h2 id="5-FlowFilePrioritizer"><a href="#5-FlowFilePrioritizer" class="headerlink" title="5.  FlowFilePrioritizer"></a>5.  FlowFilePrioritizer</h2><p>FlowFilePrioritizer接口提供了一种机制，通过该机制可以对队列中的FlowFiles进行优先级排序或排序，以便FlowFiles可以按照最有效的顺序处理特定用例。 </p><h2 id="6-AuthorityProvider"><a href="#6-AuthorityProvider" class="headerlink" title="6.  AuthorityProvider"></a>6.  AuthorityProvider</h2><p> AuthorityProvider负责确定应该授予给定用户哪些特权和角色(如果有的话) </p><h1 id="二、-Processor-API"><a href="#二、-Processor-API" class="headerlink" title="二、 Processor API"></a>二、 Processor API</h1><p>处理器是NiFi中使用最广泛的组件。处理器是唯一被赋予创建、删除、修改或检查FlowFiles(数据和属性)权限的组件。所有的处理器都是使用Java的ServiceLoader机制加载和实例化的。</p><p>虽然Processor是一个可以直接实现的接口，但是这样做是非常罕见的，因为org.apache.nifi.processor.AbstractProcessor是几乎所有Processor实现的基类。 AbstractProcessor类提供了大量的功能，这使得开发Processor的任务变得更加容易和方便。在本文的范围内，我们将主要关注处理Processor API时的AbstractProcessor类。 </p><blockquote><p> NiFi是一个高度并发的框架。这意味着所有扩展都必须是线程安全的。如果不熟悉用Java编写并发软件，强烈建议您熟悉Java并发原则。 </p></blockquote><p>为了理解Processor API，我们必须首先理解几个支持类和接口。 </p><h2 id="FlowFile"><a href="#FlowFile" class="headerlink" title="FlowFile"></a>FlowFile</h2><p> FlowFile是一个逻辑概念，它将一段数据与一组关于该数据的属性相关联。这些属性包括FlowFile的唯一标识符，以及它的名称、大小和任何其他特定于流的值。虽然FlowFile的内容和属性可以改变，但FlowFile对象是不可变的。对FlowFile的修改可以通过ProcessSession实现。 </p><p>FlowFiles的核心属性定义在org.apache.nifi.flowfile.attributes.CoreAttributes enum中。</p><ul><li> Filename (filename): FlowFile的文件名。文件名不应包含任何目录结构 </li><li> UUID (uuid):分配给该FlowFile的通用唯一标识符，用于将该FlowFile与系统中的其他FlowFile区分开来。 </li><li> 路径(path): FlowFile的路径是指FlowFile所属的相对目录，不包含文件名。 </li><li>绝对路径( absolute.path ): FlowFile的绝对路径是指FlowFile所属的绝对目录，不包含文件名。 </li><li> 优先级( priority ):表示FlowFile优先级的数值。 </li><li> MIME Type ( mime.type ):这个流文件的MIME类型。 </li><li> 丢弃原因( discard.reason ):指定FlowFile被丢弃的原因。  </li><li>替代标识符( alternate.identifier ):指示FlowFile的UUID之外的标识符，已知该标识符引用该FlowFile。 </li></ul><p><strong>其他的公共属性：</strong></p><p> 虽然这些属性不是CoreAttributes枚举的成员，但它们实际上是整个系统的标准，并且可以在大多数FlowFiles中找到。 </p><ul><li>文件大小(fileSize): FlowFile内容的大小，单位为字节。</li><li> 输入日期(entryDate): FlowFile进入系统(即创建)的日期和时间。此属性的值是一个数字，表示从1970年1月1日午夜(UTC)开始的毫秒数。 </li><li> 血统开始日期(lineageStartDate):任何时候，一个FlowFile被克隆，合并，或者分割，这将导致一个“子”FlowFile被创建。当这些子代被克隆、合并或分裂时，一个祖先链就建立起来了。该值表示最早的祖先进入系统的日期和时间。考虑这个问题的另一种方式是，该属性表示FlowFile通过系统的延迟。取值为数字，表示从1970年1月1日午夜(UTC)开始的毫秒数。 </li></ul><h2 id="ProcessSession"><a href="#ProcessSession" class="headerlink" title="ProcessSession"></a>ProcessSession</h2><p>ProcessSession(通常简称为“会话”)提供了一种机制，通过该机制可以创建、销毁、检查、克隆FlowFiles，并将其传输到其他处理器。此外，ProcessSession提供了通过添加或删除属性或修改FlowFile的内容来创建修改版本的FlowFiles的机制。ProcessSession还公开了一种发出<strong>出处事件（  <a href="https://nifi.apache.org/docs/nifi-docs/html/developer-guide.html#provenance_events">Provenance Events</a> ）</strong>的机制，该机制提供了跟踪FlowFile沿袭和历史的能力。 在对一个或多个FlowFiles执行操作后，ProcessSession可以提交或回滚。 </p><h2 id="ProcessContext"><a href="#ProcessContext" class="headerlink" title="ProcessContext"></a>ProcessContext</h2><p>ProcessContext提供了处理器和框架之间的桥梁。它提供有关处理器当前如何配置的信息，并允许处理器执行特定于框架的任务， 比如释放自己的资源，这样框架就可以在不消耗不必要资源的情况下调度其他处理器运行。 </p><h2 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h2><p>PropertyDescriptor定义了一个属性，该属性将被Processor、ReportingTask、ParameterProvider或ControllerService使用。属性的定义包括其名称、属性描述、可选的默认值、验证逻辑和指示说明是否需要该属性才能使Processor有效。PropertyDescriptor是通过实例化PropertyDescriptor的实例来创建的。构造器类，调用适当的方法来填充有关属性的详细信息，最后调用构建方法。 </p><h2 id="Validator"><a href="#Validator" class="headerlink" title="Validator"></a>Validator</h2><p>属性描述符必须指定一个或多个验证器，用于确保用户输入的属性值是有效的。如果Validator指示属性值无效，则在该属性变为有效之前，组件将无法运行或使用。如果没有指定Validator，组件将被认为是无效的，NiFi将报告不支持该属性。</p><h2 id="ValidationContext"><a href="#ValidationContext" class="headerlink" title="ValidationContext"></a>ValidationContext</h2><p>当验证属性值时，ValidationContext可以用来获取ControllerServices，创建PropertyValue对象，并使用表达式语言编译和计算属性值。</p><h2 id="PropertyValue"><a href="#PropertyValue" class="headerlink" title="PropertyValue"></a>PropertyValue</h2><p>返回给Processor的所有属性值都以PropertyValue对象的形式返回。该对象具有将值从String转换为其他形式(如数字和时间段)的方便方法，并提供用于求值Expression Language的API。 </p><h2 id="Relationship"><a href="#Relationship" class="headerlink" title="Relationship"></a>Relationship</h2><p>关系定义了FlowFile可以从处理器传输到的路由。通过实例化Relationship的实例来 <code>Relationship.Builder</code>  ，调用适当的方法来填充关系的详细信息，最后调用构建方法。 </p><h2 id="StateManager"><a href="#StateManager" class="headerlink" title="StateManager"></a>StateManager</h2><p> StateManager为处理器、报告任务和控制器服务提供了一种容易存储和检索状态的机制， 该API类似于ConcurrentHashMap，但每个操作都需要一个Scope。 这个Scope表示这个state是存在本地还是集群维度的。</p><h2 id="ProcessorInitializationContext"><a href="#ProcessorInitializationContext" class="headerlink" title="ProcessorInitializationContext"></a>ProcessorInitializationContext</h2><p>在创建了一个Processor之后，它的initialize方法将被InitializationContext对象调用。该对象向处理器公开在整个处理器生命周期中不会改变的配置，例如处理器的唯一标识符。 </p><h2 id="ComponentLog"><a href="#ComponentLog" class="headerlink" title="ComponentLog"></a>ComponentLog</h2><p>建议处理器通过ComponentLog接口执行日志记录，而不是获取第三方日志记录器的直接实例。这是因为通过ComponentLog进行日志记录允许框架将超过可配置严重性级别的日志消息呈现给用户界面，从而允许在发生重要事件时通知监视数据流的人员。此外，它通过在DEBUG模式下记录堆栈跟踪并在日志消息中提供处理器的唯一标识符，为所有处理器提供一致的日志记录格式。 </p><h1 id="三、AbstractProcessor-API"><a href="#三、AbstractProcessor-API" class="headerlink" title="三、AbstractProcessor API"></a>三、AbstractProcessor API</h1><p>由于绝大多数处理器将通过扩展AbstractProcessor来创建，因此我们将在本节中研究抽象类。AbstractProcessor提供了几个处理器开发人员会感兴趣的方法。 </p><h2 id="1、-处理器初始化"><a href="#1、-处理器初始化" class="headerlink" title="1、 处理器初始化"></a>1、 处理器初始化</h2><p> 在创建Processor之后，在调用任何其他方法之前，将调用AbstractProcessor的init方法。 该方法接受一个参数，类型为ProcessorInitializationContext。 上下文对象向处理器提供一个ComponentLog、处理器的唯一标识符和一个 ControllerServiceLookup  (可用于与已配置的ControllerServices交互)。这些对象中的每一个都由AbstractProcessor存储，并且可以由子类分别通过getLogger、getIdentifier和getControllerservicellookup方法获得。</p><h2 id="2、-暴露处理器属性"><a href="#2、-暴露处理器属性" class="headerlink" title="2、 暴露处理器属性"></a>2、 暴露处理器属性</h2><p>大多数处理器在使用之前都需要一定数量的用户配置。  处理器支持的属性通过getSupportedPropertyDescriptors方法公开给框架。 此方法不接受任何参数，并返回PropertyDescriptor对象的列表。<strong>列表中对象的顺序很重要，因为它决定了属性在用户界面中呈现的顺序。</strong> </p><h3 id="动态处理器属性"><a href="#动态处理器属性" class="headerlink" title="动态处理器属性"></a>动态处理器属性</h3><p> 除了标准属性之外，有时还希望允许用户配置名称不是预定义的其他属性。  这可以通过覆盖getSupportedDynamicPropertyDescriptor方法来实现。  此方法接受String作为其唯一参数，该参数指示属性的名称。该方法返回一个PropertyDescriptor对象，该对象可用于验证属性的名称和值。  从这个方法返回的任何PropertyDescriptor都应该在PropertyDescriptor中设置isDynamic的值为true。。AbstractProcessor的默认行为是不允许任何动态创建的属性。</p><h3 id="敏感动态属性"><a href="#敏感动态属性" class="headerlink" title="敏感动态属性"></a>敏感动态属性</h3><p>动态属性的默认实现不将属性值视为敏感值。在配置FlowFile属性或自定义表达式等特性时，这种方法是足够的，但它不能为密码或密钥等值提供保护。  </p><p>NiFi 1.17.0通过一个名为SupportsSensitiveDynamicProperties的注解引入了对敏感动态属性的框架支持。注释可以通过getSupportedDynamicPropertyDescriptor方法应用于支持动态属性的处理器、控制器服务或报告任务。注释表明组件允许将单个动态属性标记为敏感属性，以用于持久化和框架处理。 </p><p> getSupportedDynamicPropertyDescriptor必须返回一个 <code>sensitive</code>  设置为false的PropertyDescriptor，以允许自定义敏感状态。在此方法中将敏感字段设置为true将强制将所有动态属性作为敏感属性处理。这种方法允许在受支持的组件中升级敏感状态，但不降级。 </p><p>敏感属性值的安全处理是带注释的类的责任。支<strong>持敏感动态属性的组件不能记录属性值或将属性值作为FlowFile属性提供。</strong> </p><h2 id="3、-验证处理器属性"><a href="#3、-验证处理器属性" class="headerlink" title="3、 验证处理器属性"></a>3、 验证处理器属性</h2><p>如果处理器的配置无效，则处理器无法启动。 </p><p>处理器属性的验证可以通过在PropertyDescriptor上设置Validator或通过PropertyDescriptor限制属性的允许值来实现。Builder的allowableValues方法或identifiesControllerService方法。  此外，如果一个属性依赖于另一个属性( <code>PropertyDescriptor.Builder’s </code>dependsOn` method ），切不满足的话则会被校验住。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PropertyDescriptor USE_FILE = <span class="keyword">new</span> PropertyDescriptor.Buildler()</span><br><span class="line">    .name(<span class="string">&quot;Use File&quot;</span>)</span><br><span class="line">    .displayName(<span class="string">&quot;Use File&quot;</span>)</span><br><span class="line">    .required(<span class="keyword">true</span>)</span><br><span class="line">    .allowableValues(<span class="string">&quot;true&quot;</span>, <span class="string">&quot;false&quot;</span>)</span><br><span class="line">    .defaultValue(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PropertyDescriptor FILE = <span class="keyword">new</span> PropertyDescriptor.Builder()</span><br><span class="line">    .name(<span class="string">&quot;File to Use&quot;</span>)</span><br><span class="line">    .displayName(<span class="string">&quot;File to Use&quot;</span>)</span><br><span class="line">    .required(<span class="keyword">true</span>)</span><br><span class="line">    .addValidator(StandardValidators.FILE_EXISTS_VALIDATOR)</span><br><span class="line">    .dependsOn(USE_FILE, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>有时单独验证一个Processor的属性是不够的。为此，AbstractProcessor公开了一个customValidate方法。该方法接受ValidationContext类型的单个参数。这个方法的返回值是一个ValidationResult对象的集合，它描述了在验证过程中发现的任何问题。只有那些isValid方法返回false的ValidationResult对象才应该被返回。 只有当所有属性根据其关联的验证器和允许值都有效时，才会调用此方法。也就是说，只有当所有属性本身都有效时，这个方法才会被调用，并且这个方法允许将处理器的配置作为一个整体进行验证。 </p><h2 id="4、响应配置中的更改"><a href="#4、响应配置中的更改" class="headerlink" title="4、响应配置中的更改"></a>4、响应配置中的更改</h2><p> 有时，当处理器的属性发生变化时，我们希望它立即做出反应。  onPropertyModified方法允许处理器这样做。当用户更改处理器的属性值时，将为每个修改的属性调用onPropertyModified方法。 </p><p> 该方法接受三个参数:PropertyDescriptor(表示修改了哪个属性、旧值和新值。  如果属性之前没有值，第二个参数将为空。  如果该属性被删除，则第三个参数将为空。重要的是要注意，无论值是否有效，都会调用此方法。这个方法将只在值被实际修改时调用，而不是在用户更新处理器而不更改其值时调用。在调用此方法时，可以保证调用此方法的线程是当前在处理器中执行代码的唯一线程，除非处理器本身创建了自己的线程。 </p><h2 id="5、-执行工作"><a href="#5、-执行工作" class="headerlink" title="5、 执行工作"></a>5、 执行工作</h2><p> 当处理器有工作要做时，它通过框架调用它的onTrigger方法来进行调度。 </p><p> 该方法有两个参数:一个ProcessContext和一个ProcessSession。onTrigger方法的第一步通常是通过调用ProcessSession上的get方法来获取要在其上执行工作的FlowFile。 </p><p> 对于从外部源摄取数据到NiFi的处理器，跳过此步骤。然后处理器可以自由地检查FlowFile属性;添加、删除或修改属性;读取或修改FlowFile内容;并将FlowFiles传输到适当的关系。 </p><h2 id="6、-处理器何时被触发"><a href="#6、-处理器何时被触发" class="headerlink" title="6、  处理器何时被触发"></a>6、  处理器何时被触发</h2><p>处理器的onTrigger方法只有在计划运行时才会被调用，并且处理器有工作要做。如果满足以下任何一个条件，就称处理器存在工作</p><ul><li> 目标是处理器的连接在其队列中至少有一个FlowFile </li><li> 处理器没有传入连接</li><li> 处理器用@TriggerWhenEmpty注释 </li></ul><p>有几个因素会影响处理器的onTrigger方法何时被调用。</p><p>首先，除非用户已将Processor配置为运行，否则不会触发Processor。如果处理器被安排运行，框架会定期(周期由用户在用户界面中配置)检查处理器是否有工作要做。如果是，框架将检查处理器的下游目的地。 </p><p> <strong>如果处理器的任何出站连接已满，默认情况下，处理器将不会被安排运行。</strong> </p><p> 但是，@TriggerWhenAnyDestinationAvailable注释可以添加到Processor的类中。  在这种情况下，需求被更改为只有一个下游目的地必须是“可用的”(如果Connection队列未满，则认为目的地是“可用的”)，而不是要求所有下游目的地都可用。 </p><p>与处理器调度相关的还有 @TriggerSerially 注释。使用此注释的处理器永远不会有多个线程同时运行onTrigger方法。但是，需要注意的是，执行代码的线程在调用之间可能会发生变化。因此，仍然必须小心确保处理器是线程安全的</p><h2 id="7、组件生命周期"><a href="#7、组件生命周期" class="headerlink" title="7、组件生命周期"></a>7、组件生命周期</h2><h3 id="OnAdded"><a href="#OnAdded" class="headerlink" title="@OnAdded"></a>@OnAdded</h3><p> @OnAdded注释会在创建组件时立即调用一个方法 ， <code>initialize</code>  方法将在组件构造之后被调用，然后是带有@OnAdded注释的方法。 该方法在组件的生命周期中只会被调用一次。带有此注释的方法必须不带参数。 </p><h3 id="OnEnabled"><a href="#OnEnabled" class="headerlink" title="@OnEnabled"></a>@OnEnabled</h3><p> @OnEnabled注释可以用来指示一个方法应该在控制器服务被启用时被调用。 任何具有此注释的方法都会在每次用户启用该服务时被调用。此外，每次重启NiFi时，如果将NiFi配置为“ auto-resume state ”并且启用了服务，则将调用该方法。</p><p>如果带有此注释的方法抛出Throwable，则将为该组件发出一条日志消息和公告。在这种情况下，服务将保持在“ ENABLING ”状态，并且将不可用。带有此注释的所有方法将在延迟后再次调用。在所有带有此注释的方法都返回而不抛出任何东西之前，该服务将无法使用。 </p><h3 id="OnRemoved"><a href="#OnRemoved" class="headerlink" title="@OnRemoved"></a>@OnRemoved</h3><p> @OnRemoved注释导致在组件从流中移除之前调用一个方法。这允许在删除组件之前清理资源。带有此注释的方法必须不带参数。<strong>如果带有此注释的方法抛出异常，该组件仍将被删除。</strong> </p><h3 id="OnScheduled"><a href="#OnScheduled" class="headerlink" title="@OnScheduled"></a>@OnScheduled</h3><p> 每次计划运行组件时都应调用该方法。因为ControllerServices没有被调度，所以在ControllerService上使用这个注释是没有意义的。 它应该仅用于处理器和 Reporting Tasks 。如果具有此注释的任何方法抛出Exception，则不会调用具有此注释的其他方法，并将向用户显示通知。 </p><p> 在这种情况下，然后触发带有@OnUnscheduled注释的方法，然后触发带有@OnStopped注释的方法(在此状态下，如果这些方法中的任何一个抛出异常，这些异常将被忽略)。  然后，该组件将在一段时间内执行，这段时间称为“Administrative yield Duration”，这是在nifi中配置的一个值。 最后，进程将再次启动，直到所有带@OnScheduled注释的方法都返回而不抛出任何异常。 </p><p>带有此注释的方法可以不带参数，也可以只带一个参数。如果使用单个参数变体，如果组件是Processor，则参数必须是ProcessContext类型，如果组件是ReportingTask，则参数必须是ConfigurationContext类型。 </p><h3 id="OnUnscheduled"><a href="#OnUnscheduled" class="headerlink" title="@OnUnscheduled"></a>@OnUnscheduled</h3><p>每当处理器或ReportingTask不再调度运行时，将调用带有此注释的方法。此时，在Processor的onTrigger方法中可能仍有许多线程处于活动状态。如果这样的方法抛出异常，将生成一条日志消息，否则将忽略该异常，并且仍将调用带有此注释的其他方法。带有此注释的方法可以不带参数，也可以只带一个参数。如果使用单个参数变体，如果组件是Processor或ConfigurationContext，则参数必须是ProcessContext类型 </p><h3 id="OnStopped"><a href="#OnStopped" class="headerlink" title="@OnStopped"></a>@OnStopped</h3><p> 当处理器或ReportingTask不再调度运行并且所有线程都从onTrigger方法返回时，将调用带有此注释的方法。如果这样的方法抛出异常，将生成一条日志消息，否则该异常将被忽略;使用此注释的其他方法仍将被调用。带有此注释的方法允许接受0或1个参数。如果使用了参数，如果组件是ReportingTask，则参数的类型必须是ConfigurationContext;如果组件是Processor，则参数的类型必须是ProcessContext。 </p><h3 id="OnShutdown"><a href="#OnShutdown" class="headerlink" title="@OnShutdown"></a>@OnShutdown</h3><p>任何带有@OnShutdown注释的方法都将在NiFi成功关闭时被调用。如果这样的方法抛出异常，将生成一条日志消息，否则将忽略该异常，并且仍将调用带有此注释的其他方法。带有此注释的方法<strong>必须不带参数</strong>。注意:虽然NiFi将尝试在使用它的所有组件上调用带有此注释的方法，但这并不总是可能的。 </p><p>例如，进程可能意外终止，在这种情况下，它没有机会调用这些方法。因此，虽然使用此注释的方法可用于清理资源，但不应依赖于关键业务逻辑。 </p><h2 id="8、组件通知"><a href="#8、组件通知" class="headerlink" title="8、组件通知"></a>8、组件通知</h2><h3 id="OnPrimaryNodeStateChange"><a href="#OnPrimaryNodeStateChange" class="headerlink" title="@OnPrimaryNodeStateChange"></a>@OnPrimaryNodeStateChange</h3><p> @OnPrimaryNodeStateChange注释会在集群中主节点的状态发生变化时立即调用方法。带有此注释的方法要么不带参数，要么只带一个PrimaryNodeState类型的参数。PrimaryNodeState提供有关更改内容的上下文，以便组件可以采取适当的操作。PrimaryNodeState枚举器有两种可能的值:ELECTED PRIMARY NODE(接收此状态的节点已被选为NiFi集群的主节点)或PRIMARY NODE REVOKED( 接收此状态的节点是主节点，但现在其主节点角色已被撤销)</p><h2 id="9-、约束组件"><a href="#9-、约束组件" class="headerlink" title="9.、约束组件"></a>9.、约束组件</h2><p>受限制的组件是可用于执行操作员通过NIFI REST API/UI提供的任意不固定的代码，或者可以使用NIFI OS凭据在NIFI主机系统上获取或更改数据。 </p><p>这些组件可以被授权的NiFi用户用于超出应用程序的预期用途，升级特权，或者可能暴露有关NiFi进程或主机系统内部的数据。所有这些功能都应该被认为是特权的，管理员应该知道这些功能，并为一部分受信任的用户显式地启用它们。 </p><p>处理器、控制器服务或报告任务可以使用@Restricted注释进行标记。这将导致组件被视为受限组件，并且需要将用户显式地添加到可以访问受限组件的用户列表中。一旦用户被允许访问受限制的组件，他们将被允许创建和修改这些组件，假设所有其他权限都被允许。如果不能访问受限制的组件，用户仍然会知道这些类型的组件的存在，但即使有其他足够的条件，也无法创建或修改它们。</p><h2 id="10、状态管理"><a href="#10、状态管理" class="headerlink" title="10、状态管理"></a>10、状态管理</h2><p>从ProcessContext、ReportingContext和ControllerServiceInitializationContext中，组件可以调用getStateManager()方法。这个状态管理器负责提供一个简单的API来存储和检索状态。  该机制旨在使开发人员能够轻松地存储一组密钥/值对，检索这些值并原子更新它们。该状态可以在群集中局部存储在节点上，也可以在所有节点中存储。 </p><p>然而，需要注意的是，该机制的目的只是提供一种存储非常“简单”状态的机制。  因此，API只允许存储和检索Map&lt;String, String&gt;，并自动替换整个Map。此外，目前唯一支持存储集群范围状态的实现是由ZooKeeper支持的。  因此，在序列化之后，整个State Map的大小必须小于1mb。试图存储超过此值将导致抛出异常。如果处理器管理状态所需的交互比这更复杂(例如，必须存储和检索大量数据，或者必须单独存储和获取单个键)，则应该使用不同的机制(例如，与外部数据库通信)。 </p><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>当与状态管理器通信时，所有方法调用都需要提供Scope。这个Scope将是Scope.LOCAL或Scope.CLUSTER。如果NiFi在集群中运行，则此Scope向框架提供有关操作应该如何发生的重要信息。 </p><p> 如果状态使用 Scope.CLUSTER 存储。集群中的所有节点都将使用相同的状态存储机制进行通信。如果使用 Scope.LOCAL ，那么每个节点将看到状态的不同表示。 </p><p>还值得注意的是，如果将NiFi配置为作为独立实例运行，而不是在集群中运行，则 Scope总是使用Scope.LOCAL。这样做是为了允许NiFi组件的开发人员以一种一致的方式编写代码，而不必担心NiFi实例是否集群。相反，开发人员应该假设实例是集群的，并相应地编写代码。 </p><h2 id="11-报告处理器的活动"><a href="#11-报告处理器的活动" class="headerlink" title="11. 报告处理器的活动"></a>11. 报告处理器的活动</h2><p> 处理器负责报告其活动，以便用户能够了解其数据发生了什么。处理器应通过ComponentLog记录事件，该事件可通过初始化访问或调用AbstractProcessor的GetLogger方法访问。 </p><p>此外，处理器应使用通过ProcessSession的 <code>getProvenanceReporter</code>  方法获得的 <code>ProvenanceReporter</code>  接口。  ProvenanceReporter应该用于指示从外部源接收内容或将内容发送到外部位置的任何时间。  ProvenanceReTorter还具有报告何时克隆，分叉或修改的流文件以及将多个流文件合并到单个流纸上以及将流纸与其他一些标识符关联的方法。  但是，这些功能不太重要，因为该框架能够检测到这些内容并代表处理器发出适当的事件。 </p><p> 然而，对于处理器开发人员来说，发出这些事件是最佳实践，因为它在代码中变得明确说明这些事件正在发出，并且开发人员能够为事件提供其他细节，例如该动作采取了有关所采取的措施的信息。  如果处理器发出事件，则该框架将不会发出重复的事件。相反，它总是假设处理器开发人员比框架更了解处理器上下文中发生的事情。 </p><p>但是，框架可能会发出另一个事件。例如，如果处理器对FlowFile的内容及其属性进行修改，然后仅发射 ATTRIBUTES_MODIFIED  事件，则该框架将发出 CONTENT_MODIFIED  事件。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、-NiFi组件&quot;&gt;&lt;a href=&quot;#一、-NiFi组件&quot; class=&quot;headerlink&quot; title=&quot;一、 NiFi组件&quot;&gt;&lt;/a&gt;一、 NiFi组件&lt;/h1&gt;&lt;p&gt;NiFi提供了几个扩展点，使开发人员能够向应用程序添加功能以满足他们的需求。下面的列</summary>
      
    
    
    
    <category term="NiFi" scheme="https://castile.github.io/categories/NiFi/"/>
    
    
    <category term="NiFi" scheme="https://castile.github.io/tags/NiFi/"/>
    
    <category term="文档" scheme="https://castile.github.io/tags/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>无状态的NiFi</title>
    <link href="https://castile.github.io/2023/11/26/Stateless-NiFi/"/>
    <id>https://castile.github.io/2023/11/26/Stateless-NiFi/</id>
    <published>2023-11-26T07:35:13.000Z</published>
    <updated>2023-11-26T07:35:13.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Apache NiFi应用程序可以被认为是两个独立但相互交织的组件:流作者组件和流引擎。通过将这两个组件集成到一个应用程序中，NiFi允许用户创建数据流并在同一个用户界面中实时运行它。</p><p>然而，这两个概念是可以分开的。NiFi可以用来创建流，然后不仅可以由NiFi运行，还可以由其他兼容的数据流引擎运行。Apache NiFi项目提供了几个这样的数据流引擎:Apache NiFi本身、MiNiFi Java (Apache NiFi的一个子项目)、MiNiFi c++ (Apache NiFi的一个子项目)和无状态NiFi</p><p>这些数据流引擎中的每一个都有自己的优点和缺点，因此它们有自己最擅长解决的特定用例。本文将介绍无状态NiFi是什么，如何使用它，以及它的优点和缺点</p><h2 id="传统的NiFi"><a href="#传统的NiFi" class="headerlink" title="传统的NiFi"></a>传统的NiFi</h2><p>NiFi被设计为作为大型多租户应用程序运行。它努力充分利用提供给它的所有资源，包括磁盘/存储和许多线程。通常，单个NiFi实例跨许多不同的节点集群，形成一个大型的内聚数据流，该数据流可能由许多不同的子流组成。一般来说，NiFi将承担交付给它的数据的所有权。它将数据可靠地存储在磁盘上，直到它被传递到所有必要的目的地。此数据的交付可以在流中的不同位置进行优先级排序，以便将对特定目的地最重要的数据首先交付到该目的地，而相同的数据可以根据优先级以不同的顺序交付到另一个目的地。NiFi在完成所有这些工作的同时，保持非常细粒度的沿袭，并保持流中每个组件所看到的数据缓冲区(数据沿袭和数据滚动缓冲区的组合称为data Provenance)。</p><p>这些特性中的每一个都非常重要，可以提供一个非常强大、广泛、全面的视图，了解数据是如何在企业上操作和流经企业的。然而，在一些用例中，更轻量级的应用程序可以更好地服务于这些用例。一个能够与NiFi可以交互的所有不同端点进行交互的应用程序，并执行NiFi可以执行的所有转换、路由、过滤和处理。但是一个应用程序被设计为只运行一个小的子流，而不是一个有许多源和汇的大数据流。</p><h2 id="无状态NiFi"><a href="#无状态NiFi" class="headerlink" title="无状态NiFi"></a>无状态NiFi</h2><p>进入无状态NiFi(在本文档中也简称为“无状态”)。无状态NiFi中的许多概念与典型的Apache NiFi引擎中的概念不同。</p><p>无状态提供了一个占用空间更小的数据流引擎。它不包括用于编写或监视数据流的用户界面，而是运行使用NiFi应用程序编写的数据流。NiFi在能够访问快速存储(如SSD和NVMe驱动器)时表现最佳，而Stateless则将所有数据存储在内存中。</p><p>这意味着如果无状态NiFi停止，它将不再能够直接访问正在运行的数据。因此，无状态应该只用于数据源可靠且可重放的数据流，或者数据丢失不是关键问题的场景。</p><p>一个非常常见的用例是让无状态NiFi从Apache Kafka或JMS读取数据，然后执行一些路由/过滤/操作，最后将数据传递到另一个目的地。如果像这样的数据流要在NiFi中运行，那么数据将从源被消耗，写入NiFi的内部存储库，并得到确认，因此NiFi将获得该数据的所有权。然后，它将负责将其传递到所有目的地，即使应用程序重新启动也是如此。</p><p>但是，使用无状态NiFi，数据将被使用，然后传输到流中的下一个处理器。数据不会被写入任何类型的内部存储库，也不会被确认。流中的下一个处理器将处理数据，然后将其传递下去。只有当数据到达整个数据流的末端时，才会确认从源接收到的数据。如果在处理完成之前重新启动Stateless，则数据尚未得到确认，因此只是再次使用它。这允许在内存中处理数据，而不必担心数据丢失，但它也让源承担了可靠地存储数据并使数据可重放的责任。</p><h2 id="可兼容的数据流"><a href="#可兼容的数据流" class="headerlink" title="可兼容的数据流"></a>可兼容的数据流</h2><p>如上所述，无状态NiFi要求数据源既可靠又可重放。这限制了无状态可以合理交互的源。此外，对于无状态引擎能够运行的数据流，还有一些其他限制。</p><h3 id="1、-单一来源、单一目标"><a href="#1、-单一来源、单一目标" class="headerlink" title="1、 单一来源、单一目标"></a>1、 单一来源、单一目标</h3><p>在无状态状态下运行的每个数据流应该保持在单个源和单个接收器或目的地。由于Stateless不存储它正在处理的数据，也不存储元数据，例如数据流中数据排队的位置，因此将单个FlowFile发送到多个目的地可能导致数据重复。</p><p>考虑一个流，其中数据从Apache Kafka消费，然后交付到HDFS和S3。如果数据存储在HDFS中，然后存储到S3失败，则整个会话将被回滚，并且必须再次使用数据。因此，数据可能会被第二次消费并交付给HDFS。如果这种情况继续发生，数据将继续从Kafka提取并存储在HDFS中。根据目的地和流配置，这可能不是一个问题(除了浪费资源之外)，但在许多情况下，这是一个重要的问题。</p><p>因此，如果要使用无状态引擎运行数据流，那么应该将这样的数据流分解为两个不同的数据流。第一个将数据从Apache Kafka传送到HDFS，另一个将数据从Apache Kafka传送到S3。每个数据流都应该为Kafka使用一个单独的Consumer Group，这将导致每个数据流获得相同数据的副本</p><h3 id="2、对合并的支持可能有限"><a href="#2、对合并的支持可能有限" class="headerlink" title="2、对合并的支持可能有限"></a>2、对合并的支持可能有限</h3><p>由于无状态NiFi中的数据从头到尾同步地通过数据流传输，因此使用需要多个flowfile(如MergeContent和MergeRecord)的处理器可能无法接收成功所需的所有数据。如果处理器有数据排队并被触发，但没有取得任何进展，则无状态引擎将再次触发源处理器，以便向处理器提供额外的数据</p><p>然而，这可能导致数据不断被引入的情况，这取决于处理器的行为。为了避免这种情况，可以通过配置限制可能带入数据流的单个调用的数据量。如果数据流配置将每次调用的数据量限制为10 MB，但是配置了MergeContent直到至少有100 MB的可用数据才创建bin，则数据流将继续触发MergeContent运行，而不进行任何进展，直到达到最大bin年龄(如果配置)或数据流超时。</p><p>此外，根据运行Stateless的上下文，触发源组件可能不会提供额外的数据。例如，如果在数据在输入端口中排队，然后触发数据流的环境中运行无状态，则随后触发输入端口运行将不会产生额外的数据</p><p>因此，确保任何包含合并FlowFiles逻辑的数据流都配置了MergeContent和MergeRecord的最大Bin Age是很重要的。</p><h3 id="3、故障处理"><a href="#3、故障处理" class="headerlink" title="3、故障处理"></a>3、故障处理</h3><p>在传统的NiFi中，将从给定处理器的“失败”连接循环回同一处理器是很常见的。这导致处理器不断尝试处理FlowFile，直到它成功为止。这可能非常重要，因为通常一个NiFi接收数据，它负责获得该数据的所有权，并且必须能够保存该数据，直到下游服务能够接收它并随后交付该数据。</p><p>然而，对于无状态NiFi，假定数据源既可靠又可重放。此外，根据设计，无状态NiFi在重启后不会保存数据。因此，对故障处理的考虑可能会有所不同。使用无状态NiFi，如果无法将数据传递到下游系统，通常最好将FlowFile路由到输出端口，然后将输出端口标记为故障端口(参见下面的[失败端口](#failure- Ports)了解更多信息)。</p><h3 id="4、流不应该加载大量文件"><a href="#4、流不应该加载大量文件" class="headerlink" title="4、流不应该加载大量文件"></a>4、流不应该加载大量文件</h3><p>在传统的NiFi中，FlowFile内容存储在磁盘上，而不是内存中。因此，它能够处理任何大小的数据，只要它适合磁盘。然而，在无状态中，FlowFile内容存储在内存中，在JVM堆中。因此，通常不建议尝试将大量文件(例如100 GB数据集)加载到无状态NiFi中。这样做通常会导致OutOfMemoryError，或者至少会导致大量垃圾收集，从而降低性能。</p><h2 id="特性对比"><a href="#特性对比" class="headerlink" title="特性对比"></a>特性对比</h2><p>如上所述，无状态NiFi提供了一组不同于传统NiFi的特性和权衡。在这里，我们总结一下关键的区别。这种比较并不详尽，但可以快速了解这两个运行时是如何运行的。<br>| Feature | Traditional NiFi | Stateless NiFi |<br>|———|——————|—————-|<br>| 数据持久性 | 数据可靠地存储在磁盘上的FlowFile和Content Repositories中 | 数据存储在内存中，必须在重新启动时再次从源端使用 |<br>| 数据排序 | 数据在每个连接中根据选择的优先级排序独立排序 | 数据按照接收到的顺序在系统中流动(先进先出/ FIFO) |<br>| Site-to-Site | 支持完整的Site-to-Site功能，包括服务器和客户端角色 | 可以向NiFi实例推送或从NiFi实例拉取，但不能接收传入的站点到站点连接。也就是说，作为客户端而不是服务器工作 |<br>| Form Factor | 旨在利用多个内核和磁盘的优势 | 轻巧的外形因素。很容易嵌入到另一个应用程序。单线程处理 |<br>| Heap Considerations | 通常，许多用户正在使用许多处理器。不应该将FlowFile内容加载到堆中，因为它很容易导致堆耗尽 | 较小的数据流使用较少的堆。Flow一次只对一个或几个FlowFile进行操作，并将FlowFile的内容保存在Java堆的内存中。 |<br>| Data Provenance | 完全存储、索引的数据来源，可以通过UI浏览并通过Reporting Tasks导出 | 有限的数据来源功能，事件存储在内存中。无法查看，但可以使用Reporting Tasks导出。但是，由于它们在内存中，因此它们将在重新启动时丢失，并且可能在导出之前滚出 |<br>| 嵌入性 | 虽然在技术上可以嵌入传统的NiFi，但不建议这样做，因为它会启动一个重量级的用户界面，处理复杂的身份验证和授权，以及几个基于文件的外部依赖项，这可能很难管理 | 具有最小的外部依赖关系(包含扩展的目录和用于临时存储的工作目录)，并且更易于管理。可嵌入性是无状态NiFi的一个重要特性。 |</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Apache NiFi应用程序可以被认为是两个独立但相互交织的组件:流作者组件和流引擎。通过将这两个组件集成到一个应用程序中，NiFi允许用</summary>
      
    
    
    
    <category term="NiFi" scheme="https://castile.github.io/categories/NiFi/"/>
    
    
    <category term="NiFi" scheme="https://castile.github.io/tags/NiFi/"/>
    
    <category term="Stateless" scheme="https://castile.github.io/tags/Stateless/"/>
    
  </entry>
  
  <entry>
    <title>NiFi身份验证与授权验证（2）</title>
    <link href="https://castile.github.io/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/"/>
    <id>https://castile.github.io/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/</id>
    <published>2023-10-15T10:33:05.000Z</published>
    <updated>2023-10-15T10:33:05.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="授权验证（Authorization）概述"><a href="#授权验证（Authorization）概述" class="headerlink" title="授权验证（Authorization）概述"></a>授权验证（Authorization）概述</h2><p>访问Nifi界面相当于你想进入一个商业写字楼，门口保安可能会拦住你要查看你的身份证（身份验证）。现在保安从身份证上知道了我们的名字（身份验证成功），但是他依然需要确定你是在这个写字楼工作才能让你进去。为此他查找大楼员工花名册（授权验证）。只有当你的名字出现在名册上时你才会被放行。</p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697299271277.png" class width="1697299271277"><p>Nifi授权验证模块与两个数据库有关：一个是授权用户身份数据库（<code>UserGroupProvider</code>），另一个是用户权限数据库（<code>AccessPolicyProvider</code>） </p><p>其中，<code>UserGroupProvider</code>里面列出了所有被授权用户的用户名。只有在这个数据库里面的用户名才真正有权限使用Nifi。而<code>AccessPolicyProvider</code>里面列出了这些被授权用户以及他们所获得的权限之间的一一对应关系。</p><p>因此，Nifi的授权验证模块需要做的，就是先拿从身份验证模块得来的用户名与<code>UserGroupProvider</code>里的用户名做核对，看是否能找到对应的条目。如果有，再到<code>AccessPolicyProvider</code>里查看该用户有哪些权限。</p><p> 接下来，我们就看看，在Nifi当中是怎么对<code>UserGroupProvider</code>和<code>AccessPolicyProvider</code>进行设置的。 </p><h2 id="授权验证设置"><a href="#授权验证设置" class="headerlink" title="授权验证设置"></a>授权验证设置</h2><p>Nifi 会在<code>./conf/authorizers.xml</code>这个文件中寻找<code>UserGroupProvider</code>和<code>AccessPolicyProvider</code>的设置。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authorizers</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">userGroupProvider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileUserGroupProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Users File&quot;</span>&gt;</span>./conf/users.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial User Identity 1&quot;</span>&gt;</span>CN=castile-nifi, OU=nifi<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userGroupProvider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileAccessPolicyProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;User Group Provider&quot;</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Authorizations File&quot;</span>&gt;</span>./conf/authorizations.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial Admin Identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Identity 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Group&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">authorizer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>managed-authorizer<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.StandardManagedAuthorizer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Access Policy Provider&quot;</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">authorizer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorizers</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1、-UserGroupProvider-设置"><a href="#1、-UserGroupProvider-设置" class="headerlink" title="1、 UserGroupProvider 设置"></a>1、 UserGroupProvider 设置</h3><p><code>FileUserGroupProvider</code>的使用最为简单，其本质是把所有授权用户名都存在一个文件里面。在<code>./conf/authorizers.xml</code>文件中与<code>FileUserGroupProvider</code>相关的有以下条目：</p><p> 这个文件储存用户名的文件默认是<code>./conf/users.xml</code>。它可以有类似以下内容 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tenants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groups</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;66fa993d-f882-396e-bc79-3ff4b6994470&quot;</span> <span class="attr">identity</span>=<span class="string">&quot;CN=castile-nifi, OU=nifi&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tenants</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>里面配置一些用户的信息</p><h3 id="2、-AccessPolicyProvider-设置"><a href="#2、-AccessPolicyProvider-设置" class="headerlink" title="2、 AccessPolicyProvider 设置"></a>2、 AccessPolicyProvider 设置</h3><p> Nifi自带<code>AccessPolicyProvider</code>是<code>FileAccessPolicyProvider</code>。在<code>authorizers.xml</code>中相关的设置有以下的条目： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileAccessPolicyProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;User Group Provider&quot;</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Authorizations File&quot;</span>&gt;</span>./conf/authorizations.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial Admin Identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Identity 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Group&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">accessPolicyProvider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，在属性<code>User Group Provider</code>中我们指定了使用哪一个<code>UserGroupProvider</code>。而<code>Authorizations File</code>指定了权限数据都存在哪个文件，默认是<code>./conf/authorizations.xml</code>。这个文件中有类似以下的内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authorizations</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;f99bccd1-a30e-3e4a-98a2-dbc708edc67f&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/flow&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;3fbc23d1-30d2-3068-ba89-9066202e13d7&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;b8775bd4-704a-34c6-987b-84f2daf7a515&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/restricted-components&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;3fbc23d1-30d2-3068-ba89-9066202e13d7&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;ff96062a-fa99-36dc-9942-0f6442ae7212&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/policies&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;3fbc23d1-30d2-3068-ba89-9066202e13d7&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorizations</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 在这个文件中列出了每一条的权限（Policy），而每条权限都对应一个用户，这样形成了一一对应的关系，而Nifi也能够因此确定每个用户拥有什么权限。 </p><h3 id="3、-Authorizer设置"><a href="#3、-Authorizer设置" class="headerlink" title="3、 Authorizer设置"></a>3、 Authorizer设置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authorizer</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>managed-authorizer<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.StandardManagedAuthorizer<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Access Policy Provider&quot;</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">authorizer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Nifi自带有managed-authorizer和single-user-authorizer，注意我们要在这里指定<code>AccessPolicyProvider</code>。然后，在<code>nifi.properties</code>中，我们要在以下属性指定我们需要用的<code>authorizer</code>:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">nifi.security.user.authorizer</span>=<span class="string">managed-authorizer </span></span><br><span class="line"><span class="attr">或者：</span></span><br><span class="line"><span class="meta">nifi.security.user.authorizer</span>=<span class="string">single-user-authorizer</span></span><br></pre></td></tr></table></figure><p>这样，我们就告诉了Nifi我们使用的是<code>managed-authorizer</code>，然后<code>managed-authorizer</code>又指定了使用的<code>AccessPolicyProvider</code>，而<code>AccessPolicyProvider</code>又指定了所使用的<code>UserGroupProvider</code>。整个权限验证模块的设置就是这样子被串了起来。</p><h2 id="多用户授权"><a href="#多用户授权" class="headerlink" title="多用户授权"></a>多用户授权</h2><p>在生产环境中推荐使用<code>nifi.security.user.authorizer=managed-authorizer </code>, 这样可以为多个用户登录nifi并设置相应的权限。</p><p>在user.xml添加一个用户，并不设置任何权限</p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697359958358.png" class width="1697359958358"><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697359986486.png" class width="1697359986486"><p>我们是要手动添加条目到<code>./conf/users.xml</code>和<code>./conf/authorizations.xml</code>吗？并不需要，我们可以通过在Nifi的UI界面操作来添加。不过，首先你得有一个管理员账号来登录进Nifi界面才行。无论你采用哪种身份验证方法，对于一个新的加密Nifi，你必须在<code>authorizers.xml</code>的<code>AccessPolicyProvider</code>中找到这一项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial Admin Identity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 把你的用户名添加进去即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-access-policy-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileAccessPolicyProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;User Group Provider&quot;</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Authorizations File&quot;</span>&gt;</span>./conf/authorizations.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial Admin Identity&quot;</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Identity 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Node Group&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">accessPolicyProvider</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置Initial User Identity 1： admin</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">userGroupProvider</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>file-user-group-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authorization.FileUserGroupProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Users File&quot;</span>&gt;</span>./conf/users.xml<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Legacy Authorized Users File&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Initial User Identity 1&quot;</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name=&quot;Initial User Identity 1&quot;&gt;CN=admin, OU=nifi&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userGroupProvider</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>保存，重启Nifi。当你再次访问UI时就发现，关于权限的错误已经消除，主界面也可以进去了。实际上，当你添加了<code>Initial Admin Identity</code>并重启后，Nifi在后台把这名用户添加到了<code>users.xml</code>中，并且在<code>authorizations.xml</code>中添加了一些基础的权限。</p><p>user.xml中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tenants</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groups</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span> <span class="attr">identity</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;user identifier=&quot;6743d555-1f60-343a-9038-0be6fdcbf33b&quot; identity=&quot;CN=admin, OU=nifi&quot;/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tenants</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 当你使用初始管理员账号进入Nifi以后，你会发现大部分的地方都是灰色的，你基本没法做任何操作（下图） </p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697364885070.png" class width="1697364885070"><p>authorizations.xml中的配置湖自动生成：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">authorizations</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;f99bccd1-a30e-3e4a-98a2-dbc708edc67f&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/flow&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;87dce6d5-be9f-3392-a4ef-dd58a553a6a0&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/data/process-groups/2ba3a086-018b-1000-6247-3dcbfaf4602f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;2cb459c4-151d-3671-9d9b-7fa7f1448886&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/data/process-groups/2ba3a086-018b-1000-6247-3dcbfaf4602f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;f5e329a9-16eb-3aaf-a969-3778d17ad1e4&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/process-groups/2ba3a086-018b-1000-6247-3dcbfaf4602f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;3be25fe5-3d07-302c-9bf9-0b03fa9fb77d&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/process-groups/2ba3a086-018b-1000-6247-3dcbfaf4602f&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;b8775bd4-704a-34c6-987b-84f2daf7a515&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/restricted-components&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;627410be-1717-35b4-a06f-e9362b89e0b7&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/tenants&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;15e4e0bd-cb28-34fd-8587-f8d15162cba5&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/tenants&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;ff96062a-fa99-36dc-9942-0f6442ae7212&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/policies&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;ad99ea98-3af6-3561-ae27-5bf09e1d969d&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/policies&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;2e1015cb-0fed-3005-8e0d-722311f21a03&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/controller&quot;</span> <span class="attr">action</span>=<span class="string">&quot;R&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">policy</span> <span class="attr">identifier</span>=<span class="string">&quot;c6322e6c-4cc1-3bcc-91b3-2ed2111674cf&quot;</span> <span class="attr">resource</span>=<span class="string">&quot;/controller&quot;</span> <span class="attr">action</span>=<span class="string">&quot;W&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span> <span class="attr">identifier</span>=<span class="string">&quot;admin&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">policy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">authorizations</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以 通过点击右上侧的菜单栏并选择 user创建用户、Policies可以为用户进行权限管理</p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697365023394.png" class width="1697365023394"><p>创建用户后，自动会写入到user.xml中</p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697365187598.png" class width="1697365187598"><h2 id="TroubleShooting"><a href="#TroubleShooting" class="headerlink" title="TroubleShooting"></a>TroubleShooting</h2><p>1、 </p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697359326101.png" class width="1697359326101"><p>更改user.xml文件，user部分的identity不能有相同的</p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697359835216.png" class width="1697359835216"><p>2、</p><img src="/2023/10/15/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89/1697360312489.png" class width="1697360312489"><p>严格匹配，不能有“”，区分大小写</p><p>3、 当你在配置的是CN=admin, OU=nifi这种格式，那么会会从中解析出admin 作为用户名</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;授权验证（Authorization）概述&quot;&gt;&lt;a href=&quot;#授权验证（Authorization）概述&quot; class=&quot;headerlink&quot; title=&quot;授权验证（Authorization）概述&quot;&gt;&lt;/a&gt;授权验证（Authorization）概述&lt;/</summary>
      
    
    
    
    <category term="NiFi" scheme="https://castile.github.io/categories/NiFi/"/>
    
    
    <category term="NiFi" scheme="https://castile.github.io/tags/NiFi/"/>
    
    <category term="SSL" scheme="https://castile.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>NiFi身份验证与授权验证（1）</title>
    <link href="https://castile.github.io/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/"/>
    <id>https://castile.github.io/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/</id>
    <published>2023-10-14T15:59:46.000Z</published>
    <updated>2023-10-14T15:59:46.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NiFi身份验证和授权验证介绍"><a href="#NiFi身份验证和授权验证介绍" class="headerlink" title="NiFi身份验证和授权验证介绍"></a>NiFi身份验证和授权验证介绍</h2><p>身份验证（Authentication）以及授权验证（Authorization）在Nifi里面是两个相当独立的模块。其中身份验证主要的任务是确认当前操作用户<strong>是否真的是声称的身份</strong>。当用户的身份被证实以后，它的用户名会被传递到授权验证模块，而授权验证模块会在它的数据库里面查找该用户名，并确认该用户<strong>有什么权限</strong>。打个比喻，如果你想进入一个商业写字楼，门口保安可能会拦住你要查看你的身份证（身份验证）。然后他会从一个员工名册上查找你的名字（授权验证）。只有当你的名字出现在名册上时你才会被放行。</p><p>下图表明了Nifi中这两个系统间的关系。当用户试图访问Nifi时，他必须首先通过身份验证。身份验证的时候Nifi可能需要参考一个外部的身份数据库（Identity Provider），如LDAP，Kerberos，OpenID Connect等。当确认你的身份后，你的用户名会被送到授权验证模块进一步核对。授权模块在确认你的权限时也需要参考一个身份数据库（可以是一个文档，或者是LDAP服务器）以及一个记录着用户身份与权限对应关系的数据库。</p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697214104415.png" class width="1697214104415">、<p>身份验证和权限验证是完全可以采用不同的身份数据库的。所以我们说这两个系统相当独立，唯一把他们连接在一起的就是用户名的传递。 </p><h2 id="NiFi-基本配置"><a href="#NiFi-基本配置" class="headerlink" title="NiFi 基本配置"></a>NiFi 基本配置</h2><p>Nifi支持好几种用户验证方式：<code>TLS</code>, <code>LDAP</code>, <code>Kerberos</code>, <code>OpenID Connect</code>, <code>Apache Knox</code>等。我们主要介绍<code>TLS</code>以及<code>LDAP</code>两种方式。只要弄明白这两种，其余方式的设置都很类似。<br> 要开启用户验证功能，我们首先必须设置Nifi，使之只接受<code>https</code>安全连接。要达到这个目的，我们需要更改位于<code>./conf</code> 目录下的<code>nifi.properties</code>设置文件里的以下几项属性</p><p><code>nifi.web.http.port</code>：去除原来的<code>8080</code>，使该行变为<code>nifi.web.http.port=</code>，防止用户从非加密的http端口访问</p><p> <code>nifi.web.https.host</code>：设为运行Nifi的主机名字，例如<code>host-01</code> </p><p> <code>nifi.web.https.port</code>：我们用<code>8443</code>作为<code>https</code>端口</p><p> <code>nifi.security.keystore</code>：keystore的路径，例如<code>/opt/nifi/secrets/keystore.jks</code> </p><p> <code>nifi.security.keystoreType</code>：设为<code>JKS</code> </p><p> <code>nifi.security.keystorePasswd</code>：keystore的密码。</p><p> <code>nifi.security.truststore</code>：truststore的路径，例如<code>/opt/nifi/secrets/truststore.jks</code> </p><p> <code>nifi.security.truststoreType</code>：设为<code>JKS</code> </p><p> <code>nifi.security.truststorePasswd</code>：truststore的密码。</p><p> <code>nifi.remote.input.secure</code>：设为<code>true</code>，使得Nifi之间的Site-to-Site通信也用加密的方式。</p><h2 id="生成keystroe和truststore"><a href="#生成keystroe和truststore" class="headerlink" title="生成keystroe和truststore"></a>生成keystroe和truststore</h2><p>当我们要把Nifi设置成加密模式时，我们需要为其提供keystore和truststore。如果我们想通过TLS身份验证访问Nifi的UI时，我们还需要生成一个客户端的PKCS12文件来导入浏览器中。以下简单介绍怎么用Java自带的keytool来生成以上所提及的文件。</p><h3 id="1、生成KeyStore"><a href="#1、生成KeyStore" class="headerlink" title="1、生成KeyStore"></a>1、生成KeyStore</h3><p> 以下命令生成一个包含自签证书（self-signed certificate）的Java keystore： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -keyalg RSA -alias nifi -keystore keystore.jks -keypass [password] -storepass [password] -validity 365 -keysize 4096 -dname &quot;CN=[hostname], OU=nifi&quot;</span><br></pre></td></tr></table></figure><p> <code>[password]</code>为你想设置的密码，替换<code>[hostname]</code>为你运行Nifi的机器的hostname </p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697214411384.png" class width="1697214411384"><h3 id="2、-生成PKCS12文件以及对应的truststore"><a href="#2、-生成PKCS12文件以及对应的truststore" class="headerlink" title="2、 生成PKCS12文件以及对应的truststore"></a>2、 生成PKCS12文件以及对应的truststore</h3><p><code>PKCS12</code>文件是一种加密文件，一般用于存放证书以及对应的私钥。由于使用keytool无法直接生成<code>PKCS12</code>文件，我们首先生成一个包含自签证书的keystore（与上文生成Keystore的命令很相似）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -keyalg RSA -alias client -keystore client_keystore.jks -keypass password -storepass password -validity 365 -keysize 4096 -dname &quot;CN=castile, OU=nifi&quot;</span><br></pre></td></tr></table></figure><p>这里，我们只是随便设置了一个密码<code>password</code>，因为这个Keystore只是一个过渡的产物，我们最后不会用到，所以随便设置一个就好。</p><p>接着我们把这个keystore转化成PKCS12文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore client_keystore.jks -destkeystore client.p12 -srcstoretype JKS -deststoretype PKCS12 -srcstorepass password -deststorepass as1234567890 -destkeypass as1234567890 -srcalias client -destalias client</span><br></pre></td></tr></table></figure><p> 除了生成PKCS12文件外，我们还需要生成一个信任PKCS12密匙文件中的证书的truststore。为此，我们先从之前的keystore中输出密匙的证书： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -export -keystore client_keystore.jks -alias client -file client.der -storepass password</span><br></pre></td></tr></table></figure><p> 当我们得到证书以后，我们把这个证书引入到<code>truststore.jks</code>当中： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -file client.der -alias client -keystore truststore.jks -storepass as1234567890 -noprompt</span><br></pre></td></tr></table></figure><p>这是执行上述命令生成的文件：</p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697215015715.png" class width="1697215015715"><h2 id="访问nifi-UI界面"><a href="#访问nifi-UI界面" class="headerlink" title="访问nifi UI界面"></a>访问nifi UI界面</h2><p>在浏览器输入：<a href="https://192.168.160.140:9443/nifi">https://192.168.160.140:9443/nifi</a></p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697215948784.png" class width="1697215948784"><p>现在要求你输入用户名和密码，但是这个用户名和密码到底是啥呢？查找官网文档得知，有一个 <em>login-identity-providers.xml</em> 默认配置了用户名和密码</p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697216106597.png" class width="1697216106597"><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697216146697.png" class width="1697216146697"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">identifier</span>&gt;</span>single-user-provider<span class="tag">&lt;/<span class="name">identifier</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">class</span>&gt;</span>org.apache.nifi.authentication.single.user.SingleUserLoginIdentityProvider<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Username&quot;</span>&gt;</span>3df4e52a-ab76-477c-9af4-513494f21110<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Password&quot;</span>&gt;</span>$2b$12$NFheiU47xu8ezCrkt0Yz7Oxph/WRhmJaNwMPlDEPkynGSwxEPEibu<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是，貌似没啥作用啊</p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697216230305.png" class width="1697216230305"><p>原来，nifi启动的时候会自动生成一个随机用户名和密码，而且在login-single-user=credentials.xml中配置的密码是通过BCryptPasswordEncoder加密后的，</p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697297856757.png" class width="1697297856757"><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697297612867.png" class width="1697297612867"><p>可以通过以下命令设置一个好记忆的密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nifi.sh set-single-user-credentials USERNAME PASSWORD</span><br></pre></td></tr></table></figure><p>设置完后可以登录界面了</p><img src="/2023/10/14/NiFi%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89/1697299016832.png" class width="1697299016832">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;NiFi身份验证和授权验证介绍&quot;&gt;&lt;a href=&quot;#NiFi身份验证和授权验证介绍&quot; class=&quot;headerlink&quot; title=&quot;NiFi身份验证和授权验证介绍&quot;&gt;&lt;/a&gt;NiFi身份验证和授权验证介绍&lt;/h2&gt;&lt;p&gt;身份验证（Authenticatio</summary>
      
    
    
    
    <category term="NiFi" scheme="https://castile.github.io/categories/NiFi/"/>
    
    
    <category term="ssl" scheme="https://castile.github.io/tags/ssl/"/>
    
    <category term="nifi" scheme="https://castile.github.io/tags/nifi/"/>
    
    <category term="身份验证" scheme="https://castile.github.io/tags/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>castile-rpc框架：动态代理实现RPC的调用和处理</title>
    <link href="https://castile.github.io/2023/10/08/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0RPC%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>https://castile.github.io/2023/10/08/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0RPC%E7%9A%84%E8%B0%83%E7%94%A8%E5%92%8C%E5%A4%84%E7%90%86/</id>
    <published>2023-10-08T14:55:44.000Z</published>
    <updated>2023-10-08T14:55:44.249Z</updated>
    
    <content type="html"><![CDATA[<p>在一个RPC框架中，动态代理可以屏蔽rpc调用时低层的网络通讯、服务发现、负载均衡等具体细节。 使用 RPC 框架的时候，只需要调用接口方法，然后就拿到了返回结果。这些都是通过动态代理去实现的。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的优势是可以很好地遵循设计模式中的开闭原则，对扩展开发，对修改关闭。不需要关注目标类的实现细节，通过代理模式可以在不修改目标类的情况下，增强目标类功能的行为。 </p><p>动态代理是一种代理模式，它提供了一种能够在运行时动态构建代理类以及动态调用目标方法的机制。为什么称为动态是因为代理类和被代理对象的关系是在运行时决定的，代理类可以看作是对被代理对象的包装，对目标方法的调用是通过代理类来完成的。所以通过代理模式可以有效地将服务提供者和服务消费者进行解耦，隐藏了 RPC 调用的具体细节。</p><h2 id="服务消费者动态代理实现"><a href="#服务消费者动态代理实现" class="headerlink" title="服务消费者动态代理实现"></a>服务消费者动态代理实现</h2><p>我们使用@RPCReference注解来标注一个服务端接口，通过一个自定义的RpcReferenceBean完成了所有执行方法的拦截。 RpcReferenceBean 中 init() 方法是代理对象的创建入口，代理对象创建如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化bean，返回代理对象</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       RegistryService registryService = RegistryFactory.getInstance(registryAddr, RegistryType.valueOf(registryType));</span><br><span class="line">       <span class="keyword">this</span>.object = Proxy.newProxyInstance(</span><br><span class="line">               interfaceClass.getClassLoader(),</span><br><span class="line">               <span class="keyword">new</span> Class&lt;?&gt;[]&#123;interfaceClass&#125;,</span><br><span class="line">               <span class="keyword">new</span> RpcInvokerProxy(serviceVersion, timeout, registryService)</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>RpcInvokerProxy 处理器是实现动态代理逻辑的核心所在，其中包含 RPC 调用时底层网络通信、服务发现、负载均衡等具体细节 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcInvokerProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceVersion;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RegistryService registryService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcInvokerProxy</span><span class="params">(String serviceVersion, <span class="keyword">long</span> timeout, RegistryService registryService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceVersion = serviceVersion;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        <span class="keyword">this</span>.registryService = registryService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        CastileRpcProtocol&lt;RpcRequest&gt; rpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">        <span class="comment">// 消息头</span></span><br><span class="line">        MessageHeader messageHeader = <span class="keyword">new</span> MessageHeader();</span><br><span class="line">        <span class="comment">// 消息id</span></span><br><span class="line">        <span class="keyword">long</span> requestId = RpcRequestHolder.REQUEST_ID_GEN.incrementAndGet();</span><br><span class="line">        <span class="comment">// 魔数</span></span><br><span class="line">        messageHeader.setMagic(ProtocolConstants.MAGIC);</span><br><span class="line">        <span class="comment">// 版本</span></span><br><span class="line">        messageHeader.setVersion(ProtocolConstants.VERSION);</span><br><span class="line">        <span class="comment">// 序列化算法</span></span><br><span class="line">        messageHeader.setSerialization((<span class="keyword">byte</span>) SerializationTypeEnum.HESSIAN.getType());</span><br><span class="line">        <span class="comment">// 消息类型</span></span><br><span class="line">        messageHeader.setMsgType((<span class="keyword">byte</span>) MsgType.REQUEST.getType());</span><br><span class="line">        messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.SUCCESS.getCode());</span><br><span class="line"></span><br><span class="line">        rpcProtocol.setMessageHeader(messageHeader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息正文</span></span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">        rpcRequest.setServiceVersion(serviceVersion);</span><br><span class="line">        rpcRequest.setClassName(method.getDeclaringClass().getName());</span><br><span class="line">        rpcRequest.setMethodName(method.getName());</span><br><span class="line">        rpcRequest.setParameterTypes(method.getParameterTypes());</span><br><span class="line">        rpcRequest.setParams(args);</span><br><span class="line"></span><br><span class="line">        rpcProtocol.setBody(rpcRequest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建rpc客户端，发送消息进行rpc调用</span></span><br><span class="line">        RpcConsumer consumer = <span class="keyword">new</span> RpcConsumer();</span><br><span class="line"></span><br><span class="line">        RpcFuture&lt;RpcResponse&gt; rpcFuture = <span class="keyword">new</span> RpcFuture&lt;&gt;(<span class="keyword">new</span> DefaultPromise&lt;&gt;(<span class="keyword">new</span> DefaultEventLoop()), timeout);</span><br><span class="line">        RpcRequestHolder.REQUEST_MAP.put(requestId, rpcFuture);</span><br><span class="line">        consumer.sendMessage(rpcProtocol, registryService);</span><br><span class="line">        <span class="keyword">return</span> rpcFuture.getPromise().get(rpcFuture.getTimeout(), TimeUnit.MILLISECONDS).getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke() 方法的核心流程主要分为三步：构造 RPC 协议对象、发起 RPC 远程调用、等待 RPC 调用执行结果。 </p><p>发起 RPC 调用之前，我们需要找到最合适的服务节点，直接调用注册中心服务 RegistryService 的 discovery() 方法即可，默认是采用一致性 Hash 算法实现的服务发现 。为了尽可能使所有服务节点收到的请求流量更加均匀，需要为 discovery() 提供一个 invokerHashCode，一般可以采用 RPC 服务接口参数列表中第一个参数的 hashCode 作为参考依据。找到服务节点地址后，接下来通过 Netty 建立 TCP 连接，然后调用 writeAndFlush() 方法将数据发送到远端服务节点。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(CastileRpcProtocol&lt;RpcRequest&gt; protocolRequest, RegistryService registryService)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RpcRequest request = protocolRequest.getBody();</span><br><span class="line">        Object[] params = request.getParams();</span><br><span class="line">        String serviceKey = RpcServiceHelper.buildServiceKey(request.getMethodName(), request.getServiceVersion());</span><br><span class="line">        <span class="keyword">int</span> invokeHashCode = params.length &gt; <span class="number">0</span> ? params[<span class="number">0</span>].hashCode() : serviceKey.hashCode();</span><br><span class="line">        <span class="comment">// 找到需要发送到哪个服务实例</span></span><br><span class="line">        ServiceMetaData serviceMetaData = registryService.discovery(serviceKey, invokeHashCode);</span><br><span class="line">        <span class="keyword">if</span> (serviceMetaData != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(serviceMetaData.getServiceAddr(), serviceMetaData.getPort()).sync();</span><br><span class="line">            channelFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;connect rpc service &#123;&#125; om port &#123;&#125; success!&quot;</span>, serviceMetaData.getServiceAddr(), serviceMetaData.getPort());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;connect rpc server &#123;&#125; on port &#123;&#125; failed.&quot;</span>, serviceMetaData.getServiceAddr(), serviceMetaData.getPort());</span><br><span class="line">                        channelFuture.cause().printStackTrace();</span><br><span class="line">                        eventLoopGroup.shutdownGracefully();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            channelFuture.channel().writeAndFlush(protocolRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 发送RPC远程调用后，使用Promise机制等待拿到结果。</p><p>Promise 模式本质是一种异步编程模型，我们可以先拿到一个查看任务执行结果的凭证，不必等待任务执行完毕，当我们需要获取任务执行结果时，再使用凭证提供的相关接口进行获取。 </p><h2 id="服务提供者反射调用实现"><a href="#服务提供者反射调用实现" class="headerlink" title="服务提供者反射调用实现"></a>服务提供者反射调用实现</h2><p>消费者通过netty发送消息给服务端后，rpc的请求数据经过解码器解码成CastileRpcProtocol对象后，再交由RpcRequestHandler执行rpcx请求调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, CastileRpcProtocol&lt;RpcRequest&gt; msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 执行rpc调用比较耗时，因此放在业务线程池中去处理</span></span><br><span class="line">        RpcRequestProcessor.submitRequest(() -&gt; &#123;</span><br><span class="line">            CastileRpcProtocol&lt;RpcResponse&gt; rpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">            RpcResponse rpcResponse = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">            MessageHeader messageHeader = msg.getMessageHeader();</span><br><span class="line">            messageHeader.setMsgType((<span class="keyword">byte</span>) MsgType.RESPONSE.getType());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                RpcRequest request = msg.getBody();</span><br><span class="line">                String serviceKey = RpcServiceHelper.buildServiceKey(request.getClassName(), request.getServiceVersion());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取bean对象</span></span><br><span class="line">                Object serviceBean = rpcServiceMap.get(serviceKey);</span><br><span class="line">                <span class="keyword">if</span> (serviceBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 不存在</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;service not exist: %s:%s&quot;</span>, request.getClassName(), request.getMethodName()));</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; serviceClazz = serviceBean.getClass();</span><br><span class="line">                String methodName = request.getMethodName();</span><br><span class="line">                Object[] params = request.getParams();</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">                FastClass fastClass = FastClass.create(serviceClazz);</span><br><span class="line">                <span class="keyword">int</span> index = fastClass.getIndex(methodName, parameterTypes);</span><br><span class="line">                Object result = fastClass.invoke(index, serviceBean, params);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写回到response中</span></span><br><span class="line">                rpcResponse.setData(result);</span><br><span class="line">                messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.SUCCESS.getCode());</span><br><span class="line">                rpcProtocol.setBody(rpcResponse);</span><br><span class="line">                rpcProtocol.setMessageHeader(messageHeader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.FAIL.getCode());</span><br><span class="line">                rpcResponse.setMessage(throwable.toString());</span><br><span class="line">                log.error(<span class="string">&quot;process request &#123;&#125; error&quot;</span>, messageHeader.getRequestId(), throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ctx.writeAndFlush(rpcProtocol);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rpcServiceMap 中存放着服务提供者所有对外发布的服务接口，我们可以通过服务名和服务版本找到对应的服务接口。通过服务接口、方法名、方法参数列表、参数类型列表，我们一般可以使用反射的方式执行方法调用。为了加速服务接口调用的性能，我们采用 Cglib 提供的 FastClass 机制直接调用方法，Cglib 中 MethodProxy 对象就是采用了 FastClass 机制，它可以和 Method 对象完成同样的事情，但是相比于反射性能更高。 </p><p>FastClass 机制并没有采用反射的方式调用被代理的方法，而是运行时动态生成一个新的 FastClass 子类，向子类中写入直接调用目标方法的逻辑。同时该子类会为代理类分配一个 int 类型的 index 索引，FastClass 即可通过 index 索引定位到需要调用的方法。 </p><h1 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h1><p><a href="https://gitee.com/hongliangzhu/castile-rpc">https://gitee.com/hongliangzhu/castile-rpc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在一个RPC框架中，动态代理可以屏蔽rpc调用时低层的网络通讯、服务发现、负载均衡等具体细节。 使用 RPC 框架的时候，只需要调用接口方法，然后就拿到了返回结果。这些都是通过动态代理去实现的。&lt;/p&gt;
&lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class</summary>
      
    
    
    
    <category term="RPC" scheme="https://castile.github.io/categories/RPC/"/>
    
    
    <category term="RPC" scheme="https://castile.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>castile-rpc框架：服务治理-服务发现和负载均衡</title>
    <link href="https://castile.github.io/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://castile.github.io/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2023-09-27T15:25:00.000Z</published>
    <updated>2023-09-27T15:25:00.499Z</updated>
    
    <content type="html"><![CDATA[<p>在一个分布式系统中，每个服务都有多个实例，如果服务实例节点出现负载比较高，那么可能会导致该节点上面的请求处理超时，影响可用性。so，一个良好的rpc框架需要 实现合理的负载均衡算法。</p><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>服务消费者在发起请求之前都需要根据需要调用的服务去服务中心去找那些服务端实例，而且每个服务都有上线和下线的概念，因此消费端还需要感知服务提供者的实例变化，在rpc框架中，一般使用注册中心来实现服务的发现和注册。</p><p>主流的注册中心有zookeeper、Eureka、Etcd？Consul、Nacos等， 高可用的注册中心对 RPC 框架至关重要。说到高可用自然离不开 CAP 理论，一致性 Consistency、可用性 Availability 和分区容忍性 Partition tolerance 是无法同时满足的，注册中心一般分为 <strong>CP 类型注册中心</strong>和 <strong>AP 类型注册中心</strong> 。</p><p>● 一致性：指所有节点在同一时刻的数据完全一致。</p><p>● 可用性：指服务一直可用，而且响应时间正常。例如，不管什么时候访问X节点和Y节点都可以正常获取数据值，而不会出现问题。</p><p>● 分区容错性：指在遇到某节点或网络分区故障时，仍然能够对外提供满足一致性和可用性的服务。例如X节点和Y节点出现故障，但是依然可以很好地对外提供服务 </p><p><strong>CAP的取舍</strong>:</p><p>1、 满足CA舍弃P，也就是满足一致性和可用性，舍弃分区容错性。这也就意味着你的系统不是分布式的了，因为分布式就是把功能分开部署到不同的机器上。</p><p>2、满足CP舍弃A，也就是满足一致性和分区容错性，舍弃可用性。这也就意味着你的系统允许有一段时间访问失效等，不会出现数据不一致的情况。</p><p>3、满足AP舍弃C，也就是满足可用性和分区容错性，舍弃一致性。这也就意味着你的系统在并发访问的时候可能会出现数据不一致的情况。</p><p>在分布式系统中，为了避免单点故障，分区容错是不可避免的，所以对于注册中心来说只能从CP（优先保证数据一致性）、AP（优先保证数据可用性）中根据你的业务场景选择一种。</p><p> 使用最为广泛的 Zookeeper 就是 CP 类型的注册中心，集群中会有一个节点作为 Leader，如果 Leader 节点挂了，会重新进行 Leader 选举，ZooKeeper 保证了所有节点的强一致性，但是在 Leader 选举的过程中是无法对外提供服务的，牺牲了部分可用性。Eureka 是典型的 AP 类型注册中心，在实现服务发现的场景下有很大的优势，整个集群是不存在 Leader、Flower 概念的，如果其中一个节点挂了，请求会立刻转移到其他节点上。可能会存在的问题是如果不同分区无法进行节点通信，那么可能会造成节点之间的数据是有差异的，所以 AP 类型的注册中心通过牺牲强一致性来保证高可用性 。 </p><p>对于 RPC 框架而言，即使注册中心出现问题，也不应该影响服务的正常调用，所以 AP 类型的注册中心在该场景下相比于 CP 类型的注册中心更有优势。 对于成熟的 RPC 框架而言，会提供多种注册中心的选择，接下来我们便设计一个通用的注册中心接口，然后每种注册中心的实现都按该接口规范行扩展。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册微服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceMetaData 服务元数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(ServiceMetaData serviceMetaData)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(ServiceMetaData serviceMetaData)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServiceMetaData <span class="title">discovery</span><span class="params">(String serviceName, <span class="keyword">int</span> invokerHashCode)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> RegistryService 接口包含注册中心四个基本操作：<strong>服务注册 register</strong>、<strong>服务注销 unRegister</strong>、<strong>服务发现 discovery</strong>、<strong>注册中心销毁 destroy</strong>。 </p><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>服务消费者在发起 RPC 调用之前，需要感知有多少服务端节点可用，然后从中选取一个进行调用。之前我们提到了几种常用的负载均衡策略：Round-Robin 轮询、Weighted Round-Robin 权重轮询、Least Connections 最少连接数、Consistent Hash 一致性 Hash 等。  一致性 Hash 算法可以保证每个服务节点分摊的流量尽可能均匀，而且能够把服务节点扩缩容带来的影响降到最低。下面我们一起看下一致性 Hash 算法的设计思路。 </p><p>在服务端节点扩缩容时，一致性 Hash 算法会尽可能保证客户端发起的 RPC 调用还是固定分配到相同的服务节点上。一致性 Hash 算法是采用<strong>哈希环</strong>来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash。</p><p>关于一致性hash算法可参考： <a href="https://zhuanlan.zhihu.com/p/482549860?utm_medium=social&amp;utm_oi=919687111576289280">https://zhuanlan.zhihu.com/p/482549860?utm_medium=social&amp;utm_oi=919687111576289280</a></p><p>负载均衡接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceLoadBalancer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">select</span><span class="params">(List&lt;T&gt; servers, <span class="keyword">int</span> hashCode)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于zk实现的一致性hash算法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConsistentHashLoadBalancer</span> <span class="keyword">implements</span> <span class="title">ServiceLoadBalancer</span>&lt;<span class="title">ServiceInstance</span>&lt;<span class="title">ServiceMetaData</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 虚拟节点数，默认是10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VIRTUAL_NODE_SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildServiceInstanceKey</span><span class="params">(ServiceInstance&lt;ServiceMetaData&gt; instance)</span> </span>&#123;</span><br><span class="line">        ServiceMetaData payload = instance.getPayload();</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">&quot;:&quot;</span>, payload.getServiceAddr(), String.valueOf(payload.getPort()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance&lt;ServiceMetaData&gt; <span class="title">select</span><span class="params">(List&lt;ServiceInstance&lt;ServiceMetaData&gt;&gt; servers, <span class="keyword">int</span> hashCode)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, ServiceInstance&lt;ServiceMetaData&gt;&gt; ring = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ServiceInstance&lt;ServiceMetaData&gt; instance : servers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODE_SIZE; i++) &#123;</span><br><span class="line">                ring.put((buildServiceInstanceKey(instance) + VIRTUAL_NODE_SIZE + i).hashCode(), instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ceilingEntry() 方法找出大于或等于客户端 hashCode 的第一个节点，即为客户端对应要调用的服务节点</span></span><br><span class="line">        Map.Entry&lt;Integer, ServiceInstance&lt;ServiceMetaData&gt;&gt; entry = ring.ceilingEntry(hashCode);</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            entry = ring.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>服务发现的实现思路比较简单，首先找出被调用服务所有的节点列表，然后通过 ZKConsistentHashLoadBalancer 提供的一致性 Hash 算法找出相应的服务节点。具体代码实现如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ServiceMetaData <span class="title">discovery</span><span class="params">(String serviceName, <span class="keyword">int</span> invokerHashCode)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Collection&lt;ServiceInstance&lt;ServiceMetaData&gt;&gt; serviceInstances = serviceDiscovery.queryForInstances(serviceName);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 通过一些负载均衡算法，选择一个服务实例</span></span><br><span class="line">       ServiceInstance&lt;ServiceMetaData&gt; instance = <span class="keyword">new</span> ZKConsistentHashLoadBalancer().select((List&lt;ServiceInstance&lt;ServiceMetaData&gt;&gt;) serviceInstances, invokerHashCode);</span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> instance.getPayload();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在一个分布式系统中，每个服务都有多个实例，如果服务实例节点出现负载比较高，那么可能会导致该节点上面的请求处理超时，影响可用性。so，一个良好的rpc框架需要 实现合理的负载均衡算法。&lt;/p&gt;
&lt;h2 id=&quot;注册中心&quot;&gt;&lt;a href=&quot;#注册中心&quot; class=&quot;head</summary>
      
    
    
    
    <category term="RPC" scheme="https://castile.github.io/categories/RPC/"/>
    
    
    <category term="RPC" scheme="https://castile.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>castile-rpc框架：通信协议的设计和编解码器的实现</title>
    <link href="https://castile.github.io/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://castile.github.io/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-09-27T13:37:57.000Z</published>
    <updated>2023-09-27T13:37:57.027Z</updated>
    
    <content type="html"><![CDATA[<p>现在需要建立客户端和服务端之间的通信机制了，主要内容有：</p><ul><li>服务消费者实现协议编码，向服务提供者发送调用数据。</li><li>服务提供者收到数据后解码，然后向服务消费者发送响应数据，暂时忽略 RPC 请求是如何被调用的。</li><li>服务消费者收到响应数据后成功返回。</li></ul><h2 id="1、RPC-通信方案设计"><a href="#1、RPC-通信方案设计" class="headerlink" title="1、RPC 通信方案设计"></a>1、RPC 通信方案设计</h2><img src="/2023/09/27/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/1695565921880.png" class width="1695565921880"><h2 id="2、自定义RPC通信协议"><a href="#2、自定义RPC通信协议" class="headerlink" title="2、自定义RPC通信协议"></a>2、自定义RPC通信协议</h2><p>协议是服务消费者和服务提供者之间通信的基础，主流的 RPC 框架都会自定义通信协议，相比于 HTTP、HTTPS、JSON 等通用的协议，自定义协议可以实现更好的性能、扩展性以及安全性。 </p><h3 id="自定义协议要素"><a href="#自定义协议要素" class="headerlink" title="自定义协议要素"></a>自定义协议要素</h3><ul><li>魔数，用来在第一时间判定是否是无效数据包</li><li>版本号，可以支持协议的升级</li><li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li><li>状态： 失败还是成功？ 可选</li><li>消息类型，是请求、响应？这个 跟业务相关</li><li>请求序号，为了双工通信，提供异步能力</li><li>正文长度</li><li>消息正文</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">| 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">| 状态 1byte |        消息 ID 8byte     |      数据长度 4byte     |</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">|                   数据内容 （长度不定）                          |</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>我们把协议分为协议头 Header 和协议体 Body 两个部分。协议头 Header 包含魔数、协议版本号、序列化算法、报文类型、状态、消息 ID、数据长度，协议体 Body 只包含数据内容部分，数据内容的长度是不固定的。RPC 请求和响应都可以使用该协议进行通信，对应协议实体类的定义如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CastileRpcProtocol</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> MessageHeader messageHeader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageHeader</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">short</span> magic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> version;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> serialization;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> msgType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> status;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> requestId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> msgLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3、序列化算法选型"><a href="#3、序列化算法选型" class="headerlink" title="3、序列化算法选型"></a>3、序列化算法选型</h2><p>目前比较常用的序列化算法包括 Json、Kryo、Hessian、Protobuf 等，这些第三方序列化算法都比 Java 原生的序列化操作都更加高效。 我们设计了一个 RPC 序列化顶层接口， 所有的序列化算法都需要实现这个接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcSerialization</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 待序列化数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 序列化数据的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 序列化后的字节流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="keyword">byte</span>[] serialize(T obj) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf   数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;   类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] buf, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 我们为 RpcSerialization 提供了 HessianSerialization 和 JsonSerialization 两种类型的实现，为此，可以提供一个序列化工厂来切换不同的序列化算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RpcSerialization <span class="title">getRpcSerialization</span><span class="params">(<span class="keyword">byte</span> type)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        SerializationTypeEnum typeEnum = SerializationTypeEnum.findSerializationType(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (typeEnum)&#123;</span><br><span class="line">            <span class="keyword">case</span> HESSIAN:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HessianSerialization();</span><br><span class="line">            <span class="keyword">case</span> JSON:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JsonSerialization();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;serialization type is illegal, &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、通信协议的编码器"><a href="#4、通信协议的编码器" class="headerlink" title="4、通信协议的编码器"></a>4、通信协议的编码器</h2><p>Netty 提供了两个最为常用的编解码抽象基类 MessageToByteEncoder 和 ByteToMessageDecoder，帮助我们很方便地扩展实现自定义协议。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">CastileRpcProtocol</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">   | 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |</span></span><br><span class="line"><span class="comment">   +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">   | 状态 1byte |        消息 ID 8byte     |      数据长度 4byte     |</span></span><br><span class="line"><span class="comment">   +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">   |                   数据内容 （长度不定）                          |</span></span><br><span class="line"><span class="comment">   +---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, CastileRpcProtocol message, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessageHeader messageHeader = message.getMessageHeader();</span><br><span class="line">        <span class="comment">// 魔数</span></span><br><span class="line">        byteBuf.writeShort(messageHeader.getMagic());</span><br><span class="line">        <span class="comment">// 协议版本号</span></span><br><span class="line">        byteBuf.writeByte(messageHeader.getVersion());</span><br><span class="line">        <span class="comment">// 序列化算法</span></span><br><span class="line">        byteBuf.writeByte(messageHeader.getSerialization());</span><br><span class="line">        <span class="comment">// 报文类型</span></span><br><span class="line">        byteBuf.writeByte(messageHeader.getMsgType());</span><br><span class="line">        <span class="comment">// 状态</span></span><br><span class="line">        byteBuf.writeByte(messageHeader.getStatus());</span><br><span class="line">        <span class="comment">// 消息id</span></span><br><span class="line">        byteBuf.writeLong(messageHeader.getRequestId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        RpcSerialization rpcSerialization = SerializationFactory.getRpcSerialization(messageHeader.getSerialization());</span><br><span class="line">        <span class="keyword">byte</span>[] body = rpcSerialization.serialize(message.getBody());</span><br><span class="line">        <span class="comment">// 数据长度</span></span><br><span class="line">        byteBuf.writeInt(body.length);</span><br><span class="line">        byteBuf.writeBytes(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在服务消费者或者服务提供者调用 writeAndFlush() 将数据写给对方前，都已经封装成 RpcRequest 或者 RpcResponse，所以可以采用 CastileRpcProtocol作为 RPC Encoder 编码器能够支持的编码类型。 </p><h2 id="5、-通信协议的解码器"><a href="#5、-通信协议的解码器" class="headerlink" title="5、 通信协议的解码器"></a>5、 通信协议的解码器</h2><p> 解码器 相比于编码器 要复杂很多，解码器的目标是将字节流数据解码为消息对象，并传递给下一个 Inbound 处理器。整个解码过程有几个要点要特别注意： </p><ul><li><p>只有当 ByteBuf 中内容大于协议头 Header 的固定的 18 字节时，才开始读取数据。</p></li><li><p>即使已经可以完整读取出协议头 Header，但是协议体 Body 有可能还未就绪。所以在刚开始读取数据时，需要使用 markReaderIndex() 方法标记读指针位置，当 ByteBuf 中可读字节长度小于协议体 Body 的长度时，再使用 resetReaderIndex() 还原读指针位置，说明现在 ByteBuf 中可读字节还不够一个完整的数据包。</p><blockquote><p>这个其实也可以使用<strong>LengthFieldBasedFrameDecoder</strong>来处理粘包和半包问题</p></blockquote></li><li><p>根据不同的报文类型 MsgType，需要反序列化出不同的协议体对象。在 RPC 请求调用的场景下，服务提供者需要将协议体内容反序列化成 MiniRpcRequest 对象；在 RPC 结果响应的场景下，服务消费者需要将协议体内容反序列化成 MiniRpcResponse 对象。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 消息小于头长度，不完整数据</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &lt; ProtocolConstants.HEADER_TOTAL_LEN) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;message length valid failed! please check request data&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        byteBuf.markReaderIndex();</span><br><span class="line">        <span class="comment">// 魔数</span></span><br><span class="line">        <span class="keyword">short</span> magic = byteBuf.readShort();</span><br><span class="line">        <span class="comment">// 魔数不匹配，不是本系统消息</span></span><br><span class="line">        <span class="keyword">if</span> (magic != ProtocolConstants.MAGIC) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;magic number is illegal, &quot;</span> + magic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span> version = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> serializeType = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> msgType = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">byte</span> status = byteBuf.readByte();</span><br><span class="line">        <span class="keyword">long</span> requestId = byteBuf.readLong();</span><br><span class="line">        <span class="keyword">int</span> dataLength = byteBuf.readInt();</span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &lt; dataLength) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;data readableBytes less than data length!&quot;</span>);</span><br><span class="line">            byteBuf.resetReaderIndex();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[dataLength];</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line">        <span class="comment">// 获取消息类型</span></span><br><span class="line">        MsgType byTpye = MsgType.findByType(msgType);</span><br><span class="line">        <span class="keyword">if</span> (byTpye == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;msgType number is illegal, &quot;</span> + msgType);</span><br><span class="line">        &#125;</span><br><span class="line">        MessageHeader header = <span class="keyword">new</span> MessageHeader();</span><br><span class="line">        header.setMagic(magic);</span><br><span class="line">        header.setVersion(version);</span><br><span class="line">        header.setSerialization(serializeType);</span><br><span class="line">        header.setStatus(status);</span><br><span class="line">        header.setRequestId(requestId);</span><br><span class="line">        header.setMsgType(msgType);</span><br><span class="line">        header.setMsgLen(dataLength);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        RpcSerialization rpcSerialization = SerializationFactory.getRpcSerialization(serializeType);</span><br><span class="line">        <span class="keyword">switch</span> (byTpye) &#123;</span><br><span class="line">            <span class="keyword">case</span> REQUEST:</span><br><span class="line">                RpcRequest rpcRequest = rpcSerialization.deserialize(data, RpcRequest.class);</span><br><span class="line">                <span class="keyword">if</span> (rpcRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    CastileRpcProtocol&lt;RpcRequest&gt; castileRpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">                    castileRpcProtocol.setMessageHeader(header);</span><br><span class="line">                    castileRpcProtocol.setBody(rpcRequest);</span><br><span class="line">                    list.add(castileRpcProtocol);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RESPONSE:</span><br><span class="line">                RpcResponse rpcResponse = rpcSerialization.deserialize(data, RpcResponse.class);</span><br><span class="line">                <span class="keyword">if</span> (rpcResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    CastileRpcProtocol&lt;RpcResponse&gt; castileRpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">                    castileRpcProtocol.setMessageHeader(header);</span><br><span class="line">                    castileRpcProtocol.setBody(rpcResponse);</span><br><span class="line">                    list.add(castileRpcProtocol);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> HEARTBEAT:</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6、请求和响应处理"><a href="#6、请求和响应处理" class="headerlink" title="6、请求和响应处理"></a>6、请求和响应处理</h2><p>消费者调用RPC请求后，服务端通过解码器将二进制的数据解码成CastileRpcProtocol<RpcRequest>对象，再传递给RpcRequestHandler处理器执行rpc调用。 RpcRequestHandler 也是一个 Inbound 处理器，它并不需要承担解码工作，所以 RpcRequestHandler 直接继承 SimpleChannelInboundHandler 即可，然后重写 channelRead0() 方法，具体实现如下： </RpcRequest></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">CastileRpcProtocol</span>&lt;<span class="title">RpcRequest</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; rpcServiceMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcRequestHandler</span><span class="params">(Map&lt;String, Object&gt; rpcServiceMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rpcServiceMap = rpcServiceMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, CastileRpcProtocol&lt;RpcRequest&gt; msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 执行rpc调用比较耗时，因此放在业务线程池中去处理</span></span><br><span class="line">        RpcRequestProcessor.submitRequest(() -&gt; &#123;</span><br><span class="line">            CastileRpcProtocol&lt;RpcResponse&gt; rpcProtocol = <span class="keyword">new</span> CastileRpcProtocol&lt;&gt;();</span><br><span class="line">            RpcResponse rpcResponse = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">            MessageHeader messageHeader = msg.getMessageHeader();</span><br><span class="line">            messageHeader.setMsgType((<span class="keyword">byte</span>) MsgType.RESPONSE.getType());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                RpcRequest request = msg.getBody();</span><br><span class="line">                String serviceKey = RpcServiceHelper.buildServiceKey(request.getClassName(), request.getServiceVersion());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取bean对象</span></span><br><span class="line">                Object serviceBean = rpcServiceMap.get(serviceKey);</span><br><span class="line">                <span class="keyword">if</span> (serviceBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 不存在</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">&quot;service not exist: %s:%s&quot;</span>, request.getClassName(), request.getMethodName()));</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; serviceClazz = serviceBean.getClass();</span><br><span class="line">                String methodName = request.getMethodName();</span><br><span class="line">                Object[] params = request.getParams();</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">                FastClass fastClass = FastClass.create(serviceClazz);</span><br><span class="line">                <span class="keyword">int</span> index = fastClass.getIndex(methodName, parameterTypes);</span><br><span class="line">                Object result = fastClass.invoke(index, serviceBean, params);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 写回到response中</span></span><br><span class="line">                rpcResponse.setData(result);</span><br><span class="line">                messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.SUCCESS.getCode());</span><br><span class="line">                rpcProtocol.setBody(rpcResponse);</span><br><span class="line">                rpcProtocol.setMessageHeader(messageHeader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                messageHeader.setStatus((<span class="keyword">byte</span>) MsgStatus.FAIL.getCode());</span><br><span class="line">                rpcResponse.setMessage(throwable.toString());</span><br><span class="line">                log.error(<span class="string">&quot;process request &#123;&#125; error&quot;</span>, messageHeader.getRequestId(), throwable);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ctx.writeAndFlush(rpcProtocol);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 服务消费者在发起调用时，维护了请求 requestId 和 RpcFuture的映射关系，RpcResponseHandler 会根据请求的 requestId 找到对应发起调用的 RpcFuture，然后为 RpcFuture 设置响应结果。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">CastileRpcProtocol</span>&lt;<span class="title">RpcResponse</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, CastileRpcProtocol&lt;RpcResponse&gt; msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> requestId = msg.getMessageHeader().getRequestId();</span><br><span class="line">        RpcFuture&lt;RpcResponse&gt; responseRpcFuture = RpcRequestHolder.REQUEST_MAP.remove(requestId);</span><br><span class="line">        responseRpcFuture.getPromise().setSuccess(msg.getBody());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcFuture</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Promise&lt;T&gt; promise;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcFuture</span><span class="params">(Promise&lt;T&gt; promise, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.promise = promise;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在需要建立客户端和服务端之间的通信机制了，主要内容有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务消费者实现协议编码，向服务提供者发送调用数据。&lt;/li&gt;
&lt;li&gt;服务提供者收到数据后解码，然后向服务消费者发送响应数据，暂时忽略 RPC 请求是如何被调用的。&lt;/li&gt;
&lt;li&gt;服务消</summary>
      
    
    
    
    <category term="RPC" scheme="https://castile.github.io/categories/RPC/"/>
    
    
    <category term="RPC" scheme="https://castile.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>castile-rpc框架：服务的注册与发现</title>
    <link href="https://castile.github.io/2023/09/24/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    <id>https://castile.github.io/2023/09/24/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</id>
    <published>2023-09-24T14:14:07.000Z</published>
    <updated>2023-09-24T14:14:07.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先考虑用户应该如何使用"><a href="#先考虑用户应该如何使用" class="headerlink" title="先考虑用户应该如何使用"></a>先考虑用户应该如何使用</h1><h2 id="1、-服务端"><a href="#1、-服务端" class="headerlink" title="1、 服务端"></a>1、 服务端</h2><p>服务端定义一个服务接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-03 15:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打招呼</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 姓名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现服务接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-03 15:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RpcService(serviceInterface = HelloService.class, serviceVersion = &quot;1.0.0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在服务端启动的时候会向注册中心注册这个服务。</p><h2 id="2、-消费端"><a href="#2、-消费端" class="headerlink" title="2、 消费端"></a>2、 消费端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RpcReference(serviceVersion = &quot;1.0.0&quot;, timeout = 3000)</span></span><br><span class="line">    <span class="keyword">private</span> HelloFacade helloFacade;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloFacade.hello(<span class="string">&quot;mini rpc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="服务提供者提供服务"><a href="#服务提供者提供服务" class="headerlink" title="服务提供者提供服务"></a>服务提供者提供服务</h1><h2 id="1、RPC服务端"><a href="#1、RPC服务端" class="headerlink" title="1、RPC服务端"></a>1、RPC服务端</h2><p>服务提供者采用的是主从 Reactor 线程模型，启动过程包括配置线程池、Channel 初始化、端口绑定三个步骤 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.castile.rpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.castile.rpc.provider.autoconfig.RpcProperties;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动RPC服务端，</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 服务启动的时候进行服务发现与注册</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-03 22:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServerRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RpcProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String address = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap().group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line">                            <span class="comment">// TODO 添加其他处理器， 如：编解码，消息请求处理</span></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(address, <span class="keyword">this</span>.properties.getPort()).sync();</span><br><span class="line">            log.info(<span class="string">&quot;连接信息：server addr &#123;&#125; started on port &#123;&#125;&quot;</span>, address, <span class="keyword">this</span>.properties.getPort());</span><br><span class="line"></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、发布服务"><a href="#2、发布服务" class="headerlink" title="2、发布服务"></a>2、发布服务</h2><p>定义一个注解，用于标识一个服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.castile.rpc.provider;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * rpc服务注解</span><br><span class="line"> *</span><br><span class="line"> * @author Hongliang Zhu</span><br><span class="line"> * @create 2023-09-03 15:51</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Component</span><br><span class="line">public @interface RpcService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 服务所在的接口</span><br><span class="line">     *</span><br><span class="line">     * @return 服务接口</span><br><span class="line">     */</span><br><span class="line">    Class&lt;?&gt; serviceInterface() default Object.class;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 服务版本</span><br><span class="line">     *</span><br><span class="line">     * @return 版本</span><br><span class="line">     */</span><br><span class="line">    String version() default &quot;1.0.0&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有两个重要的属性，serviceInterface表示服务类型接口，version表示服务版本。 服务消费者必须指定完全一样的属性才能正确调用。有了 @RpcService 注解之后，我们就可以在服务实现类上使用它。</p><p>@RpcService 注解本质上就是 @Component，可以将服务实现类注册成 Spring 容器所管理的 Bean。这里需要了解Spring中Bean的生命周期了。</p><img src="/2023/09/24/castile-rpc%E6%A1%86%E6%9E%B6%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/1693753942141.png" class width="1693753942141"><p>Spring的BeanPostProcessor接口提供了对Bean进行再加工的扩展点。 BeanPostProcessor 常用于处理自定义注解。自定义的 Bean 可以通过实现 BeanPostProcessor 接口，在 Bean 实例化的前后加入自定义的逻辑处理。如下所示，我们通过 RpcProvider 实现 BeanPostProcessor 接口，来实现对 声明 @RpcService 注解服务的自定义处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.castile.rpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.castile.rpc.provider.autoconfig.RpcProperties;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描<span class="doctag">@RpcService</span>注解，注册到注册中心中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hongliang Zhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-09-03 23:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcProviderProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; rpcServices = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RpcProperties properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        RpcService rpcService = bean.getClass().getAnnotation(RpcService.class);</span><br><span class="line">        <span class="keyword">if</span> (rpcService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String serviceName = rpcService.serviceInterface().getName();</span><br><span class="line">            String serviceVersion = rpcService.version();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String address = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                ServiceMetaData serviceMetaData = <span class="keyword">new</span> ServiceMetaData();</span><br><span class="line">                serviceMetaData.setPort(properties.getPort());</span><br><span class="line">                serviceMetaData.setServiceAddr(address);</span><br><span class="line">                serviceMetaData.setServiceName(serviceName);</span><br><span class="line">                serviceMetaData.setServiceVersion(serviceVersion);</span><br><span class="line">                <span class="comment">// TODO 封装注册信息，注册到注册中心</span></span><br><span class="line"></span><br><span class="line">                rpcServices.put(serviceName + <span class="string">&quot;#&quot;</span> + serviceVersion, bean);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;failed to register service &#123;&#125;#&#123;&#125;&quot;</span>, serviceName, serviceVersion, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="服务消费者订阅服务"><a href="#服务消费者订阅服务" class="headerlink" title="服务消费者订阅服务"></a>服务消费者订阅服务</h1><p>消费者不属于常驻服务， 每次发起 RPC 调用时它才会去选择向哪个远端服务发送数据。 对于声明 @RpcReference 注解的成员变量，我们需要构造出一个可以真正进行 RPC 调用的 Bean，然后将它注册到 Spring 的容器中。</p><p> @RpcReference 注解的定义 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcReference &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用的服务版本</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">serviceVersion</span><span class="params">()</span> <span class="keyword">default</span> &quot;1.0.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rpc调用的超时时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 3000</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要为使用了@RpcReference注解的成员变量构造成一个自定义的bean对象，并且对该bean对象执行的所有方法进行拦截。</p><p>Spring 的 FactoryBean 接口可以帮助我们实现自定义的 Bean，FactoryBean 是一种特种的工厂 Bean，通过 getObject() 方法返回对象，而并不是 FactoryBean 本身。 </p><p>有了 @RpcReference 注解和 RpcReferenceBean 之后，我们可以使用 Spring 的扩展点 BeanFactoryPostProcessor 对 Bean 的定义进行修改。上文中服务提供者使用的是 BeanPostProcessor，BeanFactoryPostProcessor 和 BeanPostProcessor 都是 Spring 的核心扩展点，它们之间有什么区别呢？BeanFactoryPostProcessor 是 Spring 容器加载 Bean 的定义之后以及 Bean 实例化之前执行，所以 BeanFactoryPostProcessor 可以在 Bean 实例化之前获取 Bean 的配置元数据，并允许用户对其修改。而 BeanPostProcessor 是在 Bean 初始化前后执行，它并不能修改 Bean 的配置信息。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcConsumerPostProcessor</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INIT_METHOD_NAME = <span class="string">&quot;init&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; rpcRefBeanDefinitions = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        String[] beanDefinitionNames = configurableListableBeanFactory.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String beanDefName : beanDefinitionNames) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = configurableListableBeanFactory.getBeanDefinition(beanDefName);</span><br><span class="line">            <span class="keyword">final</span> String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">            <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = ClassUtils.resolveClassName(beanClassName, <span class="keyword">this</span>.classLoader);</span><br><span class="line">                ReflectionUtils.doWithFields(clazz, <span class="keyword">this</span>::parseRpcReference);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// beanClassName = null</span></span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) configurableListableBeanFactory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.rpcRefBeanDefinitions.forEach((beanName, definition) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.containsBean(beanName)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;application  context already has a bean named &quot;</span> + beanName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注册到spring中</span></span><br><span class="line">                registry.registerBeanDefinition(beanName, rpcRefBeanDefinitions.get(beanName));</span><br><span class="line">                log.info(<span class="string">&quot;registered RpcReferenceBean &#123;&#125; success.&quot;</span>, beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = applicationContext;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseRpcReference</span><span class="params">(Field field)</span> </span>&#123;</span><br><span class="line">        RpcReference annotation = AnnotationUtils.getAnnotation(field, RpcReference.class);</span><br><span class="line">        <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(RpcReferenceBean.class);</span><br><span class="line">            builder.setInitMethodName(INIT_METHOD_NAME);</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;interfaceClass&quot;</span>, field.getType());</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;serviceVersion&quot;</span>, annotation.serviceVersion());</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;timeout&quot;</span>, annotation.timeout());</span><br><span class="line">            AbstractBeanDefinition definition = builder.getBeanDefinition();</span><br><span class="line">            rpcRefBeanDefinitions.put(field.getName(), definition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;先考虑用户应该如何使用&quot;&gt;&lt;a href=&quot;#先考虑用户应该如何使用&quot; class=&quot;headerlink&quot; title=&quot;先考虑用户应该如何使用&quot;&gt;&lt;/a&gt;先考虑用户应该如何使用&lt;/h1&gt;&lt;h2 id=&quot;1、-服务端&quot;&gt;&lt;a href=&quot;#1、-服务端&quot; cla</summary>
      
    
    
    
    <category term="RPC" scheme="https://castile.github.io/categories/RPC/"/>
    
    
    <category term="rpc" scheme="https://castile.github.io/tags/rpc/"/>
    
  </entry>
  
</feed>
